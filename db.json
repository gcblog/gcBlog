{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/weixin.jpg","path":"images/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/zhifubao.jpg","path":"images/zhifubao.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"bfa04938fd59d6121adf8c8b8ba5ad9bad8d6451","modified":1534381612603},{"_id":"themes/next/.DS_Store","hash":"b4031ca706d0e344ab2ab686d4decf4474d9e602","modified":1480003795000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1462394086000},{"_id":"themes/next/_config.yml","hash":"f4cdd520ec990416e12a82bf586c485fd0ba3a0d","modified":1529550960189},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1462394086000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1462394086000},{"_id":"source/_posts/DSA和ECC签名验签.md","hash":"9ac5de0ded665d8588da75e34d83f210df1d38c0","modified":1534381646498},{"_id":"source/_posts/.DS_Store","hash":"ce33df60819576464a77745a94f3727c532d8126","modified":1531137956508},{"_id":"source/_posts/Gif播放与暂停.md","hash":"fd24f5fdad3147050af6f24fd8c4c98684ecec95","modified":1510625727724},{"_id":"source/_posts/GitHub+Hexo.md","hash":"ecf8da93260805b1e34b36625bb38c32109edc16","modified":1479308720000},{"_id":"source/_posts/IOS10语音识别详解.md","hash":"716758911074616581f1737ed407738ac31707c5","modified":1479394641000},{"_id":"source/_posts/PhotoBatch-图片去重-3.md","hash":"ce09de8d900860ee747b3cdd88f63db0116ae39f","modified":1513924138704},{"_id":"source/_posts/PhotoBatch-文件操作-1.md","hash":"1824e298a57cf50bf00ba68243d8f2c0bda5c30a","modified":1511683730748},{"_id":"source/_posts/PhotoBatch-文件重命名-2.md","hash":"1d9ac59669e1be577564077e68ecc4265d056919","modified":1512377573478},{"_id":"source/_posts/RSA签名验签.md","hash":"dc19a4fb9ede538f01b4c537bb0f67926dba0adb","modified":1530183248921},{"_id":"source/_posts/Swift小结.md","hash":"77aab038a1c4aa7324afb965da91caec94b5c8c9","modified":1480783993000},{"_id":"source/_posts/Xcode多工程联编及工程依赖.md","hash":"49ede9c4ff66cf48eaed5022bbf22d1252f2a78a","modified":1479392778000},{"_id":"source/_posts/etcd在golang中的使用.md","hash":"70a5502e3e0c2803ba418a57efc93615847417a9","modified":1530790577137},{"_id":"source/_posts/etcd多台服务器集群环境搭建使用.md","hash":"daa8d8a97f4ee6710f242805a4eaf285f7a4688c","modified":1530790955251},{"_id":"source/_posts/github ssh key问题.md","hash":"f4fd13d586c3c624cd2424b8102a5fde42afbc83","modified":1479308720000},{"_id":"source/_posts/go数组.md","hash":"6cf3d80e211310ceb2401d7862be8632dc555779","modified":1524034906366},{"_id":"source/_posts/hash算法.md","hash":"456af294fc8a5e0964d082a9e213100fc4c3f718","modified":1530011072438},{"_id":"source/_posts/iOS-release-debug版设置不同的AppIcon.md","hash":"db3f7a0062abcb716edea491f533b0c58b323b13","modified":1479390672000},{"_id":"source/_posts/iOS三种录制视频方式详细对比.md","hash":"d952de41516fdc1191df57f01cf9d4030c39012c","modified":1490113669000},{"_id":"source/_posts/iOS公共库.md","hash":"3151544c94e5c4195759978bf89f455346ded775","modified":1479394874000},{"_id":"source/_posts/iOS开发小技巧.md","hash":"bf14f40b127d5e6c7e89239466afb347614a6387","modified":1479395031000},{"_id":"source/_posts/iOS性能监测.md","hash":"afbd08d9aedc1d12d95cec3d4697ae7dc2b58c2f","modified":1483260243000},{"_id":"source/_posts/iOS数组防止越界crash.md","hash":"26b21d4c79c6ac646d5b942b05b49fb2c8bdab0c","modified":1482565927000},{"_id":"source/_posts/iOS缓存机制-非结构化存储.md","hash":"99ebdeafd337d9578dd29d3609212bee9775bd6a","modified":1479394856000},{"_id":"source/_posts/iOS视频边下边播-缓存视频数据流.md","hash":"76f47b49d63539846f1d2dd6df7bb21fd63c62e2","modified":1479394789000},{"_id":"source/_posts/instruments实践.md","hash":"e3a047cf6f51de513a9b4d6d50bd1666dd80ea83","modified":1495555203000},{"_id":"source/_posts/mac下使用golang操作mongodb.md","hash":"fa45679511e33cb2ff8ee9e7d8fea8ccf45c1856","modified":1531141370023},{"_id":"source/_posts/mac下安装go及环境变量配置.md","hash":"92eb4acf5a953a72820d1204e552d3c520f40b44","modified":1525425199222},{"_id":"source/_posts/runtime详解.md","hash":"c408545e0309792e379bcb3646ec7c4384bd7467","modified":1479390504000},{"_id":"source/_posts/swift自动布局.md","hash":"34aa7cfab50ca11f7875b5423c2daa18a1803bff","modified":1480783629000},{"_id":"source/_posts/slice.md","hash":"da4d61c2dc52010832a0618272bffd92e3f785c7","modified":1525405636408},{"_id":"source/_posts/一分钟学会环形进度条.md","hash":"0692e39b0c80c4c244b4d141ed0c2db0031afae7","modified":1479394749000},{"_id":"source/_posts/共识算法POS原理及实现.md","hash":"747176795b00722fa2f0cf78d2989eb15071388f","modified":1530272035035},{"_id":"source/_posts/共识算法DPOS原理及实现.md","hash":"e535c8cd65da6726ccc2c25bde2da06a6a8e3971","modified":1530272086151},{"_id":"source/_posts/共识算法POW原理及实现.md","hash":"434aa37e9d7286d6b7353ec0c9d94dd816ff6b6a","modified":1530271986997},{"_id":"source/_posts/分布式Raft算法原理及实现.md","hash":"62abe3597a604a0f04c198309149d255068f4864","modified":1530704284031},{"_id":"source/_posts/字符串操作.md","hash":"8870afe2de67a11c901ed43e6e8c09d9e04a65ba","modified":1524816376171},{"_id":"source/_posts/对称加密算法AES原理及实现.md","hash":"9904a2c30983a1c436dbc2e7bb148fc62a81dca6","modified":1530096835826},{"_id":"source/_posts/对称加密算法DES原理及实现.md","hash":"7c96475af9b03e764a102f81d952ce6ac13458f1","modified":1530096644652},{"_id":"source/_posts/拜占庭PBFT简单实现.md","hash":"77e7615fb883f8ebf6bde912384e64e84e847f06","modified":1530615639238},{"_id":"source/_posts/自定义刷新控件.md","hash":"2aa2503c623611c00718fb4973275038350c5910","modified":1479308720000},{"_id":"source/_posts/非对称加密RSA原理简介及使用.md","hash":"1d99df5b0538acd7dbfe88d5f6e710f64edf2e25","modified":1530182219784},{"_id":"source/about/index.md","hash":"d41e4873ac67f38cad27017b0d70da0ba1620a24","modified":1479910252000},{"_id":"source/categories/index.md","hash":"d9171c0731f852a47b8222b9a19c1867ce334011","modified":1479308954000},{"_id":"source/photo/index.md","hash":"030ee47820d31ddcc3a7ded608a050d8166c92f5","modified":1479912772000},{"_id":"source/tags/index.md","hash":"861615a062df253884ac923defb36324fb53787c","modified":1479224240000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1462394086000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1462394086000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1462394086000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1462394086000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1462394086000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1462394086000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1462394086000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1462394086000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"2872894fe6f5fce4e3a4154fc91868eb9da3bb50","modified":1480783826000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1462394086000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1462394086000},{"_id":"themes/next/layout/.DS_Store","hash":"3846e5ec0495b1629bd13b6539ee80f6793487d7","modified":1479309415000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1479310511000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1462394086000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1462394086000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1462394086000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1462394086000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1462394086000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1462394086000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1462394086000},{"_id":"themes/next/scripts/.DS_Store","hash":"2ecca5dd0b7260968763bb4ded8695e5748d3d0e","modified":1479309426000},{"_id":"themes/next/source/404.html","hash":"f1aba17a5418c5373b74ff66e13a1568fcbad85a","modified":1479306070000},{"_id":"themes/next/source/.DS_Store","hash":"3bd153df0965690c99b8e6c5112acb50d5d846a1","modified":1526352844595},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1462394086000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1462394086000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1462394086000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1462394086000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1462394086000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1462394086000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b883289054ee54a374caad5d4883591beb94bd8b","modified":1462394086000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1462394086000},{"_id":"themes/next/layout/_partials/.DS_Store","hash":"ac37a342cd76e1cbf8a9794d8d235f01f6298ca0","modified":1479912977000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"82a9bc2ba60ce68419128ff60624bd74b15dfb78","modified":1462394086000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1462394086000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"821936c82367fa08633cc11b72b13042e0d1d9d8","modified":1488728059000},{"_id":"themes/next/layout/_partials/head.swig","hash":"f83b1c55bedd2c1a3eb734c72c6997795a4e5f99","modified":1462394086000},{"_id":"themes/next/layout/_partials/header.swig","hash":"963a765dc00e6ac43cfc53ffaf5725eb854cf95e","modified":1462394086000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1462394086000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1462394086000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1462394086000},{"_id":"themes/next/layout/_scripts/.DS_Store","hash":"70fd979797dc5474f4aee387a84314bc9bb122d8","modified":1479309420000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1462394086000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1462394086000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1462394086000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1462394086000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1462394086000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1462394086000},{"_id":"themes/next/source/css/.DS_Store","hash":"bbd874d841ee8ed19a25b4fd8382ed8fc6f2c115","modified":1479309953000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1462394086000},{"_id":"themes/next/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1479293752000},{"_id":"themes/next/source/images/avatar.gif","hash":"8fe58b774b9919ba2a10ee797a07211cb81edaf8","modified":1526353084876},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1462394086000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1462394086000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1462394086000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1462394086000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1462394086000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1462394086000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1462394086000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1462394086000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1462394086000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1462394086000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1462394086000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1462394086000},{"_id":"themes/next/source/images/weixin.jpg","hash":"bb32f026574b2f072279157b2e15146bc9583885","modified":1479302089000},{"_id":"themes/next/source/js/.DS_Store","hash":"bd7c5ffc965c42df1b10ea6b51aa93e782056006","modified":1479309439000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/images/zhifubao.jpg","hash":"5975ae7e6a34a09a3c9329d320eca5b1b0aa68bc","modified":1479658083000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1462394086000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1462394086000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1462394086000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1462394086000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1462394086000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1462394086000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1462394086000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1462394086000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1462394086000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"069bb17fb1db3bc7c85c88efa3ed94ab6becbe2c","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1462394086000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1462394086000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1462394086000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/.DS_Store","hash":"75f24243df3ef5d4c6e6bf22e39100ca38f57b06","modified":1479309953000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1462394086000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1462394086000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1462394086000},{"_id":"themes/next/source/js/src/.DS_Store","hash":"741f0f6de4a16ba2e97985b249c7d6c30c7caf70","modified":1479309445000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1462394086000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1462394086000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1462394086000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1462394086000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1462394086000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1462394086000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1462394086000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1462394086000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"8c7af79407d223486fba72b8150fe045a553bf70","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1462394086000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1462394086000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1462394086000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1462394086000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1462394086000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1462394086000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1462394086000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1462394086000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1462394086000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1462394086000},{"_id":"public/atom.xml","hash":"ce2d0f3f1093eeeb5c9c5ae5f1420bf25a605502","modified":1534381671485},{"_id":"public/search.xml","hash":"07e65a85aba4d32c442248a14a3defcde917786c","modified":1534381671540},{"_id":"public/about/index.html","hash":"2a7e464369aedd0dd44789bc607cdfd798b09927","modified":1534381671553},{"_id":"public/categories/index.html","hash":"e7448f7ba02f25206d63676c8530a2022701eefe","modified":1534381671554},{"_id":"public/photo/index.html","hash":"22e7351c0d5325223da20c39fe608c8ba8a40214","modified":1534381671554},{"_id":"public/tags/index.html","hash":"c4c61d4e9de6adccbd120e27cce9703ccf6b8f06","modified":1534381671554},{"_id":"public/2018/07/09/mac下使用golang操作mongodb/index.html","hash":"792ab068b94a2b15835a0fd5fa924b704223e451","modified":1534381671554},{"_id":"public/2018/07/05/etcd多台服务器集群环境搭建使用/index.html","hash":"3a0c4043c8be0d724519f9ef1c69895c84802e15","modified":1534381671554},{"_id":"public/2018/07/05/etcd在golang中的使用/index.html","hash":"d587df24c202da44ade97652c8a9e088d9bea507","modified":1534381671554},{"_id":"public/2018/07/04/分布式Raft算法原理及实现/index.html","hash":"48558fd63b146d0e838c016bc007851511d79625","modified":1534381671554},{"_id":"public/2018/07/03/拜占庭PBFT简单实现/index.html","hash":"5801fb660a9098fdd98ccd5ba65cf39dca455ac4","modified":1534381671554},{"_id":"public/2018/06/29/共识算法DPOS原理及实现/index.html","hash":"80a718057d107811f25c69e2f4b0572df86dc4d0","modified":1534381671554},{"_id":"public/2018/06/29/共识算法POS原理及实现/index.html","hash":"4c03523aa6cd03f82da5890e7942287052a47e2e","modified":1534381671554},{"_id":"public/2018/06/29/共识算法POW原理及实现/index.html","hash":"3d74e10ede36500695b091a5a3c16cb92a760c38","modified":1534381671554},{"_id":"public/2018/06/28/DSA和ECC签名验签/index.html","hash":"78a5a2fe0f1524cc3f6a53fb051141aa6ad4cff9","modified":1534381671555},{"_id":"public/2018/06/28/RSA签名验签/index.html","hash":"cf4440b0e0ed1fc6b8b013f2663fcef1dde2b8ca","modified":1534381671555},{"_id":"public/2018/06/27/非对称加密RSA原理简介及使用/index.html","hash":"888238cadd0f1f973fb6c1c9bb80dbb5b4358299","modified":1534381671555},{"_id":"public/2018/06/27/对称加密算法AES原理及实现/index.html","hash":"299e727995f1433b67c9e7cd8b8065e92a138e6f","modified":1534381671555},{"_id":"public/2018/06/26/对称加密算法DES原理及实现/index.html","hash":"da005dd6f3da21cedc5752caeada4a07b91b3352","modified":1534381671555},{"_id":"public/2018/06/26/hash算法/index.html","hash":"b738a29fc72d2b5a74556bf854551f784c9bb0ad","modified":1534381671555},{"_id":"public/2018/05/04/slice/index.html","hash":"b6b9cb60dadc30ee61aae5138aabb34a0201f0c2","modified":1534381671555},{"_id":"public/2018/04/26/字符串操作/index.html","hash":"eb0c96f4f63d9b44b1764a6a09dda80be2c63530","modified":1534381671555},{"_id":"public/2018/04/18/go数组/index.html","hash":"0a48acffb3c72c6e1dc599eba05ebe3c801adee7","modified":1534381671555},{"_id":"public/2018/04/04/mac下安装go及环境变量配置/index.html","hash":"d1c9e8d375e167f1b99218747181ecc2af6a8712","modified":1534381671555},{"_id":"public/2017/12/22/PhotoBatch-图片去重-3/index.html","hash":"5d293a9f117df37d70274d8ce7796665a826f28d","modified":1534381671555},{"_id":"public/2017/12/04/PhotoBatch-文件重命名-2/index.html","hash":"4b50bdd5c5b73c7904d5ca2bfaa80b3ed16bc030","modified":1534381671556},{"_id":"public/2017/11/26/PhotoBatch-文件操作-1/index.html","hash":"ebe9e77c33afacee619f619b962787e70826bff4","modified":1534381671556},{"_id":"public/2017/11/14/Gif播放与暂停/index.html","hash":"e52bd876c82dd83111481b35ccfcb18422d140fe","modified":1534381671556},{"_id":"public/2017/03/22/iOS三种录制视频方式详细对比/index.html","hash":"335a7e07f53c95b53aba845c5d230b06d24a2356","modified":1534381671556},{"_id":"public/2017/01/01/instruments实践/index.html","hash":"103e2d9badd5bbab3370fa946261ef414dfd4692","modified":1534381671556},{"_id":"public/2016/12/24/iOS数组防止越界crash/index.html","hash":"dd33da3efd3bbb147a107b7b846f8a6a47962756","modified":1534381671556},{"_id":"public/2016/11/29/Swift小结/index.html","hash":"d16d37df61e60d3c7e01eefc43776321be477dc1","modified":1534381671556},{"_id":"public/2016/11/24/swift自动布局/index.html","hash":"a5870800fe01bc0fe7d0cb935910bf3d2a346f2b","modified":1534381671556},{"_id":"public/2016/11/16/自定义刷新控件/index.html","hash":"7b167828e02201eacd8514076fc5796b9855b1bc","modified":1534381671556},{"_id":"public/2016/11/16/IOS10语音识别详解/index.html","hash":"cb572ccf2aac1ad27423b20deadee6a7cfedae2b","modified":1534381671556},{"_id":"public/2016/04/16/runtime详解/index.html","hash":"11422a8af45653277cb7ae2f3a076563e9b3690f","modified":1534381671557},{"_id":"public/2016/04/13/iOS-release-debug版设置不同的AppIcon/index.html","hash":"134c427ef47926d954fe5822d5d961701a4e4f73","modified":1534381671557},{"_id":"public/2016/04/06/iOS公共库/index.html","hash":"f2a9208d5287a1d8a037a6916edf8a6bde4e4d6d","modified":1534381671557},{"_id":"public/2016/03/15/iOS开发小技巧/index.html","hash":"8b60d1386608a3e08d54dd87b58cf03f2b55dcf8","modified":1534381671557},{"_id":"public/2016/03/12/Xcode多工程联编及工程依赖/index.html","hash":"4dd6318780c93039f0021a14b0ded9f9563d0cdb","modified":1534381671557},{"_id":"public/2016/03/12/iOS缓存机制-非结构化存储/index.html","hash":"c26cc1235e15fd00981ea474788086d3b4e824d8","modified":1534381671557},{"_id":"public/2016/02/27/一分钟学会环形进度条/index.html","hash":"b50bc72a2c0fd4820fcb16fb13cd01fc06c3d588","modified":1534381671557},{"_id":"public/2016/02/27/github ssh key问题/index.html","hash":"56cf38d9eea1d05d71a1521c66b2ab183526e417","modified":1534381671557},{"_id":"public/2016/02/25/iOS视频边下边播-缓存视频数据流/index.html","hash":"9ee1b912efc7a60d612e357eea908a7ff8724c25","modified":1534381671557},{"_id":"public/2016/02/25/iOS性能监测/index.html","hash":"a2d14e13970ffec6d597b20aa9d3366a9c1fec07","modified":1534381671557},{"_id":"public/2016/02/23/GitHub+Hexo/index.html","hash":"472af4d11f95296436c7544e3b42fd7af0fba69a","modified":1534381671557},{"_id":"public/categories/加密算法/index.html","hash":"df2bd13296aa09c85353ddce4e74ab330db855e5","modified":1534381671558},{"_id":"public/categories/加密算法/page/2/index.html","hash":"887ca16e0130b3245c5e904a91db8f3b22e36b8a","modified":1534381671558},{"_id":"public/categories/Swfit/index.html","hash":"eb1704d1846ff765fb56e66991d01a975828c8f3","modified":1534381671558},{"_id":"public/categories/随笔/index.html","hash":"1a36490bf4d19a3f14571450e2e0359573503161","modified":1534381671558},{"_id":"public/categories/iOS技术/index.html","hash":"1e1aff9dc9b3ca9fb387ebf457eea0cde1918b30","modified":1534381671558},{"_id":"public/categories/iOS技术/page/2/index.html","hash":"d81f88ab7c3d9070902d9a4bfc5d067e85639218","modified":1534381671558},{"_id":"public/categories/iOS技术/page/3/index.html","hash":"71c261bff6669300c686532c401151da5e85e2f3","modified":1534381671558},{"_id":"public/categories/macOS/index.html","hash":"4afa61175b9b54b5babe7468d77597511c21fdb1","modified":1534381671558},{"_id":"public/categories/iOS配置/index.html","hash":"1fd8070dc9e3a7b7907d7a3024cc937955be5b6b","modified":1534381671558},{"_id":"public/categories/区块链/index.html","hash":"045e2b528c545c9e974162a345bfa2d28b4d9825","modified":1534381671558},{"_id":"public/categories/go/index.html","hash":"7394f93198499419452d3e2f6dc7eff997d5012a","modified":1534381671558},{"_id":"public/categories/go/page/2/index.html","hash":"410f6d70b555486708a9209e59bedc33ad22ce1b","modified":1534381671558},{"_id":"public/categories/共识算法/index.html","hash":"8cc243bd10a5542092c6822eff53b7bc6d4e2786","modified":1534381671558},{"_id":"public/archives/index.html","hash":"e45a4b5a7c6b427c1ce9a1820473d47698f17999","modified":1534381671559},{"_id":"public/archives/page/2/index.html","hash":"95025012d81f939ea53762801f09476037899444","modified":1534381671559},{"_id":"public/archives/page/3/index.html","hash":"b584676e6ed5389a55bf9daef1194178061866b3","modified":1534381671559},{"_id":"public/archives/page/4/index.html","hash":"f470dc9de2bd98b90938c7a0f87ad19ca254550c","modified":1534381671559},{"_id":"public/archives/page/5/index.html","hash":"2ecd92783df93925e79553f535cf5a39987b0a5d","modified":1534381671559},{"_id":"public/archives/page/6/index.html","hash":"b0de239c9e612deec6e003672667ba0a0c554d81","modified":1534381671559},{"_id":"public/archives/page/7/index.html","hash":"fd15e7405028ca601dba0b019f91a22f7a808670","modified":1534381671559},{"_id":"public/archives/page/8/index.html","hash":"ece614d5ad599cc7fb3a4bff864c7f17b035f936","modified":1534381671559},{"_id":"public/archives/page/9/index.html","hash":"9e776bbe4fc0b599ee7bd76be613f5fd912e0fc6","modified":1534381671559},{"_id":"public/archives/page/10/index.html","hash":"801defa1b042cdb4f85ebb054290c004e7ae2b73","modified":1534381671559},{"_id":"public/archives/2016/index.html","hash":"41fd1967dc42dd7a6538aa190f57a13d2dc12cc9","modified":1534381671559},{"_id":"public/archives/2016/page/2/index.html","hash":"6fcb57037d0f475a298358e763ba4c0d17e644dc","modified":1534381671559},{"_id":"public/archives/2016/page/3/index.html","hash":"2512119199e9a3bc6db476751bc8451a48c0860a","modified":1534381671559},{"_id":"public/archives/2016/page/4/index.html","hash":"5f334b965119196a0c9dfcfc72912ed107e4b428","modified":1534381671559},{"_id":"public/archives/2016/02/index.html","hash":"b8123b08fd4cb07577dbef0afecf7d98d38d2dd0","modified":1534381671559},{"_id":"public/archives/2016/02/page/2/index.html","hash":"034653b8108ca8fd17d6a24b0b30470b69268d57","modified":1534381671560},{"_id":"public/archives/2016/03/index.html","hash":"18ae166276b8d5945f44d062cc38482ce576d78f","modified":1534381671560},{"_id":"public/archives/2016/04/index.html","hash":"6896a0662d3313b6d1926b407c4d7abc722b3189","modified":1534381671560},{"_id":"public/archives/2016/11/index.html","hash":"b71a2ff0f206db9bd52d0b601b4736c01a114939","modified":1534381671560},{"_id":"public/archives/2016/12/index.html","hash":"95d691ebf522682fde3f50c7ba90168cf55a10a2","modified":1534381671560},{"_id":"public/archives/2017/index.html","hash":"e794cd59f6fdc2347c80808b0857306dd3783d2c","modified":1534381671560},{"_id":"public/archives/2017/page/2/index.html","hash":"86c67dc2bb8531189263e1521ba931e49fb73b8c","modified":1534381671560},{"_id":"public/archives/2017/01/index.html","hash":"8e45c3e1691618bbb48e08ee29e4421e53afa67a","modified":1534381671560},{"_id":"public/archives/2017/03/index.html","hash":"0ed5fd3538018b8987346b59258b66bdbf5cbbba","modified":1534381671560},{"_id":"public/archives/2017/11/index.html","hash":"24fb0d619f7c74be3732bcd03a8066b1aa412c1c","modified":1534381671560},{"_id":"public/archives/2017/12/index.html","hash":"ba83766dbefe2ef5bd70c9545d5d81fee33f33a5","modified":1534381671560},{"_id":"public/archives/2018/index.html","hash":"c9c7e9d3e27b2529596dabafb89154fcce511b5b","modified":1534381671560},{"_id":"public/archives/2018/page/2/index.html","hash":"ec2ddf7f22e49a78788d41526e5e31be5c0e4016","modified":1534381671560},{"_id":"public/archives/2018/page/3/index.html","hash":"4ff3dc34d9d858425b2862efe074bd6bb9a43d15","modified":1534381671560},{"_id":"public/archives/2018/page/4/index.html","hash":"2ecac24b456c7290fd6fa217c7de47184634bb89","modified":1534381671561},{"_id":"public/archives/2018/page/5/index.html","hash":"e4e3cb6534a7d7f9fa5562e6e8ec342a94b3df9b","modified":1534381671561},{"_id":"public/archives/2018/04/index.html","hash":"e74f6409e925a66b063603bb6ad4014aafadc847","modified":1534381671561},{"_id":"public/archives/2018/05/index.html","hash":"bf4787127fc961fbd9d203a8592050d8071cc6c9","modified":1534381671561},{"_id":"public/archives/2018/06/index.html","hash":"5ec4948023f0ce12febc4af34a4b9b18fddddb9a","modified":1534381671561},{"_id":"public/archives/2018/06/page/2/index.html","hash":"8ed8cb6c70a575dfb6560d5adf72f68e3c9725bf","modified":1534381671561},{"_id":"public/archives/2018/06/page/3/index.html","hash":"711b80061d53049ac1f2bfc589c444ce74b8b296","modified":1534381671561},{"_id":"public/archives/2018/07/index.html","hash":"0abafd7689277453f777d12c25c6f075ad216a81","modified":1534381671561},{"_id":"public/archives/2018/07/page/2/index.html","hash":"7fff02b0a25f35f24c633f04b4cb7bb2c791de14","modified":1534381671561},{"_id":"public/index.html","hash":"4eca6086d339aefd5a80183b16e12efd51715c9f","modified":1534381671561},{"_id":"public/page/2/index.html","hash":"5620158c6e0bcb09263ebbb663dea8498b2cb711","modified":1534381671561},{"_id":"public/page/3/index.html","hash":"ee6a995fe2315b1e89b8fe9cf9a57001b73d2e3b","modified":1534381671562},{"_id":"public/page/4/index.html","hash":"aa6605d26a24f25f281696b9ba29a69b9fb4adf6","modified":1534381671562},{"_id":"public/page/5/index.html","hash":"02db56775f77001b76ac66ae02a43881a3fa2e21","modified":1534381671562},{"_id":"public/page/6/index.html","hash":"3028810b64e911e679663df1cca1fc2ec0602692","modified":1534381671562},{"_id":"public/page/7/index.html","hash":"f8902bcf11a513a2565f7fa0ea50f787532307fb","modified":1534381671562},{"_id":"public/page/8/index.html","hash":"e44ae29ded890ab62d4356f14e7a049222bfd8bd","modified":1534381671562},{"_id":"public/page/9/index.html","hash":"618a5065da0f98348e3378da56396d7a1c7b9ca6","modified":1534381671562},{"_id":"public/page/10/index.html","hash":"eace8f6047c6f1b3d1d24ec1b3a28a185c14ebd9","modified":1534381671562},{"_id":"public/tags/DSA/index.html","hash":"146a9af9ded9f9c127a14a8b3229d28911730c77","modified":1534381671562},{"_id":"public/tags/ECC/index.html","hash":"44190dd5b3aa9731ad3cfe1e80c8c3b2ad9c05be","modified":1534381671562},{"_id":"public/tags/签名/index.html","hash":"90796dfc57e3948fbee01445f1ed3b36d34058ff","modified":1534381671562},{"_id":"public/tags/验签/index.html","hash":"86df00886730ab148204bf01d3ece96b7026c1d0","modified":1534381671563},{"_id":"public/tags/Swift/index.html","hash":"a773731450e00fa6a9040c5e3da9e9a77aa533a8","modified":1534381671563},{"_id":"public/tags/Gif/index.html","hash":"ab00f971b8203858d75f6899ac7e3a8f92016d9c","modified":1534381671563},{"_id":"public/tags/动画/index.html","hash":"38aeb193bdfb785e6c13501c4361a4b2f3bf15dd","modified":1534381671563},{"_id":"public/tags/runloop/index.html","hash":"82bd4f9546db515b684f134cd70aafcac67c2010","modified":1534381671563},{"_id":"public/tags/CADisplayLink/index.html","hash":"ebff01fe1aa4034b6dc88907be6b3d9d7fbb8c6b","modified":1534381671563},{"_id":"public/tags/github/index.html","hash":"60d6ac789b36a2b6f80390086570c1d5612264ec","modified":1534381671563},{"_id":"public/tags/hexo/index.html","hash":"03e1e2ace0b1eb13b47a658e201fb83bfb0d80d8","modified":1534381671563},{"_id":"public/tags/iOS/index.html","hash":"fc925df50e88f8806acc8eeb3a4ea31bcccb23f2","modified":1534381671563},{"_id":"public/tags/iOS/page/2/index.html","hash":"6a44ee0680fa72771d027ece5c70140cecf4c457","modified":1534381671563},{"_id":"public/tags/iOS/page/3/index.html","hash":"e6557fe7e4dd33dc66791ef90032dc55253dfbb9","modified":1534381671563},{"_id":"public/tags/iOS/page/4/index.html","hash":"dfe18e5381a1ab3043d5f4fd566663e38b54aa7d","modified":1534381671563},{"_id":"public/tags/语音识别/index.html","hash":"369067d593725ebee3462122d03f4c6146b522c3","modified":1534381671563},{"_id":"public/tags/macOS/index.html","hash":"b1f01237c5ee1ce5e446f1d060d20af37b9f7c98","modified":1534381671564},{"_id":"public/tags/macOSApp/index.html","hash":"4fa73eaee62273d35d6381658208dc6164d29939","modified":1534381671564},{"_id":"public/tags/图片去重/index.html","hash":"480cbf7b57b6bad2b1cb90df400ab1401161369c","modified":1534381671564},{"_id":"public/tags/图片相似查询/index.html","hash":"e4be87b4a7f9384de64e539241446db710c1ca37","modified":1534381671564},{"_id":"public/tags/文件处理/index.html","hash":"745c5131a943a4015df8a897d8fdc87c0936d219","modified":1534381671564},{"_id":"public/tags/文件重命名/index.html","hash":"aa072c596fd0ca68cee9c83d94f98a2eb41e606f","modified":1534381671564},{"_id":"public/tags/RSA/index.html","hash":"0f2b95f44f8487e9b96df3b577e9f3b120b8ade2","modified":1534381671564},{"_id":"public/tags/单例/index.html","hash":"00602ea9f3353af3d93f3d3cf5039722409c40e1","modified":1534381671564},{"_id":"public/tags/懒加载/index.html","hash":"09b9e441dfca34d16073c0df7418c4b7ab38c9aa","modified":1534381671565},{"_id":"public/tags/extension/index.html","hash":"e31d28c88680fa27b6869de0480fce3b39f7fd2d","modified":1534381671565},{"_id":"public/tags/网络请求/index.html","hash":"a7e3adc94f939181a4c9dc1d9cf05106d9e78748","modified":1534381671565},{"_id":"public/tags/workspace/index.html","hash":"f333bdea7f55356cd19aae25b0976695fd925fec","modified":1534381671565},{"_id":"public/tags/etcd/index.html","hash":"3fd3cce94258fee04a22e3706e079927415bb552","modified":1534381671565},{"_id":"public/tags/分布式/index.html","hash":"8ac8ea99f590f36ed2ff0cb8335db2dfa8f0db36","modified":1534381671565},{"_id":"public/tags/服务器集群/index.html","hash":"db3c444ef9db65f5ece4309590189c67636d2a0c","modified":1534381671565},{"_id":"public/tags/ssh-key/index.html","hash":"d3ecfd88d8254bc69dc8f2d86fef9f0e51387359","modified":1534381671565},{"_id":"public/tags/数组/index.html","hash":"ffc8b71d2e129dd86744425f824fc8539b68b842","modified":1534381671565},{"_id":"public/tags/go/index.html","hash":"ec9f9a06552c890e8d905e1d3d5727b8c1045c7a","modified":1534381671565},{"_id":"public/tags/go/page/2/index.html","hash":"24244cce4c1addd2288f2e0354a0ed372c81b7a6","modified":1534381671565},{"_id":"public/tags/加密算法/index.html","hash":"e707046b6272dbf3474ec4116ad9741d4ce343bb","modified":1534381671565},{"_id":"public/tags/hash/index.html","hash":"865506aadb891d7e9157075b735f4f971cbd3a60","modified":1534381671565},{"_id":"public/tags/MD5/index.html","hash":"6292287d64f98cadb1a3dc56327abc8182878a92","modified":1534381671565},{"_id":"public/tags/sha256/index.html","hash":"023caf29b015cfe7e33b75f755996ef170eb76a4","modified":1534381671565},{"_id":"public/tags/rpemd160/index.html","hash":"432c9b4357fff3e3a6b89c929c805ded501788a7","modified":1534381671565},{"_id":"public/tags/配置/index.html","hash":"5d6a5db5551d02a6e6d1623b1852c998214c0f70","modified":1534381671566},{"_id":"public/tags/视频/index.html","hash":"2ff0af6df81448dc036c9fe32d209bb248575a8e","modified":1534381671566},{"_id":"public/tags/录制视频/index.html","hash":"ed3cd4b7c58341d9d4d0a62e47d4eff91e5ea42f","modified":1534381671566},{"_id":"public/tags/公共库/index.html","hash":"7308dad73436f17086f65f8d661f2fc57eb2f5e0","modified":1534381671566},{"_id":"public/tags/缓存/index.html","hash":"10f668b13c1b0efef9867aa8ee3087bf7d79a315","modified":1534381671566},{"_id":"public/tags/性能/index.html","hash":"051e49b5c4d5672b5cef35bb6e90a1a3487a20ca","modified":1534381671566},{"_id":"public/tags/越界/index.html","hash":"52ce04fd06e4be0b84188617acdf931da8d6c0fd","modified":1534381671566},{"_id":"public/tags/NSArray/index.html","hash":"52f7a090c369a516ba95c9d904c37bed81a98cab","modified":1534381671566},{"_id":"public/tags/NSMutableArray/index.html","hash":"ac4624b41c0cc4eee62ee67bedc615f7f8427711","modified":1534381671566},{"_id":"public/tags/crash/index.html","hash":"4eb606767bc56e965a9ba8b705b34d8f3d3082f2","modified":1534381671566},{"_id":"public/tags/AVplayer/index.html","hash":"6b8c8d81896ddbc5ff5eb4daad98ac1bba54d2e8","modified":1534381671566},{"_id":"public/tags/instruments/index.html","hash":"7725430cac6e8765ff90648b5fb9fc2366eebed2","modified":1534381671566},{"_id":"public/tags/mongodb/index.html","hash":"a997413a68da27eb726baf60774612fe08d429a3","modified":1534381671567},{"_id":"public/tags/数据库/index.html","hash":"8f7425426cd6ccb5dd0f2e237d95c45547e50532","modified":1534381671567},{"_id":"public/tags/环境变量/index.html","hash":"ce8ae9ac8f04dc5dc235b3945dba9e250bf21994","modified":1534381671567},{"_id":"public/tags/runtime/index.html","hash":"324b9a93627154af968093620c83374c46f386c6","modified":1534381671567},{"_id":"public/tags/Method-Swizzling/index.html","hash":"b9e7c026325a9f0f0c34cdd514e13658b5f9ec23","modified":1534381671567},{"_id":"public/tags/自动布局/index.html","hash":"524e7937c544e0fcc25b03c75fb24e2a22974413","modified":1534381671567},{"_id":"public/tags/slice/index.html","hash":"58b2b5f95e41c9a426c10ae8210a2db2b7704acd","modified":1534381671567},{"_id":"public/tags/排序/index.html","hash":"82e948984afb562936f9f28ac146008baf28cdf3","modified":1534381671567},{"_id":"public/tags/UI/index.html","hash":"cc497e315cf20a54ab7ed85c26c1753dbef62b2f","modified":1534381671567},{"_id":"public/tags/POS/index.html","hash":"28cff36ebf156027239694f3894989a347be03bf","modified":1534381671567},{"_id":"public/tags/共识算法/index.html","hash":"fb8d9e6bfd805ad73b72462f71d556bf9c3411fe","modified":1534381671568},{"_id":"public/tags/DPOS/index.html","hash":"987dbc438a0f01a3623bad0c57312eaef0c19f11","modified":1534381671568},{"_id":"public/tags/POW/index.html","hash":"61a7c1fbadb16714903ef4df771466b1557a79a4","modified":1534381671568},{"_id":"public/tags/Raft/index.html","hash":"2e5d94331554a6777d32900e77271959caf9df8a","modified":1534381671568},{"_id":"public/tags/strings/index.html","hash":"b0387780e0e6c40cb46bf8a1ae027854b14fcca0","modified":1534381671568},{"_id":"public/tags/字符串操作/index.html","hash":"d86e44000fc96340409ebf94587820b0915666e1","modified":1534381671568},{"_id":"public/tags/AES/index.html","hash":"9ad26f149855ea8eefc76ee6ef0d972c4bd6cb12","modified":1534381671568},{"_id":"public/tags/对称加密/index.html","hash":"d89cce86e888a5a4fd93f68b9e6d16e30607d7e2","modified":1534381671568},{"_id":"public/tags/DES/index.html","hash":"db54dbf3b3f5f6d8ef2e734f4a21682ab7fd7789","modified":1534381671569},{"_id":"public/tags/3DES/index.html","hash":"9632e0651b036bdaa9e771407c9822f0d8ad69ef","modified":1534381671569},{"_id":"public/tags/拜占庭/index.html","hash":"77ccecc4eccf83073ad5de2afb5fe6f39214751a","modified":1534381671569},{"_id":"public/tags/PBFT/index.html","hash":"c06a73e79e0a51e0a4804df0bd4fd0ad4fe55f60","modified":1534381671569},{"_id":"public/tags/UIRefreshControl/index.html","hash":"5b12ade3d71581e5536704d9e0de2366df344a23","modified":1534381671569},{"_id":"public/tags/非对称加密/index.html","hash":"7d0129c0e946c1c1bc28b7b46b39b2bcfc32890b","modified":1534381671569}],"Category":[{"name":"加密算法","_id":"cjkvv5td90004lx60tp50yygo"},{"name":"Swfit","_id":"cjkvv5tdg000blx60khajht9b"},{"name":"随笔","_id":"cjkvv5tdl000glx60zy19tiq0"},{"name":"iOS技术","_id":"cjkvv5tdw000llx60y8upbiu2"},{"name":"macOS","_id":"cjkvv5te1000rlx6095nxza2c"},{"name":"iOS配置","_id":"cjkvv5ted001dlx60bbaef09t"},{"name":"区块链","_id":"cjkvv5teg001jlx60y93hjhpa"},{"name":"go","_id":"cjkvv5ten001wlx60ig5ucfri"},{"name":"共识算法","_id":"cjkvv5tf7002olx60hk4dpncf"}],"Data":[],"Page":[{"title":"about","date":"2016-11-23T13:58:16.000Z","comments":0,"_content":"\n## 关于我\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=29803270&auto=1&height=66\"></iframe>\n\n### 钱佳能\n\n> 毕业于景德镇陶瓷大学\n> 90后 双鱼座  coding studying\n> 旅行 爬山 乒乓球 卡丁车\n\n### 联系方式\n> 微信：cywt123\n> 邮箱：dearqjn@gmail.com\n\n### 当前地址\n> 北京●朝阳●望京\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-11-23 21:58:16\ncomments: false\n---\n\n## 关于我\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=29803270&auto=1&height=66\"></iframe>\n\n### 钱佳能\n\n> 毕业于景德镇陶瓷大学\n> 90后 双鱼座  coding studying\n> 旅行 爬山 乒乓球 卡丁车\n\n### 联系方式\n> 微信：cywt123\n> 邮箱：dearqjn@gmail.com\n\n### 当前地址\n> 北京●朝阳●望京\n\n","updated":"2016-11-23T14:10:52.000Z","path":"about/index.html","layout":"page","_id":"cjkvv5td50001lx60kzxp8k0g","content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"http://music.163.com/outchain/player?type=2&id=29803270&auto=1&height=66\"></iframe>\n\n<h3 id=\"钱佳能\"><a href=\"#钱佳能\" class=\"headerlink\" title=\"钱佳能\"></a>钱佳能</h3><blockquote>\n<p>毕业于景德镇陶瓷大学<br>90后 双鱼座  coding studying<br>旅行 爬山 乒乓球 卡丁车</p>\n</blockquote>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><blockquote>\n<p>微信：cywt123<br>邮箱：dearqjn@gmail.com</p>\n</blockquote>\n<h3 id=\"当前地址\"><a href=\"#当前地址\" class=\"headerlink\" title=\"当前地址\"></a>当前地址</h3><blockquote>\n<p>北京●朝阳●望京</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=29803270&auto=1&height=66\"></iframe>\n\n<h3 id=\"钱佳能\"><a href=\"#钱佳能\" class=\"headerlink\" title=\"钱佳能\"></a>钱佳能</h3><blockquote>\n<p>毕业于景德镇陶瓷大学<br>90后 双鱼座  coding studying<br>旅行 爬山 乒乓球 卡丁车</p>\n</blockquote>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><blockquote>\n<p>微信：cywt123<br>邮箱：dearqjn@gmail.com</p>\n</blockquote>\n<h3 id=\"当前地址\"><a href=\"#当前地址\" class=\"headerlink\" title=\"当前地址\"></a>当前地址</h3><blockquote>\n<p>北京●朝阳●望京</p>\n</blockquote>\n"},{"title":"分类","date":"2016-11-16T14:01:22.000Z","type":"categories","comments":0,"_content":"\n\n","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2016-11-16 22:01:22\ntype: \"categories\"\ncomments: false\n---\n\n\n","updated":"2016-11-16T15:09:14.000Z","path":"categories/index.html","layout":"page","_id":"cjkvv5td80003lx60hwasd04h","content":"","excerpt":"","more":""},{"title":"photo","date":"2016-11-23T14:52:52.000Z","_content":"","source":"photo/index.md","raw":"---\ntitle: photo\ndate: 2016-11-23 22:52:52\n---\n","updated":"2016-11-23T14:52:52.000Z","path":"photo/index.html","comments":1,"layout":"page","_id":"cjkvv5tdc0007lx6065ci47rr","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-10-19T22:49:50.000Z","type":"tags","comments":0,"_content":"\n\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-10-20 06:49:50\ntype: \"tags\"\ncomments: false\n---\n\n\n","updated":"2016-11-15T15:37:20.000Z","path":"tags/index.html","layout":"page","_id":"cjkvv5tdd0009lx60am8wrf1j","content":"","excerpt":"","more":""}],"Post":[{"title":"DSA和ECC签名验签","date":"2018-06-28T10:52:24.000Z","_content":"\n## DSA\n\nDSA 是专业用于数字签名和验签，并且只有这个作用, 不能用于加密和解密。\n在安全性上，DSA和RSA差不多，但是速度比RSA快很多。\n\n<!--more-->\n\n### DSA签名和验签\n\n```\nfunc main()  {\n\n\t//设置私钥使用的参数\n\tvar param dsa.Parameters\n\tdsa.GenerateParameters(&param, rand.Reader, dsa.L1024N160)\n\n\t//创建私钥\n\tvar pri dsa.PrivateKey\n\tpri.Parameters = param\n\tdsa.GenerateKey(&pri, rand.Reader)\n\n\n\t//生成公钥\n\tpub := pri.PublicKey\n\n\n\t//签名\n\tmessage := []byte(\"hello\")\n\tr,s,_ := dsa.Sign(rand.Reader, &pri, message)\n\n\n\t//验证\n\tif dsa.Verify(&pub, message, r, s){\n\t\tfmt.Println(\"验签成功\")\n\t}\n\t\n}\n```\n\n## ECC\n椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。\n\n椭圆曲线在密码学中的使用，是1985年由Neal Koblitz和Victor Miller分别独立提出的。\n比特币就是用ECC来做签名和验签。\n\n### 优点\n\n* 安全性高。160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。\n* 计算量小,处理速度快,在私钥的处理速度上(解密和签名),ECC远比RSA、DSA快得多\n* 存储空间占用小,ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多, 所以占用的存储进空间小得多\n* 带宽要求低使得ECC具有广泛得应用前景\n\n\n### 椭圆曲线\n\n一般情况下，椭圆曲线可用下列方程式来表示，其中a,b,c,d为系数。\n> E:y<sup>2</sup>=ax<sup>3</sup>+ bx<sup>2</sup>+cx+d\n\n例如，当a=1,b=0,c=-2,d=4时，所得到的椭圆曲线为:\n\n> E:y<sup>2</sup>=x<sup>3</sup>-2x+4\n\n该椭圆曲线E的图像如图X-1所示，可以看出根本就不是椭圆形。　　\n\n![](http://olgjbx93m.bkt.clouddn.com/20180117-211235.png)\n\n### ECC签名和验签\n\n```\nfunc main()  {\n\n\tmessage := []byte(\"hello\")\n\n\t//设置生成的私钥为256位\n\tprivatekey,_ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\n\t//创建公钥\n\tpublicKey := privatekey.PublicKey\n\n\t//hash散列明文\n\tdigest := sha256.Sum256(message)\n\n\n\t//用私钥签名\n\tr,s,_:= ecdsa.Sign(rand.Reader,privatekey, digest[:])\n\n\t//设置私钥的参数类型\n\tparam := privatekey.Curve.Params()\n\n\t//获取私钥的长度（字节）\n\tcurveOrderBytes:=param.P.BitLen()/8\n\n\t//获得签名返回的字节\n\trByte,sByte := r.Bytes(), s.Bytes()\n\n\t//创建数组合并字节\n\tsignature := make([]byte,curveOrderBytes*2)\n\tcopy(signature[:len(rByte)], rByte)\n\tcopy(signature[len(sByte):], sByte)\n\n\t//现在signature中就存放了完整的签名的结果\n\n\t//验签\n\tdigest = sha256.Sum256(message)\n\t//获得公钥的字节长度\n\tcurveOrderBytes= publicKey.Curve.Params().P.BitLen()/8\n\n\t//创建大整数类型保存rbyte,sbyte\n\tr,s = new(big.Int),new(big.Int)\n\n\tr.SetBytes(signature[:curveOrderBytes])\n\ts.SetBytes(signature[curveOrderBytes:])\n\n\n\t//开始认证\n\te:=ecdsa.Verify(&publicKey,digest[:],r,s)\n\tif e== true {\n\t\tfmt.Println(\"验签成功\")\n\t}\n}\n```\n\n\n\n\n","source":"_posts/DSA和ECC签名验签.md","raw":"---\ntitle: DSA和ECC签名验签\ncategories:\n  - 加密算法\ntags:\n  - DSA\n  - ECC\n  - 签名\n  - 验签\ndate: 2018-06-28 18:52:24\n---\n\n## DSA\n\nDSA 是专业用于数字签名和验签，并且只有这个作用, 不能用于加密和解密。\n在安全性上，DSA和RSA差不多，但是速度比RSA快很多。\n\n<!--more-->\n\n### DSA签名和验签\n\n```\nfunc main()  {\n\n\t//设置私钥使用的参数\n\tvar param dsa.Parameters\n\tdsa.GenerateParameters(&param, rand.Reader, dsa.L1024N160)\n\n\t//创建私钥\n\tvar pri dsa.PrivateKey\n\tpri.Parameters = param\n\tdsa.GenerateKey(&pri, rand.Reader)\n\n\n\t//生成公钥\n\tpub := pri.PublicKey\n\n\n\t//签名\n\tmessage := []byte(\"hello\")\n\tr,s,_ := dsa.Sign(rand.Reader, &pri, message)\n\n\n\t//验证\n\tif dsa.Verify(&pub, message, r, s){\n\t\tfmt.Println(\"验签成功\")\n\t}\n\t\n}\n```\n\n## ECC\n椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。\n\n椭圆曲线在密码学中的使用，是1985年由Neal Koblitz和Victor Miller分别独立提出的。\n比特币就是用ECC来做签名和验签。\n\n### 优点\n\n* 安全性高。160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。\n* 计算量小,处理速度快,在私钥的处理速度上(解密和签名),ECC远比RSA、DSA快得多\n* 存储空间占用小,ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多, 所以占用的存储进空间小得多\n* 带宽要求低使得ECC具有广泛得应用前景\n\n\n### 椭圆曲线\n\n一般情况下，椭圆曲线可用下列方程式来表示，其中a,b,c,d为系数。\n> E:y<sup>2</sup>=ax<sup>3</sup>+ bx<sup>2</sup>+cx+d\n\n例如，当a=1,b=0,c=-2,d=4时，所得到的椭圆曲线为:\n\n> E:y<sup>2</sup>=x<sup>3</sup>-2x+4\n\n该椭圆曲线E的图像如图X-1所示，可以看出根本就不是椭圆形。　　\n\n![](http://olgjbx93m.bkt.clouddn.com/20180117-211235.png)\n\n### ECC签名和验签\n\n```\nfunc main()  {\n\n\tmessage := []byte(\"hello\")\n\n\t//设置生成的私钥为256位\n\tprivatekey,_ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\n\t//创建公钥\n\tpublicKey := privatekey.PublicKey\n\n\t//hash散列明文\n\tdigest := sha256.Sum256(message)\n\n\n\t//用私钥签名\n\tr,s,_:= ecdsa.Sign(rand.Reader,privatekey, digest[:])\n\n\t//设置私钥的参数类型\n\tparam := privatekey.Curve.Params()\n\n\t//获取私钥的长度（字节）\n\tcurveOrderBytes:=param.P.BitLen()/8\n\n\t//获得签名返回的字节\n\trByte,sByte := r.Bytes(), s.Bytes()\n\n\t//创建数组合并字节\n\tsignature := make([]byte,curveOrderBytes*2)\n\tcopy(signature[:len(rByte)], rByte)\n\tcopy(signature[len(sByte):], sByte)\n\n\t//现在signature中就存放了完整的签名的结果\n\n\t//验签\n\tdigest = sha256.Sum256(message)\n\t//获得公钥的字节长度\n\tcurveOrderBytes= publicKey.Curve.Params().P.BitLen()/8\n\n\t//创建大整数类型保存rbyte,sbyte\n\tr,s = new(big.Int),new(big.Int)\n\n\tr.SetBytes(signature[:curveOrderBytes])\n\ts.SetBytes(signature[curveOrderBytes:])\n\n\n\t//开始认证\n\te:=ecdsa.Verify(&publicKey,digest[:],r,s)\n\tif e== true {\n\t\tfmt.Println(\"验签成功\")\n\t}\n}\n```\n\n\n\n\n","slug":"DSA和ECC签名验签","published":1,"updated":"2018-08-16T01:07:26.498Z","_id":"cjkvv5td20000lx60t4xkb8uk","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"DSA\"><a href=\"#DSA\" class=\"headerlink\" title=\"DSA\"></a>DSA</h2><p>DSA 是专业用于数字签名和验签，并且只有这个作用, 不能用于加密和解密。<br>在安全性上，DSA和RSA差不多，但是速度比RSA快很多。</p>\n<a id=\"more\"></a>\n<h3 id=\"DSA签名和验签\"><a href=\"#DSA签名和验签\" class=\"headerlink\" title=\"DSA签名和验签\"></a>DSA签名和验签</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//设置私钥使用的参数</div><div class=\"line\">\tvar param dsa.Parameters</div><div class=\"line\">\tdsa.GenerateParameters(&amp;param, rand.Reader, dsa.L1024N160)</div><div class=\"line\"></div><div class=\"line\">\t//创建私钥</div><div class=\"line\">\tvar pri dsa.PrivateKey</div><div class=\"line\">\tpri.Parameters = param</div><div class=\"line\">\tdsa.GenerateKey(&amp;pri, rand.Reader)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//生成公钥</div><div class=\"line\">\tpub := pri.PublicKey</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//签名</div><div class=\"line\">\tmessage := []byte(&quot;hello&quot;)</div><div class=\"line\">\tr,s,_ := dsa.Sign(rand.Reader, &amp;pri, message)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//验证</div><div class=\"line\">\tif dsa.Verify(&amp;pub, message, r, s)&#123;</div><div class=\"line\">\t\tfmt.Println(&quot;验签成功&quot;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"ECC\"><a href=\"#ECC\" class=\"headerlink\" title=\"ECC\"></a>ECC</h2><p>椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。</p>\n<p>椭圆曲线在密码学中的使用，是1985年由Neal Koblitz和Victor Miller分别独立提出的。<br>比特币就是用ECC来做签名和验签。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>安全性高。160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。</li>\n<li>计算量小,处理速度快,在私钥的处理速度上(解密和签名),ECC远比RSA、DSA快得多</li>\n<li>存储空间占用小,ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多, 所以占用的存储进空间小得多</li>\n<li>带宽要求低使得ECC具有广泛得应用前景</li>\n</ul>\n<h3 id=\"椭圆曲线\"><a href=\"#椭圆曲线\" class=\"headerlink\" title=\"椭圆曲线\"></a>椭圆曲线</h3><p>一般情况下，椭圆曲线可用下列方程式来表示，其中a,b,c,d为系数。</p>\n<blockquote>\n<p>E:y<sup>2</sup>=ax<sup>3</sup>+ bx<sup>2</sup>+cx+d</p>\n</blockquote>\n<p>例如，当a=1,b=0,c=-2,d=4时，所得到的椭圆曲线为:</p>\n<blockquote>\n<p>E:y<sup>2</sup>=x<sup>3</sup>-2x+4</p>\n</blockquote>\n<p>该椭圆曲线E的图像如图X-1所示，可以看出根本就不是椭圆形。　　</p>\n<p><img src=\"http://olgjbx93m.bkt.clouddn.com/20180117-211235.png\" alt=\"\"></p>\n<h3 id=\"ECC签名和验签\"><a href=\"#ECC签名和验签\" class=\"headerlink\" title=\"ECC签名和验签\"></a>ECC签名和验签</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tmessage := []byte(&quot;hello&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//设置生成的私钥为256位</div><div class=\"line\">\tprivatekey,_ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)</div><div class=\"line\"></div><div class=\"line\">\t//创建公钥</div><div class=\"line\">\tpublicKey := privatekey.PublicKey</div><div class=\"line\"></div><div class=\"line\">\t//hash散列明文</div><div class=\"line\">\tdigest := sha256.Sum256(message)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//用私钥签名</div><div class=\"line\">\tr,s,_:= ecdsa.Sign(rand.Reader,privatekey, digest[:])</div><div class=\"line\"></div><div class=\"line\">\t//设置私钥的参数类型</div><div class=\"line\">\tparam := privatekey.Curve.Params()</div><div class=\"line\"></div><div class=\"line\">\t//获取私钥的长度（字节）</div><div class=\"line\">\tcurveOrderBytes:=param.P.BitLen()/8</div><div class=\"line\"></div><div class=\"line\">\t//获得签名返回的字节</div><div class=\"line\">\trByte,sByte := r.Bytes(), s.Bytes()</div><div class=\"line\"></div><div class=\"line\">\t//创建数组合并字节</div><div class=\"line\">\tsignature := make([]byte,curveOrderBytes*2)</div><div class=\"line\">\tcopy(signature[:len(rByte)], rByte)</div><div class=\"line\">\tcopy(signature[len(sByte):], sByte)</div><div class=\"line\"></div><div class=\"line\">\t//现在signature中就存放了完整的签名的结果</div><div class=\"line\"></div><div class=\"line\">\t//验签</div><div class=\"line\">\tdigest = sha256.Sum256(message)</div><div class=\"line\">\t//获得公钥的字节长度</div><div class=\"line\">\tcurveOrderBytes= publicKey.Curve.Params().P.BitLen()/8</div><div class=\"line\"></div><div class=\"line\">\t//创建大整数类型保存rbyte,sbyte</div><div class=\"line\">\tr,s = new(big.Int),new(big.Int)</div><div class=\"line\"></div><div class=\"line\">\tr.SetBytes(signature[:curveOrderBytes])</div><div class=\"line\">\ts.SetBytes(signature[curveOrderBytes:])</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//开始认证</div><div class=\"line\">\te:=ecdsa.Verify(&amp;publicKey,digest[:],r,s)</div><div class=\"line\">\tif e== true &#123;</div><div class=\"line\">\t\tfmt.Println(&quot;验签成功&quot;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<h2 id=\"DSA\"><a href=\"#DSA\" class=\"headerlink\" title=\"DSA\"></a>DSA</h2><p>DSA 是专业用于数字签名和验签，并且只有这个作用, 不能用于加密和解密。<br>在安全性上，DSA和RSA差不多，但是速度比RSA快很多。</p>","more":"<h3 id=\"DSA签名和验签\"><a href=\"#DSA签名和验签\" class=\"headerlink\" title=\"DSA签名和验签\"></a>DSA签名和验签</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//设置私钥使用的参数</div><div class=\"line\">\tvar param dsa.Parameters</div><div class=\"line\">\tdsa.GenerateParameters(&amp;param, rand.Reader, dsa.L1024N160)</div><div class=\"line\"></div><div class=\"line\">\t//创建私钥</div><div class=\"line\">\tvar pri dsa.PrivateKey</div><div class=\"line\">\tpri.Parameters = param</div><div class=\"line\">\tdsa.GenerateKey(&amp;pri, rand.Reader)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//生成公钥</div><div class=\"line\">\tpub := pri.PublicKey</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//签名</div><div class=\"line\">\tmessage := []byte(&quot;hello&quot;)</div><div class=\"line\">\tr,s,_ := dsa.Sign(rand.Reader, &amp;pri, message)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//验证</div><div class=\"line\">\tif dsa.Verify(&amp;pub, message, r, s)&#123;</div><div class=\"line\">\t\tfmt.Println(&quot;验签成功&quot;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"ECC\"><a href=\"#ECC\" class=\"headerlink\" title=\"ECC\"></a>ECC</h2><p>椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。</p>\n<p>椭圆曲线在密码学中的使用，是1985年由Neal Koblitz和Victor Miller分别独立提出的。<br>比特币就是用ECC来做签名和验签。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>安全性高。160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密。</li>\n<li>计算量小,处理速度快,在私钥的处理速度上(解密和签名),ECC远比RSA、DSA快得多</li>\n<li>存储空间占用小,ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多, 所以占用的存储进空间小得多</li>\n<li>带宽要求低使得ECC具有广泛得应用前景</li>\n</ul>\n<h3 id=\"椭圆曲线\"><a href=\"#椭圆曲线\" class=\"headerlink\" title=\"椭圆曲线\"></a>椭圆曲线</h3><p>一般情况下，椭圆曲线可用下列方程式来表示，其中a,b,c,d为系数。</p>\n<blockquote>\n<p>E:y<sup>2</sup>=ax<sup>3</sup>+ bx<sup>2</sup>+cx+d</p>\n</blockquote>\n<p>例如，当a=1,b=0,c=-2,d=4时，所得到的椭圆曲线为:</p>\n<blockquote>\n<p>E:y<sup>2</sup>=x<sup>3</sup>-2x+4</p>\n</blockquote>\n<p>该椭圆曲线E的图像如图X-1所示，可以看出根本就不是椭圆形。　　</p>\n<p><img src=\"http://olgjbx93m.bkt.clouddn.com/20180117-211235.png\" alt=\"\"></p>\n<h3 id=\"ECC签名和验签\"><a href=\"#ECC签名和验签\" class=\"headerlink\" title=\"ECC签名和验签\"></a>ECC签名和验签</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tmessage := []byte(&quot;hello&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//设置生成的私钥为256位</div><div class=\"line\">\tprivatekey,_ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)</div><div class=\"line\"></div><div class=\"line\">\t//创建公钥</div><div class=\"line\">\tpublicKey := privatekey.PublicKey</div><div class=\"line\"></div><div class=\"line\">\t//hash散列明文</div><div class=\"line\">\tdigest := sha256.Sum256(message)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//用私钥签名</div><div class=\"line\">\tr,s,_:= ecdsa.Sign(rand.Reader,privatekey, digest[:])</div><div class=\"line\"></div><div class=\"line\">\t//设置私钥的参数类型</div><div class=\"line\">\tparam := privatekey.Curve.Params()</div><div class=\"line\"></div><div class=\"line\">\t//获取私钥的长度（字节）</div><div class=\"line\">\tcurveOrderBytes:=param.P.BitLen()/8</div><div class=\"line\"></div><div class=\"line\">\t//获得签名返回的字节</div><div class=\"line\">\trByte,sByte := r.Bytes(), s.Bytes()</div><div class=\"line\"></div><div class=\"line\">\t//创建数组合并字节</div><div class=\"line\">\tsignature := make([]byte,curveOrderBytes*2)</div><div class=\"line\">\tcopy(signature[:len(rByte)], rByte)</div><div class=\"line\">\tcopy(signature[len(sByte):], sByte)</div><div class=\"line\"></div><div class=\"line\">\t//现在signature中就存放了完整的签名的结果</div><div class=\"line\"></div><div class=\"line\">\t//验签</div><div class=\"line\">\tdigest = sha256.Sum256(message)</div><div class=\"line\">\t//获得公钥的字节长度</div><div class=\"line\">\tcurveOrderBytes= publicKey.Curve.Params().P.BitLen()/8</div><div class=\"line\"></div><div class=\"line\">\t//创建大整数类型保存rbyte,sbyte</div><div class=\"line\">\tr,s = new(big.Int),new(big.Int)</div><div class=\"line\"></div><div class=\"line\">\tr.SetBytes(signature[:curveOrderBytes])</div><div class=\"line\">\ts.SetBytes(signature[curveOrderBytes:])</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//开始认证</div><div class=\"line\">\te:=ecdsa.Verify(&amp;publicKey,digest[:],r,s)</div><div class=\"line\">\tif e== true &#123;</div><div class=\"line\">\t\tfmt.Println(&quot;验签成功&quot;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Gif播放与暂停","date":"2017-11-14T02:13:08.000Z","_content":"\n## gif播放的两种方式\n### UIWebView\n\n这应该是播放gif文件最简单的方式了，缺点：无法暂停播放\n\n```\n//1. 把gif文件 转化成 data\nguard let dataPath = Bundle.main.path(forResource: \"demo\", ofType: \"gif\") else { return }\nguard let gifData = NSData(contentsOfFile: dataPath) else { return }\n\n//2. 给UIWebView 设置data\nlet webview = UIWebView()\nwebview.frame = CGRect(x: 0, y: 300, width: self.view.frame.size.width, height: 200)\nwebview.scalesPageToFit = true\nwebview.load(gifData as Data, mimeType: \"image/gif\", textEncodingName: String(), baseURL: NSURL() as URL)\nself.view.addSubview(webview)\n```\n<!--more-->\n### UIImageView\n\n这里面有两个要点，一是从gif文件中获取图片数组，二是获取gif文件播放时长\n\n```\nlet imageView = UIImageView()\nimageView.frame = CGRect(x: 0, y: 50, width: self.view.frame.size.width, height: 200)\nself.view.addSubview(imageView)\n\n// 1. 把gif文件 转化成 data\nguard let dataPath = Bundle.main.path(forResource: \"demo\", ofType: \"gif\") else { return }\nguard let gifData = NSData(contentsOfFile: dataPath) else { return }\n\n// 2. 把data 转换成CGImageSource 对象\nguard let imageSource = CGImageSourceCreateWithData(gifData, nil) else { return }\n// 2.1 获取图片的个数\nlet imageCount = CGImageSourceGetCount(imageSource)\n\nvar images = [UIImage]()\nvar gifDuration : TimeInterval = 0\n// 3. 遍历所有的图片\nfor i in 0..<imageCount {\n    // 3.1 取出图片\n   guard let cgimage = CGImageSourceCreateImageAtIndex(imageSource, i, nil)  else { return }\n\n    let image = UIImage(cgImage: cgimage)\n    images.append(image)\n    if (i == 0) {\n        imageView.image = image\n    }\n    // 3.1 取出每张图片持续的时间\n    guard let property = CGImageSourceCopyPropertiesAtIndex(imageSource, i, nil) as? NSDictionary else { continue }\n    guard let gifDic = property[kCGImagePropertyGIFDictionary] as? NSDictionary else { continue }\n    guard let imageDuration = gifDic[kCGImagePropertyGIFDelayTime] as? NSNumber else { continue }\n    gifDuration += imageDuration.doubleValue\n\n}\n\n// 4.设置images属性\nimageView.animationImages = images\nimageView.animationDuration = gifDuration\nimageView.animationRepeatCount = 1\n\n// 5. 开始播放\nimageView.startAnimating()\n```\n\n## Gif暂停实现\n\n","source":"_posts/Gif播放与暂停.md","raw":"---\ntitle: Gif播放与暂停\ndate: 2017-11-14 10:13:08\ncategories:\n  - Swfit\ntags:\n\t- Swift\n\t- Gif\n\t- 动画\n\t- runloop\n\t- CADisplayLink\n---\n\n## gif播放的两种方式\n### UIWebView\n\n这应该是播放gif文件最简单的方式了，缺点：无法暂停播放\n\n```\n//1. 把gif文件 转化成 data\nguard let dataPath = Bundle.main.path(forResource: \"demo\", ofType: \"gif\") else { return }\nguard let gifData = NSData(contentsOfFile: dataPath) else { return }\n\n//2. 给UIWebView 设置data\nlet webview = UIWebView()\nwebview.frame = CGRect(x: 0, y: 300, width: self.view.frame.size.width, height: 200)\nwebview.scalesPageToFit = true\nwebview.load(gifData as Data, mimeType: \"image/gif\", textEncodingName: String(), baseURL: NSURL() as URL)\nself.view.addSubview(webview)\n```\n<!--more-->\n### UIImageView\n\n这里面有两个要点，一是从gif文件中获取图片数组，二是获取gif文件播放时长\n\n```\nlet imageView = UIImageView()\nimageView.frame = CGRect(x: 0, y: 50, width: self.view.frame.size.width, height: 200)\nself.view.addSubview(imageView)\n\n// 1. 把gif文件 转化成 data\nguard let dataPath = Bundle.main.path(forResource: \"demo\", ofType: \"gif\") else { return }\nguard let gifData = NSData(contentsOfFile: dataPath) else { return }\n\n// 2. 把data 转换成CGImageSource 对象\nguard let imageSource = CGImageSourceCreateWithData(gifData, nil) else { return }\n// 2.1 获取图片的个数\nlet imageCount = CGImageSourceGetCount(imageSource)\n\nvar images = [UIImage]()\nvar gifDuration : TimeInterval = 0\n// 3. 遍历所有的图片\nfor i in 0..<imageCount {\n    // 3.1 取出图片\n   guard let cgimage = CGImageSourceCreateImageAtIndex(imageSource, i, nil)  else { return }\n\n    let image = UIImage(cgImage: cgimage)\n    images.append(image)\n    if (i == 0) {\n        imageView.image = image\n    }\n    // 3.1 取出每张图片持续的时间\n    guard let property = CGImageSourceCopyPropertiesAtIndex(imageSource, i, nil) as? NSDictionary else { continue }\n    guard let gifDic = property[kCGImagePropertyGIFDictionary] as? NSDictionary else { continue }\n    guard let imageDuration = gifDic[kCGImagePropertyGIFDelayTime] as? NSNumber else { continue }\n    gifDuration += imageDuration.doubleValue\n\n}\n\n// 4.设置images属性\nimageView.animationImages = images\nimageView.animationDuration = gifDuration\nimageView.animationRepeatCount = 1\n\n// 5. 开始播放\nimageView.startAnimating()\n```\n\n## Gif暂停实现\n\n","slug":"Gif播放与暂停","published":1,"updated":"2017-11-14T02:15:27.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5td60002lx60v6uat6f2","content":"<h2 id=\"gif播放的两种方式\"><a href=\"#gif播放的两种方式\" class=\"headerlink\" title=\"gif播放的两种方式\"></a>gif播放的两种方式</h2><h3 id=\"UIWebView\"><a href=\"#UIWebView\" class=\"headerlink\" title=\"UIWebView\"></a>UIWebView</h3><p>这应该是播放gif文件最简单的方式了，缺点：无法暂停播放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1. 把gif文件 转化成 data</div><div class=\"line\">guard let dataPath = Bundle.main.path(forResource: &quot;demo&quot;, ofType: &quot;gif&quot;) else &#123; return &#125;</div><div class=\"line\">guard let gifData = NSData(contentsOfFile: dataPath) else &#123; return &#125;</div><div class=\"line\"></div><div class=\"line\">//2. 给UIWebView 设置data</div><div class=\"line\">let webview = UIWebView()</div><div class=\"line\">webview.frame = CGRect(x: 0, y: 300, width: self.view.frame.size.width, height: 200)</div><div class=\"line\">webview.scalesPageToFit = true</div><div class=\"line\">webview.load(gifData as Data, mimeType: &quot;image/gif&quot;, textEncodingName: String(), baseURL: NSURL() as URL)</div><div class=\"line\">self.view.addSubview(webview)</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"UIImageView\"><a href=\"#UIImageView\" class=\"headerlink\" title=\"UIImageView\"></a>UIImageView</h3><p>这里面有两个要点，一是从gif文件中获取图片数组，二是获取gif文件播放时长</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">let imageView = UIImageView()</div><div class=\"line\">imageView.frame = CGRect(x: 0, y: 50, width: self.view.frame.size.width, height: 200)</div><div class=\"line\">self.view.addSubview(imageView)</div><div class=\"line\"></div><div class=\"line\">// 1. 把gif文件 转化成 data</div><div class=\"line\">guard let dataPath = Bundle.main.path(forResource: &quot;demo&quot;, ofType: &quot;gif&quot;) else &#123; return &#125;</div><div class=\"line\">guard let gifData = NSData(contentsOfFile: dataPath) else &#123; return &#125;</div><div class=\"line\"></div><div class=\"line\">// 2. 把data 转换成CGImageSource 对象</div><div class=\"line\">guard let imageSource = CGImageSourceCreateWithData(gifData, nil) else &#123; return &#125;</div><div class=\"line\">// 2.1 获取图片的个数</div><div class=\"line\">let imageCount = CGImageSourceGetCount(imageSource)</div><div class=\"line\"></div><div class=\"line\">var images = [UIImage]()</div><div class=\"line\">var gifDuration : TimeInterval = 0</div><div class=\"line\">// 3. 遍历所有的图片</div><div class=\"line\">for i in 0..&lt;imageCount &#123;</div><div class=\"line\">    // 3.1 取出图片</div><div class=\"line\">   guard let cgimage = CGImageSourceCreateImageAtIndex(imageSource, i, nil)  else &#123; return &#125;</div><div class=\"line\"></div><div class=\"line\">    let image = UIImage(cgImage: cgimage)</div><div class=\"line\">    images.append(image)</div><div class=\"line\">    if (i == 0) &#123;</div><div class=\"line\">        imageView.image = image</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 3.1 取出每张图片持续的时间</div><div class=\"line\">    guard let property = CGImageSourceCopyPropertiesAtIndex(imageSource, i, nil) as? NSDictionary else &#123; continue &#125;</div><div class=\"line\">    guard let gifDic = property[kCGImagePropertyGIFDictionary] as? NSDictionary else &#123; continue &#125;</div><div class=\"line\">    guard let imageDuration = gifDic[kCGImagePropertyGIFDelayTime] as? NSNumber else &#123; continue &#125;</div><div class=\"line\">    gifDuration += imageDuration.doubleValue</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 4.设置images属性</div><div class=\"line\">imageView.animationImages = images</div><div class=\"line\">imageView.animationDuration = gifDuration</div><div class=\"line\">imageView.animationRepeatCount = 1</div><div class=\"line\"></div><div class=\"line\">// 5. 开始播放</div><div class=\"line\">imageView.startAnimating()</div></pre></td></tr></table></figure>\n<h2 id=\"Gif暂停实现\"><a href=\"#Gif暂停实现\" class=\"headerlink\" title=\"Gif暂停实现\"></a>Gif暂停实现</h2>","excerpt":"<h2 id=\"gif播放的两种方式\"><a href=\"#gif播放的两种方式\" class=\"headerlink\" title=\"gif播放的两种方式\"></a>gif播放的两种方式</h2><h3 id=\"UIWebView\"><a href=\"#UIWebView\" class=\"headerlink\" title=\"UIWebView\"></a>UIWebView</h3><p>这应该是播放gif文件最简单的方式了，缺点：无法暂停播放</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1. 把gif文件 转化成 data</div><div class=\"line\">guard let dataPath = Bundle.main.path(forResource: &quot;demo&quot;, ofType: &quot;gif&quot;) else &#123; return &#125;</div><div class=\"line\">guard let gifData = NSData(contentsOfFile: dataPath) else &#123; return &#125;</div><div class=\"line\"></div><div class=\"line\">//2. 给UIWebView 设置data</div><div class=\"line\">let webview = UIWebView()</div><div class=\"line\">webview.frame = CGRect(x: 0, y: 300, width: self.view.frame.size.width, height: 200)</div><div class=\"line\">webview.scalesPageToFit = true</div><div class=\"line\">webview.load(gifData as Data, mimeType: &quot;image/gif&quot;, textEncodingName: String(), baseURL: NSURL() as URL)</div><div class=\"line\">self.view.addSubview(webview)</div></pre></td></tr></table></figure>","more":"<h3 id=\"UIImageView\"><a href=\"#UIImageView\" class=\"headerlink\" title=\"UIImageView\"></a>UIImageView</h3><p>这里面有两个要点，一是从gif文件中获取图片数组，二是获取gif文件播放时长</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">let imageView = UIImageView()</div><div class=\"line\">imageView.frame = CGRect(x: 0, y: 50, width: self.view.frame.size.width, height: 200)</div><div class=\"line\">self.view.addSubview(imageView)</div><div class=\"line\"></div><div class=\"line\">// 1. 把gif文件 转化成 data</div><div class=\"line\">guard let dataPath = Bundle.main.path(forResource: &quot;demo&quot;, ofType: &quot;gif&quot;) else &#123; return &#125;</div><div class=\"line\">guard let gifData = NSData(contentsOfFile: dataPath) else &#123; return &#125;</div><div class=\"line\"></div><div class=\"line\">// 2. 把data 转换成CGImageSource 对象</div><div class=\"line\">guard let imageSource = CGImageSourceCreateWithData(gifData, nil) else &#123; return &#125;</div><div class=\"line\">// 2.1 获取图片的个数</div><div class=\"line\">let imageCount = CGImageSourceGetCount(imageSource)</div><div class=\"line\"></div><div class=\"line\">var images = [UIImage]()</div><div class=\"line\">var gifDuration : TimeInterval = 0</div><div class=\"line\">// 3. 遍历所有的图片</div><div class=\"line\">for i in 0..&lt;imageCount &#123;</div><div class=\"line\">    // 3.1 取出图片</div><div class=\"line\">   guard let cgimage = CGImageSourceCreateImageAtIndex(imageSource, i, nil)  else &#123; return &#125;</div><div class=\"line\"></div><div class=\"line\">    let image = UIImage(cgImage: cgimage)</div><div class=\"line\">    images.append(image)</div><div class=\"line\">    if (i == 0) &#123;</div><div class=\"line\">        imageView.image = image</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 3.1 取出每张图片持续的时间</div><div class=\"line\">    guard let property = CGImageSourceCopyPropertiesAtIndex(imageSource, i, nil) as? NSDictionary else &#123; continue &#125;</div><div class=\"line\">    guard let gifDic = property[kCGImagePropertyGIFDictionary] as? NSDictionary else &#123; continue &#125;</div><div class=\"line\">    guard let imageDuration = gifDic[kCGImagePropertyGIFDelayTime] as? NSNumber else &#123; continue &#125;</div><div class=\"line\">    gifDuration += imageDuration.doubleValue</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 4.设置images属性</div><div class=\"line\">imageView.animationImages = images</div><div class=\"line\">imageView.animationDuration = gifDuration</div><div class=\"line\">imageView.animationRepeatCount = 1</div><div class=\"line\"></div><div class=\"line\">// 5. 开始播放</div><div class=\"line\">imageView.startAnimating()</div></pre></td></tr></table></figure>\n<h2 id=\"Gif暂停实现\"><a href=\"#Gif暂停实现\" class=\"headerlink\" title=\"Gif暂停实现\"></a>Gif暂停实现</h2>"},{"title":"使用GitHub搭建Hexo博客","date":"2016-02-23T10:29:00.000Z","description":"来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。","_content":"\n来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。\n国内也有不多少的代码托管平台，本文将就用GitHub的GitHub Pages 功能来搭建，比起WordPress，hexo的搭建更加简洁，配合上markdown的使用，更加便捷的管理自己的学习文档。\n\n<!--more-->\n\n# 概况\n>1. 为什么选择[GitHub Pages](1)\n1、[GitHub Pages](1)有免费的代码托管空间，资料自己管理，保存可靠；\n2、学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多；\n3、顺便理解 GitHub 工作原理，最好的团队协作流程；\n4、GitHub建立私有仓库才会收费，所以会有很多开源代码。\n>2. [GitHub Pages](1)是什么\n应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的\"Initialize this repository with a README\" 。\n>3. [hexo](2)出自何人\nhexo出自台湾大学生 tommy351 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。\n\n# 安装准备\n>环境搭建：\n1. [Node.js](http://nodejs.org/)：下载[地址](https://nodejs.org/en/)\n2. [Git](http://git-scm.com/)：下载[地址](https://git-scm.com/download/win)\n3. [Sublime](http://www.sublimetext.com/)：下载[地址](http://www.sublimetext.com/2)\n## 安装Node \n到 Node.js 官网下载相应平台的 最新版本 ，一路安装即可。我用的是 node-v0.10.22-x86.msi\n## 安装Git \nGit的客户端很多，我用的是 msysgit ，喜欢用绿色版本 Portable application for official Git for Windows 1.8.4 ，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。\n## 安装Sublime\nSublime Text 2 在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的 Sublime Text 3 。\n\n\n# GitHub注册与配置\n\n>1. 注册：\n访问：[GitHub](0)，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。注册过程比较简单，详细也可以看：\n使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考[官方文档](https://pages.github.com/)\n\n>1. 配置和使用Github\n以下教程主要参考beiyuu的[《使用Github Pages建独立博客》](http://beiyuu.com/github-pages/)写成。\n\n>1. 配置SSH keys\n我们如何让本地git项目与远程的github建立联系呢？用SSH keys。\n打开Git Bash工具，执行以下操作\n\n>1. 检查SSH keys的设置\n\n```\n    首先我们需要检查你电脑上现有的ssh key：\n\n$ cd ~/. ssh 检查本机的ssh密钥\n\n    如果提示：No such file or directory 说明你是第一次使用git。\n\n    生成新的SSH Key：\n\n$ ssh-keygen -t rsa -C \"邮件地址@youremail.com\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key \n(/Users/your_user_directory/.ssh/id_rsa):<回车就好>\n```\n注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；\n注意2: 此处的「-C」的是大写的「C」\n\n    然后系统会要你输入密码：\nEnter passphrase (empty for no passphrase):<输入加密串>\nEnter same passphrase again:<再次输入加密串>\n\n在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。\n\n注意：输入密码的时候没有*字样的，你直接输入就可以了。\n\n最后看到这样的界面，就成功设置ssh key了：\n```\n\n```\n\n>5. 添加SSH Key到GitHub\n在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。\n>1. 打开本地C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。\n>2. 登陆github系统。点击右上角的 Account Settings--->SSH Public keys ---> add another public keys\n>3. 把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了\n\n>6. 测试\n\n```\n    可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：\n\n$ ssh -T git@github.com\n\n    如果是下面的反馈：\n\nThe authenticity of host 'github.com (207.97.227.239)' can't be established.\nRSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\nAre you sure you want to continue connecting (yes/no)?\n\n    不要紧张，输入yes就好，然后会看到：\n\nHi cnfeat! You've successfully authenticated, \nbut GitHub does not provide shell access.\n\n\n\n    设置用户信息：\n    现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。\n    Git会根据用户的名字和邮箱来记录提交。\n    GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。\n\n$ git config --global user.name \"cnfeat\"//用户名\n$ git config --global user.email \"cnfeat@gmail.com\"//填写自己的邮箱\n\n    SSH Key配置成功，本机已成功连接到github。\n\n```\n# Hexo博客\n\n>Hexo\nHexo的作者是[tommy351](https://github.com/tommy351/hexo)，根据[官方介绍](http://hexo.io/docs/index.html)，Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。hexo的主题列表 [Hexo Themes](http://github.com/tommy351/hexo/wiki/Themes)。 我比较喜欢 [pacman](http://github.com/A-limon/pacman) ， [modernist](http://github.com/heroicyang/hexo-theme-modernist) 、 [ishgo](http://github.com/DavidKk/Hexo.ishgo) ， [raytaylorism](http://github.com/raytaylorlin/hexo-theme-raytaylorism) 。 \n\n\n\n## 安装Hexo\n\n打开Git Bash工具（前提确保Node.js已经安装，环境配置OK）\n\n    $ npm install -g hexo\n\n>注释：\n\n执行命令：npm install -g hexo，报错如下：\n\n```\nnpm ERR! Error: shasum check failed for C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\npm\n-30024-KDJHJzgP\\registry.npmjs.org\\hexo-cli\\-\\hexo-cli-0.1.6.tgz\nnpm ERR! Expected: 7dc3ab939d0889c4bed6a961605ff3e2d67f67a2\nnpm ERR! Actual:   41de7d67a9b764352eb07c49c32fc38dd7f479b9\nnpm ERR! From:     https://registry.npmjs.org/hexo-cli/-/hexo-cli-0.1.6.tgz\nnpm ERR!     at d:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\sha\\index.\njs:38:8\nnpm ERR!     at ReadStream.<anonymous> (d:\\Program Files\\nodejs\\node_modules\\npm\n\\node_modules\\sha\\index.js:85:7)\nnpm ERR!     at ReadStream.emit (events.js:117:20)\nnpm ERR!     at _stream_readable.js:943:16\nnpm ERR!     at process._tickCallback (node.js:419:13)\nnpm ERR! If you need help, you may report this *entire* log,\nnpm ERR! including the npm and node versions, at:\nnpm ERR!     <http://github.com/npm/npm/issues>\n\nnpm ERR! System Windows_NT 6.2.9200\nnpm ERR! command \"d:\\\\Program Files\\\\nodejs\\\\node.exe\" \"d:\\\\Program Files\\\\nodej\ns\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\" \"install\" \"-g\" \"hexo\"\nnpm ERR! cwd C:\\Users\\Administrator\\Desktop\nnpm ERR! node -v v0.10.31\nnpm ERR! npm -v 1.4.23\nnpm ERR! registry error parsing json\nnpm ERR!\nnpm ERR! Additional logging details can be found in:\nnpm ERR!     C:\\Users\\Administrator\\Desktop\\npm-debug.log\nnpm ERR! not ok code 0\n\n    莫非是因为被墙了？换国内镜像源试试。\nnpm config set registry=\"http://registry.cnpmjs.org\"，\n    然后再次执行npm install -g hexo，成功！\n```\n\n## 部署Hexo\n\n```\n    在我的电脑中建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash。\n\n$ hexo init\n\n    如果无法使用右击“Git Bash”，则可以切换到指定目录\n\n    UUhike@UUhike-pc MINGW64 ~\n$ cd j:/github/hexo\n    UUhike@UUhike-pc MINGW64 /j/github/hexo\n\n    安装依赖包\n$ npm install\n\n    Hexo随后会自动在目标文件夹建立网站所需要的所有文件。\n    现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000看看。\n\n    本地查看\n\n$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）\n\n$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n```\n## 部署到GitHub\n\n```\n\n编辑E:\\hexo下的_config.yml，修改Deployment部分：\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n    repository: https://github.com/luuman/luuman.github.io.git\n    branch: master\n```\n>注释：\n\nhexo d，执行该命令，报错：\n\n```\nERROR Deployer not found: git\n\n执行命令：\nnpm install hexo-deployer-git --save\n再次执行hexo d,报错：\n\nINFO  Deploying: git\nINFO  Clearing .deploy folder...\nINFO  Copying files from public folder...\nwarning: LF will be replaced by CRLF in 2015/05/30/hello-world/index.html.\nThe file will have its original line endings in your working directory.\n......\n*** Please tell me who you are.\n\nRun\n\n  git config --global user.email \"you@example.com\"\n  git config --global user.name \"Your Name\"\n\nto set your account's default identity.\nOmit --global to set the identity only in this repository.\n\nfatal: unable to auto-detect email address (got 'Administrator@PC-201505290750.(none)')\nUsername for 'https://github.com': voidking\nPassword for 'https://voidking@github.com':\nerror: src refspec master does not match any.\nerror: failed to push some refs to 'https://github.com/voidking/voidking.github.io.git'\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: error: src refspec master does not match any.\nerror: failed to push some refs to 'https://github.com/voidking/voidking.github.io.git'\n\n    at ChildProcess.<anonymous> (E:\\hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:42:17)\n    at ChildProcess.emit (events.js:98:17)\n    at maybeClose (child_process.js:756:16)\n    at Process.ChildProcess._handle.onexit (child_process.js:823:5)\n```\nhexo d，执行该命令，报错：\n## 复制cnfeat的主题\n\n以下进入复制主题环节，如果那一步出现问题，或者修改后没有显示修改的结果，建议来来一个，再看看，可以解决很多问题。\n\n```\n    $ hexo clean\n\n    $ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）\n\n    $ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\n    建立了Hexo文件，复制我的主题了到themes文件夹中\n    yilia\n    $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n    modernist\n    $ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist\n    jacman\n    $ git clone https://github.com/cnfeat/cnfeat.git themes/jacman\n```\n\n\n## 启用cnfeat的主题\n\n修改Hexo目录下的config.yml配置文件中的theme属性，将其设置为jacman。同时请设置stylus属性中的compress值为true。\ntheme: jacman\n\n注意：Hexo有两个config.yml文件，一个在根目录，一个在theme下，此时修改的是在根目录下的。\n\n    更新主题\n\n    $ cd themes/jacman\n    $ git pull\n\n注意：为避免出错，请先备份你的_config.yml 文件后再升级\n本地查看调试\n\n```\n    $ hexo g #生成\n    $ hexo s #启动本地服务，进行文章预览调试\n\n    或者直接作用组合命令\n\n    $ hexo deploy -g\n    $ hexo server -g\n\n    简写：\n\n    hexo n == hexo new\n    hexo g == hexo generate\n    hexo s == hexo server\n    hexo d == hexo deploy\n```\n>4、浏览器中查看效果\n\n浏览器输入[http://localhost:4000](http://localhost:4000) ，查看搭建效果。此后的每次变更_config.yml文件或者上传文件都可以先用此命令调试，非常好用，尤其是当你想调试出自己想要的主题时。\n\n#进阶篇：Hexo设置\n\n网站搭建完成后，就可以根据自己爱好来对Hexo生成的网站进行设置了，对整站的设置，只要修改项目目录的hexo/_config.yml就可以了，这是我的设置，可供参考。\n\n>默认目录结构：\n\n```\n    .\n    ├── .deploy\n    ├── public\n    ├── scaffolds\n    ├── scripts\n    ├── source\n    |   ├── _drafts\n    |   └── _posts\n    ├── themes\n    ├── _config.yml\n    └── package.json\n```\n>hexo/_config.yml\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site #整站的基本信息\ntitle: 1000 words a Day #网站标题\nsubtitle: Writing 1000 Words a Day Changes My Life #网站副标题\ndescription: 学习总结 思考感悟 知识管理 #网站描述\nauthor:  cnFeat #网站作者，在下方显示\nemail: cnFeat@gmail.com #联系邮箱\nlanguage: zh-CN #主题实际的文件名称\ntimezone:\n\n# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing 文章布局、写作格式的定义，不修改\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format 日期格式，不修改\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination 每页显示文章数，可以自定义，我将10改成了5\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n\n# Disqus Disqus插件，我们会替换成“多说”，不修改\ndisqus_shortname:\n\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: spfk\n\n\n# 自动生成sitemap\nsitemap:\npath: sitemap.xml\nbaidusitemap:\npath: baidusitemap.xml\n\n\n# Deployment 站点部署到github要配置，上一节中已经讲过\n## Docs: http://zespia.tw/hexo/docs/deploy.html\ndeploy:\n  type: git\n  repository: git@github.com:luuman/luuman.github.io.git\n  branch: master\n```\n\n修改局部页面\n\n页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\主题名称\\中：\n>hexo\\themes\\\n\n```\n├── languages  #多语言\n|   ├── default.yml#默认语言\n|   └── zh-CN.yml  #中文语言\n├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制\n|   ├── _partial   #局部的布局，此目录下的*.ejs是对头尾等局部的控制\n|   └── _widget#小挂件的布局，页面下方小挂件的控制\n├── source #源码\n|   ├── css#css源码 \n|   |   ├── _base  #*.styl基础css\n|   |   ├── _partial   #*.styl局部css\n|   |   ├── fonts  #字体\n|   |   ├── images #图片\n|   |   └── style.styl #*.styl引入需要的css源码\n|   ├── fancybox   #fancybox效果源码\n|   └── js #javascript源代码\n├── _config.yml#主题配置文件\n└── README.md  #用GitHub的都知道\n```\n\n主题文档的配置\n>hexo\\themes/_config.yml\n\n```\n# Header\nmenu:\n  主页: /\n  所有文章: /archives\n  # 随笔: /tags/随笔\n\n# SubNav\nsubnav:\n  github: \"#\"\n  weibo: \"#\"\n  rss: \"#\"\n  zhihu: \"#\"\n  #douban: \"#\"\n  #mail: \"#\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\nrss: /atom.xml\n\n# Content\nexcerpt_link: more\nfancybox: true\nmathjax: true\n\n# Miscellaneous\ngoogle_analytics: ''\nfavicon: /favicon.png\n\n#你的头像url\navatar: \"\"\n#是否开启分享\nshare: true\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: true\n#是否开启云标签\ntagcloud: true\n\n#是否开启友情链接\n#不开启——\n#friends: false\n#开启——\nfriends:\n  奥巴马的博客: http://localhost:4000/\n  卡卡的美丽传说: http://localhost:4000/\n  本泽马的博客: http://localhost:4000/\n  吉格斯的博客: http://localhost:4000/\n  习大大大不同: http://localhost:4000/\n  托蒂的博客: http://localhost:4000/\n\n#是否开启“关于我”。\n#不开启——\n#aboutme: false\n#开启——\naboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n```\n\n# 参考资料：\n[hexo你的博客](http://ibruce.info/2013/11/22/hexo-your-blog/)\n[如何搭建一个独立博客——简明Github Pages与Hexo教程](http://www.jianshu.com/p/05289a4bc8b2#)\n[Hexo的使用介绍](http://luuman.github.io/2015/12/25/Hexo/)\n[Hexo插件安装](http://luuman.github.io/2015/12/27/Hexo-plug/)\n\n[0]: https://github.com/ \"GitHub\"\n[1]: https://pages.github.com/ \"GitHub Pages\"\n[2]: http://zespia.tw/hexo/ \"hexo\"\n\n","source":"_posts/GitHub+Hexo.md","raw":"title: 使用GitHub搭建Hexo博客\ndate: 2016-02-23 18:29:00\ndescription: 来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。\ntags: [github, hexo]\ncategories: \n- 随笔\n---\n\n来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。\n国内也有不多少的代码托管平台，本文将就用GitHub的GitHub Pages 功能来搭建，比起WordPress，hexo的搭建更加简洁，配合上markdown的使用，更加便捷的管理自己的学习文档。\n\n<!--more-->\n\n# 概况\n>1. 为什么选择[GitHub Pages](1)\n1、[GitHub Pages](1)有免费的代码托管空间，资料自己管理，保存可靠；\n2、学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多；\n3、顺便理解 GitHub 工作原理，最好的团队协作流程；\n4、GitHub建立私有仓库才会收费，所以会有很多开源代码。\n>2. [GitHub Pages](1)是什么\n应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的\"Initialize this repository with a README\" 。\n>3. [hexo](2)出自何人\nhexo出自台湾大学生 tommy351 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。\n\n# 安装准备\n>环境搭建：\n1. [Node.js](http://nodejs.org/)：下载[地址](https://nodejs.org/en/)\n2. [Git](http://git-scm.com/)：下载[地址](https://git-scm.com/download/win)\n3. [Sublime](http://www.sublimetext.com/)：下载[地址](http://www.sublimetext.com/2)\n## 安装Node \n到 Node.js 官网下载相应平台的 最新版本 ，一路安装即可。我用的是 node-v0.10.22-x86.msi\n## 安装Git \nGit的客户端很多，我用的是 msysgit ，喜欢用绿色版本 Portable application for official Git for Windows 1.8.4 ，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。\n## 安装Sublime\nSublime Text 2 在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的 Sublime Text 3 。\n\n\n# GitHub注册与配置\n\n>1. 注册：\n访问：[GitHub](0)，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。注册过程比较简单，详细也可以看：\n使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考[官方文档](https://pages.github.com/)\n\n>1. 配置和使用Github\n以下教程主要参考beiyuu的[《使用Github Pages建独立博客》](http://beiyuu.com/github-pages/)写成。\n\n>1. 配置SSH keys\n我们如何让本地git项目与远程的github建立联系呢？用SSH keys。\n打开Git Bash工具，执行以下操作\n\n>1. 检查SSH keys的设置\n\n```\n    首先我们需要检查你电脑上现有的ssh key：\n\n$ cd ~/. ssh 检查本机的ssh密钥\n\n    如果提示：No such file or directory 说明你是第一次使用git。\n\n    生成新的SSH Key：\n\n$ ssh-keygen -t rsa -C \"邮件地址@youremail.com\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key \n(/Users/your_user_directory/.ssh/id_rsa):<回车就好>\n```\n注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；\n注意2: 此处的「-C」的是大写的「C」\n\n    然后系统会要你输入密码：\nEnter passphrase (empty for no passphrase):<输入加密串>\nEnter same passphrase again:<再次输入加密串>\n\n在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。\n\n注意：输入密码的时候没有*字样的，你直接输入就可以了。\n\n最后看到这样的界面，就成功设置ssh key了：\n```\n\n```\n\n>5. 添加SSH Key到GitHub\n在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。\n>1. 打开本地C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。\n>2. 登陆github系统。点击右上角的 Account Settings--->SSH Public keys ---> add another public keys\n>3. 把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了\n\n>6. 测试\n\n```\n    可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：\n\n$ ssh -T git@github.com\n\n    如果是下面的反馈：\n\nThe authenticity of host 'github.com (207.97.227.239)' can't be established.\nRSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\nAre you sure you want to continue connecting (yes/no)?\n\n    不要紧张，输入yes就好，然后会看到：\n\nHi cnfeat! You've successfully authenticated, \nbut GitHub does not provide shell access.\n\n\n\n    设置用户信息：\n    现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。\n    Git会根据用户的名字和邮箱来记录提交。\n    GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。\n\n$ git config --global user.name \"cnfeat\"//用户名\n$ git config --global user.email \"cnfeat@gmail.com\"//填写自己的邮箱\n\n    SSH Key配置成功，本机已成功连接到github。\n\n```\n# Hexo博客\n\n>Hexo\nHexo的作者是[tommy351](https://github.com/tommy351/hexo)，根据[官方介绍](http://hexo.io/docs/index.html)，Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。hexo的主题列表 [Hexo Themes](http://github.com/tommy351/hexo/wiki/Themes)。 我比较喜欢 [pacman](http://github.com/A-limon/pacman) ， [modernist](http://github.com/heroicyang/hexo-theme-modernist) 、 [ishgo](http://github.com/DavidKk/Hexo.ishgo) ， [raytaylorism](http://github.com/raytaylorlin/hexo-theme-raytaylorism) 。 \n\n\n\n## 安装Hexo\n\n打开Git Bash工具（前提确保Node.js已经安装，环境配置OK）\n\n    $ npm install -g hexo\n\n>注释：\n\n执行命令：npm install -g hexo，报错如下：\n\n```\nnpm ERR! Error: shasum check failed for C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\npm\n-30024-KDJHJzgP\\registry.npmjs.org\\hexo-cli\\-\\hexo-cli-0.1.6.tgz\nnpm ERR! Expected: 7dc3ab939d0889c4bed6a961605ff3e2d67f67a2\nnpm ERR! Actual:   41de7d67a9b764352eb07c49c32fc38dd7f479b9\nnpm ERR! From:     https://registry.npmjs.org/hexo-cli/-/hexo-cli-0.1.6.tgz\nnpm ERR!     at d:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\sha\\index.\njs:38:8\nnpm ERR!     at ReadStream.<anonymous> (d:\\Program Files\\nodejs\\node_modules\\npm\n\\node_modules\\sha\\index.js:85:7)\nnpm ERR!     at ReadStream.emit (events.js:117:20)\nnpm ERR!     at _stream_readable.js:943:16\nnpm ERR!     at process._tickCallback (node.js:419:13)\nnpm ERR! If you need help, you may report this *entire* log,\nnpm ERR! including the npm and node versions, at:\nnpm ERR!     <http://github.com/npm/npm/issues>\n\nnpm ERR! System Windows_NT 6.2.9200\nnpm ERR! command \"d:\\\\Program Files\\\\nodejs\\\\node.exe\" \"d:\\\\Program Files\\\\nodej\ns\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\" \"install\" \"-g\" \"hexo\"\nnpm ERR! cwd C:\\Users\\Administrator\\Desktop\nnpm ERR! node -v v0.10.31\nnpm ERR! npm -v 1.4.23\nnpm ERR! registry error parsing json\nnpm ERR!\nnpm ERR! Additional logging details can be found in:\nnpm ERR!     C:\\Users\\Administrator\\Desktop\\npm-debug.log\nnpm ERR! not ok code 0\n\n    莫非是因为被墙了？换国内镜像源试试。\nnpm config set registry=\"http://registry.cnpmjs.org\"，\n    然后再次执行npm install -g hexo，成功！\n```\n\n## 部署Hexo\n\n```\n    在我的电脑中建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash。\n\n$ hexo init\n\n    如果无法使用右击“Git Bash”，则可以切换到指定目录\n\n    UUhike@UUhike-pc MINGW64 ~\n$ cd j:/github/hexo\n    UUhike@UUhike-pc MINGW64 /j/github/hexo\n\n    安装依赖包\n$ npm install\n\n    Hexo随后会自动在目标文件夹建立网站所需要的所有文件。\n    现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000看看。\n\n    本地查看\n\n$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）\n\n$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n```\n## 部署到GitHub\n\n```\n\n编辑E:\\hexo下的_config.yml，修改Deployment部分：\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n    repository: https://github.com/luuman/luuman.github.io.git\n    branch: master\n```\n>注释：\n\nhexo d，执行该命令，报错：\n\n```\nERROR Deployer not found: git\n\n执行命令：\nnpm install hexo-deployer-git --save\n再次执行hexo d,报错：\n\nINFO  Deploying: git\nINFO  Clearing .deploy folder...\nINFO  Copying files from public folder...\nwarning: LF will be replaced by CRLF in 2015/05/30/hello-world/index.html.\nThe file will have its original line endings in your working directory.\n......\n*** Please tell me who you are.\n\nRun\n\n  git config --global user.email \"you@example.com\"\n  git config --global user.name \"Your Name\"\n\nto set your account's default identity.\nOmit --global to set the identity only in this repository.\n\nfatal: unable to auto-detect email address (got 'Administrator@PC-201505290750.(none)')\nUsername for 'https://github.com': voidking\nPassword for 'https://voidking@github.com':\nerror: src refspec master does not match any.\nerror: failed to push some refs to 'https://github.com/voidking/voidking.github.io.git'\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: error: src refspec master does not match any.\nerror: failed to push some refs to 'https://github.com/voidking/voidking.github.io.git'\n\n    at ChildProcess.<anonymous> (E:\\hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:42:17)\n    at ChildProcess.emit (events.js:98:17)\n    at maybeClose (child_process.js:756:16)\n    at Process.ChildProcess._handle.onexit (child_process.js:823:5)\n```\nhexo d，执行该命令，报错：\n## 复制cnfeat的主题\n\n以下进入复制主题环节，如果那一步出现问题，或者修改后没有显示修改的结果，建议来来一个，再看看，可以解决很多问题。\n\n```\n    $ hexo clean\n\n    $ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）\n\n    $ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\n    建立了Hexo文件，复制我的主题了到themes文件夹中\n    yilia\n    $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n    modernist\n    $ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist\n    jacman\n    $ git clone https://github.com/cnfeat/cnfeat.git themes/jacman\n```\n\n\n## 启用cnfeat的主题\n\n修改Hexo目录下的config.yml配置文件中的theme属性，将其设置为jacman。同时请设置stylus属性中的compress值为true。\ntheme: jacman\n\n注意：Hexo有两个config.yml文件，一个在根目录，一个在theme下，此时修改的是在根目录下的。\n\n    更新主题\n\n    $ cd themes/jacman\n    $ git pull\n\n注意：为避免出错，请先备份你的_config.yml 文件后再升级\n本地查看调试\n\n```\n    $ hexo g #生成\n    $ hexo s #启动本地服务，进行文章预览调试\n\n    或者直接作用组合命令\n\n    $ hexo deploy -g\n    $ hexo server -g\n\n    简写：\n\n    hexo n == hexo new\n    hexo g == hexo generate\n    hexo s == hexo server\n    hexo d == hexo deploy\n```\n>4、浏览器中查看效果\n\n浏览器输入[http://localhost:4000](http://localhost:4000) ，查看搭建效果。此后的每次变更_config.yml文件或者上传文件都可以先用此命令调试，非常好用，尤其是当你想调试出自己想要的主题时。\n\n#进阶篇：Hexo设置\n\n网站搭建完成后，就可以根据自己爱好来对Hexo生成的网站进行设置了，对整站的设置，只要修改项目目录的hexo/_config.yml就可以了，这是我的设置，可供参考。\n\n>默认目录结构：\n\n```\n    .\n    ├── .deploy\n    ├── public\n    ├── scaffolds\n    ├── scripts\n    ├── source\n    |   ├── _drafts\n    |   └── _posts\n    ├── themes\n    ├── _config.yml\n    └── package.json\n```\n>hexo/_config.yml\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site #整站的基本信息\ntitle: 1000 words a Day #网站标题\nsubtitle: Writing 1000 Words a Day Changes My Life #网站副标题\ndescription: 学习总结 思考感悟 知识管理 #网站描述\nauthor:  cnFeat #网站作者，在下方显示\nemail: cnFeat@gmail.com #联系邮箱\nlanguage: zh-CN #主题实际的文件名称\ntimezone:\n\n# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing 文章布局、写作格式的定义，不修改\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format 日期格式，不修改\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination 每页显示文章数，可以自定义，我将10改成了5\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n\n# Disqus Disqus插件，我们会替换成“多说”，不修改\ndisqus_shortname:\n\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: spfk\n\n\n# 自动生成sitemap\nsitemap:\npath: sitemap.xml\nbaidusitemap:\npath: baidusitemap.xml\n\n\n# Deployment 站点部署到github要配置，上一节中已经讲过\n## Docs: http://zespia.tw/hexo/docs/deploy.html\ndeploy:\n  type: git\n  repository: git@github.com:luuman/luuman.github.io.git\n  branch: master\n```\n\n修改局部页面\n\n页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\主题名称\\中：\n>hexo\\themes\\\n\n```\n├── languages  #多语言\n|   ├── default.yml#默认语言\n|   └── zh-CN.yml  #中文语言\n├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制\n|   ├── _partial   #局部的布局，此目录下的*.ejs是对头尾等局部的控制\n|   └── _widget#小挂件的布局，页面下方小挂件的控制\n├── source #源码\n|   ├── css#css源码 \n|   |   ├── _base  #*.styl基础css\n|   |   ├── _partial   #*.styl局部css\n|   |   ├── fonts  #字体\n|   |   ├── images #图片\n|   |   └── style.styl #*.styl引入需要的css源码\n|   ├── fancybox   #fancybox效果源码\n|   └── js #javascript源代码\n├── _config.yml#主题配置文件\n└── README.md  #用GitHub的都知道\n```\n\n主题文档的配置\n>hexo\\themes/_config.yml\n\n```\n# Header\nmenu:\n  主页: /\n  所有文章: /archives\n  # 随笔: /tags/随笔\n\n# SubNav\nsubnav:\n  github: \"#\"\n  weibo: \"#\"\n  rss: \"#\"\n  zhihu: \"#\"\n  #douban: \"#\"\n  #mail: \"#\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\nrss: /atom.xml\n\n# Content\nexcerpt_link: more\nfancybox: true\nmathjax: true\n\n# Miscellaneous\ngoogle_analytics: ''\nfavicon: /favicon.png\n\n#你的头像url\navatar: \"\"\n#是否开启分享\nshare: true\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: true\n#是否开启云标签\ntagcloud: true\n\n#是否开启友情链接\n#不开启——\n#friends: false\n#开启——\nfriends:\n  奥巴马的博客: http://localhost:4000/\n  卡卡的美丽传说: http://localhost:4000/\n  本泽马的博客: http://localhost:4000/\n  吉格斯的博客: http://localhost:4000/\n  习大大大不同: http://localhost:4000/\n  托蒂的博客: http://localhost:4000/\n\n#是否开启“关于我”。\n#不开启——\n#aboutme: false\n#开启——\naboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n```\n\n# 参考资料：\n[hexo你的博客](http://ibruce.info/2013/11/22/hexo-your-blog/)\n[如何搭建一个独立博客——简明Github Pages与Hexo教程](http://www.jianshu.com/p/05289a4bc8b2#)\n[Hexo的使用介绍](http://luuman.github.io/2015/12/25/Hexo/)\n[Hexo插件安装](http://luuman.github.io/2015/12/27/Hexo-plug/)\n\n[0]: https://github.com/ \"GitHub\"\n[1]: https://pages.github.com/ \"GitHub Pages\"\n[2]: http://zespia.tw/hexo/ \"hexo\"\n\n","slug":"GitHub+Hexo","published":1,"updated":"2016-11-16T15:05:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tdb0006lx60yarqs2eo","content":"<p>来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。<br>国内也有不多少的代码托管平台，本文将就用GitHub的GitHub Pages 功能来搭建，比起WordPress，hexo的搭建更加简洁，配合上markdown的使用，更加便捷的管理自己的学习文档。</p>\n<a id=\"more\"></a>\n<h1 id=\"概况\"><a href=\"#概况\" class=\"headerlink\" title=\"概况\"></a>概况</h1><blockquote>\n<ol>\n<li>为什么选择<a href=\"1\">GitHub Pages</a><br>1、<a href=\"1\">GitHub Pages</a>有免费的代码托管空间，资料自己管理，保存可靠；<br>2、学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多；<br>3、顺便理解 GitHub 工作原理，最好的团队协作流程；<br>4、GitHub建立私有仓库才会收费，所以会有很多开源代码。</li>\n<li><a href=\"1\">GitHub Pages</a>是什么<br>应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README” 。</li>\n<li><a href=\"2\">hexo</a>出自何人<br>hexo出自台湾大学生 tommy351 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。</li>\n</ol>\n</blockquote>\n<h1 id=\"安装准备\"><a href=\"#安装准备\" class=\"headerlink\" title=\"安装准备\"></a>安装准备</h1><blockquote>\n<p>环境搭建：</p>\n<ol>\n<li><a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"external\">Node.js</a>：下载<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">地址</a></li>\n<li><a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"external\">Git</a>：下载<a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"external\">地址</a></li>\n<li><a href=\"http://www.sublimetext.com/\" target=\"_blank\" rel=\"external\">Sublime</a>：下载<a href=\"http://www.sublimetext.com/2\" target=\"_blank\" rel=\"external\">地址</a><h2 id=\"安装Node\"><a href=\"#安装Node\" class=\"headerlink\" title=\"安装Node\"></a>安装Node</h2>到 Node.js 官网下载相应平台的 最新版本 ，一路安装即可。我用的是 node-v0.10.22-x86.msi<h2 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h2>Git的客户端很多，我用的是 msysgit ，喜欢用绿色版本 Portable application for official Git for Windows 1.8.4 ，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。<h2 id=\"安装Sublime\"><a href=\"#安装Sublime\" class=\"headerlink\" title=\"安装Sublime\"></a>安装Sublime</h2>Sublime Text 2 在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的 Sublime Text 3 。</li>\n</ol>\n</blockquote>\n<h1 id=\"GitHub注册与配置\"><a href=\"#GitHub注册与配置\" class=\"headerlink\" title=\"GitHub注册与配置\"></a>GitHub注册与配置</h1><blockquote>\n<ol>\n<li><p>注册：<br>访问：<a href=\"0\">GitHub</a>，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。注册过程比较简单，详细也可以看：<br>使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考<a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">官方文档</a></p>\n</li>\n<li><p>配置和使用Github<br>以下教程主要参考beiyuu的<a href=\"http://beiyuu.com/github-pages/\" target=\"_blank\" rel=\"external\">《使用Github Pages建独立博客》</a>写成。</p>\n</li>\n<li><p>配置SSH keys<br>我们如何让本地git项目与远程的github建立联系呢？用SSH keys。<br>打开Git Bash工具，执行以下操作</p>\n</li>\n<li><p>检查SSH keys的设置</p>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">    首先我们需要检查你电脑上现有的ssh key：</div><div class=\"line\"></div><div class=\"line\">$ cd ~/. ssh 检查本机的ssh密钥</div><div class=\"line\"></div><div class=\"line\">    如果提示：No such file or directory 说明你是第一次使用git。</div><div class=\"line\"></div><div class=\"line\">    生成新的SSH Key：</div><div class=\"line\"></div><div class=\"line\">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</div><div class=\"line\">Generating public/private rsa key pair.</div><div class=\"line\">Enter file in which to save the key </div><div class=\"line\">(/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</div></pre></td></tr></table></figure>\n<p>注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；<br>注意2: 此处的「-C」的是大写的「C」</p>\n<pre><code>然后系统会要你输入密码：\n</code></pre><p>Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;<br>Enter same passphrase again:&lt;再次输入加密串&gt;</p>\n<p>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p>\n<p>注意：输入密码的时候没有*字样的，你直接输入就可以了。</p>\n<p>最后看到这样的界面，就成功设置ssh key了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<blockquote>\n<ol>\n<li>添加SSH Key到GitHub<br>在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。</li>\n<li>打开本地C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。</li>\n<li>登陆github系统。点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys</li>\n<li><p>把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了</p>\n</li>\n<li><p>测试</p>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">    可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：</div><div class=\"line\"></div><div class=\"line\">$ ssh -T git@github.com</div><div class=\"line\"></div><div class=\"line\">    如果是下面的反馈：</div><div class=\"line\"></div><div class=\"line\">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div><div class=\"line\"></div><div class=\"line\">    不要紧张，输入yes就好，然后会看到：</div><div class=\"line\"></div><div class=\"line\">Hi cnfeat! You&apos;ve successfully authenticated, </div><div class=\"line\">but GitHub does not provide shell access.</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    设置用户信息：</div><div class=\"line\">    现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。</div><div class=\"line\">    Git会根据用户的名字和邮箱来记录提交。</div><div class=\"line\">    GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。</div><div class=\"line\"></div><div class=\"line\">$ git config --global user.name &quot;cnfeat&quot;//用户名</div><div class=\"line\">$ git config --global user.email &quot;cnfeat@gmail.com&quot;//填写自己的邮箱</div><div class=\"line\"></div><div class=\"line\">    SSH Key配置成功，本机已成功连接到github。</div></pre></td></tr></table></figure>\n<h1 id=\"Hexo博客\"><a href=\"#Hexo博客\" class=\"headerlink\" title=\"Hexo博客\"></a>Hexo博客</h1><blockquote>\n<p>Hexo<br>Hexo的作者是<a href=\"https://github.com/tommy351/hexo\" target=\"_blank\" rel=\"external\">tommy351</a>，根据<a href=\"http://hexo.io/docs/index.html\" target=\"_blank\" rel=\"external\">官方介绍</a>，Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。hexo的主题列表 <a href=\"http://github.com/tommy351/hexo/wiki/Themes\" target=\"_blank\" rel=\"external\">Hexo Themes</a>。 我比较喜欢 <a href=\"http://github.com/A-limon/pacman\" target=\"_blank\" rel=\"external\">pacman</a> ， <a href=\"http://github.com/heroicyang/hexo-theme-modernist\" target=\"_blank\" rel=\"external\">modernist</a> 、 <a href=\"http://github.com/DavidKk/Hexo.ishgo\" target=\"_blank\" rel=\"external\">ishgo</a> ， <a href=\"http://github.com/raytaylorlin/hexo-theme-raytaylorism\" target=\"_blank\" rel=\"external\">raytaylorism</a> 。 </p>\n</blockquote>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>打开Git Bash工具（前提确保Node.js已经安装，环境配置OK）</p>\n<pre><code>$ npm install -g hexo\n</code></pre><blockquote>\n<p>注释：</p>\n</blockquote>\n<p>执行命令：npm install -g hexo，报错如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm ERR! Error: shasum check failed for C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\npm</div><div class=\"line\">-30024-KDJHJzgP\\registry.npmjs.org\\hexo-cli\\-\\hexo-cli-0.1.6.tgz</div><div class=\"line\">npm ERR! Expected: 7dc3ab939d0889c4bed6a961605ff3e2d67f67a2</div><div class=\"line\">npm ERR! Actual:   41de7d67a9b764352eb07c49c32fc38dd7f479b9</div><div class=\"line\">npm ERR! From:     https://registry.npmjs.org/hexo-cli/-/hexo-cli-0.1.6.tgz</div><div class=\"line\">npm ERR!     at d:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\sha\\index.</div><div class=\"line\">js:38:8</div><div class=\"line\">npm ERR!     at ReadStream.&lt;anonymous&gt; (d:\\Program Files\\nodejs\\node_modules\\npm</div><div class=\"line\">\\node_modules\\sha\\index.js:85:7)</div><div class=\"line\">npm ERR!     at ReadStream.emit (events.js:117:20)</div><div class=\"line\">npm ERR!     at _stream_readable.js:943:16</div><div class=\"line\">npm ERR!     at process._tickCallback (node.js:419:13)</div><div class=\"line\">npm ERR! If you need help, you may report this *entire* log,</div><div class=\"line\">npm ERR! including the npm and node versions, at:</div><div class=\"line\">npm ERR!     &lt;http://github.com/npm/npm/issues&gt;</div><div class=\"line\"></div><div class=\"line\">npm ERR! System Windows_NT 6.2.9200</div><div class=\"line\">npm ERR! command &quot;d:\\\\Program Files\\\\nodejs\\\\node.exe&quot; &quot;d:\\\\Program Files\\\\nodej</div><div class=\"line\">s\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js&quot; &quot;install&quot; &quot;-g&quot; &quot;hexo&quot;</div><div class=\"line\">npm ERR! cwd C:\\Users\\Administrator\\Desktop</div><div class=\"line\">npm ERR! node -v v0.10.31</div><div class=\"line\">npm ERR! npm -v 1.4.23</div><div class=\"line\">npm ERR! registry error parsing json</div><div class=\"line\">npm ERR!</div><div class=\"line\">npm ERR! Additional logging details can be found in:</div><div class=\"line\">npm ERR!     C:\\Users\\Administrator\\Desktop\\npm-debug.log</div><div class=\"line\">npm ERR! not ok code 0</div><div class=\"line\"></div><div class=\"line\">    莫非是因为被墙了？换国内镜像源试试。</div><div class=\"line\">npm config set registry=&quot;http://registry.cnpmjs.org&quot;，</div><div class=\"line\">    然后再次执行npm install -g hexo，成功！</div></pre></td></tr></table></figure>\n<h2 id=\"部署Hexo\"><a href=\"#部署Hexo\" class=\"headerlink\" title=\"部署Hexo\"></a>部署Hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">    在我的电脑中建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash。</div><div class=\"line\"></div><div class=\"line\">$ hexo init</div><div class=\"line\"></div><div class=\"line\">    如果无法使用右击“Git Bash”，则可以切换到指定目录</div><div class=\"line\"></div><div class=\"line\">    UUhike@UUhike-pc MINGW64 ~</div><div class=\"line\">$ cd j:/github/hexo</div><div class=\"line\">    UUhike@UUhike-pc MINGW64 /j/github/hexo</div><div class=\"line\"></div><div class=\"line\">    安装依赖包</div><div class=\"line\">$ npm install</div><div class=\"line\"></div><div class=\"line\">    Hexo随后会自动在目标文件夹建立网站所需要的所有文件。</div><div class=\"line\">    现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000看看。</div><div class=\"line\"></div><div class=\"line\">    本地查看</div><div class=\"line\"></div><div class=\"line\">$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）</div><div class=\"line\"></div><div class=\"line\">$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div></pre></td></tr></table></figure>\n<h2 id=\"部署到GitHub\"><a href=\"#部署到GitHub\" class=\"headerlink\" title=\"部署到GitHub\"></a>部署到GitHub</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">编辑E:\\hexo下的_config.yml，修改Deployment部分：</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: http://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">    repository: https://github.com/luuman/luuman.github.io.git</div><div class=\"line\">    branch: master</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注释：</p>\n</blockquote>\n<p>hexo d，执行该命令，报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR Deployer not found: git</div><div class=\"line\"></div><div class=\"line\">执行命令：</div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\">再次执行hexo d,报错：</div><div class=\"line\"></div><div class=\"line\">INFO  Deploying: git</div><div class=\"line\">INFO  Clearing .deploy folder...</div><div class=\"line\">INFO  Copying files from public folder...</div><div class=\"line\">warning: LF will be replaced by CRLF in 2015/05/30/hello-world/index.html.</div><div class=\"line\">The file will have its original line endings in your working directory.</div><div class=\"line\">......</div><div class=\"line\">*** Please tell me who you are.</div><div class=\"line\"></div><div class=\"line\">Run</div><div class=\"line\"></div><div class=\"line\">  git config --global user.email &quot;you@example.com&quot;</div><div class=\"line\">  git config --global user.name &quot;Your Name&quot;</div><div class=\"line\"></div><div class=\"line\">to set your account&apos;s default identity.</div><div class=\"line\">Omit --global to set the identity only in this repository.</div><div class=\"line\"></div><div class=\"line\">fatal: unable to auto-detect email address (got &apos;Administrator@PC-201505290750.(none)&apos;)</div><div class=\"line\">Username for &apos;https://github.com&apos;: voidking</div><div class=\"line\">Password for &apos;https://voidking@github.com&apos;:</div><div class=\"line\">error: src refspec master does not match any.</div><div class=\"line\">error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos;</div><div class=\"line\">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</div><div class=\"line\">Error: error: src refspec master does not match any.</div><div class=\"line\">error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos;</div><div class=\"line\"></div><div class=\"line\">    at ChildProcess.&lt;anonymous&gt; (E:\\hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:42:17)</div><div class=\"line\">    at ChildProcess.emit (events.js:98:17)</div><div class=\"line\">    at maybeClose (child_process.js:756:16)</div><div class=\"line\">    at Process.ChildProcess._handle.onexit (child_process.js:823:5)</div></pre></td></tr></table></figure>\n<p>hexo d，执行该命令，报错：</p>\n<h2 id=\"复制cnfeat的主题\"><a href=\"#复制cnfeat的主题\" class=\"headerlink\" title=\"复制cnfeat的主题\"></a>复制cnfeat的主题</h2><p>以下进入复制主题环节，如果那一步出现问题，或者修改后没有显示修改的结果，建议来来一个，再看看，可以解决很多问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo clean</div><div class=\"line\"></div><div class=\"line\">$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）</div><div class=\"line\"></div><div class=\"line\">$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div><div class=\"line\"></div><div class=\"line\">建立了Hexo文件，复制我的主题了到themes文件夹中</div><div class=\"line\">yilia</div><div class=\"line\">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</div><div class=\"line\">modernist</div><div class=\"line\">$ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist</div><div class=\"line\">jacman</div><div class=\"line\">$ git clone https://github.com/cnfeat/cnfeat.git themes/jacman</div></pre></td></tr></table></figure>\n<h2 id=\"启用cnfeat的主题\"><a href=\"#启用cnfeat的主题\" class=\"headerlink\" title=\"启用cnfeat的主题\"></a>启用cnfeat的主题</h2><p>修改Hexo目录下的config.yml配置文件中的theme属性，将其设置为jacman。同时请设置stylus属性中的compress值为true。<br>theme: jacman</p>\n<p>注意：Hexo有两个config.yml文件，一个在根目录，一个在theme下，此时修改的是在根目录下的。</p>\n<pre><code>更新主题\n\n$ cd themes/jacman\n$ git pull\n</code></pre><p>注意：为避免出错，请先备份你的_config.yml 文件后再升级<br>本地查看调试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g #生成</div><div class=\"line\">$ hexo s #启动本地服务，进行文章预览调试</div><div class=\"line\"></div><div class=\"line\">或者直接作用组合命令</div><div class=\"line\"></div><div class=\"line\">$ hexo deploy -g</div><div class=\"line\">$ hexo server -g</div><div class=\"line\"></div><div class=\"line\">简写：</div><div class=\"line\"></div><div class=\"line\">hexo n == hexo new</div><div class=\"line\">hexo g == hexo generate</div><div class=\"line\">hexo s == hexo server</div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure>\n<blockquote>\n<p>4、浏览器中查看效果</p>\n</blockquote>\n<p>浏览器输入<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> ，查看搭建效果。此后的每次变更_config.yml文件或者上传文件都可以先用此命令调试，非常好用，尤其是当你想调试出自己想要的主题时。</p>\n<p>#进阶篇：Hexo设置</p>\n<p>网站搭建完成后，就可以根据自己爱好来对Hexo生成的网站进行设置了，对整站的设置，只要修改项目目录的hexo/_config.yml就可以了，这是我的设置，可供参考。</p>\n<blockquote>\n<p>默认目录结构：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── .deploy</div><div class=\"line\">├── public</div><div class=\"line\">├── scaffolds</div><div class=\"line\">├── scripts</div><div class=\"line\">├── source</div><div class=\"line\">|   ├── _drafts</div><div class=\"line\">|   └── _posts</div><div class=\"line\">├── themes</div><div class=\"line\">├── _config.yml</div><div class=\"line\">└── package.json</div></pre></td></tr></table></figure>\n<blockquote>\n<p>hexo/_config.yml</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: http://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site #整站的基本信息</div><div class=\"line\">title: 1000 words a Day #网站标题</div><div class=\"line\">subtitle: Writing 1000 Words a Day Changes My Life #网站副标题</div><div class=\"line\">description: 学习总结 思考感悟 知识管理 #网站描述</div><div class=\"line\">author:  cnFeat #网站作者，在下方显示</div><div class=\"line\">email: cnFeat@gmail.com #联系邮箱</div><div class=\"line\">language: zh-CN #主题实际的文件名称</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项</div><div class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class=\"line\">url: http://yoursite.com</div><div class=\"line\">root: /</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"></div><div class=\"line\"># Directory</div><div class=\"line\">source_dir: source</div><div class=\"line\">public_dir: public</div><div class=\"line\">tag_dir: tags</div><div class=\"line\">archive_dir: archives</div><div class=\"line\">category_dir: categories</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">i18n_dir: :lang</div><div class=\"line\">skip_render:</div><div class=\"line\"></div><div class=\"line\"># Writing 文章布局、写作格式的定义，不修改</div><div class=\"line\">new_post_name: :title.md # File name of new posts</div><div class=\"line\">default_layout: post</div><div class=\"line\">titlecase: false # Transform title into titlecase</div><div class=\"line\">external_link: true # Open external links in new tab</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">future: true</div><div class=\"line\">highlight:</div><div class=\"line\">  enable: true</div><div class=\"line\">  line_number: true</div><div class=\"line\">  auto_detect: true</div><div class=\"line\">  tab_replace:</div><div class=\"line\"></div><div class=\"line\"># Category &amp; Tag</div><div class=\"line\">default_category: uncategorized</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"></div><div class=\"line\"># Date / Time format 日期格式，不修改</div><div class=\"line\">## Hexo uses Moment.js to parse and display date</div><div class=\"line\">## You can customize the date format as defined in</div><div class=\"line\">## http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">date_format: YYYY-MM-DD</div><div class=\"line\">time_format: HH:mm:ss</div><div class=\"line\"></div><div class=\"line\"># Pagination 每页显示文章数，可以自定义，我将10改成了5</div><div class=\"line\">## Set per_page to 0 to disable pagination</div><div class=\"line\">per_page: 5</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"></div><div class=\"line\"># Disqus Disqus插件，我们会替换成“多说”，不修改</div><div class=\"line\">disqus_shortname:</div><div class=\"line\"></div><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: http://hexo.io/plugins/</div><div class=\"line\">## Themes: http://hexo.io/themes/</div><div class=\"line\">theme: spfk</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># 自动生成sitemap</div><div class=\"line\">sitemap:</div><div class=\"line\">path: sitemap.xml</div><div class=\"line\">baidusitemap:</div><div class=\"line\">path: baidusitemap.xml</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># Deployment 站点部署到github要配置，上一节中已经讲过</div><div class=\"line\">## Docs: http://zespia.tw/hexo/docs/deploy.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:luuman/luuman.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>修改局部页面</p>\n<p>页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\主题名称\\中：</p>\n<blockquote>\n<p>hexo\\themes\\</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── languages  #多语言</div><div class=\"line\">|   ├── default.yml#默认语言</div><div class=\"line\">|   └── zh-CN.yml  #中文语言</div><div class=\"line\">├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制</div><div class=\"line\">|   ├── _partial   #局部的布局，此目录下的*.ejs是对头尾等局部的控制</div><div class=\"line\">|   └── _widget#小挂件的布局，页面下方小挂件的控制</div><div class=\"line\">├── source #源码</div><div class=\"line\">|   ├── css#css源码 </div><div class=\"line\">|   |   ├── _base  #*.styl基础css</div><div class=\"line\">|   |   ├── _partial   #*.styl局部css</div><div class=\"line\">|   |   ├── fonts  #字体</div><div class=\"line\">|   |   ├── images #图片</div><div class=\"line\">|   |   └── style.styl #*.styl引入需要的css源码</div><div class=\"line\">|   ├── fancybox   #fancybox效果源码</div><div class=\"line\">|   └── js #javascript源代码</div><div class=\"line\">├── _config.yml#主题配置文件</div><div class=\"line\">└── README.md  #用GitHub的都知道</div></pre></td></tr></table></figure>\n<p>主题文档的配置</p>\n<blockquote>\n<p>hexo\\themes/_config.yml</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Header</div><div class=\"line\">menu:</div><div class=\"line\">  主页: /</div><div class=\"line\">  所有文章: /archives</div><div class=\"line\">  # 随笔: /tags/随笔</div><div class=\"line\"></div><div class=\"line\"># SubNav</div><div class=\"line\">subnav:</div><div class=\"line\">  github: &quot;#&quot;</div><div class=\"line\">  weibo: &quot;#&quot;</div><div class=\"line\">  rss: &quot;#&quot;</div><div class=\"line\">  zhihu: &quot;#&quot;</div><div class=\"line\">  #douban: &quot;#&quot;</div><div class=\"line\">  #mail: &quot;#&quot;</div><div class=\"line\">  #facebook: &quot;#&quot;</div><div class=\"line\">  #google: &quot;#&quot;</div><div class=\"line\">  #twitter: &quot;#&quot;</div><div class=\"line\">  #linkedin: &quot;#&quot;</div><div class=\"line\"></div><div class=\"line\">rss: /atom.xml</div><div class=\"line\"></div><div class=\"line\"># Content</div><div class=\"line\">excerpt_link: more</div><div class=\"line\">fancybox: true</div><div class=\"line\">mathjax: true</div><div class=\"line\"></div><div class=\"line\"># Miscellaneous</div><div class=\"line\">google_analytics: &apos;&apos;</div><div class=\"line\">favicon: /favicon.png</div><div class=\"line\"></div><div class=\"line\">#你的头像url</div><div class=\"line\">avatar: &quot;&quot;</div><div class=\"line\">#是否开启分享</div><div class=\"line\">share: true</div><div class=\"line\">#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）</div><div class=\"line\">#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论</div><div class=\"line\">duoshuo: true</div><div class=\"line\">#是否开启云标签</div><div class=\"line\">tagcloud: true</div><div class=\"line\"></div><div class=\"line\">#是否开启友情链接</div><div class=\"line\">#不开启——</div><div class=\"line\">#friends: false</div><div class=\"line\">#开启——</div><div class=\"line\">friends:</div><div class=\"line\">  奥巴马的博客: http://localhost:4000/</div><div class=\"line\">  卡卡的美丽传说: http://localhost:4000/</div><div class=\"line\">  本泽马的博客: http://localhost:4000/</div><div class=\"line\">  吉格斯的博客: http://localhost:4000/</div><div class=\"line\">  习大大大不同: http://localhost:4000/</div><div class=\"line\">  托蒂的博客: http://localhost:4000/</div><div class=\"line\"></div><div class=\"line\">#是否开启“关于我”。</div><div class=\"line\">#不开启——</div><div class=\"line\">#aboutme: false</div><div class=\"line\">#开启——</div><div class=\"line\">aboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div></pre></td></tr></table></figure>\n<h1 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h1><p><a href=\"http://ibruce.info/2013/11/22/hexo-your-blog/\" target=\"_blank\" rel=\"external\">hexo你的博客</a><br><a href=\"http://www.jianshu.com/p/05289a4bc8b2#\" target=\"_blank\" rel=\"external\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br><a href=\"http://luuman.github.io/2015/12/25/Hexo/\" target=\"_blank\" rel=\"external\">Hexo的使用介绍</a><br><a href=\"http://luuman.github.io/2015/12/27/Hexo-plug/\" target=\"_blank\" rel=\"external\">Hexo插件安装</a></p>\n","excerpt":"<p>来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。<br>国内也有不多少的代码托管平台，本文将就用GitHub的GitHub Pages 功能来搭建，比起WordPress，hexo的搭建更加简洁，配合上markdown的使用，更加便捷的管理自己的学习文档。</p>","more":"<h1 id=\"概况\"><a href=\"#概况\" class=\"headerlink\" title=\"概况\"></a>概况</h1><blockquote>\n<ol>\n<li>为什么选择<a href=\"1\">GitHub Pages</a><br>1、<a href=\"1\">GitHub Pages</a>有免费的代码托管空间，资料自己管理，保存可靠；<br>2、学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多；<br>3、顺便理解 GitHub 工作原理，最好的团队协作流程；<br>4、GitHub建立私有仓库才会收费，所以会有很多开源代码。</li>\n<li><a href=\"1\">GitHub Pages</a>是什么<br>应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README” 。</li>\n<li><a href=\"2\">hexo</a>出自何人<br>hexo出自台湾大学生 tommy351 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。</li>\n</ol>\n</blockquote>\n<h1 id=\"安装准备\"><a href=\"#安装准备\" class=\"headerlink\" title=\"安装准备\"></a>安装准备</h1><blockquote>\n<p>环境搭建：</p>\n<ol>\n<li><a href=\"http://nodejs.org/\">Node.js</a>：下载<a href=\"https://nodejs.org/en/\">地址</a></li>\n<li><a href=\"http://git-scm.com/\">Git</a>：下载<a href=\"https://git-scm.com/download/win\">地址</a></li>\n<li><a href=\"http://www.sublimetext.com/\">Sublime</a>：下载<a href=\"http://www.sublimetext.com/2\">地址</a><h2 id=\"安装Node\"><a href=\"#安装Node\" class=\"headerlink\" title=\"安装Node\"></a>安装Node</h2>到 Node.js 官网下载相应平台的 最新版本 ，一路安装即可。我用的是 node-v0.10.22-x86.msi<h2 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h2>Git的客户端很多，我用的是 msysgit ，喜欢用绿色版本 Portable application for official Git for Windows 1.8.4 ，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。<h2 id=\"安装Sublime\"><a href=\"#安装Sublime\" class=\"headerlink\" title=\"安装Sublime\"></a>安装Sublime</h2>Sublime Text 2 在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的 Sublime Text 3 。</li>\n</ol>\n</blockquote>\n<h1 id=\"GitHub注册与配置\"><a href=\"#GitHub注册与配置\" class=\"headerlink\" title=\"GitHub注册与配置\"></a>GitHub注册与配置</h1><blockquote>\n<ol>\n<li><p>注册：<br>访问：<a href=\"0\">GitHub</a>，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。注册过程比较简单，详细也可以看：<br>使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考<a href=\"https://pages.github.com/\">官方文档</a></p>\n</li>\n<li><p>配置和使用Github<br>以下教程主要参考beiyuu的<a href=\"http://beiyuu.com/github-pages/\">《使用Github Pages建独立博客》</a>写成。</p>\n</li>\n<li><p>配置SSH keys<br>我们如何让本地git项目与远程的github建立联系呢？用SSH keys。<br>打开Git Bash工具，执行以下操作</p>\n</li>\n<li><p>检查SSH keys的设置</p>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">    首先我们需要检查你电脑上现有的ssh key：</div><div class=\"line\"></div><div class=\"line\">$ cd ~/. ssh 检查本机的ssh密钥</div><div class=\"line\"></div><div class=\"line\">    如果提示：No such file or directory 说明你是第一次使用git。</div><div class=\"line\"></div><div class=\"line\">    生成新的SSH Key：</div><div class=\"line\"></div><div class=\"line\">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</div><div class=\"line\">Generating public/private rsa key pair.</div><div class=\"line\">Enter file in which to save the key </div><div class=\"line\">(/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</div></pre></td></tr></table></figure>\n<p>注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；<br>注意2: 此处的「-C」的是大写的「C」</p>\n<pre><code>然后系统会要你输入密码：\n</code></pre><p>Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;<br>Enter same passphrase again:&lt;再次输入加密串&gt;</p>\n<p>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p>\n<p>注意：输入密码的时候没有*字样的，你直接输入就可以了。</p>\n<p>最后看到这样的界面，就成功设置ssh key了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<blockquote>\n<ol>\n<li>添加SSH Key到GitHub<br>在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。</li>\n<li>打开本地C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。</li>\n<li>登陆github系统。点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys</li>\n<li><p>把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了</p>\n</li>\n<li><p>测试</p>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">    可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：</div><div class=\"line\"></div><div class=\"line\">$ ssh -T git@github.com</div><div class=\"line\"></div><div class=\"line\">    如果是下面的反馈：</div><div class=\"line\"></div><div class=\"line\">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div><div class=\"line\"></div><div class=\"line\">    不要紧张，输入yes就好，然后会看到：</div><div class=\"line\"></div><div class=\"line\">Hi cnfeat! You&apos;ve successfully authenticated, </div><div class=\"line\">but GitHub does not provide shell access.</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    设置用户信息：</div><div class=\"line\">    现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。</div><div class=\"line\">    Git会根据用户的名字和邮箱来记录提交。</div><div class=\"line\">    GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。</div><div class=\"line\"></div><div class=\"line\">$ git config --global user.name &quot;cnfeat&quot;//用户名</div><div class=\"line\">$ git config --global user.email &quot;cnfeat@gmail.com&quot;//填写自己的邮箱</div><div class=\"line\"></div><div class=\"line\">    SSH Key配置成功，本机已成功连接到github。</div></pre></td></tr></table></figure>\n<h1 id=\"Hexo博客\"><a href=\"#Hexo博客\" class=\"headerlink\" title=\"Hexo博客\"></a>Hexo博客</h1><blockquote>\n<p>Hexo<br>Hexo的作者是<a href=\"https://github.com/tommy351/hexo\">tommy351</a>，根据<a href=\"http://hexo.io/docs/index.html\">官方介绍</a>，Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。hexo的主题列表 <a href=\"http://github.com/tommy351/hexo/wiki/Themes\">Hexo Themes</a>。 我比较喜欢 <a href=\"http://github.com/A-limon/pacman\">pacman</a> ， <a href=\"http://github.com/heroicyang/hexo-theme-modernist\">modernist</a> 、 <a href=\"http://github.com/DavidKk/Hexo.ishgo\">ishgo</a> ， <a href=\"http://github.com/raytaylorlin/hexo-theme-raytaylorism\">raytaylorism</a> 。 </p>\n</blockquote>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>打开Git Bash工具（前提确保Node.js已经安装，环境配置OK）</p>\n<pre><code>$ npm install -g hexo\n</code></pre><blockquote>\n<p>注释：</p>\n</blockquote>\n<p>执行命令：npm install -g hexo，报错如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm ERR! Error: shasum check failed for C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\npm</div><div class=\"line\">-30024-KDJHJzgP\\registry.npmjs.org\\hexo-cli\\-\\hexo-cli-0.1.6.tgz</div><div class=\"line\">npm ERR! Expected: 7dc3ab939d0889c4bed6a961605ff3e2d67f67a2</div><div class=\"line\">npm ERR! Actual:   41de7d67a9b764352eb07c49c32fc38dd7f479b9</div><div class=\"line\">npm ERR! From:     https://registry.npmjs.org/hexo-cli/-/hexo-cli-0.1.6.tgz</div><div class=\"line\">npm ERR!     at d:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\sha\\index.</div><div class=\"line\">js:38:8</div><div class=\"line\">npm ERR!     at ReadStream.&lt;anonymous&gt; (d:\\Program Files\\nodejs\\node_modules\\npm</div><div class=\"line\">\\node_modules\\sha\\index.js:85:7)</div><div class=\"line\">npm ERR!     at ReadStream.emit (events.js:117:20)</div><div class=\"line\">npm ERR!     at _stream_readable.js:943:16</div><div class=\"line\">npm ERR!     at process._tickCallback (node.js:419:13)</div><div class=\"line\">npm ERR! If you need help, you may report this *entire* log,</div><div class=\"line\">npm ERR! including the npm and node versions, at:</div><div class=\"line\">npm ERR!     &lt;http://github.com/npm/npm/issues&gt;</div><div class=\"line\"></div><div class=\"line\">npm ERR! System Windows_NT 6.2.9200</div><div class=\"line\">npm ERR! command &quot;d:\\\\Program Files\\\\nodejs\\\\node.exe&quot; &quot;d:\\\\Program Files\\\\nodej</div><div class=\"line\">s\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js&quot; &quot;install&quot; &quot;-g&quot; &quot;hexo&quot;</div><div class=\"line\">npm ERR! cwd C:\\Users\\Administrator\\Desktop</div><div class=\"line\">npm ERR! node -v v0.10.31</div><div class=\"line\">npm ERR! npm -v 1.4.23</div><div class=\"line\">npm ERR! registry error parsing json</div><div class=\"line\">npm ERR!</div><div class=\"line\">npm ERR! Additional logging details can be found in:</div><div class=\"line\">npm ERR!     C:\\Users\\Administrator\\Desktop\\npm-debug.log</div><div class=\"line\">npm ERR! not ok code 0</div><div class=\"line\"></div><div class=\"line\">    莫非是因为被墙了？换国内镜像源试试。</div><div class=\"line\">npm config set registry=&quot;http://registry.cnpmjs.org&quot;，</div><div class=\"line\">    然后再次执行npm install -g hexo，成功！</div></pre></td></tr></table></figure>\n<h2 id=\"部署Hexo\"><a href=\"#部署Hexo\" class=\"headerlink\" title=\"部署Hexo\"></a>部署Hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">    在我的电脑中建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash。</div><div class=\"line\"></div><div class=\"line\">$ hexo init</div><div class=\"line\"></div><div class=\"line\">    如果无法使用右击“Git Bash”，则可以切换到指定目录</div><div class=\"line\"></div><div class=\"line\">    UUhike@UUhike-pc MINGW64 ~</div><div class=\"line\">$ cd j:/github/hexo</div><div class=\"line\">    UUhike@UUhike-pc MINGW64 /j/github/hexo</div><div class=\"line\"></div><div class=\"line\">    安装依赖包</div><div class=\"line\">$ npm install</div><div class=\"line\"></div><div class=\"line\">    Hexo随后会自动在目标文件夹建立网站所需要的所有文件。</div><div class=\"line\">    现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000看看。</div><div class=\"line\"></div><div class=\"line\">    本地查看</div><div class=\"line\"></div><div class=\"line\">$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）</div><div class=\"line\"></div><div class=\"line\">$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div></pre></td></tr></table></figure>\n<h2 id=\"部署到GitHub\"><a href=\"#部署到GitHub\" class=\"headerlink\" title=\"部署到GitHub\"></a>部署到GitHub</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">编辑E:\\hexo下的_config.yml，修改Deployment部分：</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: http://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">    repository: https://github.com/luuman/luuman.github.io.git</div><div class=\"line\">    branch: master</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注释：</p>\n</blockquote>\n<p>hexo d，执行该命令，报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR Deployer not found: git</div><div class=\"line\"></div><div class=\"line\">执行命令：</div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\">再次执行hexo d,报错：</div><div class=\"line\"></div><div class=\"line\">INFO  Deploying: git</div><div class=\"line\">INFO  Clearing .deploy folder...</div><div class=\"line\">INFO  Copying files from public folder...</div><div class=\"line\">warning: LF will be replaced by CRLF in 2015/05/30/hello-world/index.html.</div><div class=\"line\">The file will have its original line endings in your working directory.</div><div class=\"line\">......</div><div class=\"line\">*** Please tell me who you are.</div><div class=\"line\"></div><div class=\"line\">Run</div><div class=\"line\"></div><div class=\"line\">  git config --global user.email &quot;you@example.com&quot;</div><div class=\"line\">  git config --global user.name &quot;Your Name&quot;</div><div class=\"line\"></div><div class=\"line\">to set your account&apos;s default identity.</div><div class=\"line\">Omit --global to set the identity only in this repository.</div><div class=\"line\"></div><div class=\"line\">fatal: unable to auto-detect email address (got &apos;Administrator@PC-201505290750.(none)&apos;)</div><div class=\"line\">Username for &apos;https://github.com&apos;: voidking</div><div class=\"line\">Password for &apos;https://voidking@github.com&apos;:</div><div class=\"line\">error: src refspec master does not match any.</div><div class=\"line\">error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos;</div><div class=\"line\">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</div><div class=\"line\">Error: error: src refspec master does not match any.</div><div class=\"line\">error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos;</div><div class=\"line\"></div><div class=\"line\">    at ChildProcess.&lt;anonymous&gt; (E:\\hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:42:17)</div><div class=\"line\">    at ChildProcess.emit (events.js:98:17)</div><div class=\"line\">    at maybeClose (child_process.js:756:16)</div><div class=\"line\">    at Process.ChildProcess._handle.onexit (child_process.js:823:5)</div></pre></td></tr></table></figure>\n<p>hexo d，执行该命令，报错：</p>\n<h2 id=\"复制cnfeat的主题\"><a href=\"#复制cnfeat的主题\" class=\"headerlink\" title=\"复制cnfeat的主题\"></a>复制cnfeat的主题</h2><p>以下进入复制主题环节，如果那一步出现问题，或者修改后没有显示修改的结果，建议来来一个，再看看，可以解决很多问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo clean</div><div class=\"line\"></div><div class=\"line\">$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）</div><div class=\"line\"></div><div class=\"line\">$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div><div class=\"line\"></div><div class=\"line\">建立了Hexo文件，复制我的主题了到themes文件夹中</div><div class=\"line\">yilia</div><div class=\"line\">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</div><div class=\"line\">modernist</div><div class=\"line\">$ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist</div><div class=\"line\">jacman</div><div class=\"line\">$ git clone https://github.com/cnfeat/cnfeat.git themes/jacman</div></pre></td></tr></table></figure>\n<h2 id=\"启用cnfeat的主题\"><a href=\"#启用cnfeat的主题\" class=\"headerlink\" title=\"启用cnfeat的主题\"></a>启用cnfeat的主题</h2><p>修改Hexo目录下的config.yml配置文件中的theme属性，将其设置为jacman。同时请设置stylus属性中的compress值为true。<br>theme: jacman</p>\n<p>注意：Hexo有两个config.yml文件，一个在根目录，一个在theme下，此时修改的是在根目录下的。</p>\n<pre><code>更新主题\n\n$ cd themes/jacman\n$ git pull\n</code></pre><p>注意：为避免出错，请先备份你的_config.yml 文件后再升级<br>本地查看调试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g #生成</div><div class=\"line\">$ hexo s #启动本地服务，进行文章预览调试</div><div class=\"line\"></div><div class=\"line\">或者直接作用组合命令</div><div class=\"line\"></div><div class=\"line\">$ hexo deploy -g</div><div class=\"line\">$ hexo server -g</div><div class=\"line\"></div><div class=\"line\">简写：</div><div class=\"line\"></div><div class=\"line\">hexo n == hexo new</div><div class=\"line\">hexo g == hexo generate</div><div class=\"line\">hexo s == hexo server</div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure>\n<blockquote>\n<p>4、浏览器中查看效果</p>\n</blockquote>\n<p>浏览器输入<a href=\"http://localhost:4000\">http://localhost:4000</a> ，查看搭建效果。此后的每次变更_config.yml文件或者上传文件都可以先用此命令调试，非常好用，尤其是当你想调试出自己想要的主题时。</p>\n<p>#进阶篇：Hexo设置</p>\n<p>网站搭建完成后，就可以根据自己爱好来对Hexo生成的网站进行设置了，对整站的设置，只要修改项目目录的hexo/_config.yml就可以了，这是我的设置，可供参考。</p>\n<blockquote>\n<p>默认目录结构：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── .deploy</div><div class=\"line\">├── public</div><div class=\"line\">├── scaffolds</div><div class=\"line\">├── scripts</div><div class=\"line\">├── source</div><div class=\"line\">|   ├── _drafts</div><div class=\"line\">|   └── _posts</div><div class=\"line\">├── themes</div><div class=\"line\">├── _config.yml</div><div class=\"line\">└── package.json</div></pre></td></tr></table></figure>\n<blockquote>\n<p>hexo/_config.yml</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: http://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site #整站的基本信息</div><div class=\"line\">title: 1000 words a Day #网站标题</div><div class=\"line\">subtitle: Writing 1000 Words a Day Changes My Life #网站副标题</div><div class=\"line\">description: 学习总结 思考感悟 知识管理 #网站描述</div><div class=\"line\">author:  cnFeat #网站作者，在下方显示</div><div class=\"line\">email: cnFeat@gmail.com #联系邮箱</div><div class=\"line\">language: zh-CN #主题实际的文件名称</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项</div><div class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class=\"line\">url: http://yoursite.com</div><div class=\"line\">root: /</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"></div><div class=\"line\"># Directory</div><div class=\"line\">source_dir: source</div><div class=\"line\">public_dir: public</div><div class=\"line\">tag_dir: tags</div><div class=\"line\">archive_dir: archives</div><div class=\"line\">category_dir: categories</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">i18n_dir: :lang</div><div class=\"line\">skip_render:</div><div class=\"line\"></div><div class=\"line\"># Writing 文章布局、写作格式的定义，不修改</div><div class=\"line\">new_post_name: :title.md # File name of new posts</div><div class=\"line\">default_layout: post</div><div class=\"line\">titlecase: false # Transform title into titlecase</div><div class=\"line\">external_link: true # Open external links in new tab</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">future: true</div><div class=\"line\">highlight:</div><div class=\"line\">  enable: true</div><div class=\"line\">  line_number: true</div><div class=\"line\">  auto_detect: true</div><div class=\"line\">  tab_replace:</div><div class=\"line\"></div><div class=\"line\"># Category &amp; Tag</div><div class=\"line\">default_category: uncategorized</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"></div><div class=\"line\"># Date / Time format 日期格式，不修改</div><div class=\"line\">## Hexo uses Moment.js to parse and display date</div><div class=\"line\">## You can customize the date format as defined in</div><div class=\"line\">## http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">date_format: YYYY-MM-DD</div><div class=\"line\">time_format: HH:mm:ss</div><div class=\"line\"></div><div class=\"line\"># Pagination 每页显示文章数，可以自定义，我将10改成了5</div><div class=\"line\">## Set per_page to 0 to disable pagination</div><div class=\"line\">per_page: 5</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"></div><div class=\"line\"># Disqus Disqus插件，我们会替换成“多说”，不修改</div><div class=\"line\">disqus_shortname:</div><div class=\"line\"></div><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: http://hexo.io/plugins/</div><div class=\"line\">## Themes: http://hexo.io/themes/</div><div class=\"line\">theme: spfk</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># 自动生成sitemap</div><div class=\"line\">sitemap:</div><div class=\"line\">path: sitemap.xml</div><div class=\"line\">baidusitemap:</div><div class=\"line\">path: baidusitemap.xml</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># Deployment 站点部署到github要配置，上一节中已经讲过</div><div class=\"line\">## Docs: http://zespia.tw/hexo/docs/deploy.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:luuman/luuman.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>修改局部页面</p>\n<p>页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\主题名称\\中：</p>\n<blockquote>\n<p>hexo\\themes\\</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── languages  #多语言</div><div class=\"line\">|   ├── default.yml#默认语言</div><div class=\"line\">|   └── zh-CN.yml  #中文语言</div><div class=\"line\">├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制</div><div class=\"line\">|   ├── _partial   #局部的布局，此目录下的*.ejs是对头尾等局部的控制</div><div class=\"line\">|   └── _widget#小挂件的布局，页面下方小挂件的控制</div><div class=\"line\">├── source #源码</div><div class=\"line\">|   ├── css#css源码 </div><div class=\"line\">|   |   ├── _base  #*.styl基础css</div><div class=\"line\">|   |   ├── _partial   #*.styl局部css</div><div class=\"line\">|   |   ├── fonts  #字体</div><div class=\"line\">|   |   ├── images #图片</div><div class=\"line\">|   |   └── style.styl #*.styl引入需要的css源码</div><div class=\"line\">|   ├── fancybox   #fancybox效果源码</div><div class=\"line\">|   └── js #javascript源代码</div><div class=\"line\">├── _config.yml#主题配置文件</div><div class=\"line\">└── README.md  #用GitHub的都知道</div></pre></td></tr></table></figure>\n<p>主题文档的配置</p>\n<blockquote>\n<p>hexo\\themes/_config.yml</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Header</div><div class=\"line\">menu:</div><div class=\"line\">  主页: /</div><div class=\"line\">  所有文章: /archives</div><div class=\"line\">  # 随笔: /tags/随笔</div><div class=\"line\"></div><div class=\"line\"># SubNav</div><div class=\"line\">subnav:</div><div class=\"line\">  github: &quot;#&quot;</div><div class=\"line\">  weibo: &quot;#&quot;</div><div class=\"line\">  rss: &quot;#&quot;</div><div class=\"line\">  zhihu: &quot;#&quot;</div><div class=\"line\">  #douban: &quot;#&quot;</div><div class=\"line\">  #mail: &quot;#&quot;</div><div class=\"line\">  #facebook: &quot;#&quot;</div><div class=\"line\">  #google: &quot;#&quot;</div><div class=\"line\">  #twitter: &quot;#&quot;</div><div class=\"line\">  #linkedin: &quot;#&quot;</div><div class=\"line\"></div><div class=\"line\">rss: /atom.xml</div><div class=\"line\"></div><div class=\"line\"># Content</div><div class=\"line\">excerpt_link: more</div><div class=\"line\">fancybox: true</div><div class=\"line\">mathjax: true</div><div class=\"line\"></div><div class=\"line\"># Miscellaneous</div><div class=\"line\">google_analytics: &apos;&apos;</div><div class=\"line\">favicon: /favicon.png</div><div class=\"line\"></div><div class=\"line\">#你的头像url</div><div class=\"line\">avatar: &quot;&quot;</div><div class=\"line\">#是否开启分享</div><div class=\"line\">share: true</div><div class=\"line\">#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）</div><div class=\"line\">#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论</div><div class=\"line\">duoshuo: true</div><div class=\"line\">#是否开启云标签</div><div class=\"line\">tagcloud: true</div><div class=\"line\"></div><div class=\"line\">#是否开启友情链接</div><div class=\"line\">#不开启——</div><div class=\"line\">#friends: false</div><div class=\"line\">#开启——</div><div class=\"line\">friends:</div><div class=\"line\">  奥巴马的博客: http://localhost:4000/</div><div class=\"line\">  卡卡的美丽传说: http://localhost:4000/</div><div class=\"line\">  本泽马的博客: http://localhost:4000/</div><div class=\"line\">  吉格斯的博客: http://localhost:4000/</div><div class=\"line\">  习大大大不同: http://localhost:4000/</div><div class=\"line\">  托蒂的博客: http://localhost:4000/</div><div class=\"line\"></div><div class=\"line\">#是否开启“关于我”。</div><div class=\"line\">#不开启——</div><div class=\"line\">#aboutme: false</div><div class=\"line\">#开启——</div><div class=\"line\">aboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div></pre></td></tr></table></figure>\n<h1 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h1><p><a href=\"http://ibruce.info/2013/11/22/hexo-your-blog/\">hexo你的博客</a><br><a href=\"http://www.jianshu.com/p/05289a4bc8b2#\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br><a href=\"http://luuman.github.io/2015/12/25/Hexo/\">Hexo的使用介绍</a><br><a href=\"http://luuman.github.io/2015/12/27/Hexo-plug/\">Hexo插件安装</a></p>"},{"title":"iOS语音识别","author":[{"name":"千寻墨","url":"http://www.jianshu.com/users/527ecf8c8753/latest_articles"}],"_content":"\n公司项目需要实现语音搜索，正好记录一下这个iOS10新出的API。\n\n\tiOS10是一个变化比价大的版本，开放了很多接口，这样也更方便开发者自定义各种功能。本文主要讲解一下新增的Speech框架，有了这个框架，我们想要为自己的app增加语音识别功能，不要依赖第三方的服务，几十行代码就可以轻松搞定。demo地址在文章末尾。\n\n### 一：基本配置\n- Xcode8，iOS10系统真机\n- 导入头文件：OC `#import<Speech/Speech.h>`   swift `import Speech`\n- 配置info.plist文件:配置两个权限，语音识别和麦克风\n\n\n```\n<key>NSMicrophoneUsageDescription</key>\n    <string>Your microphone will be used to record your speech when you press the \"Start Recording\" button.</string>\n    \n    <key>NSSpeechRecognitionUsageDescription</key>\n    <string>Speech recognition will be used to determine which words you speak into this device's microphone.</string>\n  \n```\n\n### 二：用到的几个类\n\n` AVAudioEngine `                           语音引擎，负责提供语音输入\n` SFSpeechAudioBufferRecognitionRequest `   处理语音识别请求\n` SFSpeechRecognizer`                       语音识别器\n` SFSpeechRecognitionTask `                 输出语音识别对象的结果\n` NSLocale `                                语言类型               \n语音识别一共就用到了这几个类，整体的流程也容易理解，语音识别器通过语音引擎，处理语音识别请求，把结果交给`SFSpeechRecognitionTask`处理，最后输出文字。\n` SFSpeechRecognizer` 自身有几个代理方法，实际上，如果只是将语音转化成文字，是不需要这几个代理方法的。\n<!--more-->\n```\n//当开始检测音频源中的语音时首先调用此方法\n-(void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task\n{\n  \n}\n//当识别出一条可用的信息后 会调用\n/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法 */\n-(void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription\n{\n   \n}\n//当识别完成所有可用的结果后调用\n- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult\n{\n    \n}\n//当不再接受音频输入时调用 即开始处理语音识别任务时调用\n- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task\n{\n    \n}\n//当语音识别任务被取消时调用\n- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task\n{\n    \n}\n//语音识别任务完成时被调用\n- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully\n{\n\n}\n```\n\n### 三：重点代码\n有两点需要注意：\n\n* 语音识别会很耗电以及会使用很多数据\n* 语音识别一次只持续大概一分钟的时间\n\n我先定义了这几个属性\n\n```\n@property (nonatomic, strong) AVAudioEngine         *audioEngine;\n@property (nonatomic, strong) SFSpeechRecognizer    *speechRecognizer;\n@property (nonatomic, strong) SFSpeechAudioBufferRecognitionRequest     *recognitionRequest;\n@property (nonatomic, strong) SFSpeechRecognitionTask   *recognitionTask;\n@property (nonatomic, strong) NSLocale                  *locale;\n```\n1. 语音权限的判断\n```\n[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) {\n        BOOL isAuthorized = NO;\n       switch (status) {\n                //结果未知 用户尚未进行选择\n            case SFSpeechRecognizerAuthorizationStatusNotDetermined:\n                isAuthorized = NO;\n                break;\n                //用户拒绝授权语音识别\n            case SFSpeechRecognizerAuthorizationStatusDenied:\n                isAuthorized = NO;\n                break;\n                //设备不支持语音识别功能\n            case SFSpeechRecognizerAuthorizationStatusRestricted:\n                isAuthorized = NO;\n                break;\n                //用户授权语音识别\n            case SFSpeechRecognizerAuthorizationStatusAuthorized:\n                isAuthorized = YES;\n                \n                break;\n                \n            default:\n                break;\n        }\n        \n        if (callback) {\n            callback(isAuthorized, status);\n        }\n    }];\n```\n2. 将语音引擎得到的语音数据添加到语音识别的请求中，这个过程也就是开始录音后的流程\n```\nAVAudioFormat *recordingFormat = [[self.audioEngine inputNode] outputFormatForBus:0];\n    [[self.audioEngine inputNode] installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) {\n        [self.recognitionRequest appendAudioPCMBuffer:buffer];\n    }];\n```\n\n3. `SFSpeechRecognitionTask ` 把上一过程中得到的语音请求转化成文字，这个过程是试试进行的。\n\n```\nself.recognitionTask = [self.speechRecognizer recognitionTaskWithRequest:self.recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) {\n        BOOL isFinal = NO;\n        NSString *bestResult = [[result bestTranscription] formattedString];\n        isFinal = result.isFinal;\n        if (error || isFinal) {\n            [self endTask];\n            if (self.delegate && [self.delegate respondsToSelector:@selector(recognizeFail:)]) {\n                [self.delegate recognizeFail:error];\n            }\n        } else {\n            if (self.delegate && [self.delegate respondsToSelector:@selector(recognizeSuccess:)]) {\n                [self.delegate recognizeSuccess:bestResult];\n            }\n        }\n    }];\n```\n### 四：提取录音文件中的文字\n1. 也需要先获取用户的授权，授权代码与上面一致。\n2. 对文件的处理相对较为简单\n```\n    //初始化一个识别器\n    SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc] initWithLocale:[NSLocale localeWithLocaleIdentifier:@\"zh_CN\"]];\n    //初始化mp3的url\n    NSURL *url = [[NSBundle mainBundle] URLForResource:@\"test.mp3\" withExtension:nil];\n    //初始化一个识别的请求\n    SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url];\n    //发起请求\n    [recognizer recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) {\n        if(error != nil)\n        {\n            NSLog(@\"识别错误:%@\",error);\n        }\n        NSString *resultString = result.bestTranscription.formattedString;\n        NSLog(@\"%@\",resultString);\n        \n    }];\n```\n\n[github地址：https://github.com/suifengqjn/IOS10Speech](https://github.com/suifengqjn/IOS10Speech)\n\n\n","source":"_posts/IOS10语音识别详解.md","raw":"---\ntitle: iOS语音识别\ntags:\n  - iOS\n  - 语音识别\ncategories:\n  - iOS技术\nauthor:\n  - name: 千寻墨\n    url: http://www.jianshu.com/users/527ecf8c8753/latest_articles\n---\n\n公司项目需要实现语音搜索，正好记录一下这个iOS10新出的API。\n\n\tiOS10是一个变化比价大的版本，开放了很多接口，这样也更方便开发者自定义各种功能。本文主要讲解一下新增的Speech框架，有了这个框架，我们想要为自己的app增加语音识别功能，不要依赖第三方的服务，几十行代码就可以轻松搞定。demo地址在文章末尾。\n\n### 一：基本配置\n- Xcode8，iOS10系统真机\n- 导入头文件：OC `#import<Speech/Speech.h>`   swift `import Speech`\n- 配置info.plist文件:配置两个权限，语音识别和麦克风\n\n\n```\n<key>NSMicrophoneUsageDescription</key>\n    <string>Your microphone will be used to record your speech when you press the \"Start Recording\" button.</string>\n    \n    <key>NSSpeechRecognitionUsageDescription</key>\n    <string>Speech recognition will be used to determine which words you speak into this device's microphone.</string>\n  \n```\n\n### 二：用到的几个类\n\n` AVAudioEngine `                           语音引擎，负责提供语音输入\n` SFSpeechAudioBufferRecognitionRequest `   处理语音识别请求\n` SFSpeechRecognizer`                       语音识别器\n` SFSpeechRecognitionTask `                 输出语音识别对象的结果\n` NSLocale `                                语言类型               \n语音识别一共就用到了这几个类，整体的流程也容易理解，语音识别器通过语音引擎，处理语音识别请求，把结果交给`SFSpeechRecognitionTask`处理，最后输出文字。\n` SFSpeechRecognizer` 自身有几个代理方法，实际上，如果只是将语音转化成文字，是不需要这几个代理方法的。\n<!--more-->\n```\n//当开始检测音频源中的语音时首先调用此方法\n-(void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task\n{\n  \n}\n//当识别出一条可用的信息后 会调用\n/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法 */\n-(void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription\n{\n   \n}\n//当识别完成所有可用的结果后调用\n- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult\n{\n    \n}\n//当不再接受音频输入时调用 即开始处理语音识别任务时调用\n- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task\n{\n    \n}\n//当语音识别任务被取消时调用\n- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task\n{\n    \n}\n//语音识别任务完成时被调用\n- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully\n{\n\n}\n```\n\n### 三：重点代码\n有两点需要注意：\n\n* 语音识别会很耗电以及会使用很多数据\n* 语音识别一次只持续大概一分钟的时间\n\n我先定义了这几个属性\n\n```\n@property (nonatomic, strong) AVAudioEngine         *audioEngine;\n@property (nonatomic, strong) SFSpeechRecognizer    *speechRecognizer;\n@property (nonatomic, strong) SFSpeechAudioBufferRecognitionRequest     *recognitionRequest;\n@property (nonatomic, strong) SFSpeechRecognitionTask   *recognitionTask;\n@property (nonatomic, strong) NSLocale                  *locale;\n```\n1. 语音权限的判断\n```\n[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) {\n        BOOL isAuthorized = NO;\n       switch (status) {\n                //结果未知 用户尚未进行选择\n            case SFSpeechRecognizerAuthorizationStatusNotDetermined:\n                isAuthorized = NO;\n                break;\n                //用户拒绝授权语音识别\n            case SFSpeechRecognizerAuthorizationStatusDenied:\n                isAuthorized = NO;\n                break;\n                //设备不支持语音识别功能\n            case SFSpeechRecognizerAuthorizationStatusRestricted:\n                isAuthorized = NO;\n                break;\n                //用户授权语音识别\n            case SFSpeechRecognizerAuthorizationStatusAuthorized:\n                isAuthorized = YES;\n                \n                break;\n                \n            default:\n                break;\n        }\n        \n        if (callback) {\n            callback(isAuthorized, status);\n        }\n    }];\n```\n2. 将语音引擎得到的语音数据添加到语音识别的请求中，这个过程也就是开始录音后的流程\n```\nAVAudioFormat *recordingFormat = [[self.audioEngine inputNode] outputFormatForBus:0];\n    [[self.audioEngine inputNode] installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) {\n        [self.recognitionRequest appendAudioPCMBuffer:buffer];\n    }];\n```\n\n3. `SFSpeechRecognitionTask ` 把上一过程中得到的语音请求转化成文字，这个过程是试试进行的。\n\n```\nself.recognitionTask = [self.speechRecognizer recognitionTaskWithRequest:self.recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) {\n        BOOL isFinal = NO;\n        NSString *bestResult = [[result bestTranscription] formattedString];\n        isFinal = result.isFinal;\n        if (error || isFinal) {\n            [self endTask];\n            if (self.delegate && [self.delegate respondsToSelector:@selector(recognizeFail:)]) {\n                [self.delegate recognizeFail:error];\n            }\n        } else {\n            if (self.delegate && [self.delegate respondsToSelector:@selector(recognizeSuccess:)]) {\n                [self.delegate recognizeSuccess:bestResult];\n            }\n        }\n    }];\n```\n### 四：提取录音文件中的文字\n1. 也需要先获取用户的授权，授权代码与上面一致。\n2. 对文件的处理相对较为简单\n```\n    //初始化一个识别器\n    SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc] initWithLocale:[NSLocale localeWithLocaleIdentifier:@\"zh_CN\"]];\n    //初始化mp3的url\n    NSURL *url = [[NSBundle mainBundle] URLForResource:@\"test.mp3\" withExtension:nil];\n    //初始化一个识别的请求\n    SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url];\n    //发起请求\n    [recognizer recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) {\n        if(error != nil)\n        {\n            NSLog(@\"识别错误:%@\",error);\n        }\n        NSString *resultString = result.bestTranscription.formattedString;\n        NSLog(@\"%@\",resultString);\n        \n    }];\n```\n\n[github地址：https://github.com/suifengqjn/IOS10Speech](https://github.com/suifengqjn/IOS10Speech)\n\n\n","slug":"IOS10语音识别详解","published":1,"date":"2016-11-16T15:05:20.000Z","updated":"2016-11-17T14:57:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tdd0008lx60d02szh8h","content":"<p>公司项目需要实现语音搜索，正好记录一下这个iOS10新出的API。</p>\n<pre><code>iOS10是一个变化比价大的版本，开放了很多接口，这样也更方便开发者自定义各种功能。本文主要讲解一下新增的Speech框架，有了这个框架，我们想要为自己的app增加语音识别功能，不要依赖第三方的服务，几十行代码就可以轻松搞定。demo地址在文章末尾。\n</code></pre><h3 id=\"一：基本配置\"><a href=\"#一：基本配置\" class=\"headerlink\" title=\"一：基本配置\"></a>一：基本配置</h3><ul>\n<li>Xcode8，iOS10系统真机</li>\n<li>导入头文件：OC <code>#import&lt;Speech/Speech.h&gt;</code>   swift <code>import Speech</code></li>\n<li>配置info.plist文件:配置两个权限，语音识别和麦克风</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;</div><div class=\"line\">    &lt;string&gt;Your microphone will be used to record your speech when you press the &quot;Start Recording&quot; button.&lt;/string&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;key&gt;NSSpeechRecognitionUsageDescription&lt;/key&gt;</div><div class=\"line\">    &lt;string&gt;Speech recognition will be used to determine which words you speak into this device&apos;s microphone.&lt;/string&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"二：用到的几个类\"><a href=\"#二：用到的几个类\" class=\"headerlink\" title=\"二：用到的几个类\"></a>二：用到的几个类</h3><p><code>AVAudioEngine</code>                           语音引擎，负责提供语音输入<br><code>SFSpeechAudioBufferRecognitionRequest</code>   处理语音识别请求<br><code>SFSpeechRecognizer</code>                       语音识别器<br><code>SFSpeechRecognitionTask</code>                 输出语音识别对象的结果<br><code>NSLocale</code>                                语言类型<br>语音识别一共就用到了这几个类，整体的流程也容易理解，语音识别器通过语音引擎，处理语音识别请求，把结果交给<code>SFSpeechRecognitionTask</code>处理，最后输出文字。<br><code>SFSpeechRecognizer</code> 自身有几个代理方法，实际上，如果只是将语音转化成文字，是不需要这几个代理方法的。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">//当开始检测音频源中的语音时首先调用此方法</div><div class=\"line\">-(void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div><div class=\"line\">//当识别出一条可用的信息后 会调用</div><div class=\"line\">/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法 */</div><div class=\"line\">-(void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription</div><div class=\"line\">&#123;</div><div class=\"line\">   </div><div class=\"line\">&#125;</div><div class=\"line\">//当识别完成所有可用的结果后调用</div><div class=\"line\">- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//当不再接受音频输入时调用 即开始处理语音识别任务时调用</div><div class=\"line\">- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//当语音识别任务被取消时调用</div><div class=\"line\">- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//语音识别任务完成时被调用</div><div class=\"line\">- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"三：重点代码\"><a href=\"#三：重点代码\" class=\"headerlink\" title=\"三：重点代码\"></a>三：重点代码</h3><p>有两点需要注意：</p>\n<ul>\n<li>语音识别会很耗电以及会使用很多数据</li>\n<li>语音识别一次只持续大概一分钟的时间</li>\n</ul>\n<p>我先定义了这几个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) AVAudioEngine         *audioEngine;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechRecognizer    *speechRecognizer;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechAudioBufferRecognitionRequest     *recognitionRequest;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechRecognitionTask   *recognitionTask;</div><div class=\"line\">@property (nonatomic, strong) NSLocale                  *locale;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>语音权限的判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123;</div><div class=\"line\">        BOOL isAuthorized = NO;</div><div class=\"line\">       switch (status) &#123;</div><div class=\"line\">                //结果未知 用户尚未进行选择</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusNotDetermined:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //用户拒绝授权语音识别</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusDenied:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //设备不支持语音识别功能</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusRestricted:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //用户授权语音识别</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusAuthorized:</div><div class=\"line\">                isAuthorized = YES;</div><div class=\"line\">                </div><div class=\"line\">                break;</div><div class=\"line\">                </div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if (callback) &#123;</div><div class=\"line\">            callback(isAuthorized, status);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n</li>\n<li><p>将语音引擎得到的语音数据添加到语音识别的请求中，这个过程也就是开始录音后的流程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">AVAudioFormat *recordingFormat = [[self.audioEngine inputNode] outputFormatForBus:0];</div><div class=\"line\">    [[self.audioEngine inputNode] installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) &#123;</div><div class=\"line\">        [self.recognitionRequest appendAudioPCMBuffer:buffer];</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>SFSpeechRecognitionTask</code> 把上一过程中得到的语音请求转化成文字，这个过程是试试进行的。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.recognitionTask = [self.speechRecognizer recognitionTaskWithRequest:self.recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123;</div><div class=\"line\">        BOOL isFinal = NO;</div><div class=\"line\">        NSString *bestResult = [[result bestTranscription] formattedString];</div><div class=\"line\">        isFinal = result.isFinal;</div><div class=\"line\">        if (error || isFinal) &#123;</div><div class=\"line\">            [self endTask];</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeFail:)]) &#123;</div><div class=\"line\">                [self.delegate recognizeFail:error];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeSuccess:)]) &#123;</div><div class=\"line\">                [self.delegate recognizeSuccess:bestResult];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<h3 id=\"四：提取录音文件中的文字\"><a href=\"#四：提取录音文件中的文字\" class=\"headerlink\" title=\"四：提取录音文件中的文字\"></a>四：提取录音文件中的文字</h3><ol>\n<li>也需要先获取用户的授权，授权代码与上面一致。</li>\n<li>对文件的处理相对较为简单<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化一个识别器</div><div class=\"line\">SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc] initWithLocale:[NSLocale localeWithLocaleIdentifier:@&quot;zh_CN&quot;]];</div><div class=\"line\">//初始化mp3的url</div><div class=\"line\">NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;test.mp3&quot; withExtension:nil];</div><div class=\"line\">//初始化一个识别的请求</div><div class=\"line\">SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url];</div><div class=\"line\">//发起请求</div><div class=\"line\">[recognizer recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123;</div><div class=\"line\">    if(error != nil)</div><div class=\"line\">    &#123;</div><div class=\"line\">        NSLog(@&quot;识别错误:%@&quot;,error);</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSString *resultString = result.bestTranscription.formattedString;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,resultString);</div><div class=\"line\">    </div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><a href=\"https://github.com/suifengqjn/IOS10Speech\" target=\"_blank\" rel=\"external\">github地址：https://github.com/suifengqjn/IOS10Speech</a></p>\n","excerpt":"<p>公司项目需要实现语音搜索，正好记录一下这个iOS10新出的API。</p>\n<pre><code>iOS10是一个变化比价大的版本，开放了很多接口，这样也更方便开发者自定义各种功能。本文主要讲解一下新增的Speech框架，有了这个框架，我们想要为自己的app增加语音识别功能，不要依赖第三方的服务，几十行代码就可以轻松搞定。demo地址在文章末尾。\n</code></pre><h3 id=\"一：基本配置\"><a href=\"#一：基本配置\" class=\"headerlink\" title=\"一：基本配置\"></a>一：基本配置</h3><ul>\n<li>Xcode8，iOS10系统真机</li>\n<li>导入头文件：OC <code>#import&lt;Speech/Speech.h&gt;</code>   swift <code>import Speech</code></li>\n<li>配置info.plist文件:配置两个权限，语音识别和麦克风</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;</div><div class=\"line\">    &lt;string&gt;Your microphone will be used to record your speech when you press the &quot;Start Recording&quot; button.&lt;/string&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;key&gt;NSSpeechRecognitionUsageDescription&lt;/key&gt;</div><div class=\"line\">    &lt;string&gt;Speech recognition will be used to determine which words you speak into this device&apos;s microphone.&lt;/string&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"二：用到的几个类\"><a href=\"#二：用到的几个类\" class=\"headerlink\" title=\"二：用到的几个类\"></a>二：用到的几个类</h3><p><code>AVAudioEngine</code>                           语音引擎，负责提供语音输入<br><code>SFSpeechAudioBufferRecognitionRequest</code>   处理语音识别请求<br><code>SFSpeechRecognizer</code>                       语音识别器<br><code>SFSpeechRecognitionTask</code>                 输出语音识别对象的结果<br><code>NSLocale</code>                                语言类型<br>语音识别一共就用到了这几个类，整体的流程也容易理解，语音识别器通过语音引擎，处理语音识别请求，把结果交给<code>SFSpeechRecognitionTask</code>处理，最后输出文字。<br><code>SFSpeechRecognizer</code> 自身有几个代理方法，实际上，如果只是将语音转化成文字，是不需要这几个代理方法的。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">//当开始检测音频源中的语音时首先调用此方法</div><div class=\"line\">-(void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div><div class=\"line\">//当识别出一条可用的信息后 会调用</div><div class=\"line\">/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法 */</div><div class=\"line\">-(void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription</div><div class=\"line\">&#123;</div><div class=\"line\">   </div><div class=\"line\">&#125;</div><div class=\"line\">//当识别完成所有可用的结果后调用</div><div class=\"line\">- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//当不再接受音频输入时调用 即开始处理语音识别任务时调用</div><div class=\"line\">- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//当语音识别任务被取消时调用</div><div class=\"line\">- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//语音识别任务完成时被调用</div><div class=\"line\">- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"三：重点代码\"><a href=\"#三：重点代码\" class=\"headerlink\" title=\"三：重点代码\"></a>三：重点代码</h3><p>有两点需要注意：</p>\n<ul>\n<li>语音识别会很耗电以及会使用很多数据</li>\n<li>语音识别一次只持续大概一分钟的时间</li>\n</ul>\n<p>我先定义了这几个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) AVAudioEngine         *audioEngine;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechRecognizer    *speechRecognizer;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechAudioBufferRecognitionRequest     *recognitionRequest;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechRecognitionTask   *recognitionTask;</div><div class=\"line\">@property (nonatomic, strong) NSLocale                  *locale;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>语音权限的判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123;</div><div class=\"line\">        BOOL isAuthorized = NO;</div><div class=\"line\">       switch (status) &#123;</div><div class=\"line\">                //结果未知 用户尚未进行选择</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusNotDetermined:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //用户拒绝授权语音识别</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusDenied:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //设备不支持语音识别功能</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusRestricted:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //用户授权语音识别</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusAuthorized:</div><div class=\"line\">                isAuthorized = YES;</div><div class=\"line\">                </div><div class=\"line\">                break;</div><div class=\"line\">                </div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if (callback) &#123;</div><div class=\"line\">            callback(isAuthorized, status);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n</li>\n<li><p>将语音引擎得到的语音数据添加到语音识别的请求中，这个过程也就是开始录音后的流程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">AVAudioFormat *recordingFormat = [[self.audioEngine inputNode] outputFormatForBus:0];</div><div class=\"line\">    [[self.audioEngine inputNode] installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) &#123;</div><div class=\"line\">        [self.recognitionRequest appendAudioPCMBuffer:buffer];</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>SFSpeechRecognitionTask</code> 把上一过程中得到的语音请求转化成文字，这个过程是试试进行的。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.recognitionTask = [self.speechRecognizer recognitionTaskWithRequest:self.recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123;</div><div class=\"line\">        BOOL isFinal = NO;</div><div class=\"line\">        NSString *bestResult = [[result bestTranscription] formattedString];</div><div class=\"line\">        isFinal = result.isFinal;</div><div class=\"line\">        if (error || isFinal) &#123;</div><div class=\"line\">            [self endTask];</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeFail:)]) &#123;</div><div class=\"line\">                [self.delegate recognizeFail:error];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeSuccess:)]) &#123;</div><div class=\"line\">                [self.delegate recognizeSuccess:bestResult];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<h3 id=\"四：提取录音文件中的文字\"><a href=\"#四：提取录音文件中的文字\" class=\"headerlink\" title=\"四：提取录音文件中的文字\"></a>四：提取录音文件中的文字</h3><ol>\n<li>也需要先获取用户的授权，授权代码与上面一致。</li>\n<li>对文件的处理相对较为简单<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化一个识别器</div><div class=\"line\">SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc] initWithLocale:[NSLocale localeWithLocaleIdentifier:@&quot;zh_CN&quot;]];</div><div class=\"line\">//初始化mp3的url</div><div class=\"line\">NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;test.mp3&quot; withExtension:nil];</div><div class=\"line\">//初始化一个识别的请求</div><div class=\"line\">SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url];</div><div class=\"line\">//发起请求</div><div class=\"line\">[recognizer recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123;</div><div class=\"line\">    if(error != nil)</div><div class=\"line\">    &#123;</div><div class=\"line\">        NSLog(@&quot;识别错误:%@&quot;,error);</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSString *resultString = result.bestTranscription.formattedString;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,resultString);</div><div class=\"line\">    </div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><a href=\"https://github.com/suifengqjn/IOS10Speech\">github地址：https://github.com/suifengqjn/IOS10Speech</a></p>"},{"title":"PhotoBatch-图片去重(3)","date":"2017-12-22T04:36:51.000Z","_content":"\n参考资料：[http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html](http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html)\n\n很多时候，我们的文件夹里会有重复或者相似的图片，这类图片自然没有必要存在多份，我们要做的就是遍历所有图片，然后找出相似的，只保留其中一张即可。\n\n这里的关键技术叫做\"感知哈希算法\"（Perceptual hash algorithm），它的作用是对每张图片生成一个\"指纹\"（fingerprint）字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似。\n\n另外还找到了其他几种方法，这里是地址\n[http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html](http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html)\n\n## 第一步，缩小尺寸。\n将图片缩小到8x8的尺寸，总共64个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。\n在macOS，使用的是`NSImage`, 两者的一些操作很类似。\n```\n- (NSImage *)reSizeImage:(NSImage *)image toSize:(CGSize)reSize\n{\n    NSImage *sourceImage = image;\n    if (![sourceImage isValid]){\n        NSLog(@\"Invalid Image\");\n    } else {\n        NSImage *smallImage = [[NSImage alloc] initWithSize: reSize];\n        [smallImage lockFocus];\n        [sourceImage setSize: reSize];\n        [[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationHigh];\n        [sourceImage drawAtPoint:NSZeroPoint fromRect:CGRectMake(0, 0, reSize.width, reSize.height) operation:NSCompositeCopy fraction:1.0];\n        [smallImage unlockFocus];\n        return smallImage;\n    }\n    return nil;\n}\n```\n <!--more-->\n## 第二步，简化色彩。\n将缩小后的图片，转为64级灰度。也就是说，所有像素点总共只有64种颜色。\n\n## 第三步，计算平均值。\n计算所有64个像素的灰度平均值。\n```\n    a[ArrSize] = 0;\n    b[ArrSize] = 0;\n    CGPoint point;\n    for (i = 0 ; i < cursize; i++) {//计算a的灰度\n        for (j = 0; j < cursize; j++) {\n            point.x = i;\n            point.y = j;\n            grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);\n            a[cursize * i + j] = grey;\n            a[ArrSize] += grey;\n        }\n    }\n    a[ArrSize] /= (ArrSize - 1);//灰度平均值\n    for (i = 0 ; i < cursize; i++) {//计算b的灰度\n        for (j = 0; j < cursize; j++) {\n            point.x = i;\n            point.y = j;\n            grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imgb]]);\n            b[cursize * i + j] = grey;\n            b[ArrSize] += grey;\n        }\n    }\n    b[ArrSize] /= (ArrSize - 1);//灰度平均值\n```\n## 第四步，比较像素的灰度。\n将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为1；小于平均值，记为0。\n```\n a[ArrSize] = 0;\n    b[ArrSize] = 0;\n    CGPoint point;\n    for (i = 0 ; i < cursize; i++) {//计算a的灰度\n        for (j = 0; j < cursize; j++) {\n            point.x = i;\n            point.y = j;\n            grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);\n            a[cursize * i + j] = grey;\n            a[ArrSize] += grey;\n        }\n    }\n```\n\n## 第五步，计算哈希值。\n将上一步的比较结果，组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。\n得到指纹以后，就可以对比不同的图片，看看64位中有多少位是不一样的。在理论上，这等同于计算\"汉明距离\"（Hamming distance）。如果不相同的数据位不超过5，就说明两张图片很相似；如果大于10，就说明这是两张不同的图片。\n\n## 代码实现\n\n上面已经得到了判断两张图片是否相似的方法，而我们要实现的功能是：从一堆图片中找出哪些图片是相似的，并把相似图片放到一起。\n实现逻辑：遍历所有图片，第一张图片先放到第一组中，第二张图片先与第一组中的第一张图片做比较，如果相似，就放到第一组中，否则放到第二组中，以此类推，直到遍历完左右图片，这时候，相似的图片都已经分到各个组中，有一些组中可能只有一张图片，表示没有与之相似大的图片，取出图片个数大于1的组，然后挨个显示这个组中的图片，让用户选择哪些图片该保留。\n\n这是一个比较耗时的操作，所以放在子线程中操作。\n```\n NSMutableArray *totalArr = [NSMutableArray array];\n    \n    __weak __typeof(self)weakSelf = self;\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        \n        for (NSString *filePath in allFiles) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@\"处理文件：%@\", filePath];\n            });\n            if (totalArr.count == 0) {\n                NSMutableArray *arr = [NSMutableArray array];\n                [arr addObject:filePath];\n                [totalArr addObject:arr];\n            } else {\n                \n                NSInteger groupCount = [[totalArr mutableCopy] count];\n                for (int i = 0; i < groupCount; i++) {\n                    NSMutableArray *arr = totalArr[i];\n                    NSImage *imagea = [[NSImage alloc] initWithContentsOfFile:arr.firstObject];\n                    NSImage *imageb = [[NSImage alloc] initWithContentsOfFile:filePath];\n                    Similarity simi = [PHCompare getSimilarityValueWithImgA:imagea ImgB:imageb];\n                    if (simi >= 0.9) { //相似度比较接近\n                        [arr addObject:filePath];\n                        break;\n                    } else {\n                        if (i == [[totalArr mutableCopy] count] - 1) {  //已经遍历到最后一组，还没有找到相似图片，新建一组\n                            NSMutableArray *arr = [NSMutableArray array];\n                            [arr addObject:filePath];\n                            @synchronized(totalArr) {\n                                [totalArr addObject:arr];\n                            }\n                            break;\n                        }\n                    }\n                }\n                \n                \n            }\n        }\n        \n        NSMutableArray *repeatArr = [NSMutableArray new];\n        for (NSArray *arr in totalArr) {\n            if (arr.count > 1) {\n                [repeatArr addObject:arr];\n            }\n        }\n        dispatch_async(dispatch_get_main_queue(), ^{\n            weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@\"处理完成\"];\n            [self.checkRepeatView buildUIWithImageArr:repeatArr];\n        });\n        \n    });\n```\n效果图：\n\n![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3_1.png)\n\n[demo地址:https://github.com/macOSApp/photoBatch](https://github.com/macOSApp/photoBatch)\n\n\n","source":"_posts/PhotoBatch-图片去重-3.md","raw":"---\ntitle: PhotoBatch-图片去重(3)\ndate: 2017-12-22 12:36:51\ntags: [macOS, macOSApp, 图片去重, 图片相似查询]\ncategories:\n- macOS\n---\n\n参考资料：[http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html](http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html)\n\n很多时候，我们的文件夹里会有重复或者相似的图片，这类图片自然没有必要存在多份，我们要做的就是遍历所有图片，然后找出相似的，只保留其中一张即可。\n\n这里的关键技术叫做\"感知哈希算法\"（Perceptual hash algorithm），它的作用是对每张图片生成一个\"指纹\"（fingerprint）字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似。\n\n另外还找到了其他几种方法，这里是地址\n[http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html](http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html)\n\n## 第一步，缩小尺寸。\n将图片缩小到8x8的尺寸，总共64个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。\n在macOS，使用的是`NSImage`, 两者的一些操作很类似。\n```\n- (NSImage *)reSizeImage:(NSImage *)image toSize:(CGSize)reSize\n{\n    NSImage *sourceImage = image;\n    if (![sourceImage isValid]){\n        NSLog(@\"Invalid Image\");\n    } else {\n        NSImage *smallImage = [[NSImage alloc] initWithSize: reSize];\n        [smallImage lockFocus];\n        [sourceImage setSize: reSize];\n        [[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationHigh];\n        [sourceImage drawAtPoint:NSZeroPoint fromRect:CGRectMake(0, 0, reSize.width, reSize.height) operation:NSCompositeCopy fraction:1.0];\n        [smallImage unlockFocus];\n        return smallImage;\n    }\n    return nil;\n}\n```\n <!--more-->\n## 第二步，简化色彩。\n将缩小后的图片，转为64级灰度。也就是说，所有像素点总共只有64种颜色。\n\n## 第三步，计算平均值。\n计算所有64个像素的灰度平均值。\n```\n    a[ArrSize] = 0;\n    b[ArrSize] = 0;\n    CGPoint point;\n    for (i = 0 ; i < cursize; i++) {//计算a的灰度\n        for (j = 0; j < cursize; j++) {\n            point.x = i;\n            point.y = j;\n            grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);\n            a[cursize * i + j] = grey;\n            a[ArrSize] += grey;\n        }\n    }\n    a[ArrSize] /= (ArrSize - 1);//灰度平均值\n    for (i = 0 ; i < cursize; i++) {//计算b的灰度\n        for (j = 0; j < cursize; j++) {\n            point.x = i;\n            point.y = j;\n            grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imgb]]);\n            b[cursize * i + j] = grey;\n            b[ArrSize] += grey;\n        }\n    }\n    b[ArrSize] /= (ArrSize - 1);//灰度平均值\n```\n## 第四步，比较像素的灰度。\n将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为1；小于平均值，记为0。\n```\n a[ArrSize] = 0;\n    b[ArrSize] = 0;\n    CGPoint point;\n    for (i = 0 ; i < cursize; i++) {//计算a的灰度\n        for (j = 0; j < cursize; j++) {\n            point.x = i;\n            point.y = j;\n            grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);\n            a[cursize * i + j] = grey;\n            a[ArrSize] += grey;\n        }\n    }\n```\n\n## 第五步，计算哈希值。\n将上一步的比较结果，组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。\n得到指纹以后，就可以对比不同的图片，看看64位中有多少位是不一样的。在理论上，这等同于计算\"汉明距离\"（Hamming distance）。如果不相同的数据位不超过5，就说明两张图片很相似；如果大于10，就说明这是两张不同的图片。\n\n## 代码实现\n\n上面已经得到了判断两张图片是否相似的方法，而我们要实现的功能是：从一堆图片中找出哪些图片是相似的，并把相似图片放到一起。\n实现逻辑：遍历所有图片，第一张图片先放到第一组中，第二张图片先与第一组中的第一张图片做比较，如果相似，就放到第一组中，否则放到第二组中，以此类推，直到遍历完左右图片，这时候，相似的图片都已经分到各个组中，有一些组中可能只有一张图片，表示没有与之相似大的图片，取出图片个数大于1的组，然后挨个显示这个组中的图片，让用户选择哪些图片该保留。\n\n这是一个比较耗时的操作，所以放在子线程中操作。\n```\n NSMutableArray *totalArr = [NSMutableArray array];\n    \n    __weak __typeof(self)weakSelf = self;\n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        \n        for (NSString *filePath in allFiles) {\n            dispatch_async(dispatch_get_main_queue(), ^{\n                weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@\"处理文件：%@\", filePath];\n            });\n            if (totalArr.count == 0) {\n                NSMutableArray *arr = [NSMutableArray array];\n                [arr addObject:filePath];\n                [totalArr addObject:arr];\n            } else {\n                \n                NSInteger groupCount = [[totalArr mutableCopy] count];\n                for (int i = 0; i < groupCount; i++) {\n                    NSMutableArray *arr = totalArr[i];\n                    NSImage *imagea = [[NSImage alloc] initWithContentsOfFile:arr.firstObject];\n                    NSImage *imageb = [[NSImage alloc] initWithContentsOfFile:filePath];\n                    Similarity simi = [PHCompare getSimilarityValueWithImgA:imagea ImgB:imageb];\n                    if (simi >= 0.9) { //相似度比较接近\n                        [arr addObject:filePath];\n                        break;\n                    } else {\n                        if (i == [[totalArr mutableCopy] count] - 1) {  //已经遍历到最后一组，还没有找到相似图片，新建一组\n                            NSMutableArray *arr = [NSMutableArray array];\n                            [arr addObject:filePath];\n                            @synchronized(totalArr) {\n                                [totalArr addObject:arr];\n                            }\n                            break;\n                        }\n                    }\n                }\n                \n                \n            }\n        }\n        \n        NSMutableArray *repeatArr = [NSMutableArray new];\n        for (NSArray *arr in totalArr) {\n            if (arr.count > 1) {\n                [repeatArr addObject:arr];\n            }\n        }\n        dispatch_async(dispatch_get_main_queue(), ^{\n            weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@\"处理完成\"];\n            [self.checkRepeatView buildUIWithImageArr:repeatArr];\n        });\n        \n    });\n```\n效果图：\n\n![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3_1.png)\n\n[demo地址:https://github.com/macOSApp/photoBatch](https://github.com/macOSApp/photoBatch)\n\n\n","slug":"PhotoBatch-图片去重-3","published":1,"updated":"2017-12-22T06:28:58.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tdf000alx60ebvkp0hh","content":"<p>参考资料：<a href=\"http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html\" target=\"_blank\" rel=\"external\">http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html</a></p>\n<p>很多时候，我们的文件夹里会有重复或者相似的图片，这类图片自然没有必要存在多份，我们要做的就是遍历所有图片，然后找出相似的，只保留其中一张即可。</p>\n<p>这里的关键技术叫做”感知哈希算法”（Perceptual hash algorithm），它的作用是对每张图片生成一个”指纹”（fingerprint）字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似。</p>\n<p>另外还找到了其他几种方法，这里是地址<br><a href=\"http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html</a></p>\n<h2 id=\"第一步，缩小尺寸。\"><a href=\"#第一步，缩小尺寸。\" class=\"headerlink\" title=\"第一步，缩小尺寸。\"></a>第一步，缩小尺寸。</h2><p>将图片缩小到8x8的尺寸，总共64个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。<br>在macOS，使用的是<code>NSImage</code>, 两者的一些操作很类似。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSImage *)reSizeImage:(NSImage *)image toSize:(CGSize)reSize</div><div class=\"line\">&#123;</div><div class=\"line\">    NSImage *sourceImage = image;</div><div class=\"line\">    if (![sourceImage isValid])&#123;</div><div class=\"line\">        NSLog(@&quot;Invalid Image&quot;);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSImage *smallImage = [[NSImage alloc] initWithSize: reSize];</div><div class=\"line\">        [smallImage lockFocus];</div><div class=\"line\">        [sourceImage setSize: reSize];</div><div class=\"line\">        [[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationHigh];</div><div class=\"line\">        [sourceImage drawAtPoint:NSZeroPoint fromRect:CGRectMake(0, 0, reSize.width, reSize.height) operation:NSCompositeCopy fraction:1.0];</div><div class=\"line\">        [smallImage unlockFocus];</div><div class=\"line\">        return smallImage;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n <a id=\"more\"></a>\n<h2 id=\"第二步，简化色彩。\"><a href=\"#第二步，简化色彩。\" class=\"headerlink\" title=\"第二步，简化色彩。\"></a>第二步，简化色彩。</h2><p>将缩小后的图片，转为64级灰度。也就是说，所有像素点总共只有64种颜色。</p>\n<h2 id=\"第三步，计算平均值。\"><a href=\"#第三步，计算平均值。\" class=\"headerlink\" title=\"第三步，计算平均值。\"></a>第三步，计算平均值。</h2><p>计算所有64个像素的灰度平均值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">a[ArrSize] = 0;</div><div class=\"line\">b[ArrSize] = 0;</div><div class=\"line\">CGPoint point;</div><div class=\"line\">for (i = 0 ; i &lt; cursize; i++) &#123;//计算a的灰度</div><div class=\"line\">    for (j = 0; j &lt; cursize; j++) &#123;</div><div class=\"line\">        point.x = i;</div><div class=\"line\">        point.y = j;</div><div class=\"line\">        grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);</div><div class=\"line\">        a[cursize * i + j] = grey;</div><div class=\"line\">        a[ArrSize] += grey;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">a[ArrSize] /= (ArrSize - 1);//灰度平均值</div><div class=\"line\">for (i = 0 ; i &lt; cursize; i++) &#123;//计算b的灰度</div><div class=\"line\">    for (j = 0; j &lt; cursize; j++) &#123;</div><div class=\"line\">        point.x = i;</div><div class=\"line\">        point.y = j;</div><div class=\"line\">        grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imgb]]);</div><div class=\"line\">        b[cursize * i + j] = grey;</div><div class=\"line\">        b[ArrSize] += grey;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">b[ArrSize] /= (ArrSize - 1);//灰度平均值</div></pre></td></tr></table></figure></p>\n<h2 id=\"第四步，比较像素的灰度。\"><a href=\"#第四步，比较像素的灰度。\" class=\"headerlink\" title=\"第四步，比较像素的灰度。\"></a>第四步，比较像素的灰度。</h2><p>将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为1；小于平均值，记为0。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">a[ArrSize] = 0;</div><div class=\"line\">   b[ArrSize] = 0;</div><div class=\"line\">   CGPoint point;</div><div class=\"line\">   for (i = 0 ; i &lt; cursize; i++) &#123;//计算a的灰度</div><div class=\"line\">       for (j = 0; j &lt; cursize; j++) &#123;</div><div class=\"line\">           point.x = i;</div><div class=\"line\">           point.y = j;</div><div class=\"line\">           grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);</div><div class=\"line\">           a[cursize * i + j] = grey;</div><div class=\"line\">           a[ArrSize] += grey;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"第五步，计算哈希值。\"><a href=\"#第五步，计算哈希值。\" class=\"headerlink\" title=\"第五步，计算哈希值。\"></a>第五步，计算哈希值。</h2><p>将上一步的比较结果，组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。<br>得到指纹以后，就可以对比不同的图片，看看64位中有多少位是不一样的。在理论上，这等同于计算”汉明距离”（Hamming distance）。如果不相同的数据位不超过5，就说明两张图片很相似；如果大于10，就说明这是两张不同的图片。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>上面已经得到了判断两张图片是否相似的方法，而我们要实现的功能是：从一堆图片中找出哪些图片是相似的，并把相似图片放到一起。<br>实现逻辑：遍历所有图片，第一张图片先放到第一组中，第二张图片先与第一组中的第一张图片做比较，如果相似，就放到第一组中，否则放到第二组中，以此类推，直到遍历完左右图片，这时候，相似的图片都已经分到各个组中，有一些组中可能只有一张图片，表示没有与之相似大的图片，取出图片个数大于1的组，然后挨个显示这个组中的图片，让用户选择哪些图片该保留。</p>\n<p>这是一个比较耗时的操作，所以放在子线程中操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSMutableArray *totalArr = [NSMutableArray array];</div><div class=\"line\">   </div><div class=\"line\">   __weak __typeof(self)weakSelf = self;</div><div class=\"line\">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">       </div><div class=\"line\">       for (NSString *filePath in allFiles) &#123;</div><div class=\"line\">           dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">               weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@&quot;处理文件：%@&quot;, filePath];</div><div class=\"line\">           &#125;);</div><div class=\"line\">           if (totalArr.count == 0) &#123;</div><div class=\"line\">               NSMutableArray *arr = [NSMutableArray array];</div><div class=\"line\">               [arr addObject:filePath];</div><div class=\"line\">               [totalArr addObject:arr];</div><div class=\"line\">           &#125; else &#123;</div><div class=\"line\">               </div><div class=\"line\">               NSInteger groupCount = [[totalArr mutableCopy] count];</div><div class=\"line\">               for (int i = 0; i &lt; groupCount; i++) &#123;</div><div class=\"line\">                   NSMutableArray *arr = totalArr[i];</div><div class=\"line\">                   NSImage *imagea = [[NSImage alloc] initWithContentsOfFile:arr.firstObject];</div><div class=\"line\">                   NSImage *imageb = [[NSImage alloc] initWithContentsOfFile:filePath];</div><div class=\"line\">                   Similarity simi = [PHCompare getSimilarityValueWithImgA:imagea ImgB:imageb];</div><div class=\"line\">                   if (simi &gt;= 0.9) &#123; //相似度比较接近</div><div class=\"line\">                       [arr addObject:filePath];</div><div class=\"line\">                       break;</div><div class=\"line\">                   &#125; else &#123;</div><div class=\"line\">                       if (i == [[totalArr mutableCopy] count] - 1) &#123;  //已经遍历到最后一组，还没有找到相似图片，新建一组</div><div class=\"line\">                           NSMutableArray *arr = [NSMutableArray array];</div><div class=\"line\">                           [arr addObject:filePath];</div><div class=\"line\">                           @synchronized(totalArr) &#123;</div><div class=\"line\">                               [totalArr addObject:arr];</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\">               </div><div class=\"line\">               </div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       NSMutableArray *repeatArr = [NSMutableArray new];</div><div class=\"line\">       for (NSArray *arr in totalArr) &#123;</div><div class=\"line\">           if (arr.count &gt; 1) &#123;</div><div class=\"line\">               [repeatArr addObject:arr];</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">           weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@&quot;处理完成&quot;];</div><div class=\"line\">           [self.checkRepeatView buildUIWithImageArr:repeatArr];</div><div class=\"line\">       &#125;);</div><div class=\"line\">       </div><div class=\"line\">   &#125;);</div></pre></td></tr></table></figure></p>\n<p>效果图：</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3_1.png\" alt=\"\"></p>\n<p><a href=\"https://github.com/macOSApp/photoBatch\" target=\"_blank\" rel=\"external\">demo地址:https://github.com/macOSApp/photoBatch</a></p>\n","excerpt":"<p>参考资料：<a href=\"http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html\">http://www.hackerfactor.com/blog/index.php?/archives/432-Looks-Like-It.html</a></p>\n<p>很多时候，我们的文件夹里会有重复或者相似的图片，这类图片自然没有必要存在多份，我们要做的就是遍历所有图片，然后找出相似的，只保留其中一张即可。</p>\n<p>这里的关键技术叫做”感知哈希算法”（Perceptual hash algorithm），它的作用是对每张图片生成一个”指纹”（fingerprint）字符串，然后比较不同图片的指纹。结果越接近，就说明图片越相似。</p>\n<p>另外还找到了其他几种方法，这里是地址<br><a href=\"http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html\">http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html</a></p>\n<h2 id=\"第一步，缩小尺寸。\"><a href=\"#第一步，缩小尺寸。\" class=\"headerlink\" title=\"第一步，缩小尺寸。\"></a>第一步，缩小尺寸。</h2><p>将图片缩小到8x8的尺寸，总共64个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。<br>在macOS，使用的是<code>NSImage</code>, 两者的一些操作很类似。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSImage *)reSizeImage:(NSImage *)image toSize:(CGSize)reSize</div><div class=\"line\">&#123;</div><div class=\"line\">    NSImage *sourceImage = image;</div><div class=\"line\">    if (![sourceImage isValid])&#123;</div><div class=\"line\">        NSLog(@&quot;Invalid Image&quot;);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSImage *smallImage = [[NSImage alloc] initWithSize: reSize];</div><div class=\"line\">        [smallImage lockFocus];</div><div class=\"line\">        [sourceImage setSize: reSize];</div><div class=\"line\">        [[NSGraphicsContext currentContext] setImageInterpolation:NSImageInterpolationHigh];</div><div class=\"line\">        [sourceImage drawAtPoint:NSZeroPoint fromRect:CGRectMake(0, 0, reSize.width, reSize.height) operation:NSCompositeCopy fraction:1.0];</div><div class=\"line\">        [smallImage unlockFocus];</div><div class=\"line\">        return smallImage;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>","more":"<h2 id=\"第二步，简化色彩。\"><a href=\"#第二步，简化色彩。\" class=\"headerlink\" title=\"第二步，简化色彩。\"></a>第二步，简化色彩。</h2><p>将缩小后的图片，转为64级灰度。也就是说，所有像素点总共只有64种颜色。</p>\n<h2 id=\"第三步，计算平均值。\"><a href=\"#第三步，计算平均值。\" class=\"headerlink\" title=\"第三步，计算平均值。\"></a>第三步，计算平均值。</h2><p>计算所有64个像素的灰度平均值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">a[ArrSize] = 0;</div><div class=\"line\">b[ArrSize] = 0;</div><div class=\"line\">CGPoint point;</div><div class=\"line\">for (i = 0 ; i &lt; cursize; i++) &#123;//计算a的灰度</div><div class=\"line\">    for (j = 0; j &lt; cursize; j++) &#123;</div><div class=\"line\">        point.x = i;</div><div class=\"line\">        point.y = j;</div><div class=\"line\">        grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);</div><div class=\"line\">        a[cursize * i + j] = grey;</div><div class=\"line\">        a[ArrSize] += grey;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">a[ArrSize] /= (ArrSize - 1);//灰度平均值</div><div class=\"line\">for (i = 0 ; i &lt; cursize; i++) &#123;//计算b的灰度</div><div class=\"line\">    for (j = 0; j &lt; cursize; j++) &#123;</div><div class=\"line\">        point.x = i;</div><div class=\"line\">        point.y = j;</div><div class=\"line\">        grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imgb]]);</div><div class=\"line\">        b[cursize * i + j] = grey;</div><div class=\"line\">        b[ArrSize] += grey;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">b[ArrSize] /= (ArrSize - 1);//灰度平均值</div></pre></td></tr></table></figure></p>\n<h2 id=\"第四步，比较像素的灰度。\"><a href=\"#第四步，比较像素的灰度。\" class=\"headerlink\" title=\"第四步，比较像素的灰度。\"></a>第四步，比较像素的灰度。</h2><p>将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为1；小于平均值，记为0。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">a[ArrSize] = 0;</div><div class=\"line\">   b[ArrSize] = 0;</div><div class=\"line\">   CGPoint point;</div><div class=\"line\">   for (i = 0 ; i &lt; cursize; i++) &#123;//计算a的灰度</div><div class=\"line\">       for (j = 0; j &lt; cursize; j++) &#123;</div><div class=\"line\">           point.x = i;</div><div class=\"line\">           point.y = j;</div><div class=\"line\">           grey = ToGrey([self NSColorToRGB:[self colorAtPixel:point img:imga]]);</div><div class=\"line\">           a[cursize * i + j] = grey;</div><div class=\"line\">           a[ArrSize] += grey;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"第五步，计算哈希值。\"><a href=\"#第五步，计算哈希值。\" class=\"headerlink\" title=\"第五步，计算哈希值。\"></a>第五步，计算哈希值。</h2><p>将上一步的比较结果，组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。<br>得到指纹以后，就可以对比不同的图片，看看64位中有多少位是不一样的。在理论上，这等同于计算”汉明距离”（Hamming distance）。如果不相同的数据位不超过5，就说明两张图片很相似；如果大于10，就说明这是两张不同的图片。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>上面已经得到了判断两张图片是否相似的方法，而我们要实现的功能是：从一堆图片中找出哪些图片是相似的，并把相似图片放到一起。<br>实现逻辑：遍历所有图片，第一张图片先放到第一组中，第二张图片先与第一组中的第一张图片做比较，如果相似，就放到第一组中，否则放到第二组中，以此类推，直到遍历完左右图片，这时候，相似的图片都已经分到各个组中，有一些组中可能只有一张图片，表示没有与之相似大的图片，取出图片个数大于1的组，然后挨个显示这个组中的图片，让用户选择哪些图片该保留。</p>\n<p>这是一个比较耗时的操作，所以放在子线程中操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSMutableArray *totalArr = [NSMutableArray array];</div><div class=\"line\">   </div><div class=\"line\">   __weak __typeof(self)weakSelf = self;</div><div class=\"line\">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">       </div><div class=\"line\">       for (NSString *filePath in allFiles) &#123;</div><div class=\"line\">           dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">               weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@&quot;处理文件：%@&quot;, filePath];</div><div class=\"line\">           &#125;);</div><div class=\"line\">           if (totalArr.count == 0) &#123;</div><div class=\"line\">               NSMutableArray *arr = [NSMutableArray array];</div><div class=\"line\">               [arr addObject:filePath];</div><div class=\"line\">               [totalArr addObject:arr];</div><div class=\"line\">           &#125; else &#123;</div><div class=\"line\">               </div><div class=\"line\">               NSInteger groupCount = [[totalArr mutableCopy] count];</div><div class=\"line\">               for (int i = 0; i &lt; groupCount; i++) &#123;</div><div class=\"line\">                   NSMutableArray *arr = totalArr[i];</div><div class=\"line\">                   NSImage *imagea = [[NSImage alloc] initWithContentsOfFile:arr.firstObject];</div><div class=\"line\">                   NSImage *imageb = [[NSImage alloc] initWithContentsOfFile:filePath];</div><div class=\"line\">                   Similarity simi = [PHCompare getSimilarityValueWithImgA:imagea ImgB:imageb];</div><div class=\"line\">                   if (simi &gt;= 0.9) &#123; //相似度比较接近</div><div class=\"line\">                       [arr addObject:filePath];</div><div class=\"line\">                       break;</div><div class=\"line\">                   &#125; else &#123;</div><div class=\"line\">                       if (i == [[totalArr mutableCopy] count] - 1) &#123;  //已经遍历到最后一组，还没有找到相似图片，新建一组</div><div class=\"line\">                           NSMutableArray *arr = [NSMutableArray array];</div><div class=\"line\">                           [arr addObject:filePath];</div><div class=\"line\">                           @synchronized(totalArr) &#123;</div><div class=\"line\">                               [totalArr addObject:arr];</div><div class=\"line\">                           &#125;</div><div class=\"line\">                           break;</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;</div><div class=\"line\">               </div><div class=\"line\">               </div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       NSMutableArray *repeatArr = [NSMutableArray new];</div><div class=\"line\">       for (NSArray *arr in totalArr) &#123;</div><div class=\"line\">           if (arr.count &gt; 1) &#123;</div><div class=\"line\">               [repeatArr addObject:arr];</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">           weakSelf.dealingLabel.stringValue = [NSString stringWithFormat:@&quot;处理完成&quot;];</div><div class=\"line\">           [self.checkRepeatView buildUIWithImageArr:repeatArr];</div><div class=\"line\">       &#125;);</div><div class=\"line\">       </div><div class=\"line\">   &#125;);</div></pre></td></tr></table></figure></p>\n<p>效果图：</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3_1.png\" alt=\"\"></p>\n<p><a href=\"https://github.com/macOSApp/photoBatch\">demo地址:https://github.com/macOSApp/photoBatch</a></p>"},{"title":"PhotoBatch-文件操作(1)","date":"2017-11-26T08:02:41.000Z","_content":"\n最近开始自学mac app开发，网上资料很少，大致看了一下官方文档，mac开发主要框架就是AppKit，我有几年iOS的开发经验，在加上官方文档和网上一些零碎的资料，慢慢学习应该是问题不大。准备自己动手制作一个批量图片处理软件，记录一下自己的学习过程，一方面帮助自己对学到知识的整理，也可以给学习macOS的人一些参考。\n\n### 文件拖拽\n\n* 需要实现的效果：将文件或者文件夹拖到到我们的app内，获得其绝对路径\n\n#### 新建 macOS 工程\n\n跟新建iOS项目工程几乎一致。\n\n![新建工程](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/1.png)\n<!--more-->\n#### 自定义PBDragView\n\n在iOS中，最核心的的框架就是`Foundation`和`UIKit`, 在macOS中，就是`Foundation`和`AppKit`, 对于iOS中大部分控件，都是把前缀又`UI`换成了`NS`, 他们看上去很类似，但是使用的时候在很多细节上却又大不相同，这里推荐一篇博客[从 UIKit 到 AppKit(https://www.objccn.io/issue-14-5)](https://www.objccn.io/issue-14-5), 讲述了这两个框架的一些异同。\n\n我们需要自定义一个 `PBDragView` 继承自`NSView`，然后当有文件或者文件夹拖动到这个View中的时候，在内部实现文件拖入拖出等方法。\n\n#### 注册支持的文件类型\n\n```\n- (void)awakeFromNib\n{\n    [super awakeFromNib];\n    // 设置支持的文件类型\n    [self registerForDraggedTypes:@[NSPasteboardTypePDF, NSPasteboardTypePNG, NSPasteboardTypeURL, NSPasteboardTypeFileURL]];\n}\n``` \n\n#### 实现文件拖动的几个方法\n\n```\n\n- (NSDragOperation)draggingEntered:(id<NSDraggingInfo>)sender\n{\n    if (self.delegate && [self.delegate respondsToSelector:@selector(dragEnter)]) {\n        [self.delegate dragEnter];\n    }\n    \n    return NSDragOperationGeneric;\n}\n\n- (void)draggingExited:(id<NSDraggingInfo>)sender\n{\n    if (self.delegate && [self.delegate respondsToSelector:@selector(dragExit)]) {\n        [self.delegate dragExit];\n    }\n}\n\n- (BOOL)performDragOperation:(id<NSDraggingInfo>)sender\n{\n    // 获取所有的路径\n    NSArray *arr =  [[sender draggingPasteboard] propertyListForType:NSFilenamesPboardType];\n    if (self.delegate && arr.count > 0 && [self.delegate respondsToSelector:@selector(dragFileComplete:)]) {\n        [self.delegate dragFileComplete:arr];\n    }\n    return YES;\n}\n```\n#### 在SB中使用PBDragView\n\n![sb的效果图](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2.png)\n\n运行程序，将文件或者文件夹拖入整个app界面，就可以获取到所有的文件路径。\n\n\n### 文件选择\n\n* 需要实现的效果：点击按钮，弹出文件选择框，可以选择文件或者文件夹\n\n#### 添加点击按钮\n\n在SB中添加按钮，然后添加点击事件\n![添加按钮](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3.png)\n\n\n#### 文件选择功能实现\n\n```\n    NSOpenPanel *openPanel = [NSOpenPanel openPanel];\n    [openPanel setPrompt: @\"打开\"];\n    [openPanel setCanChooseDirectories:YES]; //设置允许打开文件夹\n    [openPanel setAllowsMultipleSelection:YES]; // 会否允许打开多个目录\n    [openPanel setCanChooseFiles:YES];  //设置允许打开文件\n    [openPanel setCanCreateDirectories:YES]; // 允许新建文件夹\n    [openPanel setCanDownloadUbiquitousContents:NO]; //是否处理还未下载成功的文档\n    [openPanel setCanResolveUbiquitousConflicts:NO]; //是否处理有冲突的文档\n    openPanel.allowedFileTypes = [NSArray arrayWithObjects: @\"jpg\", @\"doc\",@\"txt\",@\"jpeg\",@\"png\",@\"tiff\", nil]; //设置允许打开的文件类型\n    [openPanel beginSheetModalForWindow:[NSApplication sharedApplication].keyWindow completionHandler:^(NSModalResponse result) {\n        \n        NSArray *filePaths = [openPanel URLs];\n        NSLog(@\"-----%@\", filePaths);\n        \n    }];\n```\n效果图：\n![弹出系统的文件选择框](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/4.png)\n\n[demo地址:https://github.com/macOSApp/photoBatch](https://github.com/macOSApp/photoBatch)\n\n\n","source":"_posts/PhotoBatch-文件操作-1.md","raw":"---\ntitle: PhotoBatch-文件操作(1)\ndate: 2017-11-26 16:02:41\ntags: [macOS, macOSApp, 文件处理]\ncategories:\n- macOS\n---\n\n最近开始自学mac app开发，网上资料很少，大致看了一下官方文档，mac开发主要框架就是AppKit，我有几年iOS的开发经验，在加上官方文档和网上一些零碎的资料，慢慢学习应该是问题不大。准备自己动手制作一个批量图片处理软件，记录一下自己的学习过程，一方面帮助自己对学到知识的整理，也可以给学习macOS的人一些参考。\n\n### 文件拖拽\n\n* 需要实现的效果：将文件或者文件夹拖到到我们的app内，获得其绝对路径\n\n#### 新建 macOS 工程\n\n跟新建iOS项目工程几乎一致。\n\n![新建工程](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/1.png)\n<!--more-->\n#### 自定义PBDragView\n\n在iOS中，最核心的的框架就是`Foundation`和`UIKit`, 在macOS中，就是`Foundation`和`AppKit`, 对于iOS中大部分控件，都是把前缀又`UI`换成了`NS`, 他们看上去很类似，但是使用的时候在很多细节上却又大不相同，这里推荐一篇博客[从 UIKit 到 AppKit(https://www.objccn.io/issue-14-5)](https://www.objccn.io/issue-14-5), 讲述了这两个框架的一些异同。\n\n我们需要自定义一个 `PBDragView` 继承自`NSView`，然后当有文件或者文件夹拖动到这个View中的时候，在内部实现文件拖入拖出等方法。\n\n#### 注册支持的文件类型\n\n```\n- (void)awakeFromNib\n{\n    [super awakeFromNib];\n    // 设置支持的文件类型\n    [self registerForDraggedTypes:@[NSPasteboardTypePDF, NSPasteboardTypePNG, NSPasteboardTypeURL, NSPasteboardTypeFileURL]];\n}\n``` \n\n#### 实现文件拖动的几个方法\n\n```\n\n- (NSDragOperation)draggingEntered:(id<NSDraggingInfo>)sender\n{\n    if (self.delegate && [self.delegate respondsToSelector:@selector(dragEnter)]) {\n        [self.delegate dragEnter];\n    }\n    \n    return NSDragOperationGeneric;\n}\n\n- (void)draggingExited:(id<NSDraggingInfo>)sender\n{\n    if (self.delegate && [self.delegate respondsToSelector:@selector(dragExit)]) {\n        [self.delegate dragExit];\n    }\n}\n\n- (BOOL)performDragOperation:(id<NSDraggingInfo>)sender\n{\n    // 获取所有的路径\n    NSArray *arr =  [[sender draggingPasteboard] propertyListForType:NSFilenamesPboardType];\n    if (self.delegate && arr.count > 0 && [self.delegate respondsToSelector:@selector(dragFileComplete:)]) {\n        [self.delegate dragFileComplete:arr];\n    }\n    return YES;\n}\n```\n#### 在SB中使用PBDragView\n\n![sb的效果图](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2.png)\n\n运行程序，将文件或者文件夹拖入整个app界面，就可以获取到所有的文件路径。\n\n\n### 文件选择\n\n* 需要实现的效果：点击按钮，弹出文件选择框，可以选择文件或者文件夹\n\n#### 添加点击按钮\n\n在SB中添加按钮，然后添加点击事件\n![添加按钮](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3.png)\n\n\n#### 文件选择功能实现\n\n```\n    NSOpenPanel *openPanel = [NSOpenPanel openPanel];\n    [openPanel setPrompt: @\"打开\"];\n    [openPanel setCanChooseDirectories:YES]; //设置允许打开文件夹\n    [openPanel setAllowsMultipleSelection:YES]; // 会否允许打开多个目录\n    [openPanel setCanChooseFiles:YES];  //设置允许打开文件\n    [openPanel setCanCreateDirectories:YES]; // 允许新建文件夹\n    [openPanel setCanDownloadUbiquitousContents:NO]; //是否处理还未下载成功的文档\n    [openPanel setCanResolveUbiquitousConflicts:NO]; //是否处理有冲突的文档\n    openPanel.allowedFileTypes = [NSArray arrayWithObjects: @\"jpg\", @\"doc\",@\"txt\",@\"jpeg\",@\"png\",@\"tiff\", nil]; //设置允许打开的文件类型\n    [openPanel beginSheetModalForWindow:[NSApplication sharedApplication].keyWindow completionHandler:^(NSModalResponse result) {\n        \n        NSArray *filePaths = [openPanel URLs];\n        NSLog(@\"-----%@\", filePaths);\n        \n    }];\n```\n效果图：\n![弹出系统的文件选择框](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/4.png)\n\n[demo地址:https://github.com/macOSApp/photoBatch](https://github.com/macOSApp/photoBatch)\n\n\n","slug":"PhotoBatch-文件操作-1","published":1,"updated":"2017-11-26T08:08:50.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tdh000dlx60zxys0fmr","content":"<p>最近开始自学mac app开发，网上资料很少，大致看了一下官方文档，mac开发主要框架就是AppKit，我有几年iOS的开发经验，在加上官方文档和网上一些零碎的资料，慢慢学习应该是问题不大。准备自己动手制作一个批量图片处理软件，记录一下自己的学习过程，一方面帮助自己对学到知识的整理，也可以给学习macOS的人一些参考。</p>\n<h3 id=\"文件拖拽\"><a href=\"#文件拖拽\" class=\"headerlink\" title=\"文件拖拽\"></a>文件拖拽</h3><ul>\n<li>需要实现的效果：将文件或者文件夹拖到到我们的app内，获得其绝对路径</li>\n</ul>\n<h4 id=\"新建-macOS-工程\"><a href=\"#新建-macOS-工程\" class=\"headerlink\" title=\"新建 macOS 工程\"></a>新建 macOS 工程</h4><p>跟新建iOS项目工程几乎一致。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/1.png\" alt=\"新建工程\"><br><a id=\"more\"></a></p>\n<h4 id=\"自定义PBDragView\"><a href=\"#自定义PBDragView\" class=\"headerlink\" title=\"自定义PBDragView\"></a>自定义PBDragView</h4><p>在iOS中，最核心的的框架就是<code>Foundation</code>和<code>UIKit</code>, 在macOS中，就是<code>Foundation</code>和<code>AppKit</code>, 对于iOS中大部分控件，都是把前缀又<code>UI</code>换成了<code>NS</code>, 他们看上去很类似，但是使用的时候在很多细节上却又大不相同，这里推荐一篇博客<a href=\"https://www.objccn.io/issue-14-5\" target=\"_blank\" rel=\"external\">从 UIKit 到 AppKit(https://www.objccn.io/issue-14-5)</a>, 讲述了这两个框架的一些异同。</p>\n<p>我们需要自定义一个 <code>PBDragView</code> 继承自<code>NSView</code>，然后当有文件或者文件夹拖动到这个View中的时候，在内部实现文件拖入拖出等方法。</p>\n<h4 id=\"注册支持的文件类型\"><a href=\"#注册支持的文件类型\" class=\"headerlink\" title=\"注册支持的文件类型\"></a>注册支持的文件类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)awakeFromNib</div><div class=\"line\">&#123;</div><div class=\"line\">    [super awakeFromNib];</div><div class=\"line\">    // 设置支持的文件类型</div><div class=\"line\">    [self registerForDraggedTypes:@[NSPasteboardTypePDF, NSPasteboardTypePNG, NSPasteboardTypeURL, NSPasteboardTypeFileURL]];</div><div class=\"line\">&#125;</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">#### 实现文件拖动的几个方法</div></pre></td></tr></table></figure>\n<ul>\n<li><p>(NSDragOperation)draggingEntered:(id<nsdragginginfo>)sender<br>{<br>  if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dragEnter)]) {</nsdragginginfo></p>\n<pre><code>[self.delegate dragEnter];\n</code></pre><p>  }</p>\n<p>  return NSDragOperationGeneric;<br>}</p>\n</li>\n<li><p>(void)draggingExited:(id<nsdragginginfo>)sender<br>{<br>  if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dragExit)]) {</nsdragginginfo></p>\n<pre><code>[self.delegate dragExit];\n</code></pre><p>  }<br>}</p>\n</li>\n<li><p>(BOOL)performDragOperation:(id<nsdragginginfo>)sender<br>{<br>  // 获取所有的路径<br>  NSArray *arr =  [[sender draggingPasteboard] propertyListForType:NSFilenamesPboardType];<br>  if (self.delegate &amp;&amp; arr.count &gt; 0 &amp;&amp; [self.delegate respondsToSelector:@selector(dragFileComplete:)]) {</nsdragginginfo></p>\n<pre><code>[self.delegate dragFileComplete:arr];\n</code></pre><p>  }<br>  return YES;<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 在SB中使用PBDragView</div><div class=\"line\"></div><div class=\"line\">![sb的效果图](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2.png)</div><div class=\"line\"></div><div class=\"line\">运行程序，将文件或者文件夹拖入整个app界面，就可以获取到所有的文件路径。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 文件选择</div><div class=\"line\"></div><div class=\"line\">* 需要实现的效果：点击按钮，弹出文件选择框，可以选择文件或者文件夹</div><div class=\"line\"></div><div class=\"line\">#### 添加点击按钮</div><div class=\"line\"></div><div class=\"line\">在SB中添加按钮，然后添加点击事件</div><div class=\"line\">![添加按钮](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3.png)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 文件选择功能实现</div></pre></td></tr></table></figure>\n<p>  NSOpenPanel *openPanel = [NSOpenPanel openPanel];<br>  [openPanel setPrompt: @”打开”];<br>  [openPanel setCanChooseDirectories:YES]; //设置允许打开文件夹<br>  [openPanel setAllowsMultipleSelection:YES]; // 会否允许打开多个目录<br>  [openPanel setCanChooseFiles:YES];  //设置允许打开文件<br>  [openPanel setCanCreateDirectories:YES]; // 允许新建文件夹<br>  [openPanel setCanDownloadUbiquitousContents:NO]; //是否处理还未下载成功的文档<br>  [openPanel setCanResolveUbiquitousConflicts:NO]; //是否处理有冲突的文档<br>  openPanel.allowedFileTypes = [NSArray arrayWithObjects: @”jpg”, @”doc”,@”txt”,@”jpeg”,@”png”,@”tiff”, nil]; //设置允许打开的文件类型<br>  [openPanel beginSheetModalForWindow:[NSApplication sharedApplication].keyWindow completionHandler:^(NSModalResponse result) {</p>\n<pre><code>NSArray *filePaths = [openPanel URLs];\nNSLog(@&quot;-----%@&quot;, filePaths);\n</code></pre><p>  }];<br>```<br>效果图：<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/4.png\" alt=\"弹出系统的文件选择框\"></p>\n</li>\n</ul>\n<p><a href=\"https://github.com/macOSApp/photoBatch\" target=\"_blank\" rel=\"external\">demo地址:https://github.com/macOSApp/photoBatch</a></p>\n","excerpt":"<p>最近开始自学mac app开发，网上资料很少，大致看了一下官方文档，mac开发主要框架就是AppKit，我有几年iOS的开发经验，在加上官方文档和网上一些零碎的资料，慢慢学习应该是问题不大。准备自己动手制作一个批量图片处理软件，记录一下自己的学习过程，一方面帮助自己对学到知识的整理，也可以给学习macOS的人一些参考。</p>\n<h3 id=\"文件拖拽\"><a href=\"#文件拖拽\" class=\"headerlink\" title=\"文件拖拽\"></a>文件拖拽</h3><ul>\n<li>需要实现的效果：将文件或者文件夹拖到到我们的app内，获得其绝对路径</li>\n</ul>\n<h4 id=\"新建-macOS-工程\"><a href=\"#新建-macOS-工程\" class=\"headerlink\" title=\"新建 macOS 工程\"></a>新建 macOS 工程</h4><p>跟新建iOS项目工程几乎一致。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/1.png\" alt=\"新建工程\"><br>","more":"</p>\n<h4 id=\"自定义PBDragView\"><a href=\"#自定义PBDragView\" class=\"headerlink\" title=\"自定义PBDragView\"></a>自定义PBDragView</h4><p>在iOS中，最核心的的框架就是<code>Foundation</code>和<code>UIKit</code>, 在macOS中，就是<code>Foundation</code>和<code>AppKit</code>, 对于iOS中大部分控件，都是把前缀又<code>UI</code>换成了<code>NS</code>, 他们看上去很类似，但是使用的时候在很多细节上却又大不相同，这里推荐一篇博客<a href=\"https://www.objccn.io/issue-14-5\">从 UIKit 到 AppKit(https://www.objccn.io/issue-14-5)</a>, 讲述了这两个框架的一些异同。</p>\n<p>我们需要自定义一个 <code>PBDragView</code> 继承自<code>NSView</code>，然后当有文件或者文件夹拖动到这个View中的时候，在内部实现文件拖入拖出等方法。</p>\n<h4 id=\"注册支持的文件类型\"><a href=\"#注册支持的文件类型\" class=\"headerlink\" title=\"注册支持的文件类型\"></a>注册支持的文件类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)awakeFromNib</div><div class=\"line\">&#123;</div><div class=\"line\">    [super awakeFromNib];</div><div class=\"line\">    // 设置支持的文件类型</div><div class=\"line\">    [self registerForDraggedTypes:@[NSPasteboardTypePDF, NSPasteboardTypePNG, NSPasteboardTypeURL, NSPasteboardTypeFileURL]];</div><div class=\"line\">&#125;</div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">#### 实现文件拖动的几个方法</div></pre></td></tr></table></figure>\n<ul>\n<li><p>(NSDragOperation)draggingEntered:(id<NSDraggingInfo>)sender<br>{<br>  if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dragEnter)]) {</p>\n<pre><code>[self.delegate dragEnter];\n</code></pre><p>  }</p>\n<p>  return NSDragOperationGeneric;<br>}</p>\n</li>\n<li><p>(void)draggingExited:(id<NSDraggingInfo>)sender<br>{<br>  if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(dragExit)]) {</p>\n<pre><code>[self.delegate dragExit];\n</code></pre><p>  }<br>}</p>\n</li>\n<li><p>(BOOL)performDragOperation:(id<NSDraggingInfo>)sender<br>{<br>  // 获取所有的路径<br>  NSArray *arr =  [[sender draggingPasteboard] propertyListForType:NSFilenamesPboardType];<br>  if (self.delegate &amp;&amp; arr.count &gt; 0 &amp;&amp; [self.delegate respondsToSelector:@selector(dragFileComplete:)]) {</p>\n<pre><code>[self.delegate dragFileComplete:arr];\n</code></pre><p>  }<br>  return YES;<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 在SB中使用PBDragView</div><div class=\"line\"></div><div class=\"line\">![sb的效果图](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2.png)</div><div class=\"line\"></div><div class=\"line\">运行程序，将文件或者文件夹拖入整个app界面，就可以获取到所有的文件路径。</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### 文件选择</div><div class=\"line\"></div><div class=\"line\">* 需要实现的效果：点击按钮，弹出文件选择框，可以选择文件或者文件夹</div><div class=\"line\"></div><div class=\"line\">#### 添加点击按钮</div><div class=\"line\"></div><div class=\"line\">在SB中添加按钮，然后添加点击事件</div><div class=\"line\">![添加按钮](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/3.png)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#### 文件选择功能实现</div></pre></td></tr></table></figure>\n<p>  NSOpenPanel *openPanel = [NSOpenPanel openPanel];<br>  [openPanel setPrompt: @”打开”];<br>  [openPanel setCanChooseDirectories:YES]; //设置允许打开文件夹<br>  [openPanel setAllowsMultipleSelection:YES]; // 会否允许打开多个目录<br>  [openPanel setCanChooseFiles:YES];  //设置允许打开文件<br>  [openPanel setCanCreateDirectories:YES]; // 允许新建文件夹<br>  [openPanel setCanDownloadUbiquitousContents:NO]; //是否处理还未下载成功的文档<br>  [openPanel setCanResolveUbiquitousConflicts:NO]; //是否处理有冲突的文档<br>  openPanel.allowedFileTypes = [NSArray arrayWithObjects: @”jpg”, @”doc”,@”txt”,@”jpeg”,@”png”,@”tiff”, nil]; //设置允许打开的文件类型<br>  [openPanel beginSheetModalForWindow:[NSApplication sharedApplication].keyWindow completionHandler:^(NSModalResponse result) {</p>\n<pre><code>NSArray *filePaths = [openPanel URLs];\nNSLog(@&quot;-----%@&quot;, filePaths);\n</code></pre><p>  }];<br>```<br>效果图：<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/4.png\" alt=\"弹出系统的文件选择框\"></p>\n</li>\n</ul>\n<p><a href=\"https://github.com/macOSApp/photoBatch\">demo地址:https://github.com/macOSApp/photoBatch</a></p>"},{"title":"PhotoBatch-文件重命名(2)","date":"2017-12-04T08:50:20.000Z","_content":"\n上一篇文章已经写了如何获取文件夹路径，今天实现photoBatch的第一个简单功能，图片批量重命名，当然也可以对任何文件进行重命名\n\n### 搭建界面\n\n搭了个简单的界面，如下图：\n![布局用了purelayout框架](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2_1.png)\n我们需要得到重命名后的文件名前缀，以及文件格式和是否保留原文件，给这3个变量一个默认值。\n\n### 文件夹处理\n\n获取到文件路径后处理：需要对每个文件的路径进行处理，如果是以\n`file://`开头，需要把前面的`file://`去掉，这种地址无法处理。这里是对文件夹路径的处理，处理完的路径再加上文件名就是完整的路径。\n\n<!--more-->\n\n```\n- (void)dealFiles:(NSArray *)filepaths\n{\n    self.dealingLabel.stringValue = [filepaths.firstObject description];\n    \n    NSMutableArray *arr = [NSMutableArray new];\n    // 对文件夹路径进行处理\n    for (NSString *path in filepaths) {\n        if ([[path description] hasPrefix:@\"file:///\"]) {\n            NSString *newpath = [[path description] substringFromIndex:7];\n            if ([newpath hasSuffix:@\"/\"]) {\n                newpath  = [newpath substringToIndex:newpath.length - 1];\n            }\n            [arr addObject:newpath];\n            \n        } else {\n            if ([[path description] hasSuffix:@\"/\"]) {\n                NSString *tempStr = [path description];\n                [arr addObject:[tempStr substringToIndex:tempStr.length - 1]];\n            } else {\n                [arr addObject:[path description]];\n            }\n            \n        }\n    }\n    \n    self.folderPaths = filepaths;\n    \n    NSMutableArray *allFiles = [NSMutableArray new];\n    for (NSString *docuPath in self.folderPaths) { // 遍历所有文件夹 获取所有文件个数\n        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名\n        [allFiles addObjectsFromArray:files];\n    }\n\n    NSAlert *alert = [[NSAlert alloc] init];\n    [alert setMessageText:@\"文件获取成功\"];\n    [alert setInformativeText:[NSString stringWithFormat:@\"文件总数：%ld 个\", allFiles.count]];\n    [alert beginSheetModalForWindow:self.view.window completionHandler:^(NSModalResponse returnCode) {\n    }];\n}\n```\n\n### 文件批量重命名\n\n遍历所有文件夹下所有文件，`NSFileManager` 并没有重命名的方法，如果要保留原文件，则执行`copy`操作，如果不保留原文件，则执行`move`操作。下面是重命名代码的实现。\n\n```\n- (IBAction)StartAction:(NSButton *)sender {\n    \n    \n    NSMutableArray *allFiles = [NSMutableArray new];\n    for (NSString *docuPath in self.folderPaths) {\n        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名\n        for (NSString *filename in files) {\n            [allFiles addObject:[NSString stringWithFormat:@\"%@/%@\", docuPath, filename]];\n        }\n    }\n    if (allFiles.count == 0) {\n        return;\n    }\n    NSString *resultFilePath = [NSString stringWithFormat:@\"%@/%@\", self.folderPaths.firstObject, @\"result\"];\n    \n    NSError *err = nil;\n    [XCFileManager createDirectoryAtPath:resultFilePath error:&err];\n    NSString *prefixName = _reNameView.prefixInput.stringValue;\n    if (!prefixName || prefixName.length == 0) {\n        prefixName = @\"img_\";\n    }\n    NSString *suffixName = _reNameView.suffixInput.stringValue;\n    if(!suffixName || suffixName.length == 0) {\n        suffixName = @\"\";\n    }\n    NSInteger index = 1;\n    NSString *suffix = @\"\";\n    for (NSString *path in allFiles) {\n//        // 如果遇到 没有文件名的文件，直接过滤\n        if ([path componentsSeparatedByString:@\".\"].count < 2) {\n            continue;\n        }\n        if (suffixName.length == 0) {\n            suffix = [[path componentsSeparatedByString:@\".\"].lastObject description];\n        } else {\n            suffix = suffixName;\n        }\n        self.dealingLabel.stringValue = [path description];\n        \n        NSString *movePath = [NSString stringWithFormat:@\"%@/%@%ld.%@\", resultFilePath, prefixName, index,suffix];\n        if (_reNameView.checkSaveBtn.state == 1) {\n           [XCFileManager moveItemAtPath:path toPath:movePath overwrite:NO];\n        } else {\n            [XCFileManager moveItemAtPath:path toPath:movePath overwrite:YES];\n        }\n        \n        index ++;\n    }\n    \n    self.dealingLabel.stringValue = @\"处理完成\";\n    \n}\n```\n[demo地址:https://github.com/macOSApp/photoBatch](https://github.com/macOSApp/photoBatch)\n\n\n","source":"_posts/PhotoBatch-文件重命名-2.md","raw":"---\ntitle: PhotoBatch-文件重命名(2)\ndate: 2017-12-04 16:50:20\ntags: [macOS, macOSApp, 文件重命名]\ncategories:\n- macOS\n---\n\n上一篇文章已经写了如何获取文件夹路径，今天实现photoBatch的第一个简单功能，图片批量重命名，当然也可以对任何文件进行重命名\n\n### 搭建界面\n\n搭了个简单的界面，如下图：\n![布局用了purelayout框架](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2_1.png)\n我们需要得到重命名后的文件名前缀，以及文件格式和是否保留原文件，给这3个变量一个默认值。\n\n### 文件夹处理\n\n获取到文件路径后处理：需要对每个文件的路径进行处理，如果是以\n`file://`开头，需要把前面的`file://`去掉，这种地址无法处理。这里是对文件夹路径的处理，处理完的路径再加上文件名就是完整的路径。\n\n<!--more-->\n\n```\n- (void)dealFiles:(NSArray *)filepaths\n{\n    self.dealingLabel.stringValue = [filepaths.firstObject description];\n    \n    NSMutableArray *arr = [NSMutableArray new];\n    // 对文件夹路径进行处理\n    for (NSString *path in filepaths) {\n        if ([[path description] hasPrefix:@\"file:///\"]) {\n            NSString *newpath = [[path description] substringFromIndex:7];\n            if ([newpath hasSuffix:@\"/\"]) {\n                newpath  = [newpath substringToIndex:newpath.length - 1];\n            }\n            [arr addObject:newpath];\n            \n        } else {\n            if ([[path description] hasSuffix:@\"/\"]) {\n                NSString *tempStr = [path description];\n                [arr addObject:[tempStr substringToIndex:tempStr.length - 1]];\n            } else {\n                [arr addObject:[path description]];\n            }\n            \n        }\n    }\n    \n    self.folderPaths = filepaths;\n    \n    NSMutableArray *allFiles = [NSMutableArray new];\n    for (NSString *docuPath in self.folderPaths) { // 遍历所有文件夹 获取所有文件个数\n        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名\n        [allFiles addObjectsFromArray:files];\n    }\n\n    NSAlert *alert = [[NSAlert alloc] init];\n    [alert setMessageText:@\"文件获取成功\"];\n    [alert setInformativeText:[NSString stringWithFormat:@\"文件总数：%ld 个\", allFiles.count]];\n    [alert beginSheetModalForWindow:self.view.window completionHandler:^(NSModalResponse returnCode) {\n    }];\n}\n```\n\n### 文件批量重命名\n\n遍历所有文件夹下所有文件，`NSFileManager` 并没有重命名的方法，如果要保留原文件，则执行`copy`操作，如果不保留原文件，则执行`move`操作。下面是重命名代码的实现。\n\n```\n- (IBAction)StartAction:(NSButton *)sender {\n    \n    \n    NSMutableArray *allFiles = [NSMutableArray new];\n    for (NSString *docuPath in self.folderPaths) {\n        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名\n        for (NSString *filename in files) {\n            [allFiles addObject:[NSString stringWithFormat:@\"%@/%@\", docuPath, filename]];\n        }\n    }\n    if (allFiles.count == 0) {\n        return;\n    }\n    NSString *resultFilePath = [NSString stringWithFormat:@\"%@/%@\", self.folderPaths.firstObject, @\"result\"];\n    \n    NSError *err = nil;\n    [XCFileManager createDirectoryAtPath:resultFilePath error:&err];\n    NSString *prefixName = _reNameView.prefixInput.stringValue;\n    if (!prefixName || prefixName.length == 0) {\n        prefixName = @\"img_\";\n    }\n    NSString *suffixName = _reNameView.suffixInput.stringValue;\n    if(!suffixName || suffixName.length == 0) {\n        suffixName = @\"\";\n    }\n    NSInteger index = 1;\n    NSString *suffix = @\"\";\n    for (NSString *path in allFiles) {\n//        // 如果遇到 没有文件名的文件，直接过滤\n        if ([path componentsSeparatedByString:@\".\"].count < 2) {\n            continue;\n        }\n        if (suffixName.length == 0) {\n            suffix = [[path componentsSeparatedByString:@\".\"].lastObject description];\n        } else {\n            suffix = suffixName;\n        }\n        self.dealingLabel.stringValue = [path description];\n        \n        NSString *movePath = [NSString stringWithFormat:@\"%@/%@%ld.%@\", resultFilePath, prefixName, index,suffix];\n        if (_reNameView.checkSaveBtn.state == 1) {\n           [XCFileManager moveItemAtPath:path toPath:movePath overwrite:NO];\n        } else {\n            [XCFileManager moveItemAtPath:path toPath:movePath overwrite:YES];\n        }\n        \n        index ++;\n    }\n    \n    self.dealingLabel.stringValue = @\"处理完成\";\n    \n}\n```\n[demo地址:https://github.com/macOSApp/photoBatch](https://github.com/macOSApp/photoBatch)\n\n\n","slug":"PhotoBatch-文件重命名-2","published":1,"updated":"2017-12-04T08:52:53.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tdk000flx60f2vmpiws","content":"<p>上一篇文章已经写了如何获取文件夹路径，今天实现photoBatch的第一个简单功能，图片批量重命名，当然也可以对任何文件进行重命名</p>\n<h3 id=\"搭建界面\"><a href=\"#搭建界面\" class=\"headerlink\" title=\"搭建界面\"></a>搭建界面</h3><p>搭了个简单的界面，如下图：<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2_1.png\" alt=\"布局用了purelayout框架\"><br>我们需要得到重命名后的文件名前缀，以及文件格式和是否保留原文件，给这3个变量一个默认值。</p>\n<h3 id=\"文件夹处理\"><a href=\"#文件夹处理\" class=\"headerlink\" title=\"文件夹处理\"></a>文件夹处理</h3><p>获取到文件路径后处理：需要对每个文件的路径进行处理，如果是以<br><code>file://</code>开头，需要把前面的<code>file://</code>去掉，这种地址无法处理。这里是对文件夹路径的处理，处理完的路径再加上文件名就是完整的路径。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)dealFiles:(NSArray *)filepaths</div><div class=\"line\">&#123;</div><div class=\"line\">    self.dealingLabel.stringValue = [filepaths.firstObject description];</div><div class=\"line\">    </div><div class=\"line\">    NSMutableArray *arr = [NSMutableArray new];</div><div class=\"line\">    // 对文件夹路径进行处理</div><div class=\"line\">    for (NSString *path in filepaths) &#123;</div><div class=\"line\">        if ([[path description] hasPrefix:@&quot;file:///&quot;]) &#123;</div><div class=\"line\">            NSString *newpath = [[path description] substringFromIndex:7];</div><div class=\"line\">            if ([newpath hasSuffix:@&quot;/&quot;]) &#123;</div><div class=\"line\">                newpath  = [newpath substringToIndex:newpath.length - 1];</div><div class=\"line\">            &#125;</div><div class=\"line\">            [arr addObject:newpath];</div><div class=\"line\">            </div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if ([[path description] hasSuffix:@&quot;/&quot;]) &#123;</div><div class=\"line\">                NSString *tempStr = [path description];</div><div class=\"line\">                [arr addObject:[tempStr substringToIndex:tempStr.length - 1]];</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                [arr addObject:[path description]];</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.folderPaths = filepaths;</div><div class=\"line\">    </div><div class=\"line\">    NSMutableArray *allFiles = [NSMutableArray new];</div><div class=\"line\">    for (NSString *docuPath in self.folderPaths) &#123; // 遍历所有文件夹 获取所有文件个数</div><div class=\"line\">        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名</div><div class=\"line\">        [allFiles addObjectsFromArray:files];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    NSAlert *alert = [[NSAlert alloc] init];</div><div class=\"line\">    [alert setMessageText:@&quot;文件获取成功&quot;];</div><div class=\"line\">    [alert setInformativeText:[NSString stringWithFormat:@&quot;文件总数：%ld 个&quot;, allFiles.count]];</div><div class=\"line\">    [alert beginSheetModalForWindow:self.view.window completionHandler:^(NSModalResponse returnCode) &#123;</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"文件批量重命名\"><a href=\"#文件批量重命名\" class=\"headerlink\" title=\"文件批量重命名\"></a>文件批量重命名</h3><p>遍历所有文件夹下所有文件，<code>NSFileManager</code> 并没有重命名的方法，如果要保留原文件，则执行<code>copy</code>操作，如果不保留原文件，则执行<code>move</code>操作。下面是重命名代码的实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (IBAction)StartAction:(NSButton *)sender &#123;</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    NSMutableArray *allFiles = [NSMutableArray new];</div><div class=\"line\">    for (NSString *docuPath in self.folderPaths) &#123;</div><div class=\"line\">        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名</div><div class=\"line\">        for (NSString *filename in files) &#123;</div><div class=\"line\">            [allFiles addObject:[NSString stringWithFormat:@&quot;%@/%@&quot;, docuPath, filename]];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (allFiles.count == 0) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSString *resultFilePath = [NSString stringWithFormat:@&quot;%@/%@&quot;, self.folderPaths.firstObject, @&quot;result&quot;];</div><div class=\"line\">    </div><div class=\"line\">    NSError *err = nil;</div><div class=\"line\">    [XCFileManager createDirectoryAtPath:resultFilePath error:&amp;err];</div><div class=\"line\">    NSString *prefixName = _reNameView.prefixInput.stringValue;</div><div class=\"line\">    if (!prefixName || prefixName.length == 0) &#123;</div><div class=\"line\">        prefixName = @&quot;img_&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSString *suffixName = _reNameView.suffixInput.stringValue;</div><div class=\"line\">    if(!suffixName || suffixName.length == 0) &#123;</div><div class=\"line\">        suffixName = @&quot;&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSInteger index = 1;</div><div class=\"line\">    NSString *suffix = @&quot;&quot;;</div><div class=\"line\">    for (NSString *path in allFiles) &#123;</div><div class=\"line\">//        // 如果遇到 没有文件名的文件，直接过滤</div><div class=\"line\">        if ([path componentsSeparatedByString:@&quot;.&quot;].count &lt; 2) &#123;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (suffixName.length == 0) &#123;</div><div class=\"line\">            suffix = [[path componentsSeparatedByString:@&quot;.&quot;].lastObject description];</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            suffix = suffixName;</div><div class=\"line\">        &#125;</div><div class=\"line\">        self.dealingLabel.stringValue = [path description];</div><div class=\"line\">        </div><div class=\"line\">        NSString *movePath = [NSString stringWithFormat:@&quot;%@/%@%ld.%@&quot;, resultFilePath, prefixName, index,suffix];</div><div class=\"line\">        if (_reNameView.checkSaveBtn.state == 1) &#123;</div><div class=\"line\">           [XCFileManager moveItemAtPath:path toPath:movePath overwrite:NO];</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            [XCFileManager moveItemAtPath:path toPath:movePath overwrite:YES];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        index ++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.dealingLabel.stringValue = @&quot;处理完成&quot;;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/macOSApp/photoBatch\" target=\"_blank\" rel=\"external\">demo地址:https://github.com/macOSApp/photoBatch</a></p>\n","excerpt":"<p>上一篇文章已经写了如何获取文件夹路径，今天实现photoBatch的第一个简单功能，图片批量重命名，当然也可以对任何文件进行重命名</p>\n<h3 id=\"搭建界面\"><a href=\"#搭建界面\" class=\"headerlink\" title=\"搭建界面\"></a>搭建界面</h3><p>搭了个简单的界面，如下图：<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PhotoBatch/2_1.png\" alt=\"布局用了purelayout框架\"><br>我们需要得到重命名后的文件名前缀，以及文件格式和是否保留原文件，给这3个变量一个默认值。</p>\n<h3 id=\"文件夹处理\"><a href=\"#文件夹处理\" class=\"headerlink\" title=\"文件夹处理\"></a>文件夹处理</h3><p>获取到文件路径后处理：需要对每个文件的路径进行处理，如果是以<br><code>file://</code>开头，需要把前面的<code>file://</code>去掉，这种地址无法处理。这里是对文件夹路径的处理，处理完的路径再加上文件名就是完整的路径。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)dealFiles:(NSArray *)filepaths</div><div class=\"line\">&#123;</div><div class=\"line\">    self.dealingLabel.stringValue = [filepaths.firstObject description];</div><div class=\"line\">    </div><div class=\"line\">    NSMutableArray *arr = [NSMutableArray new];</div><div class=\"line\">    // 对文件夹路径进行处理</div><div class=\"line\">    for (NSString *path in filepaths) &#123;</div><div class=\"line\">        if ([[path description] hasPrefix:@&quot;file:///&quot;]) &#123;</div><div class=\"line\">            NSString *newpath = [[path description] substringFromIndex:7];</div><div class=\"line\">            if ([newpath hasSuffix:@&quot;/&quot;]) &#123;</div><div class=\"line\">                newpath  = [newpath substringToIndex:newpath.length - 1];</div><div class=\"line\">            &#125;</div><div class=\"line\">            [arr addObject:newpath];</div><div class=\"line\">            </div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if ([[path description] hasSuffix:@&quot;/&quot;]) &#123;</div><div class=\"line\">                NSString *tempStr = [path description];</div><div class=\"line\">                [arr addObject:[tempStr substringToIndex:tempStr.length - 1]];</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                [arr addObject:[path description]];</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.folderPaths = filepaths;</div><div class=\"line\">    </div><div class=\"line\">    NSMutableArray *allFiles = [NSMutableArray new];</div><div class=\"line\">    for (NSString *docuPath in self.folderPaths) &#123; // 遍历所有文件夹 获取所有文件个数</div><div class=\"line\">        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名</div><div class=\"line\">        [allFiles addObjectsFromArray:files];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    NSAlert *alert = [[NSAlert alloc] init];</div><div class=\"line\">    [alert setMessageText:@&quot;文件获取成功&quot;];</div><div class=\"line\">    [alert setInformativeText:[NSString stringWithFormat:@&quot;文件总数：%ld 个&quot;, allFiles.count]];</div><div class=\"line\">    [alert beginSheetModalForWindow:self.view.window completionHandler:^(NSModalResponse returnCode) &#123;</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"文件批量重命名\"><a href=\"#文件批量重命名\" class=\"headerlink\" title=\"文件批量重命名\"></a>文件批量重命名</h3><p>遍历所有文件夹下所有文件，<code>NSFileManager</code> 并没有重命名的方法，如果要保留原文件，则执行<code>copy</code>操作，如果不保留原文件，则执行<code>move</code>操作。下面是重命名代码的实现。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (IBAction)StartAction:(NSButton *)sender &#123;</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    NSMutableArray *allFiles = [NSMutableArray new];</div><div class=\"line\">    for (NSString *docuPath in self.folderPaths) &#123;</div><div class=\"line\">        NSArray *files = [XCFileManager listFilesInDirectoryAtPath:docuPath deep:NO];//这里遍历得到的只是文件名</div><div class=\"line\">        for (NSString *filename in files) &#123;</div><div class=\"line\">            [allFiles addObject:[NSString stringWithFormat:@&quot;%@/%@&quot;, docuPath, filename]];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (allFiles.count == 0) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSString *resultFilePath = [NSString stringWithFormat:@&quot;%@/%@&quot;, self.folderPaths.firstObject, @&quot;result&quot;];</div><div class=\"line\">    </div><div class=\"line\">    NSError *err = nil;</div><div class=\"line\">    [XCFileManager createDirectoryAtPath:resultFilePath error:&amp;err];</div><div class=\"line\">    NSString *prefixName = _reNameView.prefixInput.stringValue;</div><div class=\"line\">    if (!prefixName || prefixName.length == 0) &#123;</div><div class=\"line\">        prefixName = @&quot;img_&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSString *suffixName = _reNameView.suffixInput.stringValue;</div><div class=\"line\">    if(!suffixName || suffixName.length == 0) &#123;</div><div class=\"line\">        suffixName = @&quot;&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSInteger index = 1;</div><div class=\"line\">    NSString *suffix = @&quot;&quot;;</div><div class=\"line\">    for (NSString *path in allFiles) &#123;</div><div class=\"line\">//        // 如果遇到 没有文件名的文件，直接过滤</div><div class=\"line\">        if ([path componentsSeparatedByString:@&quot;.&quot;].count &lt; 2) &#123;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (suffixName.length == 0) &#123;</div><div class=\"line\">            suffix = [[path componentsSeparatedByString:@&quot;.&quot;].lastObject description];</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            suffix = suffixName;</div><div class=\"line\">        &#125;</div><div class=\"line\">        self.dealingLabel.stringValue = [path description];</div><div class=\"line\">        </div><div class=\"line\">        NSString *movePath = [NSString stringWithFormat:@&quot;%@/%@%ld.%@&quot;, resultFilePath, prefixName, index,suffix];</div><div class=\"line\">        if (_reNameView.checkSaveBtn.state == 1) &#123;</div><div class=\"line\">           [XCFileManager moveItemAtPath:path toPath:movePath overwrite:NO];</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            [XCFileManager moveItemAtPath:path toPath:movePath overwrite:YES];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        index ++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.dealingLabel.stringValue = @&quot;处理完成&quot;;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/macOSApp/photoBatch\">demo地址:https://github.com/macOSApp/photoBatch</a></p>"},{"title":"RSA签名验签","date":"2018-06-28T10:51:55.000Z","_content":"## 什么是数字签名\n\n数字签名就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。\n\n\n## 签名的生成和验证\n\n### 生成消息签名的行为\n\n生成消息签名这一行为是由消息的发送者来完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值，这个行为意味着“我认可该消息的内容”。\n\n<!--more-->\n\n### 验证消息签名的行为\n\n验证数字签名这一行为一般是由消息的接收者来完成的，但也可以由需要验证消息的第三方来完成，这里的第三方在本书中被命名为验证者。验证签名就是检查该消息的签名是否真的属于发送者,验证的结果可以是成功或者失败，成功就意味着这个签名是属于发送者的，失败则意味着这个签名不是属于发送者的。\n\n## 公钥密码与数字签名\n\n在数字签名中，生成签名和验证签名这两个行为需要使用各自专用的密钥来完成。发送者使用“签名密钥”来生成消息的签名，而验证者则使用“验证密钥”来验证消息的签名。数字签名对签名密钥和验证密钥进行了区分，使用验证密钥是无法生成签名的。此外，签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。\n\n\n### 公钥密码机制\n\n公钥密码包括一个由公钥和私钥组成的密钥对，其中公钥用于加密，私钥用于解密。用公钥加密所得到的密文只有\n用与之对应的私钥才能正确解密。\n\n\n### 数字签名\n\n数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和公钥密码是相反的，即用 **私钥加密** 相当于 **生成签名**，而用 **公钥解密** 则相当于**验证签名**。\n\n\n## 数字签名算法\n\n### RSA\n\nRSA是提出这个算法的三人姓氏开头字母组成，可用于加密，也可以用于数字签名。\n\n### DSA\n\nDSA ( Digital Signature Algorithm)是一种数字签名算法，是由NIST ( National Institute of Standards and Technology,美国国家标准技术研究所)于1991年制定的数字签名规范( DSS)。DSA是Schnorr算法与ElGammal方式的变体，只能被用于数字签名。\n\n### ECDSA\n\nECDSA ( Elliptic Curve Digital Signature Algorithm)是一~种利用椭圆曲线密码来实现的数字\n签名算法( NIST FIPS 186-3 )。\n\n\n## RSA算法实现签名和验签\n```\nfunc main()  {\n\n\t//生成私钥\n\tpri,_ := rsa.GenerateKey(rand.Reader, 1024)\n\n\t//生成公钥\n\tpub := &pri.PublicKey\n\n\n\tplainTxt := []byte(\"hello world，你好\")\n\n\t//对原文进行hash散列\n\th := md5.New()\n\th.Write(plainTxt)\n\thashed := h.Sum(nil)\n\n\n\topts := rsa.PSSOptions{rsa.PSSSaltLengthAuto, crypto.MD5}\n\n\t//实现签名\n\n\tsign,_ := rsa.SignPSS(rand.Reader,pri, crypto.MD5,hashed,&opts)\n\n\tfmt.Println(hex.EncodeToString(sign))\n\t\n\n\t//通过公钥实现验签\n\terr:= rsa.VerifyPSS(pub, crypto.MD5,hashed, sign, &opts)\n\n\t//err 为空 及验签成功\n\tfmt.Println(\"err:\", err)\n\n}\n```\n\n\n\n\n","source":"_posts/RSA签名验签.md","raw":"---\ntitle: RSA签名验签\ncategories:\n  - 加密算法\ntags:\n  - RSA\n  - 签名\n  - 验签\ndate: 2018-06-28 18:51:55\n---\n## 什么是数字签名\n\n数字签名就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。\n\n\n## 签名的生成和验证\n\n### 生成消息签名的行为\n\n生成消息签名这一行为是由消息的发送者来完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值，这个行为意味着“我认可该消息的内容”。\n\n<!--more-->\n\n### 验证消息签名的行为\n\n验证数字签名这一行为一般是由消息的接收者来完成的，但也可以由需要验证消息的第三方来完成，这里的第三方在本书中被命名为验证者。验证签名就是检查该消息的签名是否真的属于发送者,验证的结果可以是成功或者失败，成功就意味着这个签名是属于发送者的，失败则意味着这个签名不是属于发送者的。\n\n## 公钥密码与数字签名\n\n在数字签名中，生成签名和验证签名这两个行为需要使用各自专用的密钥来完成。发送者使用“签名密钥”来生成消息的签名，而验证者则使用“验证密钥”来验证消息的签名。数字签名对签名密钥和验证密钥进行了区分，使用验证密钥是无法生成签名的。此外，签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。\n\n\n### 公钥密码机制\n\n公钥密码包括一个由公钥和私钥组成的密钥对，其中公钥用于加密，私钥用于解密。用公钥加密所得到的密文只有\n用与之对应的私钥才能正确解密。\n\n\n### 数字签名\n\n数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和公钥密码是相反的，即用 **私钥加密** 相当于 **生成签名**，而用 **公钥解密** 则相当于**验证签名**。\n\n\n## 数字签名算法\n\n### RSA\n\nRSA是提出这个算法的三人姓氏开头字母组成，可用于加密，也可以用于数字签名。\n\n### DSA\n\nDSA ( Digital Signature Algorithm)是一种数字签名算法，是由NIST ( National Institute of Standards and Technology,美国国家标准技术研究所)于1991年制定的数字签名规范( DSS)。DSA是Schnorr算法与ElGammal方式的变体，只能被用于数字签名。\n\n### ECDSA\n\nECDSA ( Elliptic Curve Digital Signature Algorithm)是一~种利用椭圆曲线密码来实现的数字\n签名算法( NIST FIPS 186-3 )。\n\n\n## RSA算法实现签名和验签\n```\nfunc main()  {\n\n\t//生成私钥\n\tpri,_ := rsa.GenerateKey(rand.Reader, 1024)\n\n\t//生成公钥\n\tpub := &pri.PublicKey\n\n\n\tplainTxt := []byte(\"hello world，你好\")\n\n\t//对原文进行hash散列\n\th := md5.New()\n\th.Write(plainTxt)\n\thashed := h.Sum(nil)\n\n\n\topts := rsa.PSSOptions{rsa.PSSSaltLengthAuto, crypto.MD5}\n\n\t//实现签名\n\n\tsign,_ := rsa.SignPSS(rand.Reader,pri, crypto.MD5,hashed,&opts)\n\n\tfmt.Println(hex.EncodeToString(sign))\n\t\n\n\t//通过公钥实现验签\n\terr:= rsa.VerifyPSS(pub, crypto.MD5,hashed, sign, &opts)\n\n\t//err 为空 及验签成功\n\tfmt.Println(\"err:\", err)\n\n}\n```\n\n\n\n\n","slug":"RSA签名验签","published":1,"updated":"2018-06-28T10:54:08.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tdp000ilx60ctsu6tri","content":"<h2 id=\"什么是数字签名\"><a href=\"#什么是数字签名\" class=\"headerlink\" title=\"什么是数字签名\"></a>什么是数字签名</h2><p>数字签名就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。</p>\n<h2 id=\"签名的生成和验证\"><a href=\"#签名的生成和验证\" class=\"headerlink\" title=\"签名的生成和验证\"></a>签名的生成和验证</h2><h3 id=\"生成消息签名的行为\"><a href=\"#生成消息签名的行为\" class=\"headerlink\" title=\"生成消息签名的行为\"></a>生成消息签名的行为</h3><p>生成消息签名这一行为是由消息的发送者来完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值，这个行为意味着“我认可该消息的内容”。</p>\n<a id=\"more\"></a>\n<h3 id=\"验证消息签名的行为\"><a href=\"#验证消息签名的行为\" class=\"headerlink\" title=\"验证消息签名的行为\"></a>验证消息签名的行为</h3><p>验证数字签名这一行为一般是由消息的接收者来完成的，但也可以由需要验证消息的第三方来完成，这里的第三方在本书中被命名为验证者。验证签名就是检查该消息的签名是否真的属于发送者,验证的结果可以是成功或者失败，成功就意味着这个签名是属于发送者的，失败则意味着这个签名不是属于发送者的。</p>\n<h2 id=\"公钥密码与数字签名\"><a href=\"#公钥密码与数字签名\" class=\"headerlink\" title=\"公钥密码与数字签名\"></a>公钥密码与数字签名</h2><p>在数字签名中，生成签名和验证签名这两个行为需要使用各自专用的密钥来完成。发送者使用“签名密钥”来生成消息的签名，而验证者则使用“验证密钥”来验证消息的签名。数字签名对签名密钥和验证密钥进行了区分，使用验证密钥是无法生成签名的。此外，签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。</p>\n<h3 id=\"公钥密码机制\"><a href=\"#公钥密码机制\" class=\"headerlink\" title=\"公钥密码机制\"></a>公钥密码机制</h3><p>公钥密码包括一个由公钥和私钥组成的密钥对，其中公钥用于加密，私钥用于解密。用公钥加密所得到的密文只有<br>用与之对应的私钥才能正确解密。</p>\n<h3 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h3><p>数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和公钥密码是相反的，即用 <strong>私钥加密</strong> 相当于 <strong>生成签名</strong>，而用 <strong>公钥解密</strong> 则相当于<strong>验证签名</strong>。</p>\n<h2 id=\"数字签名算法\"><a href=\"#数字签名算法\" class=\"headerlink\" title=\"数字签名算法\"></a>数字签名算法</h2><h3 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h3><p>RSA是提出这个算法的三人姓氏开头字母组成，可用于加密，也可以用于数字签名。</p>\n<h3 id=\"DSA\"><a href=\"#DSA\" class=\"headerlink\" title=\"DSA\"></a>DSA</h3><p>DSA ( Digital Signature Algorithm)是一种数字签名算法，是由NIST ( National Institute of Standards and Technology,美国国家标准技术研究所)于1991年制定的数字签名规范( DSS)。DSA是Schnorr算法与ElGammal方式的变体，只能被用于数字签名。</p>\n<h3 id=\"ECDSA\"><a href=\"#ECDSA\" class=\"headerlink\" title=\"ECDSA\"></a>ECDSA</h3><p>ECDSA ( Elliptic Curve Digital Signature Algorithm)是一~种利用椭圆曲线密码来实现的数字<br>签名算法( NIST FIPS 186-3 )。</p>\n<h2 id=\"RSA算法实现签名和验签\"><a href=\"#RSA算法实现签名和验签\" class=\"headerlink\" title=\"RSA算法实现签名和验签\"></a>RSA算法实现签名和验签</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//生成私钥</div><div class=\"line\">\tpri,_ := rsa.GenerateKey(rand.Reader, 1024)</div><div class=\"line\"></div><div class=\"line\">\t//生成公钥</div><div class=\"line\">\tpub := &amp;pri.PublicKey</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tplainTxt := []byte(&quot;hello world，你好&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//对原文进行hash散列</div><div class=\"line\">\th := md5.New()</div><div class=\"line\">\th.Write(plainTxt)</div><div class=\"line\">\thashed := h.Sum(nil)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\topts := rsa.PSSOptions&#123;rsa.PSSSaltLengthAuto, crypto.MD5&#125;</div><div class=\"line\"></div><div class=\"line\">\t//实现签名</div><div class=\"line\"></div><div class=\"line\">\tsign,_ := rsa.SignPSS(rand.Reader,pri, crypto.MD5,hashed,&amp;opts)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(sign))</div><div class=\"line\">\t</div><div class=\"line\"></div><div class=\"line\">\t//通过公钥实现验签</div><div class=\"line\">\terr:= rsa.VerifyPSS(pub, crypto.MD5,hashed, sign, &amp;opts)</div><div class=\"line\"></div><div class=\"line\">\t//err 为空 及验签成功</div><div class=\"line\">\tfmt.Println(&quot;err:&quot;, err)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<h2 id=\"什么是数字签名\"><a href=\"#什么是数字签名\" class=\"headerlink\" title=\"什么是数字签名\"></a>什么是数字签名</h2><p>数字签名就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。</p>\n<h2 id=\"签名的生成和验证\"><a href=\"#签名的生成和验证\" class=\"headerlink\" title=\"签名的生成和验证\"></a>签名的生成和验证</h2><h3 id=\"生成消息签名的行为\"><a href=\"#生成消息签名的行为\" class=\"headerlink\" title=\"生成消息签名的行为\"></a>生成消息签名的行为</h3><p>生成消息签名这一行为是由消息的发送者来完成的，也称为“对消息签名”。生成签名就是根据消息内容计算数字签名的值，这个行为意味着“我认可该消息的内容”。</p>","more":"<h3 id=\"验证消息签名的行为\"><a href=\"#验证消息签名的行为\" class=\"headerlink\" title=\"验证消息签名的行为\"></a>验证消息签名的行为</h3><p>验证数字签名这一行为一般是由消息的接收者来完成的，但也可以由需要验证消息的第三方来完成，这里的第三方在本书中被命名为验证者。验证签名就是检查该消息的签名是否真的属于发送者,验证的结果可以是成功或者失败，成功就意味着这个签名是属于发送者的，失败则意味着这个签名不是属于发送者的。</p>\n<h2 id=\"公钥密码与数字签名\"><a href=\"#公钥密码与数字签名\" class=\"headerlink\" title=\"公钥密码与数字签名\"></a>公钥密码与数字签名</h2><p>在数字签名中，生成签名和验证签名这两个行为需要使用各自专用的密钥来完成。发送者使用“签名密钥”来生成消息的签名，而验证者则使用“验证密钥”来验证消息的签名。数字签名对签名密钥和验证密钥进行了区分，使用验证密钥是无法生成签名的。此外，签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有。</p>\n<h3 id=\"公钥密码机制\"><a href=\"#公钥密码机制\" class=\"headerlink\" title=\"公钥密码机制\"></a>公钥密码机制</h3><p>公钥密码包括一个由公钥和私钥组成的密钥对，其中公钥用于加密，私钥用于解密。用公钥加密所得到的密文只有<br>用与之对应的私钥才能正确解密。</p>\n<h3 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h3><p>数字签名中也同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和公钥密码是相反的，即用 <strong>私钥加密</strong> 相当于 <strong>生成签名</strong>，而用 <strong>公钥解密</strong> 则相当于<strong>验证签名</strong>。</p>\n<h2 id=\"数字签名算法\"><a href=\"#数字签名算法\" class=\"headerlink\" title=\"数字签名算法\"></a>数字签名算法</h2><h3 id=\"RSA\"><a href=\"#RSA\" class=\"headerlink\" title=\"RSA\"></a>RSA</h3><p>RSA是提出这个算法的三人姓氏开头字母组成，可用于加密，也可以用于数字签名。</p>\n<h3 id=\"DSA\"><a href=\"#DSA\" class=\"headerlink\" title=\"DSA\"></a>DSA</h3><p>DSA ( Digital Signature Algorithm)是一种数字签名算法，是由NIST ( National Institute of Standards and Technology,美国国家标准技术研究所)于1991年制定的数字签名规范( DSS)。DSA是Schnorr算法与ElGammal方式的变体，只能被用于数字签名。</p>\n<h3 id=\"ECDSA\"><a href=\"#ECDSA\" class=\"headerlink\" title=\"ECDSA\"></a>ECDSA</h3><p>ECDSA ( Elliptic Curve Digital Signature Algorithm)是一~种利用椭圆曲线密码来实现的数字<br>签名算法( NIST FIPS 186-3 )。</p>\n<h2 id=\"RSA算法实现签名和验签\"><a href=\"#RSA算法实现签名和验签\" class=\"headerlink\" title=\"RSA算法实现签名和验签\"></a>RSA算法实现签名和验签</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//生成私钥</div><div class=\"line\">\tpri,_ := rsa.GenerateKey(rand.Reader, 1024)</div><div class=\"line\"></div><div class=\"line\">\t//生成公钥</div><div class=\"line\">\tpub := &amp;pri.PublicKey</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tplainTxt := []byte(&quot;hello world，你好&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//对原文进行hash散列</div><div class=\"line\">\th := md5.New()</div><div class=\"line\">\th.Write(plainTxt)</div><div class=\"line\">\thashed := h.Sum(nil)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\topts := rsa.PSSOptions&#123;rsa.PSSSaltLengthAuto, crypto.MD5&#125;</div><div class=\"line\"></div><div class=\"line\">\t//实现签名</div><div class=\"line\"></div><div class=\"line\">\tsign,_ := rsa.SignPSS(rand.Reader,pri, crypto.MD5,hashed,&amp;opts)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(sign))</div><div class=\"line\">\t</div><div class=\"line\"></div><div class=\"line\">\t//通过公钥实现验签</div><div class=\"line\">\terr:= rsa.VerifyPSS(pub, crypto.MD5,hashed, sign, &amp;opts)</div><div class=\"line\"></div><div class=\"line\">\t//err 为空 及验签成功</div><div class=\"line\">\tfmt.Println(&quot;err:&quot;, err)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Swift小结","date":"2016-11-29T15:30:40.000Z","_content":"\n### 懒加载\n- 格式 `lazy var 变量: 类型 = { 创建变量代码 }()`\n- 以 `lazy var` 开头，闭包末尾跟一个'()'\n- \t懒加载的写法本质上是定义并执行一个闭包\n-  好处：没有解包的麻烦，并且 延迟创建\n-  与OC懒加载的区别：这里的懒加载只会执行一次，如果中途被设置成nil，也不会再次执行\n懒加载完整的写法：\neg:懒加载一个数组\n\n```\nlazy var dataList: [String] = { () -> [String] in\n        return [\"zero\",\"one\", \"two\"]\n}()\n```\n\nin 和 前面的代码块可以省略，写成这样\n\n```\nlazy var dataList: [String] = {\n        return [\"zero\",\"one\", \"two\"]\n}()\n```\n\n后面的闭包和括号也能省略,这种写法是最为简洁的懒加载形式，一般这样写就可以了\n\n`lazy var dataList: [String] = [\"zero\",\"one\", \"two\"]`\n\n比如懒加载一个label\n\n`lazy var label: UILabel = UIlabel()`\n\n如果对label需要添加其他属性，就可以写成带（）的\n\n```\nlazy var label :UILabel = {\n       let label = UILabel()\n        label.font = UIFont.systemFont(ofSize: 15)\n        label.textColor = UIColor.red\n        return label\n}()\n```\n<!--more-->\n### extension\nswift中一个类只有一个.m文件，所有代码都会写在.m中，代码多了，难免就会混乱，`extension` 就是用来隔离代码用的。\nextension最常用的几个地方：\n#### 代理方法\n```\nextension HomeViewController : UITableViewdelegate,UItableViewDataSource {\n}\n\n```\n#### 对类的扩展\n```\nimport UIKit\n\n//对UIBarButtonItem UIbarButton 的一个扩展\nextension UIBarButtonItem {\n    // 便利构造函数\n    convenience init(imageName: String, highImageName: String, size: CGSize = CGSize.zero) {\n        \n        let btn = UIButton();\n       \n        btn.setImage(UIImage(named: imageName), for: UIControlState())\n        if(highImageName != \"\") {\n            btn.setImage(UIImage(named: highImageName), for: .highlighted)\n        }\n        \n        if size == CGSize.zero {\n            btn.sizeToFit()\n        }else {\n            btn.frame = CGRect(origin: CGPoint.zero, size: size)\n        }\n        self.init(customView: btn)\n    }\n}\n```\n#### 本类中的私有方法\nextension 外如果想调用extension 内的私有方法，需要加上`fileprivate`\n```\n// MARK: - 设置UI界面\nextension HomeController {\n    fileprivate func setupUI() {\n        setupNavgationbar()\n    }\n    private func setupNavgationbar() {\n   self.navigationItem.leftBarButtonItem = UIBarButtonItem(imageName:\"logo\")\n           \n}\n\n```\n\n### Swift宏定义\nSwift中没有宏的存在，但是有其他实现的方法。而且Swift共享整个命名空间，不在需要.pch文件。新建一个Swfit file文件，最好导入UIKit框架，没有参数的宏直接使用常量定义即可，有参数的宏使用函数代替\n\n#### 无参数的宏\n```\n//oc中的宏定义\n#define kIOS7   [UIDevice currentDevice].systemVersion.doubleValue>=7.0 ? 1 :0\n#define kIOS8   [UIDevice currentDevice].systemVersion.doubleValue>=8.0 ? 1 :0\n#define kScreenHeight     [UIScreen mainScreen].bounds.size.height\n#define kScreenWidth      [UIScreen mainScreen].bounds.size.width\n//转换成Swift的写法\nlet kIOS7 = Double(UIDevice().systemVersion)>=7.0 ? 1 :0\nlet kIOS8 = Double(UIDevice().systemVersion)>=8.0 ? 1 :0\n\nlet kScreenHeight = UIScreen.mainScreen().bounds.size.height\nlet kScreenWidth = UIScreen.mainScreen().bounds.size.width\n\n```\n#### 有参数的宏\n\n```\n//oc写法\n#define RGBCOLOR(r,g,b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1]\n//Swift中的写法\nfunc RGBCOLOR(r:CGFloat,_ g:CGFloat,_ b:CGFloat) -> UIColor\n{\n    return UIColor(red: (r)/255.0, green: (g)/255.0, blue: (b)/255.0, alpha: 1.0)\n}\n\n```\n\n### Swift中weakSelf 的 写法\n\n#### 第一种 类似OC的写法\n这里只能用 `var` 修饰\n```\nweak var weakSelf = self\nloadData { (result) in\n    print(weakSelf?.view)\n}\n```\n\n#### 第二种 Swift推荐的方式\n```\nloadData { [weak self] (result) in\n     print(self?.view)\n}\n```\n#### 第三种 不推荐使用\n[unowned self] 表示{} 中的 所有self 都是 assgined， 不会强引用，但是对象释放，指针地址不会变化 \n```\n//相当于 OC  __unsafe_unretain \n// 如果对象被释放，继续调用，就会出现野指针,有极大的安全隐患\nloadData { [unowned self] (result) in\n\t\tprint(self.view) \n}\n```\n\n### 单例\nSwift中单例写法较为简单，并且线程安全\n```\nstatic let shared: XCRequest = {\n     // 实例化对象\n     let instance = XCRequest()\n     // 返回对象\n     return instance\n }()\n```\n还有另外一种写法\n```\nstatic let instance: XCRequest = XCRequest()\n    \n      class func shareManager() ->XCRequest {\n        \n      return instance  \n}\n```\n\n### getter&setter\n\n模仿OC的写法，事实上Swift不会这么写\n```\nvar _name: String?\n\nvar name: String? {\n    get {\n        return _name\n    }\n    set {\n        _name = newValue\n    }\n}\n\n      var age:Int{\n        // 如果只重写了get,没有set. 那么属性是一个\"计算型\"属性\n        // 计算型属性不占用存储空间, 相当于OC中的readOnly\n        get{\n            return 30\n        }\n    }\n   \n    // 如果只有get可以简写为\n    var gender:String{\n        return \"lnj\" \n    }\n\n```\n#### 计算型属性\n只有getter，没有setter的属性被称为计算型属性\n```\nvar title: String { \n\t\tget { \n\t\t\treturn \"Mr \" + (name ?? \"\") \n\t\t} \n}\n```\n\n- 只实现 getter 方法的属性被称为计算型属性，等同于 OC 中的 ReadOnly 属性\n- 计算型属性本身不占用内存空间\n- 不可以给计算型属性设置数值\n\n计算型属性可以使用以下代码简写:\n```\nvar title: String { \n\treturn \"Mr \" + (name ?? \"\") \n}\n```\n\n#### didSet\nOC中最常见的就是重写setter方法，然后同时做一些额外的事情，那么Swift中就用didSet来实现\n\n```\nvar room_list : [[String : NSObject]]? {\n        didSet {\n            guard let room_list = room_list else { return }\n            for dict in room_list {\n                anchors.append(AnchorModel(dict: dict))\n            }\n        }\n    }\n```\n### 构造函数，析构函数\n先了解两个概念\n#### 方法重载：\n\t•\t函数名相同，参数名／参数类型／参数个数不同\n\t•\t重载函数并不仅仅局限于构造函数\n\t•\t函数重载是面相对象程序设计语言的重要标志\n\t•\tOC 不支持函数重载，OC 的替代方式是 withXXX…\n#### 方法重写：\n\t•\t也叫覆盖，指在子类中定义一个与父类中方法同名同参数列表的方法。\n\t•\t重写父类方法需要加override\n\t•\t重写是子类的方法覆盖父类的方法，要求方法名和参数都相同\n\t•\t因为子类会继承父类的方法，而重写就是将从父类继承过来的方法重新定义一次，重新填写方法中的代码。\n\t•\t重写必须继承，重载不用\n\t\n#### 构造函数\n\n```\nclass Person: NSObject {\n\n    var name: String\n    \n    ///最简单的必选属性的构造函数\n    ///构造函数的目的，给自己分配空间并设置初始值\n    ///属性的初始化放在super.init前面\n    /// 重写父类方法需要加override\n    override init () {\n        \n        name = \"default name:Tom\"\n        \n        super.init()\n    }\n    \n    /// 如果实现了 构造函数的重载，并且没有重写构造函数，那么系统不再提供原始的init()函数\n    /// 方法重载（类似OC自定义初始化方法）\n    init(name: String) {\n        self.name = name\n        super.init()\n    }\n    \n}\n```\n#### 析构函数\n相当于OC中的dealloc方法\n```\ndeinit {\n    print(\"被释放了\")\n}\n```\n\n### guard let & if let \n相当于OC中用if来判断某个值是不是为空\n我认为这个语法最大的好处是避免了写大量的 ？！，\n用来判断的这个属性必须是可选的\nguard 与 if 的区别是 guard只有在条件不满足的时候才会执行这段代码\n```\nguard let _:String = pe.name else {\n\t\treturn\n}\n```\n\n如果要判断多个参数,一直在后面加\n```\nguard let _ = pe.name, let _ = pe.title else {\n            return\n}\n```\n\nif let 可以在条件成立或者不成立的情况下，在{}中分别处理\n```\nif let name = pe.name {\n            print(name)\n     } else {\n            return\n}\n```\n\n### as\nas 的三种情况\n\n#### as？ \n\t1.\t前面的返回值是可选的\n\t2.\tguard let / if let 一定用 as?\n#### as! \n\t1.\t前面的返回值一定有值\n#### as \n\t1.\tNSString -> String\n\t2.\tNSArray ->[ ]\n\t3.\tNSDictionary -> [ ]\n\t4.\t这种情况是因为底层做了结构体和OC对象的桥接\n\n### try 处理错误异常\n\n```\nlet jsonSTring = \"{\\\"name\\\": \\\"zhang\\\"]\"\nlet data = jsonSTring.data(using: .utf8)\n//方法1. 推荐，如果解析成功就有值，否则 为nil\nlet json1 = try? JSONSerialization.jsonObject(with: data!, options: [])\nprint(json1 ?? \"json1 为 nil\")\n\n//方法2. 墙裂不推荐 如果解析成功就有值，否则crash\n//let json2 = try! JSONSerialization.jsonObject(with: data!, options: [])\n\n//方法3. 异常处理,能够接受错误，可以在错误的情况下另行处理\ndo {\n    let json3 = try JSONSerialization.jsonObject(with: data!, options: [])\n    print(json3)\n} catch {\n    print(error);\n}\n\n```\n\n### 网络请求\n#### GET\n\n```\nfunc getWithPath(path: String,param: Dictionary<String,Any>?,completion: @escaping ((_ result: Any?, _ success:Bool) -> ())) {\n        \n        let url = URL(string: path.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)!)\n        if let para = param {\n            //对参数进行处理\n            print(para)\n        } else {\n            \n        }\n        let session = URLSession.shared\n        \n        let dataTask = session.dataTask(with: url!) { (data, respond, error) in\n            \n            if let data = data {\n                \n                if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments){\n                    \n                    completion(result,true)\n                }\n            }else {\n                \n                completion(error,false)\n            }\n        }\n        dataTask.resume()\n    }\n```\n\n#### POST \n\n```\nfunc postWithPath(path: String,paras: Dictionary<String,Any>?,success: @escaping ((_ result: Any) -> ()),failure: @escaping ((_ error: Error) -> ())) {\n        \n        let url = URL(string: path)\n        var request = URLRequest.init(url: url!)\n        request.httpMethod = \"POST\"\n        print(path)\n        request.httpBody = path.data(using: .utf8)\n        let session = URLSession.shared\n        let dataTask = session.dataTask(with: request) { (data, respond, error) in\n            \n            if let data = data {\n                \n                if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) {\n                    \n                    success(result)\n                }\n                \n            }else {\n                failure(error!)\n            }\n        }\n        dataTask.resume()\n    }\n```\n\n\n","source":"_posts/Swift小结.md","raw":"---\ntitle: Swift小结\ndate: 2016-11-29 23:30:40\ncategories:\n  - Swfit\ntags:\n\t- Swift\n\t- 单例\n\t- 懒加载\n\t- extension\n\t- 网络请求\n---\n\n### 懒加载\n- 格式 `lazy var 变量: 类型 = { 创建变量代码 }()`\n- 以 `lazy var` 开头，闭包末尾跟一个'()'\n- \t懒加载的写法本质上是定义并执行一个闭包\n-  好处：没有解包的麻烦，并且 延迟创建\n-  与OC懒加载的区别：这里的懒加载只会执行一次，如果中途被设置成nil，也不会再次执行\n懒加载完整的写法：\neg:懒加载一个数组\n\n```\nlazy var dataList: [String] = { () -> [String] in\n        return [\"zero\",\"one\", \"two\"]\n}()\n```\n\nin 和 前面的代码块可以省略，写成这样\n\n```\nlazy var dataList: [String] = {\n        return [\"zero\",\"one\", \"two\"]\n}()\n```\n\n后面的闭包和括号也能省略,这种写法是最为简洁的懒加载形式，一般这样写就可以了\n\n`lazy var dataList: [String] = [\"zero\",\"one\", \"two\"]`\n\n比如懒加载一个label\n\n`lazy var label: UILabel = UIlabel()`\n\n如果对label需要添加其他属性，就可以写成带（）的\n\n```\nlazy var label :UILabel = {\n       let label = UILabel()\n        label.font = UIFont.systemFont(ofSize: 15)\n        label.textColor = UIColor.red\n        return label\n}()\n```\n<!--more-->\n### extension\nswift中一个类只有一个.m文件，所有代码都会写在.m中，代码多了，难免就会混乱，`extension` 就是用来隔离代码用的。\nextension最常用的几个地方：\n#### 代理方法\n```\nextension HomeViewController : UITableViewdelegate,UItableViewDataSource {\n}\n\n```\n#### 对类的扩展\n```\nimport UIKit\n\n//对UIBarButtonItem UIbarButton 的一个扩展\nextension UIBarButtonItem {\n    // 便利构造函数\n    convenience init(imageName: String, highImageName: String, size: CGSize = CGSize.zero) {\n        \n        let btn = UIButton();\n       \n        btn.setImage(UIImage(named: imageName), for: UIControlState())\n        if(highImageName != \"\") {\n            btn.setImage(UIImage(named: highImageName), for: .highlighted)\n        }\n        \n        if size == CGSize.zero {\n            btn.sizeToFit()\n        }else {\n            btn.frame = CGRect(origin: CGPoint.zero, size: size)\n        }\n        self.init(customView: btn)\n    }\n}\n```\n#### 本类中的私有方法\nextension 外如果想调用extension 内的私有方法，需要加上`fileprivate`\n```\n// MARK: - 设置UI界面\nextension HomeController {\n    fileprivate func setupUI() {\n        setupNavgationbar()\n    }\n    private func setupNavgationbar() {\n   self.navigationItem.leftBarButtonItem = UIBarButtonItem(imageName:\"logo\")\n           \n}\n\n```\n\n### Swift宏定义\nSwift中没有宏的存在，但是有其他实现的方法。而且Swift共享整个命名空间，不在需要.pch文件。新建一个Swfit file文件，最好导入UIKit框架，没有参数的宏直接使用常量定义即可，有参数的宏使用函数代替\n\n#### 无参数的宏\n```\n//oc中的宏定义\n#define kIOS7   [UIDevice currentDevice].systemVersion.doubleValue>=7.0 ? 1 :0\n#define kIOS8   [UIDevice currentDevice].systemVersion.doubleValue>=8.0 ? 1 :0\n#define kScreenHeight     [UIScreen mainScreen].bounds.size.height\n#define kScreenWidth      [UIScreen mainScreen].bounds.size.width\n//转换成Swift的写法\nlet kIOS7 = Double(UIDevice().systemVersion)>=7.0 ? 1 :0\nlet kIOS8 = Double(UIDevice().systemVersion)>=8.0 ? 1 :0\n\nlet kScreenHeight = UIScreen.mainScreen().bounds.size.height\nlet kScreenWidth = UIScreen.mainScreen().bounds.size.width\n\n```\n#### 有参数的宏\n\n```\n//oc写法\n#define RGBCOLOR(r,g,b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1]\n//Swift中的写法\nfunc RGBCOLOR(r:CGFloat,_ g:CGFloat,_ b:CGFloat) -> UIColor\n{\n    return UIColor(red: (r)/255.0, green: (g)/255.0, blue: (b)/255.0, alpha: 1.0)\n}\n\n```\n\n### Swift中weakSelf 的 写法\n\n#### 第一种 类似OC的写法\n这里只能用 `var` 修饰\n```\nweak var weakSelf = self\nloadData { (result) in\n    print(weakSelf?.view)\n}\n```\n\n#### 第二种 Swift推荐的方式\n```\nloadData { [weak self] (result) in\n     print(self?.view)\n}\n```\n#### 第三种 不推荐使用\n[unowned self] 表示{} 中的 所有self 都是 assgined， 不会强引用，但是对象释放，指针地址不会变化 \n```\n//相当于 OC  __unsafe_unretain \n// 如果对象被释放，继续调用，就会出现野指针,有极大的安全隐患\nloadData { [unowned self] (result) in\n\t\tprint(self.view) \n}\n```\n\n### 单例\nSwift中单例写法较为简单，并且线程安全\n```\nstatic let shared: XCRequest = {\n     // 实例化对象\n     let instance = XCRequest()\n     // 返回对象\n     return instance\n }()\n```\n还有另外一种写法\n```\nstatic let instance: XCRequest = XCRequest()\n    \n      class func shareManager() ->XCRequest {\n        \n      return instance  \n}\n```\n\n### getter&setter\n\n模仿OC的写法，事实上Swift不会这么写\n```\nvar _name: String?\n\nvar name: String? {\n    get {\n        return _name\n    }\n    set {\n        _name = newValue\n    }\n}\n\n      var age:Int{\n        // 如果只重写了get,没有set. 那么属性是一个\"计算型\"属性\n        // 计算型属性不占用存储空间, 相当于OC中的readOnly\n        get{\n            return 30\n        }\n    }\n   \n    // 如果只有get可以简写为\n    var gender:String{\n        return \"lnj\" \n    }\n\n```\n#### 计算型属性\n只有getter，没有setter的属性被称为计算型属性\n```\nvar title: String { \n\t\tget { \n\t\t\treturn \"Mr \" + (name ?? \"\") \n\t\t} \n}\n```\n\n- 只实现 getter 方法的属性被称为计算型属性，等同于 OC 中的 ReadOnly 属性\n- 计算型属性本身不占用内存空间\n- 不可以给计算型属性设置数值\n\n计算型属性可以使用以下代码简写:\n```\nvar title: String { \n\treturn \"Mr \" + (name ?? \"\") \n}\n```\n\n#### didSet\nOC中最常见的就是重写setter方法，然后同时做一些额外的事情，那么Swift中就用didSet来实现\n\n```\nvar room_list : [[String : NSObject]]? {\n        didSet {\n            guard let room_list = room_list else { return }\n            for dict in room_list {\n                anchors.append(AnchorModel(dict: dict))\n            }\n        }\n    }\n```\n### 构造函数，析构函数\n先了解两个概念\n#### 方法重载：\n\t•\t函数名相同，参数名／参数类型／参数个数不同\n\t•\t重载函数并不仅仅局限于构造函数\n\t•\t函数重载是面相对象程序设计语言的重要标志\n\t•\tOC 不支持函数重载，OC 的替代方式是 withXXX…\n#### 方法重写：\n\t•\t也叫覆盖，指在子类中定义一个与父类中方法同名同参数列表的方法。\n\t•\t重写父类方法需要加override\n\t•\t重写是子类的方法覆盖父类的方法，要求方法名和参数都相同\n\t•\t因为子类会继承父类的方法，而重写就是将从父类继承过来的方法重新定义一次，重新填写方法中的代码。\n\t•\t重写必须继承，重载不用\n\t\n#### 构造函数\n\n```\nclass Person: NSObject {\n\n    var name: String\n    \n    ///最简单的必选属性的构造函数\n    ///构造函数的目的，给自己分配空间并设置初始值\n    ///属性的初始化放在super.init前面\n    /// 重写父类方法需要加override\n    override init () {\n        \n        name = \"default name:Tom\"\n        \n        super.init()\n    }\n    \n    /// 如果实现了 构造函数的重载，并且没有重写构造函数，那么系统不再提供原始的init()函数\n    /// 方法重载（类似OC自定义初始化方法）\n    init(name: String) {\n        self.name = name\n        super.init()\n    }\n    \n}\n```\n#### 析构函数\n相当于OC中的dealloc方法\n```\ndeinit {\n    print(\"被释放了\")\n}\n```\n\n### guard let & if let \n相当于OC中用if来判断某个值是不是为空\n我认为这个语法最大的好处是避免了写大量的 ？！，\n用来判断的这个属性必须是可选的\nguard 与 if 的区别是 guard只有在条件不满足的时候才会执行这段代码\n```\nguard let _:String = pe.name else {\n\t\treturn\n}\n```\n\n如果要判断多个参数,一直在后面加\n```\nguard let _ = pe.name, let _ = pe.title else {\n            return\n}\n```\n\nif let 可以在条件成立或者不成立的情况下，在{}中分别处理\n```\nif let name = pe.name {\n            print(name)\n     } else {\n            return\n}\n```\n\n### as\nas 的三种情况\n\n#### as？ \n\t1.\t前面的返回值是可选的\n\t2.\tguard let / if let 一定用 as?\n#### as! \n\t1.\t前面的返回值一定有值\n#### as \n\t1.\tNSString -> String\n\t2.\tNSArray ->[ ]\n\t3.\tNSDictionary -> [ ]\n\t4.\t这种情况是因为底层做了结构体和OC对象的桥接\n\n### try 处理错误异常\n\n```\nlet jsonSTring = \"{\\\"name\\\": \\\"zhang\\\"]\"\nlet data = jsonSTring.data(using: .utf8)\n//方法1. 推荐，如果解析成功就有值，否则 为nil\nlet json1 = try? JSONSerialization.jsonObject(with: data!, options: [])\nprint(json1 ?? \"json1 为 nil\")\n\n//方法2. 墙裂不推荐 如果解析成功就有值，否则crash\n//let json2 = try! JSONSerialization.jsonObject(with: data!, options: [])\n\n//方法3. 异常处理,能够接受错误，可以在错误的情况下另行处理\ndo {\n    let json3 = try JSONSerialization.jsonObject(with: data!, options: [])\n    print(json3)\n} catch {\n    print(error);\n}\n\n```\n\n### 网络请求\n#### GET\n\n```\nfunc getWithPath(path: String,param: Dictionary<String,Any>?,completion: @escaping ((_ result: Any?, _ success:Bool) -> ())) {\n        \n        let url = URL(string: path.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)!)\n        if let para = param {\n            //对参数进行处理\n            print(para)\n        } else {\n            \n        }\n        let session = URLSession.shared\n        \n        let dataTask = session.dataTask(with: url!) { (data, respond, error) in\n            \n            if let data = data {\n                \n                if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments){\n                    \n                    completion(result,true)\n                }\n            }else {\n                \n                completion(error,false)\n            }\n        }\n        dataTask.resume()\n    }\n```\n\n#### POST \n\n```\nfunc postWithPath(path: String,paras: Dictionary<String,Any>?,success: @escaping ((_ result: Any) -> ()),failure: @escaping ((_ error: Error) -> ())) {\n        \n        let url = URL(string: path)\n        var request = URLRequest.init(url: url!)\n        request.httpMethod = \"POST\"\n        print(path)\n        request.httpBody = path.data(using: .utf8)\n        let session = URLSession.shared\n        let dataTask = session.dataTask(with: request) { (data, respond, error) in\n            \n            if let data = data {\n                \n                if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) {\n                    \n                    success(result)\n                }\n                \n            }else {\n                failure(error!)\n            }\n        }\n        dataTask.resume()\n    }\n```\n\n\n","slug":"Swift小结","published":1,"updated":"2016-12-03T16:53:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tdv000jlx60b4vt3pn9","content":"<h3 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h3><ul>\n<li>格式 <code>lazy var 变量: 类型 = { 创建变量代码 }()</code></li>\n<li>以 <code>lazy var</code> 开头，闭包末尾跟一个’()’</li>\n<li>懒加载的写法本质上是定义并执行一个闭包</li>\n<li>好处：没有解包的麻烦，并且 延迟创建</li>\n<li>与OC懒加载的区别：这里的懒加载只会执行一次，如果中途被设置成nil，也不会再次执行<br>懒加载完整的写法：<br>eg:懒加载一个数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">lazy var dataList: [String] = &#123; () -&gt; [String] in</div><div class=\"line\">        return [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;]</div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure>\n<p>in 和 前面的代码块可以省略，写成这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">lazy var dataList: [String] = &#123;</div><div class=\"line\">        return [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;]</div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure>\n<p>后面的闭包和括号也能省略,这种写法是最为简洁的懒加载形式，一般这样写就可以了</p>\n<p><code>lazy var dataList: [String] = [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;]</code></p>\n<p>比如懒加载一个label</p>\n<p><code>lazy var label: UILabel = UIlabel()</code></p>\n<p>如果对label需要添加其他属性，就可以写成带（）的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">lazy var label :UILabel = &#123;</div><div class=\"line\">       let label = UILabel()</div><div class=\"line\">        label.font = UIFont.systemFont(ofSize: 15)</div><div class=\"line\">        label.textColor = UIColor.red</div><div class=\"line\">        return label</div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"extension\"><a href=\"#extension\" class=\"headerlink\" title=\"extension\"></a>extension</h3><p>swift中一个类只有一个.m文件，所有代码都会写在.m中，代码多了，难免就会混乱，<code>extension</code> 就是用来隔离代码用的。<br>extension最常用的几个地方：</p>\n<h4 id=\"代理方法\"><a href=\"#代理方法\" class=\"headerlink\" title=\"代理方法\"></a>代理方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">extension HomeViewController : UITableViewdelegate,UItableViewDataSource &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"对类的扩展\"><a href=\"#对类的扩展\" class=\"headerlink\" title=\"对类的扩展\"></a>对类的扩展</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\"></div><div class=\"line\">//对UIBarButtonItem UIbarButton 的一个扩展</div><div class=\"line\">extension UIBarButtonItem &#123;</div><div class=\"line\">    // 便利构造函数</div><div class=\"line\">    convenience init(imageName: String, highImageName: String, size: CGSize = CGSize.zero) &#123;</div><div class=\"line\">        </div><div class=\"line\">        let btn = UIButton();</div><div class=\"line\">       </div><div class=\"line\">        btn.setImage(UIImage(named: imageName), for: UIControlState())</div><div class=\"line\">        if(highImageName != &quot;&quot;) &#123;</div><div class=\"line\">            btn.setImage(UIImage(named: highImageName), for: .highlighted)</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if size == CGSize.zero &#123;</div><div class=\"line\">            btn.sizeToFit()</div><div class=\"line\">        &#125;else &#123;</div><div class=\"line\">            btn.frame = CGRect(origin: CGPoint.zero, size: size)</div><div class=\"line\">        &#125;</div><div class=\"line\">        self.init(customView: btn)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"本类中的私有方法\"><a href=\"#本类中的私有方法\" class=\"headerlink\" title=\"本类中的私有方法\"></a>本类中的私有方法</h4><p>extension 外如果想调用extension 内的私有方法，需要加上<code>fileprivate</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// MARK: - 设置UI界面</div><div class=\"line\">extension HomeController &#123;</div><div class=\"line\">    fileprivate func setupUI() &#123;</div><div class=\"line\">        setupNavgationbar()</div><div class=\"line\">    &#125;</div><div class=\"line\">    private func setupNavgationbar() &#123;</div><div class=\"line\">   self.navigationItem.leftBarButtonItem = UIBarButtonItem(imageName:&quot;logo&quot;)</div><div class=\"line\">           </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Swift宏定义\"><a href=\"#Swift宏定义\" class=\"headerlink\" title=\"Swift宏定义\"></a>Swift宏定义</h3><p>Swift中没有宏的存在，但是有其他实现的方法。而且Swift共享整个命名空间，不在需要.pch文件。新建一个Swfit file文件，最好导入UIKit框架，没有参数的宏直接使用常量定义即可，有参数的宏使用函数代替</p>\n<h4 id=\"无参数的宏\"><a href=\"#无参数的宏\" class=\"headerlink\" title=\"无参数的宏\"></a>无参数的宏</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//oc中的宏定义</div><div class=\"line\">#define kIOS7   [UIDevice currentDevice].systemVersion.doubleValue&gt;=7.0 ? 1 :0</div><div class=\"line\">#define kIOS8   [UIDevice currentDevice].systemVersion.doubleValue&gt;=8.0 ? 1 :0</div><div class=\"line\">#define kScreenHeight     [UIScreen mainScreen].bounds.size.height</div><div class=\"line\">#define kScreenWidth      [UIScreen mainScreen].bounds.size.width</div><div class=\"line\">//转换成Swift的写法</div><div class=\"line\">let kIOS7 = Double(UIDevice().systemVersion)&gt;=7.0 ? 1 :0</div><div class=\"line\">let kIOS8 = Double(UIDevice().systemVersion)&gt;=8.0 ? 1 :0</div><div class=\"line\"></div><div class=\"line\">let kScreenHeight = UIScreen.mainScreen().bounds.size.height</div><div class=\"line\">let kScreenWidth = UIScreen.mainScreen().bounds.size.width</div></pre></td></tr></table></figure>\n<h4 id=\"有参数的宏\"><a href=\"#有参数的宏\" class=\"headerlink\" title=\"有参数的宏\"></a>有参数的宏</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//oc写法</div><div class=\"line\">#define RGBCOLOR(r,g,b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1]</div><div class=\"line\">//Swift中的写法</div><div class=\"line\">func RGBCOLOR(r:CGFloat,_ g:CGFloat,_ b:CGFloat) -&gt; UIColor</div><div class=\"line\">&#123;</div><div class=\"line\">    return UIColor(red: (r)/255.0, green: (g)/255.0, blue: (b)/255.0, alpha: 1.0)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Swift中weakSelf-的-写法\"><a href=\"#Swift中weakSelf-的-写法\" class=\"headerlink\" title=\"Swift中weakSelf 的 写法\"></a>Swift中weakSelf 的 写法</h3><h4 id=\"第一种-类似OC的写法\"><a href=\"#第一种-类似OC的写法\" class=\"headerlink\" title=\"第一种 类似OC的写法\"></a>第一种 类似OC的写法</h4><p>这里只能用 <code>var</code> 修饰<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">weak var weakSelf = self</div><div class=\"line\">loadData &#123; (result) in</div><div class=\"line\">    print(weakSelf?.view)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"第二种-Swift推荐的方式\"><a href=\"#第二种-Swift推荐的方式\" class=\"headerlink\" title=\"第二种 Swift推荐的方式\"></a>第二种 Swift推荐的方式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">loadData &#123; [weak self] (result) in</div><div class=\"line\">     print(self?.view)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"第三种-不推荐使用\"><a href=\"#第三种-不推荐使用\" class=\"headerlink\" title=\"第三种 不推荐使用\"></a>第三种 不推荐使用</h4><p>[unowned self] 表示{} 中的 所有self 都是 assgined， 不会强引用，但是对象释放，指针地址不会变化<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//相当于 OC  __unsafe_unretain </div><div class=\"line\">// 如果对象被释放，继续调用，就会出现野指针,有极大的安全隐患</div><div class=\"line\">loadData &#123; [unowned self] (result) in</div><div class=\"line\">\t\tprint(self.view) </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"单例\"><a href=\"#单例\" class=\"headerlink\" title=\"单例\"></a>单例</h3><p>Swift中单例写法较为简单，并且线程安全<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">static let shared: XCRequest = &#123;</div><div class=\"line\">     // 实例化对象</div><div class=\"line\">     let instance = XCRequest()</div><div class=\"line\">     // 返回对象</div><div class=\"line\">     return instance</div><div class=\"line\"> &#125;()</div></pre></td></tr></table></figure></p>\n<p>还有另外一种写法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">static let instance: XCRequest = XCRequest()</div><div class=\"line\">    </div><div class=\"line\">      class func shareManager() -&gt;XCRequest &#123;</div><div class=\"line\">        </div><div class=\"line\">      return instance  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"getter-amp-setter\"><a href=\"#getter-amp-setter\" class=\"headerlink\" title=\"getter&amp;setter\"></a>getter&amp;setter</h3><p>模仿OC的写法，事实上Swift不会这么写<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">var _name: String?</div><div class=\"line\"></div><div class=\"line\">var name: String? &#123;</div><div class=\"line\">    get &#123;</div><div class=\"line\">        return _name</div><div class=\"line\">    &#125;</div><div class=\"line\">    set &#123;</div><div class=\"line\">        _name = newValue</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">      var age:Int&#123;</div><div class=\"line\">        // 如果只重写了get,没有set. 那么属性是一个&quot;计算型&quot;属性</div><div class=\"line\">        // 计算型属性不占用存储空间, 相当于OC中的readOnly</div><div class=\"line\">        get&#123;</div><div class=\"line\">            return 30</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">   </div><div class=\"line\">    // 如果只有get可以简写为</div><div class=\"line\">    var gender:String&#123;</div><div class=\"line\">        return &quot;lnj&quot; </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"计算型属性\"><a href=\"#计算型属性\" class=\"headerlink\" title=\"计算型属性\"></a>计算型属性</h4><p>只有getter，没有setter的属性被称为计算型属性<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var title: String &#123; </div><div class=\"line\">\t\tget &#123; </div><div class=\"line\">\t\t\treturn &quot;Mr &quot; + (name ?? &quot;&quot;) </div><div class=\"line\">\t\t&#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>只实现 getter 方法的属性被称为计算型属性，等同于 OC 中的 ReadOnly 属性</li>\n<li>计算型属性本身不占用内存空间</li>\n<li>不可以给计算型属性设置数值</li>\n</ul>\n<p>计算型属性可以使用以下代码简写:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var title: String &#123; </div><div class=\"line\">\treturn &quot;Mr &quot; + (name ?? &quot;&quot;) </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"didSet\"><a href=\"#didSet\" class=\"headerlink\" title=\"didSet\"></a>didSet</h4><p>OC中最常见的就是重写setter方法，然后同时做一些额外的事情，那么Swift中就用didSet来实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var room_list : [[String : NSObject]]? &#123;</div><div class=\"line\">        didSet &#123;</div><div class=\"line\">            guard let room_list = room_list else &#123; return &#125;</div><div class=\"line\">            for dict in room_list &#123;</div><div class=\"line\">                anchors.append(AnchorModel(dict: dict))</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"构造函数，析构函数\"><a href=\"#构造函数，析构函数\" class=\"headerlink\" title=\"构造函数，析构函数\"></a>构造函数，析构函数</h3><p>先了解两个概念</p>\n<h4 id=\"方法重载：\"><a href=\"#方法重载：\" class=\"headerlink\" title=\"方法重载：\"></a>方法重载：</h4><pre><code>•    函数名相同，参数名／参数类型／参数个数不同\n•    重载函数并不仅仅局限于构造函数\n•    函数重载是面相对象程序设计语言的重要标志\n•    OC 不支持函数重载，OC 的替代方式是 withXXX…\n</code></pre><h4 id=\"方法重写：\"><a href=\"#方法重写：\" class=\"headerlink\" title=\"方法重写：\"></a>方法重写：</h4><pre><code>•    也叫覆盖，指在子类中定义一个与父类中方法同名同参数列表的方法。\n•    重写父类方法需要加override\n•    重写是子类的方法覆盖父类的方法，要求方法名和参数都相同\n•    因为子类会继承父类的方法，而重写就是将从父类继承过来的方法重新定义一次，重新填写方法中的代码。\n•    重写必须继承，重载不用\n</code></pre><h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Person: NSObject &#123;</div><div class=\"line\"></div><div class=\"line\">    var name: String</div><div class=\"line\">    </div><div class=\"line\">    ///最简单的必选属性的构造函数</div><div class=\"line\">    ///构造函数的目的，给自己分配空间并设置初始值</div><div class=\"line\">    ///属性的初始化放在super.init前面</div><div class=\"line\">    /// 重写父类方法需要加override</div><div class=\"line\">    override init () &#123;</div><div class=\"line\">        </div><div class=\"line\">        name = &quot;default name:Tom&quot;</div><div class=\"line\">        </div><div class=\"line\">        super.init()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    /// 如果实现了 构造函数的重载，并且没有重写构造函数，那么系统不再提供原始的init()函数</div><div class=\"line\">    /// 方法重载（类似OC自定义初始化方法）</div><div class=\"line\">    init(name: String) &#123;</div><div class=\"line\">        self.name = name</div><div class=\"line\">        super.init()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h4><p>相当于OC中的dealloc方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">deinit &#123;</div><div class=\"line\">    print(&quot;被释放了&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"guard-let-amp-if-let\"><a href=\"#guard-let-amp-if-let\" class=\"headerlink\" title=\"guard let &amp; if let\"></a>guard let &amp; if let</h3><p>相当于OC中用if来判断某个值是不是为空<br>我认为这个语法最大的好处是避免了写大量的 ？！，<br>用来判断的这个属性必须是可选的<br>guard 与 if 的区别是 guard只有在条件不满足的时候才会执行这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">guard let _:String = pe.name else &#123;</div><div class=\"line\">\t\treturn</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果要判断多个参数,一直在后面加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">guard let _ = pe.name, let _ = pe.title else &#123;</div><div class=\"line\">            return</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>if let 可以在条件成立或者不成立的情况下，在{}中分别处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if let name = pe.name &#123;</div><div class=\"line\">            print(name)</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">            return</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"as\"><a href=\"#as\" class=\"headerlink\" title=\"as\"></a>as</h3><p>as 的三种情况</p>\n<h4 id=\"as？\"><a href=\"#as？\" class=\"headerlink\" title=\"as？\"></a>as？</h4><pre><code>1.    前面的返回值是可选的\n2.    guard let / if let 一定用 as?\n</code></pre><h4 id=\"as-1\"><a href=\"#as-1\" class=\"headerlink\" title=\"as!\"></a>as!</h4><pre><code>1.    前面的返回值一定有值\n</code></pre><h4 id=\"as-2\"><a href=\"#as-2\" class=\"headerlink\" title=\"as\"></a>as</h4><pre><code>1.    NSString -&gt; String\n2.    NSArray -&gt;[ ]\n3.    NSDictionary -&gt; [ ]\n4.    这种情况是因为底层做了结构体和OC对象的桥接\n</code></pre><h3 id=\"try-处理错误异常\"><a href=\"#try-处理错误异常\" class=\"headerlink\" title=\"try 处理错误异常\"></a>try 处理错误异常</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">let jsonSTring = &quot;&#123;\\&quot;name\\&quot;: \\&quot;zhang\\&quot;]&quot;</div><div class=\"line\">let data = jsonSTring.data(using: .utf8)</div><div class=\"line\">//方法1. 推荐，如果解析成功就有值，否则 为nil</div><div class=\"line\">let json1 = try? JSONSerialization.jsonObject(with: data!, options: [])</div><div class=\"line\">print(json1 ?? &quot;json1 为 nil&quot;)</div><div class=\"line\"></div><div class=\"line\">//方法2. 墙裂不推荐 如果解析成功就有值，否则crash</div><div class=\"line\">//let json2 = try! JSONSerialization.jsonObject(with: data!, options: [])</div><div class=\"line\"></div><div class=\"line\">//方法3. 异常处理,能够接受错误，可以在错误的情况下另行处理</div><div class=\"line\">do &#123;</div><div class=\"line\">    let json3 = try JSONSerialization.jsonObject(with: data!, options: [])</div><div class=\"line\">    print(json3)</div><div class=\"line\">&#125; catch &#123;</div><div class=\"line\">    print(error);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h3><h4 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">func getWithPath(path: String,param: Dictionary&lt;String,Any&gt;?,completion: @escaping ((_ result: Any?, _ success:Bool) -&gt; ())) &#123;</div><div class=\"line\">        </div><div class=\"line\">        let url = URL(string: path.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)!)</div><div class=\"line\">        if let para = param &#123;</div><div class=\"line\">            //对参数进行处理</div><div class=\"line\">            print(para)</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        let session = URLSession.shared</div><div class=\"line\">        </div><div class=\"line\">        let dataTask = session.dataTask(with: url!) &#123; (data, respond, error) in</div><div class=\"line\">            </div><div class=\"line\">            if let data = data &#123;</div><div class=\"line\">                </div><div class=\"line\">                if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments)&#123;</div><div class=\"line\">                    </div><div class=\"line\">                    completion(result,true)</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;else &#123;</div><div class=\"line\">                </div><div class=\"line\">                completion(error,false)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        dataTask.resume()</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func postWithPath(path: String,paras: Dictionary&lt;String,Any&gt;?,success: @escaping ((_ result: Any) -&gt; ()),failure: @escaping ((_ error: Error) -&gt; ())) &#123;</div><div class=\"line\">        </div><div class=\"line\">        let url = URL(string: path)</div><div class=\"line\">        var request = URLRequest.init(url: url!)</div><div class=\"line\">        request.httpMethod = &quot;POST&quot;</div><div class=\"line\">        print(path)</div><div class=\"line\">        request.httpBody = path.data(using: .utf8)</div><div class=\"line\">        let session = URLSession.shared</div><div class=\"line\">        let dataTask = session.dataTask(with: request) &#123; (data, respond, error) in</div><div class=\"line\">            </div><div class=\"line\">            if let data = data &#123;</div><div class=\"line\">                </div><div class=\"line\">                if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) &#123;</div><div class=\"line\">                    </div><div class=\"line\">                    success(result)</div><div class=\"line\">                &#125;</div><div class=\"line\">                </div><div class=\"line\">            &#125;else &#123;</div><div class=\"line\">                failure(error!)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        dataTask.resume()</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n","excerpt":"<h3 id=\"懒加载\"><a href=\"#懒加载\" class=\"headerlink\" title=\"懒加载\"></a>懒加载</h3><ul>\n<li>格式 <code>lazy var 变量: 类型 = { 创建变量代码 }()</code></li>\n<li>以 <code>lazy var</code> 开头，闭包末尾跟一个’()’</li>\n<li>懒加载的写法本质上是定义并执行一个闭包</li>\n<li>好处：没有解包的麻烦，并且 延迟创建</li>\n<li>与OC懒加载的区别：这里的懒加载只会执行一次，如果中途被设置成nil，也不会再次执行<br>懒加载完整的写法：<br>eg:懒加载一个数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">lazy var dataList: [String] = &#123; () -&gt; [String] in</div><div class=\"line\">        return [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;]</div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure>\n<p>in 和 前面的代码块可以省略，写成这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">lazy var dataList: [String] = &#123;</div><div class=\"line\">        return [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;]</div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure>\n<p>后面的闭包和括号也能省略,这种写法是最为简洁的懒加载形式，一般这样写就可以了</p>\n<p><code>lazy var dataList: [String] = [&quot;zero&quot;,&quot;one&quot;, &quot;two&quot;]</code></p>\n<p>比如懒加载一个label</p>\n<p><code>lazy var label: UILabel = UIlabel()</code></p>\n<p>如果对label需要添加其他属性，就可以写成带（）的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">lazy var label :UILabel = &#123;</div><div class=\"line\">       let label = UILabel()</div><div class=\"line\">        label.font = UIFont.systemFont(ofSize: 15)</div><div class=\"line\">        label.textColor = UIColor.red</div><div class=\"line\">        return label</div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure>","more":"<h3 id=\"extension\"><a href=\"#extension\" class=\"headerlink\" title=\"extension\"></a>extension</h3><p>swift中一个类只有一个.m文件，所有代码都会写在.m中，代码多了，难免就会混乱，<code>extension</code> 就是用来隔离代码用的。<br>extension最常用的几个地方：</p>\n<h4 id=\"代理方法\"><a href=\"#代理方法\" class=\"headerlink\" title=\"代理方法\"></a>代理方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">extension HomeViewController : UITableViewdelegate,UItableViewDataSource &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"对类的扩展\"><a href=\"#对类的扩展\" class=\"headerlink\" title=\"对类的扩展\"></a>对类的扩展</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">import UIKit</div><div class=\"line\"></div><div class=\"line\">//对UIBarButtonItem UIbarButton 的一个扩展</div><div class=\"line\">extension UIBarButtonItem &#123;</div><div class=\"line\">    // 便利构造函数</div><div class=\"line\">    convenience init(imageName: String, highImageName: String, size: CGSize = CGSize.zero) &#123;</div><div class=\"line\">        </div><div class=\"line\">        let btn = UIButton();</div><div class=\"line\">       </div><div class=\"line\">        btn.setImage(UIImage(named: imageName), for: UIControlState())</div><div class=\"line\">        if(highImageName != &quot;&quot;) &#123;</div><div class=\"line\">            btn.setImage(UIImage(named: highImageName), for: .highlighted)</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if size == CGSize.zero &#123;</div><div class=\"line\">            btn.sizeToFit()</div><div class=\"line\">        &#125;else &#123;</div><div class=\"line\">            btn.frame = CGRect(origin: CGPoint.zero, size: size)</div><div class=\"line\">        &#125;</div><div class=\"line\">        self.init(customView: btn)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"本类中的私有方法\"><a href=\"#本类中的私有方法\" class=\"headerlink\" title=\"本类中的私有方法\"></a>本类中的私有方法</h4><p>extension 外如果想调用extension 内的私有方法，需要加上<code>fileprivate</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// MARK: - 设置UI界面</div><div class=\"line\">extension HomeController &#123;</div><div class=\"line\">    fileprivate func setupUI() &#123;</div><div class=\"line\">        setupNavgationbar()</div><div class=\"line\">    &#125;</div><div class=\"line\">    private func setupNavgationbar() &#123;</div><div class=\"line\">   self.navigationItem.leftBarButtonItem = UIBarButtonItem(imageName:&quot;logo&quot;)</div><div class=\"line\">           </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"Swift宏定义\"><a href=\"#Swift宏定义\" class=\"headerlink\" title=\"Swift宏定义\"></a>Swift宏定义</h3><p>Swift中没有宏的存在，但是有其他实现的方法。而且Swift共享整个命名空间，不在需要.pch文件。新建一个Swfit file文件，最好导入UIKit框架，没有参数的宏直接使用常量定义即可，有参数的宏使用函数代替</p>\n<h4 id=\"无参数的宏\"><a href=\"#无参数的宏\" class=\"headerlink\" title=\"无参数的宏\"></a>无参数的宏</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//oc中的宏定义</div><div class=\"line\">#define kIOS7   [UIDevice currentDevice].systemVersion.doubleValue&gt;=7.0 ? 1 :0</div><div class=\"line\">#define kIOS8   [UIDevice currentDevice].systemVersion.doubleValue&gt;=8.0 ? 1 :0</div><div class=\"line\">#define kScreenHeight     [UIScreen mainScreen].bounds.size.height</div><div class=\"line\">#define kScreenWidth      [UIScreen mainScreen].bounds.size.width</div><div class=\"line\">//转换成Swift的写法</div><div class=\"line\">let kIOS7 = Double(UIDevice().systemVersion)&gt;=7.0 ? 1 :0</div><div class=\"line\">let kIOS8 = Double(UIDevice().systemVersion)&gt;=8.0 ? 1 :0</div><div class=\"line\"></div><div class=\"line\">let kScreenHeight = UIScreen.mainScreen().bounds.size.height</div><div class=\"line\">let kScreenWidth = UIScreen.mainScreen().bounds.size.width</div></pre></td></tr></table></figure>\n<h4 id=\"有参数的宏\"><a href=\"#有参数的宏\" class=\"headerlink\" title=\"有参数的宏\"></a>有参数的宏</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//oc写法</div><div class=\"line\">#define RGBCOLOR(r,g,b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1]</div><div class=\"line\">//Swift中的写法</div><div class=\"line\">func RGBCOLOR(r:CGFloat,_ g:CGFloat,_ b:CGFloat) -&gt; UIColor</div><div class=\"line\">&#123;</div><div class=\"line\">    return UIColor(red: (r)/255.0, green: (g)/255.0, blue: (b)/255.0, alpha: 1.0)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Swift中weakSelf-的-写法\"><a href=\"#Swift中weakSelf-的-写法\" class=\"headerlink\" title=\"Swift中weakSelf 的 写法\"></a>Swift中weakSelf 的 写法</h3><h4 id=\"第一种-类似OC的写法\"><a href=\"#第一种-类似OC的写法\" class=\"headerlink\" title=\"第一种 类似OC的写法\"></a>第一种 类似OC的写法</h4><p>这里只能用 <code>var</code> 修饰<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">weak var weakSelf = self</div><div class=\"line\">loadData &#123; (result) in</div><div class=\"line\">    print(weakSelf?.view)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"第二种-Swift推荐的方式\"><a href=\"#第二种-Swift推荐的方式\" class=\"headerlink\" title=\"第二种 Swift推荐的方式\"></a>第二种 Swift推荐的方式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">loadData &#123; [weak self] (result) in</div><div class=\"line\">     print(self?.view)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"第三种-不推荐使用\"><a href=\"#第三种-不推荐使用\" class=\"headerlink\" title=\"第三种 不推荐使用\"></a>第三种 不推荐使用</h4><p>[unowned self] 表示{} 中的 所有self 都是 assgined， 不会强引用，但是对象释放，指针地址不会变化<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//相当于 OC  __unsafe_unretain </div><div class=\"line\">// 如果对象被释放，继续调用，就会出现野指针,有极大的安全隐患</div><div class=\"line\">loadData &#123; [unowned self] (result) in</div><div class=\"line\">\t\tprint(self.view) </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"单例\"><a href=\"#单例\" class=\"headerlink\" title=\"单例\"></a>单例</h3><p>Swift中单例写法较为简单，并且线程安全<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">static let shared: XCRequest = &#123;</div><div class=\"line\">     // 实例化对象</div><div class=\"line\">     let instance = XCRequest()</div><div class=\"line\">     // 返回对象</div><div class=\"line\">     return instance</div><div class=\"line\"> &#125;()</div></pre></td></tr></table></figure></p>\n<p>还有另外一种写法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">static let instance: XCRequest = XCRequest()</div><div class=\"line\">    </div><div class=\"line\">      class func shareManager() -&gt;XCRequest &#123;</div><div class=\"line\">        </div><div class=\"line\">      return instance  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"getter-amp-setter\"><a href=\"#getter-amp-setter\" class=\"headerlink\" title=\"getter&amp;setter\"></a>getter&amp;setter</h3><p>模仿OC的写法，事实上Swift不会这么写<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">var _name: String?</div><div class=\"line\"></div><div class=\"line\">var name: String? &#123;</div><div class=\"line\">    get &#123;</div><div class=\"line\">        return _name</div><div class=\"line\">    &#125;</div><div class=\"line\">    set &#123;</div><div class=\"line\">        _name = newValue</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">      var age:Int&#123;</div><div class=\"line\">        // 如果只重写了get,没有set. 那么属性是一个&quot;计算型&quot;属性</div><div class=\"line\">        // 计算型属性不占用存储空间, 相当于OC中的readOnly</div><div class=\"line\">        get&#123;</div><div class=\"line\">            return 30</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">   </div><div class=\"line\">    // 如果只有get可以简写为</div><div class=\"line\">    var gender:String&#123;</div><div class=\"line\">        return &quot;lnj&quot; </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"计算型属性\"><a href=\"#计算型属性\" class=\"headerlink\" title=\"计算型属性\"></a>计算型属性</h4><p>只有getter，没有setter的属性被称为计算型属性<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var title: String &#123; </div><div class=\"line\">\t\tget &#123; </div><div class=\"line\">\t\t\treturn &quot;Mr &quot; + (name ?? &quot;&quot;) </div><div class=\"line\">\t\t&#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>只实现 getter 方法的属性被称为计算型属性，等同于 OC 中的 ReadOnly 属性</li>\n<li>计算型属性本身不占用内存空间</li>\n<li>不可以给计算型属性设置数值</li>\n</ul>\n<p>计算型属性可以使用以下代码简写:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var title: String &#123; </div><div class=\"line\">\treturn &quot;Mr &quot; + (name ?? &quot;&quot;) </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"didSet\"><a href=\"#didSet\" class=\"headerlink\" title=\"didSet\"></a>didSet</h4><p>OC中最常见的就是重写setter方法，然后同时做一些额外的事情，那么Swift中就用didSet来实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var room_list : [[String : NSObject]]? &#123;</div><div class=\"line\">        didSet &#123;</div><div class=\"line\">            guard let room_list = room_list else &#123; return &#125;</div><div class=\"line\">            for dict in room_list &#123;</div><div class=\"line\">                anchors.append(AnchorModel(dict: dict))</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"构造函数，析构函数\"><a href=\"#构造函数，析构函数\" class=\"headerlink\" title=\"构造函数，析构函数\"></a>构造函数，析构函数</h3><p>先了解两个概念</p>\n<h4 id=\"方法重载：\"><a href=\"#方法重载：\" class=\"headerlink\" title=\"方法重载：\"></a>方法重载：</h4><pre><code>•    函数名相同，参数名／参数类型／参数个数不同\n•    重载函数并不仅仅局限于构造函数\n•    函数重载是面相对象程序设计语言的重要标志\n•    OC 不支持函数重载，OC 的替代方式是 withXXX…\n</code></pre><h4 id=\"方法重写：\"><a href=\"#方法重写：\" class=\"headerlink\" title=\"方法重写：\"></a>方法重写：</h4><pre><code>•    也叫覆盖，指在子类中定义一个与父类中方法同名同参数列表的方法。\n•    重写父类方法需要加override\n•    重写是子类的方法覆盖父类的方法，要求方法名和参数都相同\n•    因为子类会继承父类的方法，而重写就是将从父类继承过来的方法重新定义一次，重新填写方法中的代码。\n•    重写必须继承，重载不用\n</code></pre><h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Person: NSObject &#123;</div><div class=\"line\"></div><div class=\"line\">    var name: String</div><div class=\"line\">    </div><div class=\"line\">    ///最简单的必选属性的构造函数</div><div class=\"line\">    ///构造函数的目的，给自己分配空间并设置初始值</div><div class=\"line\">    ///属性的初始化放在super.init前面</div><div class=\"line\">    /// 重写父类方法需要加override</div><div class=\"line\">    override init () &#123;</div><div class=\"line\">        </div><div class=\"line\">        name = &quot;default name:Tom&quot;</div><div class=\"line\">        </div><div class=\"line\">        super.init()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    /// 如果实现了 构造函数的重载，并且没有重写构造函数，那么系统不再提供原始的init()函数</div><div class=\"line\">    /// 方法重载（类似OC自定义初始化方法）</div><div class=\"line\">    init(name: String) &#123;</div><div class=\"line\">        self.name = name</div><div class=\"line\">        super.init()</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h4><p>相当于OC中的dealloc方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">deinit &#123;</div><div class=\"line\">    print(&quot;被释放了&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"guard-let-amp-if-let\"><a href=\"#guard-let-amp-if-let\" class=\"headerlink\" title=\"guard let &amp; if let\"></a>guard let &amp; if let</h3><p>相当于OC中用if来判断某个值是不是为空<br>我认为这个语法最大的好处是避免了写大量的 ？！，<br>用来判断的这个属性必须是可选的<br>guard 与 if 的区别是 guard只有在条件不满足的时候才会执行这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">guard let _:String = pe.name else &#123;</div><div class=\"line\">\t\treturn</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果要判断多个参数,一直在后面加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">guard let _ = pe.name, let _ = pe.title else &#123;</div><div class=\"line\">            return</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>if let 可以在条件成立或者不成立的情况下，在{}中分别处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if let name = pe.name &#123;</div><div class=\"line\">            print(name)</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">            return</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"as\"><a href=\"#as\" class=\"headerlink\" title=\"as\"></a>as</h3><p>as 的三种情况</p>\n<h4 id=\"as？\"><a href=\"#as？\" class=\"headerlink\" title=\"as？\"></a>as？</h4><pre><code>1.    前面的返回值是可选的\n2.    guard let / if let 一定用 as?\n</code></pre><h4 id=\"as-1\"><a href=\"#as-1\" class=\"headerlink\" title=\"as!\"></a>as!</h4><pre><code>1.    前面的返回值一定有值\n</code></pre><h4 id=\"as-2\"><a href=\"#as-2\" class=\"headerlink\" title=\"as\"></a>as</h4><pre><code>1.    NSString -&gt; String\n2.    NSArray -&gt;[ ]\n3.    NSDictionary -&gt; [ ]\n4.    这种情况是因为底层做了结构体和OC对象的桥接\n</code></pre><h3 id=\"try-处理错误异常\"><a href=\"#try-处理错误异常\" class=\"headerlink\" title=\"try 处理错误异常\"></a>try 处理错误异常</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">let jsonSTring = &quot;&#123;\\&quot;name\\&quot;: \\&quot;zhang\\&quot;]&quot;</div><div class=\"line\">let data = jsonSTring.data(using: .utf8)</div><div class=\"line\">//方法1. 推荐，如果解析成功就有值，否则 为nil</div><div class=\"line\">let json1 = try? JSONSerialization.jsonObject(with: data!, options: [])</div><div class=\"line\">print(json1 ?? &quot;json1 为 nil&quot;)</div><div class=\"line\"></div><div class=\"line\">//方法2. 墙裂不推荐 如果解析成功就有值，否则crash</div><div class=\"line\">//let json2 = try! JSONSerialization.jsonObject(with: data!, options: [])</div><div class=\"line\"></div><div class=\"line\">//方法3. 异常处理,能够接受错误，可以在错误的情况下另行处理</div><div class=\"line\">do &#123;</div><div class=\"line\">    let json3 = try JSONSerialization.jsonObject(with: data!, options: [])</div><div class=\"line\">    print(json3)</div><div class=\"line\">&#125; catch &#123;</div><div class=\"line\">    print(error);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h3><h4 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">func getWithPath(path: String,param: Dictionary&lt;String,Any&gt;?,completion: @escaping ((_ result: Any?, _ success:Bool) -&gt; ())) &#123;</div><div class=\"line\">        </div><div class=\"line\">        let url = URL(string: path.addingPercentEncoding(withAllowedCharacters: CharacterSet.urlQueryAllowed)!)</div><div class=\"line\">        if let para = param &#123;</div><div class=\"line\">            //对参数进行处理</div><div class=\"line\">            print(para)</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        let session = URLSession.shared</div><div class=\"line\">        </div><div class=\"line\">        let dataTask = session.dataTask(with: url!) &#123; (data, respond, error) in</div><div class=\"line\">            </div><div class=\"line\">            if let data = data &#123;</div><div class=\"line\">                </div><div class=\"line\">                if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments)&#123;</div><div class=\"line\">                    </div><div class=\"line\">                    completion(result,true)</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;else &#123;</div><div class=\"line\">                </div><div class=\"line\">                completion(error,false)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        dataTask.resume()</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func postWithPath(path: String,paras: Dictionary&lt;String,Any&gt;?,success: @escaping ((_ result: Any) -&gt; ()),failure: @escaping ((_ error: Error) -&gt; ())) &#123;</div><div class=\"line\">        </div><div class=\"line\">        let url = URL(string: path)</div><div class=\"line\">        var request = URLRequest.init(url: url!)</div><div class=\"line\">        request.httpMethod = &quot;POST&quot;</div><div class=\"line\">        print(path)</div><div class=\"line\">        request.httpBody = path.data(using: .utf8)</div><div class=\"line\">        let session = URLSession.shared</div><div class=\"line\">        let dataTask = session.dataTask(with: request) &#123; (data, respond, error) in</div><div class=\"line\">            </div><div class=\"line\">            if let data = data &#123;</div><div class=\"line\">                </div><div class=\"line\">                if let result = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) &#123;</div><div class=\"line\">                    </div><div class=\"line\">                    success(result)</div><div class=\"line\">                &#125;</div><div class=\"line\">                </div><div class=\"line\">            &#125;else &#123;</div><div class=\"line\">                failure(error!)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        dataTask.resume()</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>"},{"title":"Xcode多工程联编及工程依赖","date":"2016-03-12T15:47:36.000Z","_content":"\n\n在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。\n\n### 一:target\n\ntarget指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。\n\ntarget会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。\n\n若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。\n\n<!-- more -->\n\n### 二:project\n\nxcode project是存储构建一个或多个软件产品所需的所有文件，资源和信息的仓库。\nproject包含构建product所需的所有要素并维护它们之间的关系，它包含一个或多个targets(target指定了构建product的方式)。\nproject定义了所有target的默认build settings，各target可以重载。Xcode project文件包含如下信息：源文件的引用：源代码（包括头文件和实现文件），library和framework(xcode内部或者外部),资源文件，interface builder文件文件结构列表中组织源文件的Groupsproject级别的build选项targetsdebug或测试program的可执行环境：从xcode运行或调试时启动哪些可以执行文件，传给可执行文件的命令行参数，程序运行时设置的环境变量总之，project可以单独存在也可以包含在workspace中，同时可以在Scheme中指定哪个Target、build配置、哪个可执行配置在某个时刻是有效的。\n\n### 三:build settings\n\n一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。\n\n### 四:workspace\n\nworkspace 是组织projects和其他协同工作的文档的一份文档。除此之外，它还维护project和target之间的显性及隐性的依赖关系。默认workspace中的所有Xcode projects都在同一个目录下构建，称为workspace build directory，由于所有project的所有文件都在同一个目录下，所以所有文件都对每个project可见。\n比如两个project使用同一个库，则不用复制到另一个project目录中。workspace中的每个project都有其独立id,同时project可以属于多个workspace，可以单独打开project或者在其他workspace中打开，且都不用重新配置project或者workspace。\n可以使用workspace默认的build 目录，也可以指定一个。如果project指定了构建目录，这个目录会被project构建时所在的workspace的build目录覆盖。\n\n### 五:xcode schemexcode \n\nscheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。\n\n一般的某个应用单独新建一个 project 就可以了，然后把所有的程序文件都放在里面，这个可以满足大部分普通的需求，但是有时候，项目有可能要使用其他的项目文件，或者引入其他的静态库文件，这个时候 workspace 就派上用场了，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，如果不用 workspace，以前的做法是如果用到其他项目的文件，要手动 copy 文件到当前的项目，在 workspace 里这个步骤不需要了。\n\n### 六:案例\n\n下面是我自己的例子 ，现在用 workspace 管理2个 project，其中一个是 static library: MyStaticLib，另外一个是依赖这个静态库的 project:  MyUseStatic，菜单 xocde7 > file > New Workspace 新建一个空的workspace，名字可以随便取。\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/1.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/2.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/3.png)\n\n在左边 project navigator 右键菜单 New Project ,然后选择 Ios > Framework & Library > Cocoa Touch Static Library , 然后输入项目名称 MyStaticLib，这样就新建了一个空白的静态库项目，接着新建个类文件，名字为 MyLib, 选中 MyLib.h头文件，打开右边的 File inspector 窗口，在 Target membership 中将 MyStaticLib 后面的 project改成 public 。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/4.png)\n\n在左边的 project navigator 右键菜单 New Project ,然后选择 Ios > Application > Single View Application，然后输入项目名称 MyUseStatic，下面配置让它依赖 MyStaticLib，打开 Build Phases配置选项 然后展开 Link Binary With Libraries ，点击 + 会看到 Workspace > libMyStaticLib.a ，选中它，就让此项目产生了对 MyStaticLib的依赖关系，然后在 Build S Setting配置选项里 搜索 USER_HEADER_SEARCH_PATHS，将它的值设为 MyStaticLib 的build prouect 路径，在import静态库中的新文件时，会到这个路径中寻找。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/6.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/7.png)\n现在编译  MyUseStatic 会自动先编译依赖的 MyStaticLib。\n\n参考文章：http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory\n\n[!更多文章可前往我的blog：http://gcblog.github.io](http://gcblog.github.io)\n\n\n\n\n\n\n","source":"_posts/Xcode多工程联编及工程依赖.md","raw":"---\ntitle: Xcode多工程联编及工程依赖\ntags:\n  - iOS\n  - workspace\ncategories:\n  - iOS配置\ndate: 2016-03-12 23:47:36\n---\n\n\n在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。\n\n### 一:target\n\ntarget指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。\n\ntarget会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。\n\n若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。\n\n<!-- more -->\n\n### 二:project\n\nxcode project是存储构建一个或多个软件产品所需的所有文件，资源和信息的仓库。\nproject包含构建product所需的所有要素并维护它们之间的关系，它包含一个或多个targets(target指定了构建product的方式)。\nproject定义了所有target的默认build settings，各target可以重载。Xcode project文件包含如下信息：源文件的引用：源代码（包括头文件和实现文件），library和framework(xcode内部或者外部),资源文件，interface builder文件文件结构列表中组织源文件的Groupsproject级别的build选项targetsdebug或测试program的可执行环境：从xcode运行或调试时启动哪些可以执行文件，传给可执行文件的命令行参数，程序运行时设置的环境变量总之，project可以单独存在也可以包含在workspace中，同时可以在Scheme中指定哪个Target、build配置、哪个可执行配置在某个时刻是有效的。\n\n### 三:build settings\n\n一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。\n\n### 四:workspace\n\nworkspace 是组织projects和其他协同工作的文档的一份文档。除此之外，它还维护project和target之间的显性及隐性的依赖关系。默认workspace中的所有Xcode projects都在同一个目录下构建，称为workspace build directory，由于所有project的所有文件都在同一个目录下，所以所有文件都对每个project可见。\n比如两个project使用同一个库，则不用复制到另一个project目录中。workspace中的每个project都有其独立id,同时project可以属于多个workspace，可以单独打开project或者在其他workspace中打开，且都不用重新配置project或者workspace。\n可以使用workspace默认的build 目录，也可以指定一个。如果project指定了构建目录，这个目录会被project构建时所在的workspace的build目录覆盖。\n\n### 五:xcode schemexcode \n\nscheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。\n\n一般的某个应用单独新建一个 project 就可以了，然后把所有的程序文件都放在里面，这个可以满足大部分普通的需求，但是有时候，项目有可能要使用其他的项目文件，或者引入其他的静态库文件，这个时候 workspace 就派上用场了，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，如果不用 workspace，以前的做法是如果用到其他项目的文件，要手动 copy 文件到当前的项目，在 workspace 里这个步骤不需要了。\n\n### 六:案例\n\n下面是我自己的例子 ，现在用 workspace 管理2个 project，其中一个是 static library: MyStaticLib，另外一个是依赖这个静态库的 project:  MyUseStatic，菜单 xocde7 > file > New Workspace 新建一个空的workspace，名字可以随便取。\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/1.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/2.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/3.png)\n\n在左边 project navigator 右键菜单 New Project ,然后选择 Ios > Framework & Library > Cocoa Touch Static Library , 然后输入项目名称 MyStaticLib，这样就新建了一个空白的静态库项目，接着新建个类文件，名字为 MyLib, 选中 MyLib.h头文件，打开右边的 File inspector 窗口，在 Target membership 中将 MyStaticLib 后面的 project改成 public 。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/4.png)\n\n在左边的 project navigator 右键菜单 New Project ,然后选择 Ios > Application > Single View Application，然后输入项目名称 MyUseStatic，下面配置让它依赖 MyStaticLib，打开 Build Phases配置选项 然后展开 Link Binary With Libraries ，点击 + 会看到 Workspace > libMyStaticLib.a ，选中它，就让此项目产生了对 MyStaticLib的依赖关系，然后在 Build S Setting配置选项里 搜索 USER_HEADER_SEARCH_PATHS，将它的值设为 MyStaticLib 的build prouect 路径，在import静态库中的新文件时，会到这个路径中寻找。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/6.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/7.png)\n现在编译  MyUseStatic 会自动先编译依赖的 MyStaticLib。\n\n参考文章：http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory\n\n[!更多文章可前往我的blog：http://gcblog.github.io](http://gcblog.github.io)\n\n\n\n\n\n\n","slug":"Xcode多工程联编及工程依赖","published":1,"updated":"2016-11-17T14:26:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tdx000nlx60fc98whkl","content":"<p>在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。</p>\n<h3 id=\"一-target\"><a href=\"#一-target\" class=\"headerlink\" title=\"一:target\"></a>一:target</h3><p>target指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。</p>\n<p>target会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。</p>\n<p>若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。</p>\n<a id=\"more\"></a>\n<h3 id=\"二-project\"><a href=\"#二-project\" class=\"headerlink\" title=\"二:project\"></a>二:project</h3><p>xcode project是存储构建一个或多个软件产品所需的所有文件，资源和信息的仓库。<br>project包含构建product所需的所有要素并维护它们之间的关系，它包含一个或多个targets(target指定了构建product的方式)。<br>project定义了所有target的默认build settings，各target可以重载。Xcode project文件包含如下信息：源文件的引用：源代码（包括头文件和实现文件），library和framework(xcode内部或者外部),资源文件，interface builder文件文件结构列表中组织源文件的Groupsproject级别的build选项targetsdebug或测试program的可执行环境：从xcode运行或调试时启动哪些可以执行文件，传给可执行文件的命令行参数，程序运行时设置的环境变量总之，project可以单独存在也可以包含在workspace中，同时可以在Scheme中指定哪个Target、build配置、哪个可执行配置在某个时刻是有效的。</p>\n<h3 id=\"三-build-settings\"><a href=\"#三-build-settings\" class=\"headerlink\" title=\"三:build settings\"></a>三:build settings</h3><p>一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。</p>\n<h3 id=\"四-workspace\"><a href=\"#四-workspace\" class=\"headerlink\" title=\"四:workspace\"></a>四:workspace</h3><p>workspace 是组织projects和其他协同工作的文档的一份文档。除此之外，它还维护project和target之间的显性及隐性的依赖关系。默认workspace中的所有Xcode projects都在同一个目录下构建，称为workspace build directory，由于所有project的所有文件都在同一个目录下，所以所有文件都对每个project可见。<br>比如两个project使用同一个库，则不用复制到另一个project目录中。workspace中的每个project都有其独立id,同时project可以属于多个workspace，可以单独打开project或者在其他workspace中打开，且都不用重新配置project或者workspace。<br>可以使用workspace默认的build 目录，也可以指定一个。如果project指定了构建目录，这个目录会被project构建时所在的workspace的build目录覆盖。</p>\n<h3 id=\"五-xcode-schemexcode\"><a href=\"#五-xcode-schemexcode\" class=\"headerlink\" title=\"五:xcode schemexcode\"></a>五:xcode schemexcode</h3><p>scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。</p>\n<p>一般的某个应用单独新建一个 project 就可以了，然后把所有的程序文件都放在里面，这个可以满足大部分普通的需求，但是有时候，项目有可能要使用其他的项目文件，或者引入其他的静态库文件，这个时候 workspace 就派上用场了，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，如果不用 workspace，以前的做法是如果用到其他项目的文件，要手动 copy 文件到当前的项目，在 workspace 里这个步骤不需要了。</p>\n<h3 id=\"六-案例\"><a href=\"#六-案例\" class=\"headerlink\" title=\"六:案例\"></a>六:案例</h3><p>下面是我自己的例子 ，现在用 workspace 管理2个 project，其中一个是 static library: MyStaticLib，另外一个是依赖这个静态库的 project:  MyUseStatic，菜单 xocde7 &gt; file &gt; New Workspace 新建一个空的workspace，名字可以随便取。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/1.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/2.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/3.png\" alt=\"image\"></p>\n<p>在左边 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Framework &amp; Library &gt; Cocoa Touch Static Library , 然后输入项目名称 MyStaticLib，这样就新建了一个空白的静态库项目，接着新建个类文件，名字为 MyLib, 选中 MyLib.h头文件，打开右边的 File inspector 窗口，在 Target membership 中将 MyStaticLib 后面的 project改成 public 。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/4.png\" alt=\"image\"></p>\n<p>在左边的 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Application &gt; Single View Application，然后输入项目名称 MyUseStatic，下面配置让它依赖 MyStaticLib，打开 Build Phases配置选项 然后展开 Link Binary With Libraries ，点击 + 会看到 Workspace &gt; libMyStaticLib.a ，选中它，就让此项目产生了对 MyStaticLib的依赖关系，然后在 Build S Setting配置选项里 搜索 USER_HEADER_SEARCH_PATHS，将它的值设为 MyStaticLib 的build prouect 路径，在import静态库中的新文件时，会到这个路径中寻找。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/6.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/7.png\" alt=\"image\"><br>现在编译  MyUseStatic 会自动先编译依赖的 MyStaticLib。</p>\n<p>参考文章：<a href=\"http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory\" target=\"_blank\" rel=\"external\">http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory</a></p>\n<p><a href=\"http://gcblog.github.io\" target=\"_blank\" rel=\"external\">!更多文章可前往我的blog：http://gcblog.github.io</a></p>\n","excerpt":"<p>在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。</p>\n<h3 id=\"一-target\"><a href=\"#一-target\" class=\"headerlink\" title=\"一:target\"></a>一:target</h3><p>target指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。</p>\n<p>target会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。</p>\n<p>若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。</p>","more":"<h3 id=\"二-project\"><a href=\"#二-project\" class=\"headerlink\" title=\"二:project\"></a>二:project</h3><p>xcode project是存储构建一个或多个软件产品所需的所有文件，资源和信息的仓库。<br>project包含构建product所需的所有要素并维护它们之间的关系，它包含一个或多个targets(target指定了构建product的方式)。<br>project定义了所有target的默认build settings，各target可以重载。Xcode project文件包含如下信息：源文件的引用：源代码（包括头文件和实现文件），library和framework(xcode内部或者外部),资源文件，interface builder文件文件结构列表中组织源文件的Groupsproject级别的build选项targetsdebug或测试program的可执行环境：从xcode运行或调试时启动哪些可以执行文件，传给可执行文件的命令行参数，程序运行时设置的环境变量总之，project可以单独存在也可以包含在workspace中，同时可以在Scheme中指定哪个Target、build配置、哪个可执行配置在某个时刻是有效的。</p>\n<h3 id=\"三-build-settings\"><a href=\"#三-build-settings\" class=\"headerlink\" title=\"三:build settings\"></a>三:build settings</h3><p>一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。</p>\n<h3 id=\"四-workspace\"><a href=\"#四-workspace\" class=\"headerlink\" title=\"四:workspace\"></a>四:workspace</h3><p>workspace 是组织projects和其他协同工作的文档的一份文档。除此之外，它还维护project和target之间的显性及隐性的依赖关系。默认workspace中的所有Xcode projects都在同一个目录下构建，称为workspace build directory，由于所有project的所有文件都在同一个目录下，所以所有文件都对每个project可见。<br>比如两个project使用同一个库，则不用复制到另一个project目录中。workspace中的每个project都有其独立id,同时project可以属于多个workspace，可以单独打开project或者在其他workspace中打开，且都不用重新配置project或者workspace。<br>可以使用workspace默认的build 目录，也可以指定一个。如果project指定了构建目录，这个目录会被project构建时所在的workspace的build目录覆盖。</p>\n<h3 id=\"五-xcode-schemexcode\"><a href=\"#五-xcode-schemexcode\" class=\"headerlink\" title=\"五:xcode schemexcode\"></a>五:xcode schemexcode</h3><p>scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。</p>\n<p>一般的某个应用单独新建一个 project 就可以了，然后把所有的程序文件都放在里面，这个可以满足大部分普通的需求，但是有时候，项目有可能要使用其他的项目文件，或者引入其他的静态库文件，这个时候 workspace 就派上用场了，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，如果不用 workspace，以前的做法是如果用到其他项目的文件，要手动 copy 文件到当前的项目，在 workspace 里这个步骤不需要了。</p>\n<h3 id=\"六-案例\"><a href=\"#六-案例\" class=\"headerlink\" title=\"六:案例\"></a>六:案例</h3><p>下面是我自己的例子 ，现在用 workspace 管理2个 project，其中一个是 static library: MyStaticLib，另外一个是依赖这个静态库的 project:  MyUseStatic，菜单 xocde7 &gt; file &gt; New Workspace 新建一个空的workspace，名字可以随便取。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/1.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/2.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/3.png\" alt=\"image\"></p>\n<p>在左边 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Framework &amp; Library &gt; Cocoa Touch Static Library , 然后输入项目名称 MyStaticLib，这样就新建了一个空白的静态库项目，接着新建个类文件，名字为 MyLib, 选中 MyLib.h头文件，打开右边的 File inspector 窗口，在 Target membership 中将 MyStaticLib 后面的 project改成 public 。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/4.png\" alt=\"image\"></p>\n<p>在左边的 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Application &gt; Single View Application，然后输入项目名称 MyUseStatic，下面配置让它依赖 MyStaticLib，打开 Build Phases配置选项 然后展开 Link Binary With Libraries ，点击 + 会看到 Workspace &gt; libMyStaticLib.a ，选中它，就让此项目产生了对 MyStaticLib的依赖关系，然后在 Build S Setting配置选项里 搜索 USER_HEADER_SEARCH_PATHS，将它的值设为 MyStaticLib 的build prouect 路径，在import静态库中的新文件时，会到这个路径中寻找。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/6.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/7.png\" alt=\"image\"><br>现在编译  MyUseStatic 会自动先编译依赖的 MyStaticLib。</p>\n<p>参考文章：<a href=\"http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory\">http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory</a></p>\n<p><a href=\"http://gcblog.github.io\">!更多文章可前往我的blog：http://gcblog.github.io</a></p>"},{"title":"etcd在golang中的使用","date":"2018-07-05T11:35:05.000Z","_content":"\n## 什么是etcd\n\nETCD是用于共享配置和服务发现的分布式，一致性的KV存储系统\netcd作为一个受到ZooKeeper与doozer启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。\n\t1.\t简单：基于HTTP+JSON的API让你用curl就可以轻松使用。\n\t2.\t安全：可选SSL客户认证机制。\n\t3.\t快速：每个实例每秒支持一千次写操作。\n\t4.\t可信：使用Raft算法充分实现了分布式。\n\t\n!<--more-->\n\t\n## 安装\n\n在如下路径创建文件夹\n`$ mkdir -p $GOPATH/src/github.com/coreos`\n\n下载etcd包\n`$ git clone https://github.com/coreos/etcd.git`\n\n下载完后，然后依次执行下面命令\n```\n$ cd etcd\n$ ./build\n$ ./bin/etcd\n```\n\n## 代码实现\n\n```\npackage main\n\nimport (\n\t\"time\"\n\t\"github.com/coreos/etcd/clientv3\"\n\t\"fmt\"\n\t\"context\"\n\t\"github.com/coreos/etcd/mvcc/mvccpb\"\n\t\"ketang/netWork/0604_Socket/Tool\"\n)\n\nvar (\n\tdialTimeout = 5 * time.Second\n\trequestTimeout = 2 * time.Second\n\tendPoints = []string{\"127.0.0.1:2379\"} //etcd 默认接受数据的端口2379\n)\n//添加 删除 查找 前缀 延时\n\nvar etcd *clientv3.Client\nfunc main()  {\n\tfmt.Println(Tool.GetLocalIp())\n\tvar err error\n\tetcd, err =clientv3.New(clientv3.Config{\n\t\tEndpoints:endPoints,\n\t\tDialTimeout:dialTimeout,\n\n\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\t\n\t//添加\n\terr = putValue(\"a\", \"abc\")\n\tfmt.Println(err)\n\n\t//查找\n\tresult := getValue(\"a\")\n\tfmt.Println(result)\n\n\t//删除\n\tcnt := delValue(\"a\")\n\tfmt.Println(\"delete:\", cnt)\n\n\n\terr = putValue(\"b1\", \"abc1\")\n\terr = putValue(\"b2\", \"abc2\")\n\terr = putValue(\"b3\", \"abc3\")\n\n\t//按前缀查找\n\tresult = getValueWIthPrefix(\"b\")\n\tfmt.Println(result)\n\tfor _,item := range result {\n\t\tfmt.Println(string(item.Key),string(item.Value))\n\t}\n\n\t//按前缀删除\n\tcnt2 := delValueWithPrefix(\"b\")\n\tfmt.Println(\"批量删除：\", cnt2)\n\n\n\n\t//事务处理\n\tputValue(\"user1\", \"zhangsan\")\n\t_,err = etcd.Txn(context.TODO()).\n\t\tIf(clientv3.Compare(clientv3.Value(\"user1\"),\"=\", \"zhangsan\")).\n\t\tThen(clientv3.OpPut(\"user1\", \"zhangsan\")).\n\t\tElse(clientv3.OpPut(\"user1\", \"lisi\")).Commit()\n\n\tfmt.Println(err)\n\tresult = getValue(\"user1\")\n\tfmt.Println(\"user1:\", string(result[0].Value))\n\n\n\t//lease 设置有效时间\n\tresp, err:= etcd.Grant(context.TODO(), 1)\n\t_,err = etcd.Put(context.TODO(), \"username\",\"wangwu\",clientv3.WithLease(resp.ID))\n\n\ttime.Sleep(3 * time.Second)\n\n\tv := getValue(\"username\")\n\tfmt.Println(\"lease:\",v)\n\n\n\t//watch监听的使用\n\tputValue(\"w\", \"hello\")\n\tgo func() {\n\t\trch := etcd.Watch(context.Background(),\"w\")\n\t\tfor wresp := range  rch {\n\t\t\tfor _,ev := range wresp.Events {\n\t\t\t\tfmt.Printf(\"watch>>w  %s %q %q\\n\", ev.Type,ev.Kv, ev.Kv)\n\t\t\t}\n\t\t}\n\t}()\n\n\tputValue(\"w\", \"hello world!\")\n\n\n\n\t//监听某个key在一定范围内 value的变化\n\t//putValue(\"fo0\", \"a\")\n\tgo func() {\n\t\t//监听范围 [fo0-fo3)\n\t\trch := etcd.Watch(context.Background(), \"fo0\", clientv3.WithRange(\"fo3\"))\n\n\t\tfor wresp := range  rch {\n\t\t\tfor _,ev := range wresp.Events {\n\t\t\t\tfmt.Printf(\"watch range  --   %s %q %q\\n\", ev.Type,ev.Kv, ev.Kv)\n\t\t\t}\n\t\t}\n\t}()\n\n\tputValue(\"fo0\", \"b\")\n\tputValue(\"fo1\", \"b\")\n\tputValue(\"fo2\", \"c\")\n\tputValue(\"fo2.5\", \"c\")\n\tputValue(\"fo3\", \"c\")\n\n\t\n\ttime.Sleep(10 * time.Second)\n\n}\n\n\n//添加键值对\nfunc putValue(key, value string)  error  {\n\t_, err := etcd.Put(context.TODO(),key, value)\n\treturn err\n}\n\n//查询\nfunc getValue(key string) []*mvccpb.KeyValue  {\n\tresp, err := etcd.Get(context.TODO(), key)\n\tif err != nil {\n\t\treturn  nil\n\t} else {\n\t\treturn resp.Kvs\n\t}\n}\n\n// 返回删除了几条数据\nfunc delValue(key string) int64  {\n\tres,err := etcd.Delete(context.TODO(),key)\n\tif err != nil {\n\t\treturn 0\n\t} else {\n\t\treturn res.Deleted\n\t}\n\n}\n\n\n//按照前缀删除\nfunc delValueWithPrefix(prefix string) int64  {\n\tres,err := etcd.Delete(context.TODO(),prefix,clientv3.WithPrefix())\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn 0\n\t} else {\n\t\treturn res.Deleted\n\t}\n}\n\nfunc getValueWIthPrefix(prefix string) []*mvccpb.KeyValue {\n\tresp, err := etcd.Get(context.TODO(), prefix, clientv3.WithPrefix())\n\tif err != nil {\n\t\treturn  nil\n\t} else {\n\t\treturn resp.Kvs\n\t}\n}\n\n```\n\n\n","source":"_posts/etcd在golang中的使用.md","raw":"---\ntitle: etcd在golang中的使用\ncategories:\n  - 区块链\ntags:\n  - etcd\n  - 分布式\ndate: 2018-07-05 19:35:05\n---\n\n## 什么是etcd\n\nETCD是用于共享配置和服务发现的分布式，一致性的KV存储系统\netcd作为一个受到ZooKeeper与doozer启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。\n\t1.\t简单：基于HTTP+JSON的API让你用curl就可以轻松使用。\n\t2.\t安全：可选SSL客户认证机制。\n\t3.\t快速：每个实例每秒支持一千次写操作。\n\t4.\t可信：使用Raft算法充分实现了分布式。\n\t\n!<--more-->\n\t\n## 安装\n\n在如下路径创建文件夹\n`$ mkdir -p $GOPATH/src/github.com/coreos`\n\n下载etcd包\n`$ git clone https://github.com/coreos/etcd.git`\n\n下载完后，然后依次执行下面命令\n```\n$ cd etcd\n$ ./build\n$ ./bin/etcd\n```\n\n## 代码实现\n\n```\npackage main\n\nimport (\n\t\"time\"\n\t\"github.com/coreos/etcd/clientv3\"\n\t\"fmt\"\n\t\"context\"\n\t\"github.com/coreos/etcd/mvcc/mvccpb\"\n\t\"ketang/netWork/0604_Socket/Tool\"\n)\n\nvar (\n\tdialTimeout = 5 * time.Second\n\trequestTimeout = 2 * time.Second\n\tendPoints = []string{\"127.0.0.1:2379\"} //etcd 默认接受数据的端口2379\n)\n//添加 删除 查找 前缀 延时\n\nvar etcd *clientv3.Client\nfunc main()  {\n\tfmt.Println(Tool.GetLocalIp())\n\tvar err error\n\tetcd, err =clientv3.New(clientv3.Config{\n\t\tEndpoints:endPoints,\n\t\tDialTimeout:dialTimeout,\n\n\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\t\n\t//添加\n\terr = putValue(\"a\", \"abc\")\n\tfmt.Println(err)\n\n\t//查找\n\tresult := getValue(\"a\")\n\tfmt.Println(result)\n\n\t//删除\n\tcnt := delValue(\"a\")\n\tfmt.Println(\"delete:\", cnt)\n\n\n\terr = putValue(\"b1\", \"abc1\")\n\terr = putValue(\"b2\", \"abc2\")\n\terr = putValue(\"b3\", \"abc3\")\n\n\t//按前缀查找\n\tresult = getValueWIthPrefix(\"b\")\n\tfmt.Println(result)\n\tfor _,item := range result {\n\t\tfmt.Println(string(item.Key),string(item.Value))\n\t}\n\n\t//按前缀删除\n\tcnt2 := delValueWithPrefix(\"b\")\n\tfmt.Println(\"批量删除：\", cnt2)\n\n\n\n\t//事务处理\n\tputValue(\"user1\", \"zhangsan\")\n\t_,err = etcd.Txn(context.TODO()).\n\t\tIf(clientv3.Compare(clientv3.Value(\"user1\"),\"=\", \"zhangsan\")).\n\t\tThen(clientv3.OpPut(\"user1\", \"zhangsan\")).\n\t\tElse(clientv3.OpPut(\"user1\", \"lisi\")).Commit()\n\n\tfmt.Println(err)\n\tresult = getValue(\"user1\")\n\tfmt.Println(\"user1:\", string(result[0].Value))\n\n\n\t//lease 设置有效时间\n\tresp, err:= etcd.Grant(context.TODO(), 1)\n\t_,err = etcd.Put(context.TODO(), \"username\",\"wangwu\",clientv3.WithLease(resp.ID))\n\n\ttime.Sleep(3 * time.Second)\n\n\tv := getValue(\"username\")\n\tfmt.Println(\"lease:\",v)\n\n\n\t//watch监听的使用\n\tputValue(\"w\", \"hello\")\n\tgo func() {\n\t\trch := etcd.Watch(context.Background(),\"w\")\n\t\tfor wresp := range  rch {\n\t\t\tfor _,ev := range wresp.Events {\n\t\t\t\tfmt.Printf(\"watch>>w  %s %q %q\\n\", ev.Type,ev.Kv, ev.Kv)\n\t\t\t}\n\t\t}\n\t}()\n\n\tputValue(\"w\", \"hello world!\")\n\n\n\n\t//监听某个key在一定范围内 value的变化\n\t//putValue(\"fo0\", \"a\")\n\tgo func() {\n\t\t//监听范围 [fo0-fo3)\n\t\trch := etcd.Watch(context.Background(), \"fo0\", clientv3.WithRange(\"fo3\"))\n\n\t\tfor wresp := range  rch {\n\t\t\tfor _,ev := range wresp.Events {\n\t\t\t\tfmt.Printf(\"watch range  --   %s %q %q\\n\", ev.Type,ev.Kv, ev.Kv)\n\t\t\t}\n\t\t}\n\t}()\n\n\tputValue(\"fo0\", \"b\")\n\tputValue(\"fo1\", \"b\")\n\tputValue(\"fo2\", \"c\")\n\tputValue(\"fo2.5\", \"c\")\n\tputValue(\"fo3\", \"c\")\n\n\t\n\ttime.Sleep(10 * time.Second)\n\n}\n\n\n//添加键值对\nfunc putValue(key, value string)  error  {\n\t_, err := etcd.Put(context.TODO(),key, value)\n\treturn err\n}\n\n//查询\nfunc getValue(key string) []*mvccpb.KeyValue  {\n\tresp, err := etcd.Get(context.TODO(), key)\n\tif err != nil {\n\t\treturn  nil\n\t} else {\n\t\treturn resp.Kvs\n\t}\n}\n\n// 返回删除了几条数据\nfunc delValue(key string) int64  {\n\tres,err := etcd.Delete(context.TODO(),key)\n\tif err != nil {\n\t\treturn 0\n\t} else {\n\t\treturn res.Deleted\n\t}\n\n}\n\n\n//按照前缀删除\nfunc delValueWithPrefix(prefix string) int64  {\n\tres,err := etcd.Delete(context.TODO(),prefix,clientv3.WithPrefix())\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn 0\n\t} else {\n\t\treturn res.Deleted\n\t}\n}\n\nfunc getValueWIthPrefix(prefix string) []*mvccpb.KeyValue {\n\tresp, err := etcd.Get(context.TODO(), prefix, clientv3.WithPrefix())\n\tif err != nil {\n\t\treturn  nil\n\t} else {\n\t\treturn resp.Kvs\n\t}\n}\n\n```\n\n\n","slug":"etcd在golang中的使用","published":1,"updated":"2018-07-05T11:36:17.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5te0000plx60303bt08j","content":"<h2 id=\"什么是etcd\"><a href=\"#什么是etcd\" class=\"headerlink\" title=\"什么是etcd\"></a>什么是etcd</h2><p>ETCD是用于共享配置和服务发现的分布式，一致性的KV存储系统<br>etcd作为一个受到ZooKeeper与doozer启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。</p>\n<pre><code>1.    简单：基于HTTP+JSON的API让你用curl就可以轻松使用。\n2.    安全：可选SSL客户认证机制。\n3.    快速：每个实例每秒支持一千次写操作。\n4.    可信：使用Raft算法充分实现了分布式。\n</code></pre><p>!&lt;–more–&gt;</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>在如下路径创建文件夹<br><code>$ mkdir -p $GOPATH/src/github.com/coreos</code></p>\n<p>下载etcd包<br><code>$ git clone https://github.com/coreos/etcd.git</code></p>\n<p>下载完后，然后依次执行下面命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd etcd</div><div class=\"line\">$ ./build</div><div class=\"line\">$ ./bin/etcd</div></pre></td></tr></table></figure></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;time&quot;</div><div class=\"line\">\t&quot;github.com/coreos/etcd/clientv3&quot;</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;context&quot;</div><div class=\"line\">\t&quot;github.com/coreos/etcd/mvcc/mvccpb&quot;</div><div class=\"line\">\t&quot;ketang/netWork/0604_Socket/Tool&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">var (</div><div class=\"line\">\tdialTimeout = 5 * time.Second</div><div class=\"line\">\trequestTimeout = 2 * time.Second</div><div class=\"line\">\tendPoints = []string&#123;&quot;127.0.0.1:2379&quot;&#125; //etcd 默认接受数据的端口2379</div><div class=\"line\">)</div><div class=\"line\">//添加 删除 查找 前缀 延时</div><div class=\"line\"></div><div class=\"line\">var etcd *clientv3.Client</div><div class=\"line\">func main()  &#123;</div><div class=\"line\">\tfmt.Println(Tool.GetLocalIp())</div><div class=\"line\">\tvar err error</div><div class=\"line\">\tetcd, err =clientv3.New(clientv3.Config&#123;</div><div class=\"line\">\t\tEndpoints:endPoints,</div><div class=\"line\">\t\tDialTimeout:dialTimeout,</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t&#125;)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t//添加</div><div class=\"line\">\terr = putValue(&quot;a&quot;, &quot;abc&quot;)</div><div class=\"line\">\tfmt.Println(err)</div><div class=\"line\"></div><div class=\"line\">\t//查找</div><div class=\"line\">\tresult := getValue(&quot;a&quot;)</div><div class=\"line\">\tfmt.Println(result)</div><div class=\"line\"></div><div class=\"line\">\t//删除</div><div class=\"line\">\tcnt := delValue(&quot;a&quot;)</div><div class=\"line\">\tfmt.Println(&quot;delete:&quot;, cnt)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\terr = putValue(&quot;b1&quot;, &quot;abc1&quot;)</div><div class=\"line\">\terr = putValue(&quot;b2&quot;, &quot;abc2&quot;)</div><div class=\"line\">\terr = putValue(&quot;b3&quot;, &quot;abc3&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//按前缀查找</div><div class=\"line\">\tresult = getValueWIthPrefix(&quot;b&quot;)</div><div class=\"line\">\tfmt.Println(result)</div><div class=\"line\">\tfor _,item := range result &#123;</div><div class=\"line\">\t\tfmt.Println(string(item.Key),string(item.Value))</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t//按前缀删除</div><div class=\"line\">\tcnt2 := delValueWithPrefix(&quot;b&quot;)</div><div class=\"line\">\tfmt.Println(&quot;批量删除：&quot;, cnt2)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//事务处理</div><div class=\"line\">\tputValue(&quot;user1&quot;, &quot;zhangsan&quot;)</div><div class=\"line\">\t_,err = etcd.Txn(context.TODO()).</div><div class=\"line\">\t\tIf(clientv3.Compare(clientv3.Value(&quot;user1&quot;),&quot;=&quot;, &quot;zhangsan&quot;)).</div><div class=\"line\">\t\tThen(clientv3.OpPut(&quot;user1&quot;, &quot;zhangsan&quot;)).</div><div class=\"line\">\t\tElse(clientv3.OpPut(&quot;user1&quot;, &quot;lisi&quot;)).Commit()</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(err)</div><div class=\"line\">\tresult = getValue(&quot;user1&quot;)</div><div class=\"line\">\tfmt.Println(&quot;user1:&quot;, string(result[0].Value))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//lease 设置有效时间</div><div class=\"line\">\tresp, err:= etcd.Grant(context.TODO(), 1)</div><div class=\"line\">\t_,err = etcd.Put(context.TODO(), &quot;username&quot;,&quot;wangwu&quot;,clientv3.WithLease(resp.ID))</div><div class=\"line\"></div><div class=\"line\">\ttime.Sleep(3 * time.Second)</div><div class=\"line\"></div><div class=\"line\">\tv := getValue(&quot;username&quot;)</div><div class=\"line\">\tfmt.Println(&quot;lease:&quot;,v)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//watch监听的使用</div><div class=\"line\">\tputValue(&quot;w&quot;, &quot;hello&quot;)</div><div class=\"line\">\tgo func() &#123;</div><div class=\"line\">\t\trch := etcd.Watch(context.Background(),&quot;w&quot;)</div><div class=\"line\">\t\tfor wresp := range  rch &#123;</div><div class=\"line\">\t\t\tfor _,ev := range wresp.Events &#123;</div><div class=\"line\">\t\t\t\tfmt.Printf(&quot;watch&gt;&gt;w  %s %q %q\\n&quot;, ev.Type,ev.Kv, ev.Kv)</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;()</div><div class=\"line\"></div><div class=\"line\">\tputValue(&quot;w&quot;, &quot;hello world!&quot;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//监听某个key在一定范围内 value的变化</div><div class=\"line\">\t//putValue(&quot;fo0&quot;, &quot;a&quot;)</div><div class=\"line\">\tgo func() &#123;</div><div class=\"line\">\t\t//监听范围 [fo0-fo3)</div><div class=\"line\">\t\trch := etcd.Watch(context.Background(), &quot;fo0&quot;, clientv3.WithRange(&quot;fo3&quot;))</div><div class=\"line\"></div><div class=\"line\">\t\tfor wresp := range  rch &#123;</div><div class=\"line\">\t\t\tfor _,ev := range wresp.Events &#123;</div><div class=\"line\">\t\t\t\tfmt.Printf(&quot;watch range  --   %s %q %q\\n&quot;, ev.Type,ev.Kv, ev.Kv)</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;()</div><div class=\"line\"></div><div class=\"line\">\tputValue(&quot;fo0&quot;, &quot;b&quot;)</div><div class=\"line\">\tputValue(&quot;fo1&quot;, &quot;b&quot;)</div><div class=\"line\">\tputValue(&quot;fo2&quot;, &quot;c&quot;)</div><div class=\"line\">\tputValue(&quot;fo2.5&quot;, &quot;c&quot;)</div><div class=\"line\">\tputValue(&quot;fo3&quot;, &quot;c&quot;)</div><div class=\"line\"></div><div class=\"line\">\t</div><div class=\"line\">\ttime.Sleep(10 * time.Second)</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//添加键值对</div><div class=\"line\">func putValue(key, value string)  error  &#123;</div><div class=\"line\">\t_, err := etcd.Put(context.TODO(),key, value)</div><div class=\"line\">\treturn err</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//查询</div><div class=\"line\">func getValue(key string) []*mvccpb.KeyValue  &#123;</div><div class=\"line\">\tresp, err := etcd.Get(context.TODO(), key)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\treturn  nil</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\treturn resp.Kvs</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 返回删除了几条数据</div><div class=\"line\">func delValue(key string) int64  &#123;</div><div class=\"line\">\tres,err := etcd.Delete(context.TODO(),key)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\treturn 0</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\treturn res.Deleted</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//按照前缀删除</div><div class=\"line\">func delValueWithPrefix(prefix string) int64  &#123;</div><div class=\"line\">\tres,err := etcd.Delete(context.TODO(),prefix,clientv3.WithPrefix())</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t\treturn 0</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\treturn res.Deleted</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func getValueWIthPrefix(prefix string) []*mvccpb.KeyValue &#123;</div><div class=\"line\">\tresp, err := etcd.Get(context.TODO(), prefix, clientv3.WithPrefix())</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\treturn  nil</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\treturn resp.Kvs</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"什么是etcd\"><a href=\"#什么是etcd\" class=\"headerlink\" title=\"什么是etcd\"></a>什么是etcd</h2><p>ETCD是用于共享配置和服务发现的分布式，一致性的KV存储系统<br>etcd作为一个受到ZooKeeper与doozer启发而催生的项目，除了拥有与之类似的功能外，更专注于以下四点。</p>\n<pre><code>1.    简单：基于HTTP+JSON的API让你用curl就可以轻松使用。\n2.    安全：可选SSL客户认证机制。\n3.    快速：每个实例每秒支持一千次写操作。\n4.    可信：使用Raft算法充分实现了分布式。\n</code></pre><p>!&lt;–more–&gt;</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>在如下路径创建文件夹<br><code>$ mkdir -p $GOPATH/src/github.com/coreos</code></p>\n<p>下载etcd包<br><code>$ git clone https://github.com/coreos/etcd.git</code></p>\n<p>下载完后，然后依次执行下面命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd etcd</div><div class=\"line\">$ ./build</div><div class=\"line\">$ ./bin/etcd</div></pre></td></tr></table></figure></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;time&quot;</div><div class=\"line\">\t&quot;github.com/coreos/etcd/clientv3&quot;</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;context&quot;</div><div class=\"line\">\t&quot;github.com/coreos/etcd/mvcc/mvccpb&quot;</div><div class=\"line\">\t&quot;ketang/netWork/0604_Socket/Tool&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">var (</div><div class=\"line\">\tdialTimeout = 5 * time.Second</div><div class=\"line\">\trequestTimeout = 2 * time.Second</div><div class=\"line\">\tendPoints = []string&#123;&quot;127.0.0.1:2379&quot;&#125; //etcd 默认接受数据的端口2379</div><div class=\"line\">)</div><div class=\"line\">//添加 删除 查找 前缀 延时</div><div class=\"line\"></div><div class=\"line\">var etcd *clientv3.Client</div><div class=\"line\">func main()  &#123;</div><div class=\"line\">\tfmt.Println(Tool.GetLocalIp())</div><div class=\"line\">\tvar err error</div><div class=\"line\">\tetcd, err =clientv3.New(clientv3.Config&#123;</div><div class=\"line\">\t\tEndpoints:endPoints,</div><div class=\"line\">\t\tDialTimeout:dialTimeout,</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t&#125;)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\t//添加</div><div class=\"line\">\terr = putValue(&quot;a&quot;, &quot;abc&quot;)</div><div class=\"line\">\tfmt.Println(err)</div><div class=\"line\"></div><div class=\"line\">\t//查找</div><div class=\"line\">\tresult := getValue(&quot;a&quot;)</div><div class=\"line\">\tfmt.Println(result)</div><div class=\"line\"></div><div class=\"line\">\t//删除</div><div class=\"line\">\tcnt := delValue(&quot;a&quot;)</div><div class=\"line\">\tfmt.Println(&quot;delete:&quot;, cnt)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\terr = putValue(&quot;b1&quot;, &quot;abc1&quot;)</div><div class=\"line\">\terr = putValue(&quot;b2&quot;, &quot;abc2&quot;)</div><div class=\"line\">\terr = putValue(&quot;b3&quot;, &quot;abc3&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//按前缀查找</div><div class=\"line\">\tresult = getValueWIthPrefix(&quot;b&quot;)</div><div class=\"line\">\tfmt.Println(result)</div><div class=\"line\">\tfor _,item := range result &#123;</div><div class=\"line\">\t\tfmt.Println(string(item.Key),string(item.Value))</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t//按前缀删除</div><div class=\"line\">\tcnt2 := delValueWithPrefix(&quot;b&quot;)</div><div class=\"line\">\tfmt.Println(&quot;批量删除：&quot;, cnt2)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//事务处理</div><div class=\"line\">\tputValue(&quot;user1&quot;, &quot;zhangsan&quot;)</div><div class=\"line\">\t_,err = etcd.Txn(context.TODO()).</div><div class=\"line\">\t\tIf(clientv3.Compare(clientv3.Value(&quot;user1&quot;),&quot;=&quot;, &quot;zhangsan&quot;)).</div><div class=\"line\">\t\tThen(clientv3.OpPut(&quot;user1&quot;, &quot;zhangsan&quot;)).</div><div class=\"line\">\t\tElse(clientv3.OpPut(&quot;user1&quot;, &quot;lisi&quot;)).Commit()</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(err)</div><div class=\"line\">\tresult = getValue(&quot;user1&quot;)</div><div class=\"line\">\tfmt.Println(&quot;user1:&quot;, string(result[0].Value))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//lease 设置有效时间</div><div class=\"line\">\tresp, err:= etcd.Grant(context.TODO(), 1)</div><div class=\"line\">\t_,err = etcd.Put(context.TODO(), &quot;username&quot;,&quot;wangwu&quot;,clientv3.WithLease(resp.ID))</div><div class=\"line\"></div><div class=\"line\">\ttime.Sleep(3 * time.Second)</div><div class=\"line\"></div><div class=\"line\">\tv := getValue(&quot;username&quot;)</div><div class=\"line\">\tfmt.Println(&quot;lease:&quot;,v)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//watch监听的使用</div><div class=\"line\">\tputValue(&quot;w&quot;, &quot;hello&quot;)</div><div class=\"line\">\tgo func() &#123;</div><div class=\"line\">\t\trch := etcd.Watch(context.Background(),&quot;w&quot;)</div><div class=\"line\">\t\tfor wresp := range  rch &#123;</div><div class=\"line\">\t\t\tfor _,ev := range wresp.Events &#123;</div><div class=\"line\">\t\t\t\tfmt.Printf(&quot;watch&gt;&gt;w  %s %q %q\\n&quot;, ev.Type,ev.Kv, ev.Kv)</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;()</div><div class=\"line\"></div><div class=\"line\">\tputValue(&quot;w&quot;, &quot;hello world!&quot;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//监听某个key在一定范围内 value的变化</div><div class=\"line\">\t//putValue(&quot;fo0&quot;, &quot;a&quot;)</div><div class=\"line\">\tgo func() &#123;</div><div class=\"line\">\t\t//监听范围 [fo0-fo3)</div><div class=\"line\">\t\trch := etcd.Watch(context.Background(), &quot;fo0&quot;, clientv3.WithRange(&quot;fo3&quot;))</div><div class=\"line\"></div><div class=\"line\">\t\tfor wresp := range  rch &#123;</div><div class=\"line\">\t\t\tfor _,ev := range wresp.Events &#123;</div><div class=\"line\">\t\t\t\tfmt.Printf(&quot;watch range  --   %s %q %q\\n&quot;, ev.Type,ev.Kv, ev.Kv)</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;()</div><div class=\"line\"></div><div class=\"line\">\tputValue(&quot;fo0&quot;, &quot;b&quot;)</div><div class=\"line\">\tputValue(&quot;fo1&quot;, &quot;b&quot;)</div><div class=\"line\">\tputValue(&quot;fo2&quot;, &quot;c&quot;)</div><div class=\"line\">\tputValue(&quot;fo2.5&quot;, &quot;c&quot;)</div><div class=\"line\">\tputValue(&quot;fo3&quot;, &quot;c&quot;)</div><div class=\"line\"></div><div class=\"line\">\t</div><div class=\"line\">\ttime.Sleep(10 * time.Second)</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//添加键值对</div><div class=\"line\">func putValue(key, value string)  error  &#123;</div><div class=\"line\">\t_, err := etcd.Put(context.TODO(),key, value)</div><div class=\"line\">\treturn err</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//查询</div><div class=\"line\">func getValue(key string) []*mvccpb.KeyValue  &#123;</div><div class=\"line\">\tresp, err := etcd.Get(context.TODO(), key)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\treturn  nil</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\treturn resp.Kvs</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 返回删除了几条数据</div><div class=\"line\">func delValue(key string) int64  &#123;</div><div class=\"line\">\tres,err := etcd.Delete(context.TODO(),key)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\treturn 0</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\treturn res.Deleted</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//按照前缀删除</div><div class=\"line\">func delValueWithPrefix(prefix string) int64  &#123;</div><div class=\"line\">\tres,err := etcd.Delete(context.TODO(),prefix,clientv3.WithPrefix())</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t\treturn 0</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\treturn res.Deleted</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func getValueWIthPrefix(prefix string) []*mvccpb.KeyValue &#123;</div><div class=\"line\">\tresp, err := etcd.Get(context.TODO(), prefix, clientv3.WithPrefix())</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\treturn  nil</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\treturn resp.Kvs</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"etcd多台服务器集群环境搭建使用","date":"2018-07-05T11:41:22.000Z","_content":"\n\n## 下载安装 etcd\n\n```\n$ mkdir -p $GOPATH/src/github.com/coreos\n$ git clone https://github.com/coreos/etcd.git\n$ cd etcd\n$ ./build\n```\n\n<!--more-->\n\n## 启动服务\n\n每个节点都要执行以下配置，HOST_1、HOST_2、HOST_3 分别设置为多台服务器的IP\n\n进入到bin目录下\n`$ cd $GOPATH/src/github.com/coreos/etcd/bin`\n\n3个ip分别换成3太服务器真实的ip\n\n```\nTOKEN=token-03\nCLUSTER_STATE=new\nNAME_1=machine-1\nNAME_2=machine-2\nNAME_3=machine-3\nHOST_1=192.168.1.105\nHOST_2=192.168.1.143\nHOST_3=192.168.1.103\nCLUSTER=${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380\n```\n\n**machine 1** 执行如下命令\n\n```\n$ cd $GOPATH/src/github.com/coreos/etcd/bin\n\n# For machine 1\nTHIS_NAME=${NAME_1}\nTHIS_IP=${HOST_1}\n./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}\n\n```\n\n**machine 2** 执行如下命令\n\n```\n$ cd $GOPATH/src/github.com/coreos/etcd/bin\n\n# For machine 2\nTHIS_NAME=${NAME_2}\nTHIS_IP=${HOST_2}\n./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}\n\n```\n\n**machine 3** 执行如下命令\n\n```\n$ cd $GOPATH/src/github.com/coreos/etcd/bin\n\n# For machine 3\nTHIS_NAME=${NAME_3}\nTHIS_IP=${HOST_3}\n./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}\n```\n\n检测服务器运行是否正常\n\n3个ip分别换成3太服务器真实的ip\n\n```\n$ cd $GOPATH/src/github.com/coreos/etcd/bin\n\nexport ETCDCTL_API=3\nHOST_1=192.168.1.105\nHOST_2=192.168.1.143\nHOST_3=192.168.1.103\nENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379\n```\n\n查看进入集群的服务器列表\n`./etcdctl --endpoints=$ENDPOINTS member list`\n\n## 存储数据\n\n```\n./etcdctl --endpoints=$ENDPOINTS put foo \"Hello World!\"\n\n./etcdctl --endpoints=$ENDPOINTS get foo\n./etcdctl --endpoints=$ENDPOINTS --write-out=\"json\" get foo\n```\n\n## 根据前缀查询\n\n```\n./etcdctl --endpoints=$ENDPOINTS put web1 value1\n./etcdctl --endpoints=$ENDPOINTS put web2 value2\n./etcdctl --endpoints=$ENDPOINTS put web3 value3\n\n./etcdctl --endpoints=$ENDPOINTS get web --prefix\n\nweb1\nvalue1\nweb2\nvalue2\nweb3\nvalue3\n```\n\n## 删除\n\n```\n./etcdctl --endpoints=$ENDPOINTS put key myvalue\n./etcdctl --endpoints=$ENDPOINTS del key\n\n./etcdctl --endpoints=$ENDPOINTS put k1 value1\n./etcdctl --endpoints=$ENDPOINTS put k2 value2\n./etcdctl --endpoints=$ENDPOINTS del k --prefix\n```\n\n## 事务写入\n\n```\n$ ./etcdctl --endpoints=$ENDPOINTS put user1 bad\nOK\n\n$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive\n\ncompares:\n// 输入以下内容，输入结束按 两次回车\nvalue(\"user1\") = \"bad\"      \n\n//如果 user1 = bad，则执行 get user1 \nsuccess requests (get, put, del):\nget user1\n\n//如果 user1 != bad，则执行 put user1 good\nfailure requests (get, put, del):\nput user1 good\n\n// 运行结果，执行 success\nSUCCESS\n\nuser1\nbad\n\n\n$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive\ncompares:\nvalue(\"user1\") = \"111\"  \n\n// 如果 user1 = 111，则执行 get user1 \nsuccess requests (get, put, del):\nget user1\n\n//如果 user1 != 111，则执行 put user1 2222\nfailure requests (get, put, del):\nput user1 2222\n\n// 运行结果，执行 failure\nFAILURE\n\nOK\n\n$ ./etcdctl --endpoints=$ENDPOINTS get user1\nuser1\n2222\n```\n\n## watch \n\n```\n// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知\n./etcdctl --endpoints=$ENDPOINTS watch stock1\n\n// 新打开终端\n$ cd $GOPATH/src/github.com/coreos/etcd/bin\n\nexport ETCDCTL_API=3\nHOST_1=192.168.1.126\nHOST_2=192.168.1.119\nHOST_3=192.168.1.103\nENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379\n./etcdctl --endpoints=$ENDPOINTS put stock1 1000\n\n./etcdctl --endpoints=$ENDPOINTS watch stock --prefix\n\n./etcdctl --endpoints=$ENDPOINTS put stock1 10\n./etcdctl --endpoints=$ENDPOINTS put stock2 20\n```\n\n## 更多操作\n\nhttps://coreos.com/etcd/docs/latest/demo.html\n\n\n\n\n","source":"_posts/etcd多台服务器集群环境搭建使用.md","raw":"---\ntitle: etcd多台服务器集群环境搭建使用\ncategories:\n  - 区块链\ntags:\n  - etcd\n  - 分布式\n  - 服务器集群\ndate: 2018-07-05 19:41:22\n---\n\n\n## 下载安装 etcd\n\n```\n$ mkdir -p $GOPATH/src/github.com/coreos\n$ git clone https://github.com/coreos/etcd.git\n$ cd etcd\n$ ./build\n```\n\n<!--more-->\n\n## 启动服务\n\n每个节点都要执行以下配置，HOST_1、HOST_2、HOST_3 分别设置为多台服务器的IP\n\n进入到bin目录下\n`$ cd $GOPATH/src/github.com/coreos/etcd/bin`\n\n3个ip分别换成3太服务器真实的ip\n\n```\nTOKEN=token-03\nCLUSTER_STATE=new\nNAME_1=machine-1\nNAME_2=machine-2\nNAME_3=machine-3\nHOST_1=192.168.1.105\nHOST_2=192.168.1.143\nHOST_3=192.168.1.103\nCLUSTER=${NAME_1}=http://${HOST_1}:2380,${NAME_2}=http://${HOST_2}:2380,${NAME_3}=http://${HOST_3}:2380\n```\n\n**machine 1** 执行如下命令\n\n```\n$ cd $GOPATH/src/github.com/coreos/etcd/bin\n\n# For machine 1\nTHIS_NAME=${NAME_1}\nTHIS_IP=${HOST_1}\n./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}\n\n```\n\n**machine 2** 执行如下命令\n\n```\n$ cd $GOPATH/src/github.com/coreos/etcd/bin\n\n# For machine 2\nTHIS_NAME=${NAME_2}\nTHIS_IP=${HOST_2}\n./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}\n\n```\n\n**machine 3** 执行如下命令\n\n```\n$ cd $GOPATH/src/github.com/coreos/etcd/bin\n\n# For machine 3\nTHIS_NAME=${NAME_3}\nTHIS_IP=${HOST_3}\n./etcd --data-dir=data.etcd --name ${THIS_NAME} --initial-advertise-peer-urls http://${THIS_IP}:2380 --listen-peer-urls http://${THIS_IP}:2380 --advertise-client-urls http://${THIS_IP}:2379 --listen-client-urls http://${THIS_IP}:2379 --initial-cluster ${CLUSTER} --initial-cluster-state ${CLUSTER_STATE} --initial-cluster-token ${TOKEN}\n```\n\n检测服务器运行是否正常\n\n3个ip分别换成3太服务器真实的ip\n\n```\n$ cd $GOPATH/src/github.com/coreos/etcd/bin\n\nexport ETCDCTL_API=3\nHOST_1=192.168.1.105\nHOST_2=192.168.1.143\nHOST_3=192.168.1.103\nENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379\n```\n\n查看进入集群的服务器列表\n`./etcdctl --endpoints=$ENDPOINTS member list`\n\n## 存储数据\n\n```\n./etcdctl --endpoints=$ENDPOINTS put foo \"Hello World!\"\n\n./etcdctl --endpoints=$ENDPOINTS get foo\n./etcdctl --endpoints=$ENDPOINTS --write-out=\"json\" get foo\n```\n\n## 根据前缀查询\n\n```\n./etcdctl --endpoints=$ENDPOINTS put web1 value1\n./etcdctl --endpoints=$ENDPOINTS put web2 value2\n./etcdctl --endpoints=$ENDPOINTS put web3 value3\n\n./etcdctl --endpoints=$ENDPOINTS get web --prefix\n\nweb1\nvalue1\nweb2\nvalue2\nweb3\nvalue3\n```\n\n## 删除\n\n```\n./etcdctl --endpoints=$ENDPOINTS put key myvalue\n./etcdctl --endpoints=$ENDPOINTS del key\n\n./etcdctl --endpoints=$ENDPOINTS put k1 value1\n./etcdctl --endpoints=$ENDPOINTS put k2 value2\n./etcdctl --endpoints=$ENDPOINTS del k --prefix\n```\n\n## 事务写入\n\n```\n$ ./etcdctl --endpoints=$ENDPOINTS put user1 bad\nOK\n\n$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive\n\ncompares:\n// 输入以下内容，输入结束按 两次回车\nvalue(\"user1\") = \"bad\"      \n\n//如果 user1 = bad，则执行 get user1 \nsuccess requests (get, put, del):\nget user1\n\n//如果 user1 != bad，则执行 put user1 good\nfailure requests (get, put, del):\nput user1 good\n\n// 运行结果，执行 success\nSUCCESS\n\nuser1\nbad\n\n\n$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive\ncompares:\nvalue(\"user1\") = \"111\"  \n\n// 如果 user1 = 111，则执行 get user1 \nsuccess requests (get, put, del):\nget user1\n\n//如果 user1 != 111，则执行 put user1 2222\nfailure requests (get, put, del):\nput user1 2222\n\n// 运行结果，执行 failure\nFAILURE\n\nOK\n\n$ ./etcdctl --endpoints=$ENDPOINTS get user1\nuser1\n2222\n```\n\n## watch \n\n```\n// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知\n./etcdctl --endpoints=$ENDPOINTS watch stock1\n\n// 新打开终端\n$ cd $GOPATH/src/github.com/coreos/etcd/bin\n\nexport ETCDCTL_API=3\nHOST_1=192.168.1.126\nHOST_2=192.168.1.119\nHOST_3=192.168.1.103\nENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379\n./etcdctl --endpoints=$ENDPOINTS put stock1 1000\n\n./etcdctl --endpoints=$ENDPOINTS watch stock --prefix\n\n./etcdctl --endpoints=$ENDPOINTS put stock1 10\n./etcdctl --endpoints=$ENDPOINTS put stock2 20\n```\n\n## 更多操作\n\nhttps://coreos.com/etcd/docs/latest/demo.html\n\n\n\n\n","slug":"etcd多台服务器集群环境搭建使用","published":1,"updated":"2018-07-05T11:42:35.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5te2000tlx60w9ylsric","content":"<h2 id=\"下载安装-etcd\"><a href=\"#下载安装-etcd\" class=\"headerlink\" title=\"下载安装 etcd\"></a>下载安装 etcd</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mkdir -p $GOPATH/src/github.com/coreos</div><div class=\"line\">$ git clone https://github.com/coreos/etcd.git</div><div class=\"line\">$ cd etcd</div><div class=\"line\">$ ./build</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><p>每个节点都要执行以下配置，HOST_1、HOST_2、HOST_3 分别设置为多台服务器的IP</p>\n<p>进入到bin目录下<br><code>$ cd $GOPATH/src/github.com/coreos/etcd/bin</code></p>\n<p>3个ip分别换成3太服务器真实的ip</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">TOKEN=token-03</div><div class=\"line\">CLUSTER_STATE=new</div><div class=\"line\">NAME_1=machine-1</div><div class=\"line\">NAME_2=machine-2</div><div class=\"line\">NAME_3=machine-3</div><div class=\"line\">HOST_1=192.168.1.105</div><div class=\"line\">HOST_2=192.168.1.143</div><div class=\"line\">HOST_3=192.168.1.103</div><div class=\"line\">CLUSTER=$&#123;NAME_1&#125;=http://$&#123;HOST_1&#125;:2380,$&#123;NAME_2&#125;=http://$&#123;HOST_2&#125;:2380,$&#123;NAME_3&#125;=http://$&#123;HOST_3&#125;:2380</div></pre></td></tr></table></figure>\n<p><strong>machine 1</strong> 执行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd $GOPATH/src/github.com/coreos/etcd/bin</div><div class=\"line\"></div><div class=\"line\"># For machine 1</div><div class=\"line\">THIS_NAME=$&#123;NAME_1&#125;</div><div class=\"line\">THIS_IP=$&#123;HOST_1&#125;</div><div class=\"line\">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</div></pre></td></tr></table></figure>\n<p><strong>machine 2</strong> 执行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd $GOPATH/src/github.com/coreos/etcd/bin</div><div class=\"line\"></div><div class=\"line\"># For machine 2</div><div class=\"line\">THIS_NAME=$&#123;NAME_2&#125;</div><div class=\"line\">THIS_IP=$&#123;HOST_2&#125;</div><div class=\"line\">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</div></pre></td></tr></table></figure>\n<p><strong>machine 3</strong> 执行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd $GOPATH/src/github.com/coreos/etcd/bin</div><div class=\"line\"></div><div class=\"line\"># For machine 3</div><div class=\"line\">THIS_NAME=$&#123;NAME_3&#125;</div><div class=\"line\">THIS_IP=$&#123;HOST_3&#125;</div><div class=\"line\">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</div></pre></td></tr></table></figure>\n<p>检测服务器运行是否正常</p>\n<p>3个ip分别换成3太服务器真实的ip</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd $GOPATH/src/github.com/coreos/etcd/bin</div><div class=\"line\"></div><div class=\"line\">export ETCDCTL_API=3</div><div class=\"line\">HOST_1=192.168.1.105</div><div class=\"line\">HOST_2=192.168.1.143</div><div class=\"line\">HOST_3=192.168.1.103</div><div class=\"line\">ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379</div></pre></td></tr></table></figure>\n<p>查看进入集群的服务器列表<br><code>./etcdctl --endpoints=$ENDPOINTS member list</code></p>\n<h2 id=\"存储数据\"><a href=\"#存储数据\" class=\"headerlink\" title=\"存储数据\"></a>存储数据</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put foo &quot;Hello World!&quot;</div><div class=\"line\"></div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS get foo</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS --write-out=&quot;json&quot; get foo</div></pre></td></tr></table></figure>\n<h2 id=\"根据前缀查询\"><a href=\"#根据前缀查询\" class=\"headerlink\" title=\"根据前缀查询\"></a>根据前缀查询</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put web1 value1</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put web2 value2</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put web3 value3</div><div class=\"line\"></div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS get web --prefix</div><div class=\"line\"></div><div class=\"line\">web1</div><div class=\"line\">value1</div><div class=\"line\">web2</div><div class=\"line\">value2</div><div class=\"line\">web3</div><div class=\"line\">value3</div></pre></td></tr></table></figure>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put key myvalue</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS del key</div><div class=\"line\"></div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put k1 value1</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put k2 value2</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS del k --prefix</div></pre></td></tr></table></figure>\n<h2 id=\"事务写入\"><a href=\"#事务写入\" class=\"headerlink\" title=\"事务写入\"></a>事务写入</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ./etcdctl --endpoints=$ENDPOINTS put user1 bad</div><div class=\"line\">OK</div><div class=\"line\"></div><div class=\"line\">$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive</div><div class=\"line\"></div><div class=\"line\">compares:</div><div class=\"line\">// 输入以下内容，输入结束按 两次回车</div><div class=\"line\">value(&quot;user1&quot;) = &quot;bad&quot;      </div><div class=\"line\"></div><div class=\"line\">//如果 user1 = bad，则执行 get user1 </div><div class=\"line\">success requests (get, put, del):</div><div class=\"line\">get user1</div><div class=\"line\"></div><div class=\"line\">//如果 user1 != bad，则执行 put user1 good</div><div class=\"line\">failure requests (get, put, del):</div><div class=\"line\">put user1 good</div><div class=\"line\"></div><div class=\"line\">// 运行结果，执行 success</div><div class=\"line\">SUCCESS</div><div class=\"line\"></div><div class=\"line\">user1</div><div class=\"line\">bad</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive</div><div class=\"line\">compares:</div><div class=\"line\">value(&quot;user1&quot;) = &quot;111&quot;  </div><div class=\"line\"></div><div class=\"line\">// 如果 user1 = 111，则执行 get user1 </div><div class=\"line\">success requests (get, put, del):</div><div class=\"line\">get user1</div><div class=\"line\"></div><div class=\"line\">//如果 user1 != 111，则执行 put user1 2222</div><div class=\"line\">failure requests (get, put, del):</div><div class=\"line\">put user1 2222</div><div class=\"line\"></div><div class=\"line\">// 运行结果，执行 failure</div><div class=\"line\">FAILURE</div><div class=\"line\"></div><div class=\"line\">OK</div><div class=\"line\"></div><div class=\"line\">$ ./etcdctl --endpoints=$ENDPOINTS get user1</div><div class=\"line\">user1</div><div class=\"line\">2222</div></pre></td></tr></table></figure>\n<h2 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS watch stock1</div><div class=\"line\"></div><div class=\"line\">// 新打开终端</div><div class=\"line\">$ cd $GOPATH/src/github.com/coreos/etcd/bin</div><div class=\"line\"></div><div class=\"line\">export ETCDCTL_API=3</div><div class=\"line\">HOST_1=192.168.1.126</div><div class=\"line\">HOST_2=192.168.1.119</div><div class=\"line\">HOST_3=192.168.1.103</div><div class=\"line\">ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put stock1 1000</div><div class=\"line\"></div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS watch stock --prefix</div><div class=\"line\"></div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put stock1 10</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put stock2 20</div></pre></td></tr></table></figure>\n<h2 id=\"更多操作\"><a href=\"#更多操作\" class=\"headerlink\" title=\"更多操作\"></a>更多操作</h2><p><a href=\"https://coreos.com/etcd/docs/latest/demo.html\" target=\"_blank\" rel=\"external\">https://coreos.com/etcd/docs/latest/demo.html</a></p>\n","excerpt":"<h2 id=\"下载安装-etcd\"><a href=\"#下载安装-etcd\" class=\"headerlink\" title=\"下载安装 etcd\"></a>下载安装 etcd</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ mkdir -p $GOPATH/src/github.com/coreos</div><div class=\"line\">$ git clone https://github.com/coreos/etcd.git</div><div class=\"line\">$ cd etcd</div><div class=\"line\">$ ./build</div></pre></td></tr></table></figure>","more":"<h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><p>每个节点都要执行以下配置，HOST_1、HOST_2、HOST_3 分别设置为多台服务器的IP</p>\n<p>进入到bin目录下<br><code>$ cd $GOPATH/src/github.com/coreos/etcd/bin</code></p>\n<p>3个ip分别换成3太服务器真实的ip</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">TOKEN=token-03</div><div class=\"line\">CLUSTER_STATE=new</div><div class=\"line\">NAME_1=machine-1</div><div class=\"line\">NAME_2=machine-2</div><div class=\"line\">NAME_3=machine-3</div><div class=\"line\">HOST_1=192.168.1.105</div><div class=\"line\">HOST_2=192.168.1.143</div><div class=\"line\">HOST_3=192.168.1.103</div><div class=\"line\">CLUSTER=$&#123;NAME_1&#125;=http://$&#123;HOST_1&#125;:2380,$&#123;NAME_2&#125;=http://$&#123;HOST_2&#125;:2380,$&#123;NAME_3&#125;=http://$&#123;HOST_3&#125;:2380</div></pre></td></tr></table></figure>\n<p><strong>machine 1</strong> 执行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd $GOPATH/src/github.com/coreos/etcd/bin</div><div class=\"line\"></div><div class=\"line\"># For machine 1</div><div class=\"line\">THIS_NAME=$&#123;NAME_1&#125;</div><div class=\"line\">THIS_IP=$&#123;HOST_1&#125;</div><div class=\"line\">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</div></pre></td></tr></table></figure>\n<p><strong>machine 2</strong> 执行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd $GOPATH/src/github.com/coreos/etcd/bin</div><div class=\"line\"></div><div class=\"line\"># For machine 2</div><div class=\"line\">THIS_NAME=$&#123;NAME_2&#125;</div><div class=\"line\">THIS_IP=$&#123;HOST_2&#125;</div><div class=\"line\">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</div></pre></td></tr></table></figure>\n<p><strong>machine 3</strong> 执行如下命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd $GOPATH/src/github.com/coreos/etcd/bin</div><div class=\"line\"></div><div class=\"line\"># For machine 3</div><div class=\"line\">THIS_NAME=$&#123;NAME_3&#125;</div><div class=\"line\">THIS_IP=$&#123;HOST_3&#125;</div><div class=\"line\">./etcd --data-dir=data.etcd --name $&#123;THIS_NAME&#125; --initial-advertise-peer-urls http://$&#123;THIS_IP&#125;:2380 --listen-peer-urls http://$&#123;THIS_IP&#125;:2380 --advertise-client-urls http://$&#123;THIS_IP&#125;:2379 --listen-client-urls http://$&#123;THIS_IP&#125;:2379 --initial-cluster $&#123;CLUSTER&#125; --initial-cluster-state $&#123;CLUSTER_STATE&#125; --initial-cluster-token $&#123;TOKEN&#125;</div></pre></td></tr></table></figure>\n<p>检测服务器运行是否正常</p>\n<p>3个ip分别换成3太服务器真实的ip</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd $GOPATH/src/github.com/coreos/etcd/bin</div><div class=\"line\"></div><div class=\"line\">export ETCDCTL_API=3</div><div class=\"line\">HOST_1=192.168.1.105</div><div class=\"line\">HOST_2=192.168.1.143</div><div class=\"line\">HOST_3=192.168.1.103</div><div class=\"line\">ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379</div></pre></td></tr></table></figure>\n<p>查看进入集群的服务器列表<br><code>./etcdctl --endpoints=$ENDPOINTS member list</code></p>\n<h2 id=\"存储数据\"><a href=\"#存储数据\" class=\"headerlink\" title=\"存储数据\"></a>存储数据</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put foo &quot;Hello World!&quot;</div><div class=\"line\"></div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS get foo</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS --write-out=&quot;json&quot; get foo</div></pre></td></tr></table></figure>\n<h2 id=\"根据前缀查询\"><a href=\"#根据前缀查询\" class=\"headerlink\" title=\"根据前缀查询\"></a>根据前缀查询</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put web1 value1</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put web2 value2</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put web3 value3</div><div class=\"line\"></div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS get web --prefix</div><div class=\"line\"></div><div class=\"line\">web1</div><div class=\"line\">value1</div><div class=\"line\">web2</div><div class=\"line\">value2</div><div class=\"line\">web3</div><div class=\"line\">value3</div></pre></td></tr></table></figure>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put key myvalue</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS del key</div><div class=\"line\"></div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put k1 value1</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put k2 value2</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS del k --prefix</div></pre></td></tr></table></figure>\n<h2 id=\"事务写入\"><a href=\"#事务写入\" class=\"headerlink\" title=\"事务写入\"></a>事务写入</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ./etcdctl --endpoints=$ENDPOINTS put user1 bad</div><div class=\"line\">OK</div><div class=\"line\"></div><div class=\"line\">$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive</div><div class=\"line\"></div><div class=\"line\">compares:</div><div class=\"line\">// 输入以下内容，输入结束按 两次回车</div><div class=\"line\">value(&quot;user1&quot;) = &quot;bad&quot;      </div><div class=\"line\"></div><div class=\"line\">//如果 user1 = bad，则执行 get user1 </div><div class=\"line\">success requests (get, put, del):</div><div class=\"line\">get user1</div><div class=\"line\"></div><div class=\"line\">//如果 user1 != bad，则执行 put user1 good</div><div class=\"line\">failure requests (get, put, del):</div><div class=\"line\">put user1 good</div><div class=\"line\"></div><div class=\"line\">// 运行结果，执行 success</div><div class=\"line\">SUCCESS</div><div class=\"line\"></div><div class=\"line\">user1</div><div class=\"line\">bad</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ ./etcdctl --endpoints=$ENDPOINTS txn --interactive</div><div class=\"line\">compares:</div><div class=\"line\">value(&quot;user1&quot;) = &quot;111&quot;  </div><div class=\"line\"></div><div class=\"line\">// 如果 user1 = 111，则执行 get user1 </div><div class=\"line\">success requests (get, put, del):</div><div class=\"line\">get user1</div><div class=\"line\"></div><div class=\"line\">//如果 user1 != 111，则执行 put user1 2222</div><div class=\"line\">failure requests (get, put, del):</div><div class=\"line\">put user1 2222</div><div class=\"line\"></div><div class=\"line\">// 运行结果，执行 failure</div><div class=\"line\">FAILURE</div><div class=\"line\"></div><div class=\"line\">OK</div><div class=\"line\"></div><div class=\"line\">$ ./etcdctl --endpoints=$ENDPOINTS get user1</div><div class=\"line\">user1</div><div class=\"line\">2222</div></pre></td></tr></table></figure>\n<h2 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS watch stock1</div><div class=\"line\"></div><div class=\"line\">// 新打开终端</div><div class=\"line\">$ cd $GOPATH/src/github.com/coreos/etcd/bin</div><div class=\"line\"></div><div class=\"line\">export ETCDCTL_API=3</div><div class=\"line\">HOST_1=192.168.1.126</div><div class=\"line\">HOST_2=192.168.1.119</div><div class=\"line\">HOST_3=192.168.1.103</div><div class=\"line\">ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put stock1 1000</div><div class=\"line\"></div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS watch stock --prefix</div><div class=\"line\"></div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put stock1 10</div><div class=\"line\">./etcdctl --endpoints=$ENDPOINTS put stock2 20</div></pre></td></tr></table></figure>\n<h2 id=\"更多操作\"><a href=\"#更多操作\" class=\"headerlink\" title=\"更多操作\"></a>更多操作</h2><p><a href=\"https://coreos.com/etcd/docs/latest/demo.html\">https://coreos.com/etcd/docs/latest/demo.html</a></p>"},{"title":"github ssh key 问题","date":"2016-02-27T09:02:21.000Z","_content":"   \n   当我部署hexo在github上的时候去看了一下ssh key，发现github上早就有ssh key了，但是我从来没有手动去生成过，并且这个key的名字与手动生成的不一样，文件名是这样github_rsa，当然还有另外一个pub格式的，而如果我们手动生成的话，必然是id_rsa,除非我们自己改名。这个key应该是我安装github客户端的时候生成的，不过我可以在github提交代码，hexo也部署成功了，这些东西也从来没去了解过，然后这次出问题了，折腾了很久。\n   <!-- more -->\n   我打算把博客迁移到gitcafe上，然后我申请了一个gitcafe账号，然后也是配置相关ssh key，当我生成了gitcafe 的ssh key 后，我的github 就不能提交代码了。可恶的是我在gitcafe上添加ssh key后，也是提交不了代码，现在我两个地方都不能用了。现在我的ssh是这样的，github是github_rsa，gitcafe是id_rsa，然后我又在网上搜索管理多个ssh key方法，通过config配置，但是还是没有用。最后搞了很久，实在没有办法，我就先把gitcafe 的 key 给删了，看看github能不能用了，结果发现github还是不能用，这回蛋疼了。最后终于决定，我把ssh目录给清空了，然后重新手动生成github ssh key，这回github能用了，有点劫后余生的感觉，毕竟公司的代码就托管在github上，要是不能用了，工作都做不了。然后我又有些不甘心，再次尝试 gitcafe的 ssh key，然后在通过config管理，这回能用了。\n   原因就在于第一个github的key不是我自己生成的，如果你也遇到此类问题，可以试试清空哪些不是自己生成的key。\n\n","source":"_posts/github ssh key问题.md","raw":"---\ntitle: github ssh key 问题\ndate: 2016-02-27 17:02:21\ntags: [github, ssh key]\ncategories: \n- 随笔\n---\n   \n   当我部署hexo在github上的时候去看了一下ssh key，发现github上早就有ssh key了，但是我从来没有手动去生成过，并且这个key的名字与手动生成的不一样，文件名是这样github_rsa，当然还有另外一个pub格式的，而如果我们手动生成的话，必然是id_rsa,除非我们自己改名。这个key应该是我安装github客户端的时候生成的，不过我可以在github提交代码，hexo也部署成功了，这些东西也从来没去了解过，然后这次出问题了，折腾了很久。\n   <!-- more -->\n   我打算把博客迁移到gitcafe上，然后我申请了一个gitcafe账号，然后也是配置相关ssh key，当我生成了gitcafe 的ssh key 后，我的github 就不能提交代码了。可恶的是我在gitcafe上添加ssh key后，也是提交不了代码，现在我两个地方都不能用了。现在我的ssh是这样的，github是github_rsa，gitcafe是id_rsa，然后我又在网上搜索管理多个ssh key方法，通过config配置，但是还是没有用。最后搞了很久，实在没有办法，我就先把gitcafe 的 key 给删了，看看github能不能用了，结果发现github还是不能用，这回蛋疼了。最后终于决定，我把ssh目录给清空了，然后重新手动生成github ssh key，这回github能用了，有点劫后余生的感觉，毕竟公司的代码就托管在github上，要是不能用了，工作都做不了。然后我又有些不甘心，再次尝试 gitcafe的 ssh key，然后在通过config管理，这回能用了。\n   原因就在于第一个github的key不是我自己生成的，如果你也遇到此类问题，可以试试清空哪些不是自己生成的key。\n\n","slug":"github ssh key问题","published":1,"updated":"2016-11-16T15:05:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5te4000wlx6074tvjcij","content":"<p>   当我部署hexo在github上的时候去看了一下ssh key，发现github上早就有ssh key了，但是我从来没有手动去生成过，并且这个key的名字与手动生成的不一样，文件名是这样github_rsa，当然还有另外一个pub格式的，而如果我们手动生成的话，必然是id_rsa,除非我们自己改名。这个key应该是我安装github客户端的时候生成的，不过我可以在github提交代码，hexo也部署成功了，这些东西也从来没去了解过，然后这次出问题了，折腾了很久。<br>   <a id=\"more\"></a><br>   我打算把博客迁移到gitcafe上，然后我申请了一个gitcafe账号，然后也是配置相关ssh key，当我生成了gitcafe 的ssh key 后，我的github 就不能提交代码了。可恶的是我在gitcafe上添加ssh key后，也是提交不了代码，现在我两个地方都不能用了。现在我的ssh是这样的，github是github_rsa，gitcafe是id_rsa，然后我又在网上搜索管理多个ssh key方法，通过config配置，但是还是没有用。最后搞了很久，实在没有办法，我就先把gitcafe 的 key 给删了，看看github能不能用了，结果发现github还是不能用，这回蛋疼了。最后终于决定，我把ssh目录给清空了，然后重新手动生成github ssh key，这回github能用了，有点劫后余生的感觉，毕竟公司的代码就托管在github上，要是不能用了，工作都做不了。然后我又有些不甘心，再次尝试 gitcafe的 ssh key，然后在通过config管理，这回能用了。<br>   原因就在于第一个github的key不是我自己生成的，如果你也遇到此类问题，可以试试清空哪些不是自己生成的key。</p>\n","excerpt":"<p>   当我部署hexo在github上的时候去看了一下ssh key，发现github上早就有ssh key了，但是我从来没有手动去生成过，并且这个key的名字与手动生成的不一样，文件名是这样github_rsa，当然还有另外一个pub格式的，而如果我们手动生成的话，必然是id_rsa,除非我们自己改名。这个key应该是我安装github客户端的时候生成的，不过我可以在github提交代码，hexo也部署成功了，这些东西也从来没去了解过，然后这次出问题了，折腾了很久。<br>","more":"<br>   我打算把博客迁移到gitcafe上，然后我申请了一个gitcafe账号，然后也是配置相关ssh key，当我生成了gitcafe 的ssh key 后，我的github 就不能提交代码了。可恶的是我在gitcafe上添加ssh key后，也是提交不了代码，现在我两个地方都不能用了。现在我的ssh是这样的，github是github_rsa，gitcafe是id_rsa，然后我又在网上搜索管理多个ssh key方法，通过config配置，但是还是没有用。最后搞了很久，实在没有办法，我就先把gitcafe 的 key 给删了，看看github能不能用了，结果发现github还是不能用，这回蛋疼了。最后终于决定，我把ssh目录给清空了，然后重新手动生成github ssh key，这回github能用了，有点劫后余生的感觉，毕竟公司的代码就托管在github上，要是不能用了，工作都做不了。然后我又有些不甘心，再次尝试 gitcafe的 ssh key，然后在通过config管理，这回能用了。<br>   原因就在于第一个github的key不是我自己生成的，如果你也遇到此类问题，可以试试清空哪些不是自己生成的key。</p>"},{"title":"go数组","date":"2018-04-18T06:59:13.000Z","_content":"\n\n### 数组\n\n* 在Go语言中数组是一个值类型（value type）。是真真实实的数组，而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化，这一点严重不同于C语言。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。\n* 定义数组的格式：var <varName> [n]<type>，n>=0\n* 数组长度也是类型的一部分，因此具有不同长度的数组为不同类型\n* 注意区分指向数组的指针和指针数组\n* 数组在Go中为值类型\n* 数组之间可以使用==或!=进行比较，但不可以使用<或>(比较的前提是数组个数相同，并且元素类型相同)\n* 可以使用new来创建数组，此方法返回一个指向数组的指针\n* Go支持多维数组\n\n<!--more-->\n#### 创建数组\n\n```\nfunc createArr() {\n\n\t// 指定数组长度\n\t// 创建数组如果给定数组长度，数组个数就不能超过这个长度\n\tvar arr1 = [5]int{1, 3, 5, 2, 9}\n\tfmt.Println(arr1)\n\n\t//不指定数组长度\n\t//Go 语言会根据元素的个数来设置数组的大小\n\tvar arr2 = []int{1, 2}\n\tvar arr3 = [...]int{2, 3, 4}\n\tfmt.Println(arr2)\n\tfmt.Println(arr3)\n\n\t//创建变量或者常量 可以简写\n\tarr4 := []int{5}\n\tfmt.Println(arr4)\n\t//初始化对指定元素赋值\n\t//第三个元素 初始化为1\n\tvar arr5 = [5]int{3: 1}\n\tfmt.Println(arr5)\n\n\t// 获取数组的长度和容量\n\tfmt.Println(len(arr1))\n\tfmt.Println(cap(arr1))\n\n}\n```\n结果\n```\n[1 3 5 2 9]\n[1 2]\n[2 3 4]\n[5]\n[0 0 0 1 0]\n5\n5\n```\n\n#### 编辑数组\n\n```\nfunc editArr() {\n\n\tvar arr1 = []int{1, 2}\n\tfmt.Print(len(arr1), cap(arr1))\n\tfmt.Println(arr1)\n\n\t// 给arr1 添加元素 3，4\n\tvar arr2 = append(arr1, 3, 4)\n\tfmt.Println(\"arr1 = \", arr1)\n\tfmt.Println(\"arr2 = \", arr2)\n\tfmt.Print(len(arr1), cap(arr1))\n\n\t//改变数组中元素的值\n\tarr1[0] = 9\n\tfmt.Println(arr1)\n}\n```\n结果\n```\n2 2[1 2]\n[1 2 3 4]\n4 4[9 2 3 4]\n```\n\n#### 指针&数组\n\n```\nfunc pointArr() {\n\t//数组指针   它是一个指针，指向数组的地址\n\ta := []int{5: 1}\n\tvar p *[]int = &a\n\tfmt.Println(a)\n\tfmt.Println(p) //比a 多了一个取地址符\n\n\t// 指针数组 数组里存放的是指针地址，不是实际的值\n\tvar x, y = 4, 5\n\tarr := []*int{&x, &y}\n\tfmt.Println(arr)\n}\n```\n结果\n```\n[0 0 0 0 0 1]\n&[0 0 0 0 0 1]\n[0xc4200142b0 0xc4200142b8]\n```\n\n#### range遍历数组\n\n```\nfunc rangeArr() {\n\n\tvar arr = []int{1, 2, 3, 4, 5}\n\tfor i, v := range arr {\n\t\tfmt.Println(i, v)\n\t}\n}\n```\n结果\n```\n0 1\n1 2\n2 3\n3 4\n4 5\n```\n#### new 关键字创建数组\n\n```\nfunc newarr() {\n\n\tvar a = [5]int{}\n\ta[1] = 2\n\tfmt.Println(a)\n\n\tp := new([5]int) //可以通过下标赋值\n\tp[1] = 2\n\tfmt.Println(p)\n\n}\n```\n结果\n```\n[0 2 0 0 0]\n&[0 2 0 0 0]\n```\n\n#### 数组传递\n\n在函数内改变数组不会影响原本数组的值，因为是指类选，会进行一次拷贝\n```\nfunc main() {\n\n\tvar testArr = [5]int{1, 2, 3, 4, 5}\n\n\tfmt.Println(testArr)\n\n\tmodifyarr(testArr)\n\n\tfmt.Println(\"In main\", testArr)\n\n}\n\nfunc modifyarr(arr [5]int) {\n\tarr[0] = 10\n\tfmt.Println(\"In modify\", arr)\n}\n```\n结果\n```\n[1 2 3 4 5]\nIn modify [10 2 3 4 5]\nIn main [1 2 3 4 5]\n```\n\n","source":"_posts/go数组.md","raw":"---\ntitle: go数组\ndate: 2018-04-18 14:59:13\ntags: [数组, go]\ncategories: \n- go\n---\n\n\n### 数组\n\n* 在Go语言中数组是一个值类型（value type）。是真真实实的数组，而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化，这一点严重不同于C语言。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。\n* 定义数组的格式：var <varName> [n]<type>，n>=0\n* 数组长度也是类型的一部分，因此具有不同长度的数组为不同类型\n* 注意区分指向数组的指针和指针数组\n* 数组在Go中为值类型\n* 数组之间可以使用==或!=进行比较，但不可以使用<或>(比较的前提是数组个数相同，并且元素类型相同)\n* 可以使用new来创建数组，此方法返回一个指向数组的指针\n* Go支持多维数组\n\n<!--more-->\n#### 创建数组\n\n```\nfunc createArr() {\n\n\t// 指定数组长度\n\t// 创建数组如果给定数组长度，数组个数就不能超过这个长度\n\tvar arr1 = [5]int{1, 3, 5, 2, 9}\n\tfmt.Println(arr1)\n\n\t//不指定数组长度\n\t//Go 语言会根据元素的个数来设置数组的大小\n\tvar arr2 = []int{1, 2}\n\tvar arr3 = [...]int{2, 3, 4}\n\tfmt.Println(arr2)\n\tfmt.Println(arr3)\n\n\t//创建变量或者常量 可以简写\n\tarr4 := []int{5}\n\tfmt.Println(arr4)\n\t//初始化对指定元素赋值\n\t//第三个元素 初始化为1\n\tvar arr5 = [5]int{3: 1}\n\tfmt.Println(arr5)\n\n\t// 获取数组的长度和容量\n\tfmt.Println(len(arr1))\n\tfmt.Println(cap(arr1))\n\n}\n```\n结果\n```\n[1 3 5 2 9]\n[1 2]\n[2 3 4]\n[5]\n[0 0 0 1 0]\n5\n5\n```\n\n#### 编辑数组\n\n```\nfunc editArr() {\n\n\tvar arr1 = []int{1, 2}\n\tfmt.Print(len(arr1), cap(arr1))\n\tfmt.Println(arr1)\n\n\t// 给arr1 添加元素 3，4\n\tvar arr2 = append(arr1, 3, 4)\n\tfmt.Println(\"arr1 = \", arr1)\n\tfmt.Println(\"arr2 = \", arr2)\n\tfmt.Print(len(arr1), cap(arr1))\n\n\t//改变数组中元素的值\n\tarr1[0] = 9\n\tfmt.Println(arr1)\n}\n```\n结果\n```\n2 2[1 2]\n[1 2 3 4]\n4 4[9 2 3 4]\n```\n\n#### 指针&数组\n\n```\nfunc pointArr() {\n\t//数组指针   它是一个指针，指向数组的地址\n\ta := []int{5: 1}\n\tvar p *[]int = &a\n\tfmt.Println(a)\n\tfmt.Println(p) //比a 多了一个取地址符\n\n\t// 指针数组 数组里存放的是指针地址，不是实际的值\n\tvar x, y = 4, 5\n\tarr := []*int{&x, &y}\n\tfmt.Println(arr)\n}\n```\n结果\n```\n[0 0 0 0 0 1]\n&[0 0 0 0 0 1]\n[0xc4200142b0 0xc4200142b8]\n```\n\n#### range遍历数组\n\n```\nfunc rangeArr() {\n\n\tvar arr = []int{1, 2, 3, 4, 5}\n\tfor i, v := range arr {\n\t\tfmt.Println(i, v)\n\t}\n}\n```\n结果\n```\n0 1\n1 2\n2 3\n3 4\n4 5\n```\n#### new 关键字创建数组\n\n```\nfunc newarr() {\n\n\tvar a = [5]int{}\n\ta[1] = 2\n\tfmt.Println(a)\n\n\tp := new([5]int) //可以通过下标赋值\n\tp[1] = 2\n\tfmt.Println(p)\n\n}\n```\n结果\n```\n[0 2 0 0 0]\n&[0 2 0 0 0]\n```\n\n#### 数组传递\n\n在函数内改变数组不会影响原本数组的值，因为是指类选，会进行一次拷贝\n```\nfunc main() {\n\n\tvar testArr = [5]int{1, 2, 3, 4, 5}\n\n\tfmt.Println(testArr)\n\n\tmodifyarr(testArr)\n\n\tfmt.Println(\"In main\", testArr)\n\n}\n\nfunc modifyarr(arr [5]int) {\n\tarr[0] = 10\n\tfmt.Println(\"In modify\", arr)\n}\n```\n结果\n```\n[1 2 3 4 5]\nIn modify [10 2 3 4 5]\nIn main [1 2 3 4 5]\n```\n\n","slug":"go数组","published":1,"updated":"2018-04-18T07:01:46.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5te5000zlx6062460h7g","content":"<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ul>\n<li>在Go语言中数组是一个值类型（value type）。是真真实实的数组，而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化，这一点严重不同于C语言。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。</li>\n<li>定义数组的格式：var <varname> [n]<type>，n&gt;=0</type></varname></li>\n<li>数组长度也是类型的一部分，因此具有不同长度的数组为不同类型</li>\n<li>注意区分指向数组的指针和指针数组</li>\n<li>数组在Go中为值类型</li>\n<li>数组之间可以使用==或!=进行比较，但不可以使用&lt;或&gt;(比较的前提是数组个数相同，并且元素类型相同)</li>\n<li>可以使用new来创建数组，此方法返回一个指向数组的指针</li>\n<li>Go支持多维数组</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"创建数组\"><a href=\"#创建数组\" class=\"headerlink\" title=\"创建数组\"></a>创建数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">func createArr() &#123;</div><div class=\"line\"></div><div class=\"line\">\t// 指定数组长度</div><div class=\"line\">\t// 创建数组如果给定数组长度，数组个数就不能超过这个长度</div><div class=\"line\">\tvar arr1 = [5]int&#123;1, 3, 5, 2, 9&#125;</div><div class=\"line\">\tfmt.Println(arr1)</div><div class=\"line\"></div><div class=\"line\">\t//不指定数组长度</div><div class=\"line\">\t//Go 语言会根据元素的个数来设置数组的大小</div><div class=\"line\">\tvar arr2 = []int&#123;1, 2&#125;</div><div class=\"line\">\tvar arr3 = [...]int&#123;2, 3, 4&#125;</div><div class=\"line\">\tfmt.Println(arr2)</div><div class=\"line\">\tfmt.Println(arr3)</div><div class=\"line\"></div><div class=\"line\">\t//创建变量或者常量 可以简写</div><div class=\"line\">\tarr4 := []int&#123;5&#125;</div><div class=\"line\">\tfmt.Println(arr4)</div><div class=\"line\">\t//初始化对指定元素赋值</div><div class=\"line\">\t//第三个元素 初始化为1</div><div class=\"line\">\tvar arr5 = [5]int&#123;3: 1&#125;</div><div class=\"line\">\tfmt.Println(arr5)</div><div class=\"line\"></div><div class=\"line\">\t// 获取数组的长度和容量</div><div class=\"line\">\tfmt.Println(len(arr1))</div><div class=\"line\">\tfmt.Println(cap(arr1))</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[1 3 5 2 9]</div><div class=\"line\">[1 2]</div><div class=\"line\">[2 3 4]</div><div class=\"line\">[5]</div><div class=\"line\">[0 0 0 1 0]</div><div class=\"line\">5</div><div class=\"line\">5</div></pre></td></tr></table></figure></p>\n<h4 id=\"编辑数组\"><a href=\"#编辑数组\" class=\"headerlink\" title=\"编辑数组\"></a>编辑数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">func editArr() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar arr1 = []int&#123;1, 2&#125;</div><div class=\"line\">\tfmt.Print(len(arr1), cap(arr1))</div><div class=\"line\">\tfmt.Println(arr1)</div><div class=\"line\"></div><div class=\"line\">\t// 给arr1 添加元素 3，4</div><div class=\"line\">\tvar arr2 = append(arr1, 3, 4)</div><div class=\"line\">\tfmt.Println(&quot;arr1 = &quot;, arr1)</div><div class=\"line\">\tfmt.Println(&quot;arr2 = &quot;, arr2)</div><div class=\"line\">\tfmt.Print(len(arr1), cap(arr1))</div><div class=\"line\"></div><div class=\"line\">\t//改变数组中元素的值</div><div class=\"line\">\tarr1[0] = 9</div><div class=\"line\">\tfmt.Println(arr1)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">2 2[1 2]</div><div class=\"line\">[1 2 3 4]</div><div class=\"line\">4 4[9 2 3 4]</div></pre></td></tr></table></figure></p>\n<h4 id=\"指针-amp-数组\"><a href=\"#指针-amp-数组\" class=\"headerlink\" title=\"指针&amp;数组\"></a>指针&amp;数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">func pointArr() &#123;</div><div class=\"line\">\t//数组指针   它是一个指针，指向数组的地址</div><div class=\"line\">\ta := []int&#123;5: 1&#125;</div><div class=\"line\">\tvar p *[]int = &amp;a</div><div class=\"line\">\tfmt.Println(a)</div><div class=\"line\">\tfmt.Println(p) //比a 多了一个取地址符</div><div class=\"line\"></div><div class=\"line\">\t// 指针数组 数组里存放的是指针地址，不是实际的值</div><div class=\"line\">\tvar x, y = 4, 5</div><div class=\"line\">\tarr := []*int&#123;&amp;x, &amp;y&#125;</div><div class=\"line\">\tfmt.Println(arr)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0 0 0 0 0 1]</div><div class=\"line\">&amp;[0 0 0 0 0 1]</div><div class=\"line\">[0xc4200142b0 0xc4200142b8]</div></pre></td></tr></table></figure></p>\n<h4 id=\"range遍历数组\"><a href=\"#range遍历数组\" class=\"headerlink\" title=\"range遍历数组\"></a>range遍历数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">func rangeArr() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar arr = []int&#123;1, 2, 3, 4, 5&#125;</div><div class=\"line\">\tfor i, v := range arr &#123;</div><div class=\"line\">\t\tfmt.Println(i, v)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">0 1</div><div class=\"line\">1 2</div><div class=\"line\">2 3</div><div class=\"line\">3 4</div><div class=\"line\">4 5</div></pre></td></tr></table></figure></p>\n<h4 id=\"new-关键字创建数组\"><a href=\"#new-关键字创建数组\" class=\"headerlink\" title=\"new 关键字创建数组\"></a>new 关键字创建数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func newarr() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar a = [5]int&#123;&#125;</div><div class=\"line\">\ta[1] = 2</div><div class=\"line\">\tfmt.Println(a)</div><div class=\"line\"></div><div class=\"line\">\tp := new([5]int) //可以通过下标赋值</div><div class=\"line\">\tp[1] = 2</div><div class=\"line\">\tfmt.Println(p)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0 2 0 0 0]</div><div class=\"line\">&amp;[0 2 0 0 0]</div></pre></td></tr></table></figure></p>\n<h4 id=\"数组传递\"><a href=\"#数组传递\" class=\"headerlink\" title=\"数组传递\"></a>数组传递</h4><p>在函数内改变数组不会影响原本数组的值，因为是指类选，会进行一次拷贝<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar testArr = [5]int&#123;1, 2, 3, 4, 5&#125;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(testArr)</div><div class=\"line\"></div><div class=\"line\">\tmodifyarr(testArr)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(&quot;In main&quot;, testArr)</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func modifyarr(arr [5]int) &#123;</div><div class=\"line\">\tarr[0] = 10</div><div class=\"line\">\tfmt.Println(&quot;In modify&quot;, arr)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[1 2 3 4 5]</div><div class=\"line\">In modify [10 2 3 4 5]</div><div class=\"line\">In main [1 2 3 4 5]</div></pre></td></tr></table></figure></p>\n","excerpt":"<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ul>\n<li>在Go语言中数组是一个值类型（value type）。是真真实实的数组，而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化，这一点严重不同于C语言。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。</li>\n<li>定义数组的格式：var <varName> [n]<type>，n&gt;=0</li>\n<li>数组长度也是类型的一部分，因此具有不同长度的数组为不同类型</li>\n<li>注意区分指向数组的指针和指针数组</li>\n<li>数组在Go中为值类型</li>\n<li>数组之间可以使用==或!=进行比较，但不可以使用&lt;或&gt;(比较的前提是数组个数相同，并且元素类型相同)</li>\n<li>可以使用new来创建数组，此方法返回一个指向数组的指针</li>\n<li>Go支持多维数组</li>\n</ul>","more":"<h4 id=\"创建数组\"><a href=\"#创建数组\" class=\"headerlink\" title=\"创建数组\"></a>创建数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">func createArr() &#123;</div><div class=\"line\"></div><div class=\"line\">\t// 指定数组长度</div><div class=\"line\">\t// 创建数组如果给定数组长度，数组个数就不能超过这个长度</div><div class=\"line\">\tvar arr1 = [5]int&#123;1, 3, 5, 2, 9&#125;</div><div class=\"line\">\tfmt.Println(arr1)</div><div class=\"line\"></div><div class=\"line\">\t//不指定数组长度</div><div class=\"line\">\t//Go 语言会根据元素的个数来设置数组的大小</div><div class=\"line\">\tvar arr2 = []int&#123;1, 2&#125;</div><div class=\"line\">\tvar arr3 = [...]int&#123;2, 3, 4&#125;</div><div class=\"line\">\tfmt.Println(arr2)</div><div class=\"line\">\tfmt.Println(arr3)</div><div class=\"line\"></div><div class=\"line\">\t//创建变量或者常量 可以简写</div><div class=\"line\">\tarr4 := []int&#123;5&#125;</div><div class=\"line\">\tfmt.Println(arr4)</div><div class=\"line\">\t//初始化对指定元素赋值</div><div class=\"line\">\t//第三个元素 初始化为1</div><div class=\"line\">\tvar arr5 = [5]int&#123;3: 1&#125;</div><div class=\"line\">\tfmt.Println(arr5)</div><div class=\"line\"></div><div class=\"line\">\t// 获取数组的长度和容量</div><div class=\"line\">\tfmt.Println(len(arr1))</div><div class=\"line\">\tfmt.Println(cap(arr1))</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[1 3 5 2 9]</div><div class=\"line\">[1 2]</div><div class=\"line\">[2 3 4]</div><div class=\"line\">[5]</div><div class=\"line\">[0 0 0 1 0]</div><div class=\"line\">5</div><div class=\"line\">5</div></pre></td></tr></table></figure></p>\n<h4 id=\"编辑数组\"><a href=\"#编辑数组\" class=\"headerlink\" title=\"编辑数组\"></a>编辑数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">func editArr() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar arr1 = []int&#123;1, 2&#125;</div><div class=\"line\">\tfmt.Print(len(arr1), cap(arr1))</div><div class=\"line\">\tfmt.Println(arr1)</div><div class=\"line\"></div><div class=\"line\">\t// 给arr1 添加元素 3，4</div><div class=\"line\">\tvar arr2 = append(arr1, 3, 4)</div><div class=\"line\">\tfmt.Println(&quot;arr1 = &quot;, arr1)</div><div class=\"line\">\tfmt.Println(&quot;arr2 = &quot;, arr2)</div><div class=\"line\">\tfmt.Print(len(arr1), cap(arr1))</div><div class=\"line\"></div><div class=\"line\">\t//改变数组中元素的值</div><div class=\"line\">\tarr1[0] = 9</div><div class=\"line\">\tfmt.Println(arr1)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">2 2[1 2]</div><div class=\"line\">[1 2 3 4]</div><div class=\"line\">4 4[9 2 3 4]</div></pre></td></tr></table></figure></p>\n<h4 id=\"指针-amp-数组\"><a href=\"#指针-amp-数组\" class=\"headerlink\" title=\"指针&amp;数组\"></a>指针&amp;数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">func pointArr() &#123;</div><div class=\"line\">\t//数组指针   它是一个指针，指向数组的地址</div><div class=\"line\">\ta := []int&#123;5: 1&#125;</div><div class=\"line\">\tvar p *[]int = &amp;a</div><div class=\"line\">\tfmt.Println(a)</div><div class=\"line\">\tfmt.Println(p) //比a 多了一个取地址符</div><div class=\"line\"></div><div class=\"line\">\t// 指针数组 数组里存放的是指针地址，不是实际的值</div><div class=\"line\">\tvar x, y = 4, 5</div><div class=\"line\">\tarr := []*int&#123;&amp;x, &amp;y&#125;</div><div class=\"line\">\tfmt.Println(arr)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0 0 0 0 0 1]</div><div class=\"line\">&amp;[0 0 0 0 0 1]</div><div class=\"line\">[0xc4200142b0 0xc4200142b8]</div></pre></td></tr></table></figure></p>\n<h4 id=\"range遍历数组\"><a href=\"#range遍历数组\" class=\"headerlink\" title=\"range遍历数组\"></a>range遍历数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">func rangeArr() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar arr = []int&#123;1, 2, 3, 4, 5&#125;</div><div class=\"line\">\tfor i, v := range arr &#123;</div><div class=\"line\">\t\tfmt.Println(i, v)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">0 1</div><div class=\"line\">1 2</div><div class=\"line\">2 3</div><div class=\"line\">3 4</div><div class=\"line\">4 5</div></pre></td></tr></table></figure></p>\n<h4 id=\"new-关键字创建数组\"><a href=\"#new-关键字创建数组\" class=\"headerlink\" title=\"new 关键字创建数组\"></a>new 关键字创建数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func newarr() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar a = [5]int&#123;&#125;</div><div class=\"line\">\ta[1] = 2</div><div class=\"line\">\tfmt.Println(a)</div><div class=\"line\"></div><div class=\"line\">\tp := new([5]int) //可以通过下标赋值</div><div class=\"line\">\tp[1] = 2</div><div class=\"line\">\tfmt.Println(p)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0 2 0 0 0]</div><div class=\"line\">&amp;[0 2 0 0 0]</div></pre></td></tr></table></figure></p>\n<h4 id=\"数组传递\"><a href=\"#数组传递\" class=\"headerlink\" title=\"数组传递\"></a>数组传递</h4><p>在函数内改变数组不会影响原本数组的值，因为是指类选，会进行一次拷贝<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar testArr = [5]int&#123;1, 2, 3, 4, 5&#125;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(testArr)</div><div class=\"line\"></div><div class=\"line\">\tmodifyarr(testArr)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(&quot;In main&quot;, testArr)</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func modifyarr(arr [5]int) &#123;</div><div class=\"line\">\tarr[0] = 10</div><div class=\"line\">\tfmt.Println(&quot;In modify&quot;, arr)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[1 2 3 4 5]</div><div class=\"line\">In modify [10 2 3 4 5]</div><div class=\"line\">In main [1 2 3 4 5]</div></pre></td></tr></table></figure></p>"},{"title":"hash算法","date":"2018-06-26T11:00:51.000Z","_content":"\n## 什么是 hash 算法\n\n散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，然后到相应的单元里去取要找的结点。通过散列方法可以对结点进行快速检索。散列（hash，也称“哈希”）是一种重要的存储方式，也是一种常见的检索方法。\n\n散列算法（Hash Algorithm），又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。\n\n## Hash算法有什么特点\n\n一个优秀的 hash 算法，将能实现：\n\n* **正向快速**：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。\n\n* **逆向困难**：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。\n\n* **输入敏感**：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。\n\n* **冲突避免**：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。\n\n但在不同的使用场景中，如数据结构和安全领域里，其中对某一些特点会有所侧重。\n<!--more-->\n## 几种常见的hash算法\n* MD5\n* SHA-1\n* SHA-2\n* SHA-256\n* SHA-512\n* SHA-3\n* RIPEMD-160\n\n## MD5 加密使用\n\n```\nfunc Md5(data string)  {\n\n\tfmt.Println(\"-----------Md5-----------\")\n\tmes := []byte(data)\n\n\t// 1. 使用系统的包实现\n\t// 密文为16进制的数字 16 *8 = 128位\n\tby := md5.Sum(mes)\n\tfmt.Printf(\"%x\\n\", by)\n\n\t// 2. 第二种写法\n\tm := md5.New()\n\tm.Write(mes)\n\t//将字节数组转换成字符串\n\ts2:= hex.EncodeToString(m.Sum(nil))\n\tfmt.Println(s2)\n}\n```\n\n## Sha256加密使用\n\n```\nfunc Sha256(data string)  {\n\n\tfmt.Println(\"--------sha256----------\")\n\n\t// 32字节 通用在公链中 32 * 8 = 256 位\n\t// 2. 第一种写法\n\tby := sha256.Sum256([]byte(data))\n\ts := fmt.Sprintf(\"%x\", by)\n\tfmt.Println(s)\n\n  // 2. 第二种写法\n\tm := sha256.New()\n\tm.Write([]byte(data))\n\ts2 := hex.EncodeToString(m.Sum(nil))\n\tfmt.Println(s2)\n\n\n\t//对文件中的数据进行加密\n\tfile, _ := os.Open(\"test.txt\")\n\th := sha256.New()\n\t//将file copy到 h中\n\tio.Copy(h, file)\n\tresu := h.Sum(nil)\n\n\tfmt.Println(hex.EncodeToString(resu))\n}\n```\n\n## rpemd160加密使用\n\n```\n//需要用到三方库 crypto\nfunc Ripem160(data string)  {\n\n\tfmt.Println(\"-------Ripem160--------\")\n\trip := ripemd160.New()\n\trip.Write([]byte(data))\n\tres := hex.EncodeToString(rip.Sum(nil))\n\n\tfmt.Println(res)\n}\n```\n\n## md5 实现原理\n\n对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。\n\n1. **填充**：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)；\n\n2. **记录信息长度**：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N\\*512+448+64=(N+1)*512位。\n\n3. **装入标准的幻数（四个整数）**：标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301，B=0XEFCDAB89，C=0X98BADCFE，D=0X10325476）\n\n4. 四轮循环运算\n\n## sha256 实现原理\n\nSHA-256 算法输入报文的最大长度不超过2^64 bit，输入按512-bit 分组进行处理，产生的输出是一个256-bit 的报文摘要。\n\n* **附加填充比特**：对报文进行填充使报文长度与448 模512 同余（长度=448 mod 512），填充的比特数范围是1 到512，填充比特串的最高位为1，其余位为0。就是先在报文后面加一个 1，再加很多个0，直到长度 满足 mod 512=448.为什么是448，因为448+64=512. 第二步会加上一个 64bit的 原始报文的 长度信息。\n\n* **附加长度值** 将用64-bit 表示的初始报文（填充前）的位长度附加在步骤1 的结果后（低位字节优先）。\n\n* **初始化缓存**：使用一个256-bit 的缓存来存放该散列函数的中间及最终结果。 \n*  **处理512-bit（16 个字）报文分组序列**：该算法使用了六种基本逻辑函数，由64步迭代运算组成。每步都以256-bit 缓存值ABCDEFGH 为输入，然后更新缓存内容。 每步使用一个32-bit 常数值Kt 和一个32-bit Wt。 \n\n\n","source":"_posts/hash算法.md","raw":"---\ntitle: hash算法\ncategories:\n  - 加密算法\ntags:\n  - 加密算法\n  - hash\n  - MD5\n  - sha256\n  - rpemd160\n  - go\ndate: 2018-06-26 19:00:51\n---\n\n## 什么是 hash 算法\n\n散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，然后到相应的单元里去取要找的结点。通过散列方法可以对结点进行快速检索。散列（hash，也称“哈希”）是一种重要的存储方式，也是一种常见的检索方法。\n\n散列算法（Hash Algorithm），又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。\n\n## Hash算法有什么特点\n\n一个优秀的 hash 算法，将能实现：\n\n* **正向快速**：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。\n\n* **逆向困难**：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。\n\n* **输入敏感**：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。\n\n* **冲突避免**：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。\n\n但在不同的使用场景中，如数据结构和安全领域里，其中对某一些特点会有所侧重。\n<!--more-->\n## 几种常见的hash算法\n* MD5\n* SHA-1\n* SHA-2\n* SHA-256\n* SHA-512\n* SHA-3\n* RIPEMD-160\n\n## MD5 加密使用\n\n```\nfunc Md5(data string)  {\n\n\tfmt.Println(\"-----------Md5-----------\")\n\tmes := []byte(data)\n\n\t// 1. 使用系统的包实现\n\t// 密文为16进制的数字 16 *8 = 128位\n\tby := md5.Sum(mes)\n\tfmt.Printf(\"%x\\n\", by)\n\n\t// 2. 第二种写法\n\tm := md5.New()\n\tm.Write(mes)\n\t//将字节数组转换成字符串\n\ts2:= hex.EncodeToString(m.Sum(nil))\n\tfmt.Println(s2)\n}\n```\n\n## Sha256加密使用\n\n```\nfunc Sha256(data string)  {\n\n\tfmt.Println(\"--------sha256----------\")\n\n\t// 32字节 通用在公链中 32 * 8 = 256 位\n\t// 2. 第一种写法\n\tby := sha256.Sum256([]byte(data))\n\ts := fmt.Sprintf(\"%x\", by)\n\tfmt.Println(s)\n\n  // 2. 第二种写法\n\tm := sha256.New()\n\tm.Write([]byte(data))\n\ts2 := hex.EncodeToString(m.Sum(nil))\n\tfmt.Println(s2)\n\n\n\t//对文件中的数据进行加密\n\tfile, _ := os.Open(\"test.txt\")\n\th := sha256.New()\n\t//将file copy到 h中\n\tio.Copy(h, file)\n\tresu := h.Sum(nil)\n\n\tfmt.Println(hex.EncodeToString(resu))\n}\n```\n\n## rpemd160加密使用\n\n```\n//需要用到三方库 crypto\nfunc Ripem160(data string)  {\n\n\tfmt.Println(\"-------Ripem160--------\")\n\trip := ripemd160.New()\n\trip.Write([]byte(data))\n\tres := hex.EncodeToString(rip.Sum(nil))\n\n\tfmt.Println(res)\n}\n```\n\n## md5 实现原理\n\n对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。\n\n1. **填充**：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)；\n\n2. **记录信息长度**：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N\\*512+448+64=(N+1)*512位。\n\n3. **装入标准的幻数（四个整数）**：标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301，B=0XEFCDAB89，C=0X98BADCFE，D=0X10325476）\n\n4. 四轮循环运算\n\n## sha256 实现原理\n\nSHA-256 算法输入报文的最大长度不超过2^64 bit，输入按512-bit 分组进行处理，产生的输出是一个256-bit 的报文摘要。\n\n* **附加填充比特**：对报文进行填充使报文长度与448 模512 同余（长度=448 mod 512），填充的比特数范围是1 到512，填充比特串的最高位为1，其余位为0。就是先在报文后面加一个 1，再加很多个0，直到长度 满足 mod 512=448.为什么是448，因为448+64=512. 第二步会加上一个 64bit的 原始报文的 长度信息。\n\n* **附加长度值** 将用64-bit 表示的初始报文（填充前）的位长度附加在步骤1 的结果后（低位字节优先）。\n\n* **初始化缓存**：使用一个256-bit 的缓存来存放该散列函数的中间及最终结果。 \n*  **处理512-bit（16 个字）报文分组序列**：该算法使用了六种基本逻辑函数，由64步迭代运算组成。每步都以256-bit 缓存值ABCDEFGH 为输入，然后更新缓存内容。 每步使用一个32-bit 常数值Kt 和一个32-bit Wt。 \n\n\n","slug":"hash算法","published":1,"updated":"2018-06-26T11:04:32.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5te80013lx6082p6wkla","content":"<h2 id=\"什么是-hash-算法\"><a href=\"#什么是-hash-算法\" class=\"headerlink\" title=\"什么是 hash 算法\"></a>什么是 hash 算法</h2><p>散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，然后到相应的单元里去取要找的结点。通过散列方法可以对结点进行快速检索。散列（hash，也称“哈希”）是一种重要的存储方式，也是一种常见的检索方法。</p>\n<p>散列算法（Hash Algorithm），又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。</p>\n<h2 id=\"Hash算法有什么特点\"><a href=\"#Hash算法有什么特点\" class=\"headerlink\" title=\"Hash算法有什么特点\"></a>Hash算法有什么特点</h2><p>一个优秀的 hash 算法，将能实现：</p>\n<ul>\n<li><p><strong>正向快速</strong>：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。</p>\n</li>\n<li><p><strong>逆向困难</strong>：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。</p>\n</li>\n<li><p><strong>输入敏感</strong>：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。</p>\n</li>\n<li><p><strong>冲突避免</strong>：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。</p>\n</li>\n</ul>\n<p>但在不同的使用场景中，如数据结构和安全领域里，其中对某一些特点会有所侧重。<br><a id=\"more\"></a></p>\n<h2 id=\"几种常见的hash算法\"><a href=\"#几种常见的hash算法\" class=\"headerlink\" title=\"几种常见的hash算法\"></a>几种常见的hash算法</h2><ul>\n<li>MD5</li>\n<li>SHA-1</li>\n<li>SHA-2</li>\n<li>SHA-256</li>\n<li>SHA-512</li>\n<li>SHA-3</li>\n<li>RIPEMD-160</li>\n</ul>\n<h2 id=\"MD5-加密使用\"><a href=\"#MD5-加密使用\" class=\"headerlink\" title=\"MD5 加密使用\"></a>MD5 加密使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">func Md5(data string)  &#123;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(&quot;-----------Md5-----------&quot;)</div><div class=\"line\">\tmes := []byte(data)</div><div class=\"line\"></div><div class=\"line\">\t// 1. 使用系统的包实现</div><div class=\"line\">\t// 密文为16进制的数字 16 *8 = 128位</div><div class=\"line\">\tby := md5.Sum(mes)</div><div class=\"line\">\tfmt.Printf(&quot;%x\\n&quot;, by)</div><div class=\"line\"></div><div class=\"line\">\t// 2. 第二种写法</div><div class=\"line\">\tm := md5.New()</div><div class=\"line\">\tm.Write(mes)</div><div class=\"line\">\t//将字节数组转换成字符串</div><div class=\"line\">\ts2:= hex.EncodeToString(m.Sum(nil))</div><div class=\"line\">\tfmt.Println(s2)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Sha256加密使用\"><a href=\"#Sha256加密使用\" class=\"headerlink\" title=\"Sha256加密使用\"></a>Sha256加密使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">func Sha256(data string)  &#123;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(&quot;--------sha256----------&quot;)</div><div class=\"line\"></div><div class=\"line\">\t// 32字节 通用在公链中 32 * 8 = 256 位</div><div class=\"line\">\t// 2. 第一种写法</div><div class=\"line\">\tby := sha256.Sum256([]byte(data))</div><div class=\"line\">\ts := fmt.Sprintf(&quot;%x&quot;, by)</div><div class=\"line\">\tfmt.Println(s)</div><div class=\"line\"></div><div class=\"line\">  // 2. 第二种写法</div><div class=\"line\">\tm := sha256.New()</div><div class=\"line\">\tm.Write([]byte(data))</div><div class=\"line\">\ts2 := hex.EncodeToString(m.Sum(nil))</div><div class=\"line\">\tfmt.Println(s2)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//对文件中的数据进行加密</div><div class=\"line\">\tfile, _ := os.Open(&quot;test.txt&quot;)</div><div class=\"line\">\th := sha256.New()</div><div class=\"line\">\t//将file copy到 h中</div><div class=\"line\">\tio.Copy(h, file)</div><div class=\"line\">\tresu := h.Sum(nil)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(resu))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"rpemd160加密使用\"><a href=\"#rpemd160加密使用\" class=\"headerlink\" title=\"rpemd160加密使用\"></a>rpemd160加密使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//需要用到三方库 crypto</div><div class=\"line\">func Ripem160(data string)  &#123;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(&quot;-------Ripem160--------&quot;)</div><div class=\"line\">\trip := ripemd160.New()</div><div class=\"line\">\trip.Write([]byte(data))</div><div class=\"line\">\tres := hex.EncodeToString(rip.Sum(nil))</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(res)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"md5-实现原理\"><a href=\"#md5-实现原理\" class=\"headerlink\" title=\"md5 实现原理\"></a>md5 实现原理</h2><p>对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>\n<ol>\n<li><p><strong>填充</strong>：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)；</p>\n</li>\n<li><p><strong>记录信息长度</strong>：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。</p>\n</li>\n<li><p><strong>装入标准的幻数（四个整数）</strong>：标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301，B=0XEFCDAB89，C=0X98BADCFE，D=0X10325476）</p>\n</li>\n<li><p>四轮循环运算</p>\n</li>\n</ol>\n<h2 id=\"sha256-实现原理\"><a href=\"#sha256-实现原理\" class=\"headerlink\" title=\"sha256 实现原理\"></a>sha256 实现原理</h2><p>SHA-256 算法输入报文的最大长度不超过2^64 bit，输入按512-bit 分组进行处理，产生的输出是一个256-bit 的报文摘要。</p>\n<ul>\n<li><p><strong>附加填充比特</strong>：对报文进行填充使报文长度与448 模512 同余（长度=448 mod 512），填充的比特数范围是1 到512，填充比特串的最高位为1，其余位为0。就是先在报文后面加一个 1，再加很多个0，直到长度 满足 mod 512=448.为什么是448，因为448+64=512. 第二步会加上一个 64bit的 原始报文的 长度信息。</p>\n</li>\n<li><p><strong>附加长度值</strong> 将用64-bit 表示的初始报文（填充前）的位长度附加在步骤1 的结果后（低位字节优先）。</p>\n</li>\n<li><p><strong>初始化缓存</strong>：使用一个256-bit 的缓存来存放该散列函数的中间及最终结果。 </p>\n</li>\n<li><strong>处理512-bit（16 个字）报文分组序列</strong>：该算法使用了六种基本逻辑函数，由64步迭代运算组成。每步都以256-bit 缓存值ABCDEFGH 为输入，然后更新缓存内容。 每步使用一个32-bit 常数值Kt 和一个32-bit Wt。 </li>\n</ul>\n","excerpt":"<h2 id=\"什么是-hash-算法\"><a href=\"#什么是-hash-算法\" class=\"headerlink\" title=\"什么是 hash 算法\"></a>什么是 hash 算法</h2><p>散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，然后到相应的单元里去取要找的结点。通过散列方法可以对结点进行快速检索。散列（hash，也称“哈希”）是一种重要的存储方式，也是一种常见的检索方法。</p>\n<p>散列算法（Hash Algorithm），又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。</p>\n<h2 id=\"Hash算法有什么特点\"><a href=\"#Hash算法有什么特点\" class=\"headerlink\" title=\"Hash算法有什么特点\"></a>Hash算法有什么特点</h2><p>一个优秀的 hash 算法，将能实现：</p>\n<ul>\n<li><p><strong>正向快速</strong>：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。</p>\n</li>\n<li><p><strong>逆向困难</strong>：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。</p>\n</li>\n<li><p><strong>输入敏感</strong>：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。</p>\n</li>\n<li><p><strong>冲突避免</strong>：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。</p>\n</li>\n</ul>\n<p>但在不同的使用场景中，如数据结构和安全领域里，其中对某一些特点会有所侧重。<br>","more":"</p>\n<h2 id=\"几种常见的hash算法\"><a href=\"#几种常见的hash算法\" class=\"headerlink\" title=\"几种常见的hash算法\"></a>几种常见的hash算法</h2><ul>\n<li>MD5</li>\n<li>SHA-1</li>\n<li>SHA-2</li>\n<li>SHA-256</li>\n<li>SHA-512</li>\n<li>SHA-3</li>\n<li>RIPEMD-160</li>\n</ul>\n<h2 id=\"MD5-加密使用\"><a href=\"#MD5-加密使用\" class=\"headerlink\" title=\"MD5 加密使用\"></a>MD5 加密使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">func Md5(data string)  &#123;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(&quot;-----------Md5-----------&quot;)</div><div class=\"line\">\tmes := []byte(data)</div><div class=\"line\"></div><div class=\"line\">\t// 1. 使用系统的包实现</div><div class=\"line\">\t// 密文为16进制的数字 16 *8 = 128位</div><div class=\"line\">\tby := md5.Sum(mes)</div><div class=\"line\">\tfmt.Printf(&quot;%x\\n&quot;, by)</div><div class=\"line\"></div><div class=\"line\">\t// 2. 第二种写法</div><div class=\"line\">\tm := md5.New()</div><div class=\"line\">\tm.Write(mes)</div><div class=\"line\">\t//将字节数组转换成字符串</div><div class=\"line\">\ts2:= hex.EncodeToString(m.Sum(nil))</div><div class=\"line\">\tfmt.Println(s2)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Sha256加密使用\"><a href=\"#Sha256加密使用\" class=\"headerlink\" title=\"Sha256加密使用\"></a>Sha256加密使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">func Sha256(data string)  &#123;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(&quot;--------sha256----------&quot;)</div><div class=\"line\"></div><div class=\"line\">\t// 32字节 通用在公链中 32 * 8 = 256 位</div><div class=\"line\">\t// 2. 第一种写法</div><div class=\"line\">\tby := sha256.Sum256([]byte(data))</div><div class=\"line\">\ts := fmt.Sprintf(&quot;%x&quot;, by)</div><div class=\"line\">\tfmt.Println(s)</div><div class=\"line\"></div><div class=\"line\">  // 2. 第二种写法</div><div class=\"line\">\tm := sha256.New()</div><div class=\"line\">\tm.Write([]byte(data))</div><div class=\"line\">\ts2 := hex.EncodeToString(m.Sum(nil))</div><div class=\"line\">\tfmt.Println(s2)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//对文件中的数据进行加密</div><div class=\"line\">\tfile, _ := os.Open(&quot;test.txt&quot;)</div><div class=\"line\">\th := sha256.New()</div><div class=\"line\">\t//将file copy到 h中</div><div class=\"line\">\tio.Copy(h, file)</div><div class=\"line\">\tresu := h.Sum(nil)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(resu))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"rpemd160加密使用\"><a href=\"#rpemd160加密使用\" class=\"headerlink\" title=\"rpemd160加密使用\"></a>rpemd160加密使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//需要用到三方库 crypto</div><div class=\"line\">func Ripem160(data string)  &#123;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(&quot;-------Ripem160--------&quot;)</div><div class=\"line\">\trip := ripemd160.New()</div><div class=\"line\">\trip.Write([]byte(data))</div><div class=\"line\">\tres := hex.EncodeToString(rip.Sum(nil))</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(res)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"md5-实现原理\"><a href=\"#md5-实现原理\" class=\"headerlink\" title=\"md5 实现原理\"></a>md5 实现原理</h2><p>对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。</p>\n<ol>\n<li><p><strong>填充</strong>：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为N*512+448(bit)；</p>\n</li>\n<li><p><strong>记录信息长度</strong>：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。</p>\n</li>\n<li><p><strong>装入标准的幻数（四个整数）</strong>：标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。如果在程序中定义应该是（A=0X67452301，B=0XEFCDAB89，C=0X98BADCFE，D=0X10325476）</p>\n</li>\n<li><p>四轮循环运算</p>\n</li>\n</ol>\n<h2 id=\"sha256-实现原理\"><a href=\"#sha256-实现原理\" class=\"headerlink\" title=\"sha256 实现原理\"></a>sha256 实现原理</h2><p>SHA-256 算法输入报文的最大长度不超过2^64 bit，输入按512-bit 分组进行处理，产生的输出是一个256-bit 的报文摘要。</p>\n<ul>\n<li><p><strong>附加填充比特</strong>：对报文进行填充使报文长度与448 模512 同余（长度=448 mod 512），填充的比特数范围是1 到512，填充比特串的最高位为1，其余位为0。就是先在报文后面加一个 1，再加很多个0，直到长度 满足 mod 512=448.为什么是448，因为448+64=512. 第二步会加上一个 64bit的 原始报文的 长度信息。</p>\n</li>\n<li><p><strong>附加长度值</strong> 将用64-bit 表示的初始报文（填充前）的位长度附加在步骤1 的结果后（低位字节优先）。</p>\n</li>\n<li><p><strong>初始化缓存</strong>：使用一个256-bit 的缓存来存放该散列函数的中间及最终结果。 </p>\n</li>\n<li><strong>处理512-bit（16 个字）报文分组序列</strong>：该算法使用了六种基本逻辑函数，由64步迭代运算组成。每步都以256-bit 缓存值ABCDEFGH 为输入，然后更新缓存内容。 每步使用一个32-bit 常数值Kt 和一个32-bit Wt。 </li>\n</ul>"},{"title":"iOS release,debug版设置不同的AppIcon","author":[{"name":"千寻墨","url":"http://www.jianshu.com/users/527ecf8c8753/latest_articles"}],"date":"2016-04-13T10:41:56.000Z","_content":"\n也许你也遇到过这种情况，产品经理或者测试让你给装个测试包，一会装正式环境的，一会又装测试环境的，一会又装个灰度环境的。弄来弄去的有时候自己都搞不清楚测试包是什么环境下的。\n\n通过判断debug还是release环境，我们可以用很多种方法来区分这两种环境，这里最简单而且效果非常好的一种方法。不同的环境下采用不同的图标，这样软件一安装上就可以非常明显的分辨出来。\n\n#### 第一步\n\n创建一个新的AppIcon\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/1.png)\n\n<!-- more -->\n\n#### 第二步\n\n给两个AppIcon分别加入不同的图片\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/2.png)\n\n\n#### 第三步\n\n在build Setting 里面搜索 icon，找到Asset catalog AppIcon set name\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/3.png)\n\n#### 第四步\n\n分别给debug和release设置不同的AppIcon。到这里就全部完成了，快去试试吧。\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/4.png)\n\n","source":"_posts/iOS-release-debug版设置不同的AppIcon.md","raw":"---\ntitle: iOS release,debug版设置不同的AppIcon\ntags:\n  - iOS\n  - 配置\ncategories:\n  - iOS配置\nauthor:\n  - name: 千寻墨\n    url: 'http://www.jianshu.com/users/527ecf8c8753/latest_articles'\ndate: 2016-04-13 18:41:56\n---\n\n也许你也遇到过这种情况，产品经理或者测试让你给装个测试包，一会装正式环境的，一会又装测试环境的，一会又装个灰度环境的。弄来弄去的有时候自己都搞不清楚测试包是什么环境下的。\n\n通过判断debug还是release环境，我们可以用很多种方法来区分这两种环境，这里最简单而且效果非常好的一种方法。不同的环境下采用不同的图标，这样软件一安装上就可以非常明显的分辨出来。\n\n#### 第一步\n\n创建一个新的AppIcon\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/1.png)\n\n<!-- more -->\n\n#### 第二步\n\n给两个AppIcon分别加入不同的图片\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/2.png)\n\n\n#### 第三步\n\n在build Setting 里面搜索 icon，找到Asset catalog AppIcon set name\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/3.png)\n\n#### 第四步\n\n分别给debug和release设置不同的AppIcon。到这里就全部完成了，快去试试吧。\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/4.png)\n\n","slug":"iOS-release-debug版设置不同的AppIcon","published":1,"updated":"2016-11-17T13:51:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5te90016lx60tvf9o00v","content":"<p>也许你也遇到过这种情况，产品经理或者测试让你给装个测试包，一会装正式环境的，一会又装测试环境的，一会又装个灰度环境的。弄来弄去的有时候自己都搞不清楚测试包是什么环境下的。</p>\n<p>通过判断debug还是release环境，我们可以用很多种方法来区分这两种环境，这里最简单而且效果非常好的一种方法。不同的环境下采用不同的图标，这样软件一安装上就可以非常明显的分辨出来。</p>\n<h4 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h4><p>创建一个新的AppIcon</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/1.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h4 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h4><p>给两个AppIcon分别加入不同的图片</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/2.png\" alt=\"image\"></p>\n<h4 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h4><p>在build Setting 里面搜索 icon，找到Asset catalog AppIcon set name</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/3.png\" alt=\"image\"></p>\n<h4 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h4><p>分别给debug和release设置不同的AppIcon。到这里就全部完成了，快去试试吧。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/4.png\" alt=\"image\"></p>\n","excerpt":"<p>也许你也遇到过这种情况，产品经理或者测试让你给装个测试包，一会装正式环境的，一会又装测试环境的，一会又装个灰度环境的。弄来弄去的有时候自己都搞不清楚测试包是什么环境下的。</p>\n<p>通过判断debug还是release环境，我们可以用很多种方法来区分这两种环境，这里最简单而且效果非常好的一种方法。不同的环境下采用不同的图标，这样软件一安装上就可以非常明显的分辨出来。</p>\n<h4 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h4><p>创建一个新的AppIcon</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/1.png\" alt=\"image\"></p>","more":"<h4 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h4><p>给两个AppIcon分别加入不同的图片</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/2.png\" alt=\"image\"></p>\n<h4 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h4><p>在build Setting 里面搜索 icon，找到Asset catalog AppIcon set name</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/3.png\" alt=\"image\"></p>\n<h4 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h4><p>分别给debug和release设置不同的AppIcon。到这里就全部完成了，快去试试吧。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/4.png\" alt=\"image\"></p>"},{"title":"iOS三种录制视频方式详细对比","date":"2017-03-21T16:24:33.000Z","_content":"\n### 先附上参考资料\n\n[http://www.jianshu.com/p/16cb14f53933](http://www.jianshu.com/p/16cb14f53933)\n\n[https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html](https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html)\n\n[https://github.com/objcio/VideoCaptureDemo](https://github.com/objcio/VideoCaptureDemo)\n\n[https://github.com/gsixxxx/DTSmallVideo](https://github.com/gsixxxx/DTSmallVideo)\n\n[https://github.com/AndyFightting/VideoRecord](https://github.com/AndyFightting/VideoRecord)\n\n### 卷首吐槽语\n这还是第一次接触自定义界面录制视频，包括各种参数的设置，不得不说，录制视频这块，各种类，各种方法，蛮复杂的，网上的资料也是各种杂乱，想要弄清楚还真是得费一番功夫，我参考了大量资料，根据自己的思路整理了一遍，按照我的思路来，保证你看一遍就会，我这里只是简单的录制，压缩，剪裁，导出等功能，不设计滤镜，添加背景音乐，合并，字幕等等，重要的是这个流程，主流程会了，其他也就是锦上添花了。\n\n先附上dome [demo地址](https://github.com/suifengqjn/VideoRecord)\n\n### 脑图\n方便大家对三中录制方式有一个大概的了解，看一下这张图片。\n![基本属性与类](https://github.com/suifengqjn/demoimages/blob/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/1.png?raw=true)\n第一种采用系统的录制较为简单，详细介绍后面两种。\n<!-- more -->\n\n### 效果图\n![1](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c1.png) ![2](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c2.png) ![3](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c3.png) ![4](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c4.png) ![5](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c5.png) ![6](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c6.png)\n\ndemo中把三种方式单独分开，便于学习。支持闪光灯，切换镜头，录制不同尺寸的视频等。\n\n### 1.UIImagePickerController\n\n这种方式只能设置一些简单参数，自定义程度不高,只能自定义界面上的操作按钮，还有视频的画质等。\n\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    if ([self isVideoRecordingAvailable]) {\n        return;\n    }\n    self.sourceType = UIImagePickerControllerSourceTypeCamera;\n    self.mediaTypes = @[(NSString *)kUTTypeMovie];\n    self.delegate = self;\n    \n    //隐藏系统自带UI\n    self.showsCameraControls = NO;\n    //设置摄像头\n    [self switchCameraIsFront:NO];\n    //设置视频画质类别\n    self.videoQuality = UIImagePickerControllerQualityTypeMedium;\n    //设置散光灯类型\n    self.cameraFlashMode = UIImagePickerControllerCameraFlashModeAuto;\n    //设置录制的最大时长\n    self.videoMaximumDuration = 20;\n}\n- (BOOL)isVideoRecordingAvailable\n{\n    if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]){\n        NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];\n        if([availableMediaTypes containsObject:(NSString *)kUTTypeMovie]){\n            return YES;\n        }\n    }\n    return NO;\n}\n\n- (void)switchCameraIsFront:(BOOL)front\n{\n    if (front) {\n        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront]){\n            [self setCameraDevice:UIImagePickerControllerCameraDeviceFront];\n            \n        }\n    } else {\n        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceRear]){\n            [self setCameraDevice:UIImagePickerControllerCameraDeviceRear];\n            \n        }\n    }\n}\n```\n\n### 2.AVCaptureSession+AVCaptureMovieFileOutput\n\n流程：\n```\n1. 创建捕捉会话\n2. 设置视频的输入\n3. 设置音频的输入\n4. 输出源设置,这里视频，音频数据会合并到一起输出，在代理方法中国也可以单独拿到视频或者音频数据，给AVCaptureMovieFileOutput指定路径，开始录制之后就会向这个路径写入数据\n5. 添加视频预览层\n6. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据\n```\n\n#### 0. 创建捕捉会话\n```\n\tself.session = [[AVCaptureSession alloc] init];\n    if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) {//设置分辨率\n        _session.sessionPreset=AVCaptureSessionPreset640x480;\n    }\n```\n#### 1. 视频的输入\n```\n   - (void)setUpVideo\n{\n    // 1.1 获取视频输入设备(摄像头)\n    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头\n    \n    // 视频 HDR (高动态范围图像)\n    // videoCaptureDevice.videoHDREnabled = YES;\n    // 设置最大，最小帧速率\n    //videoCaptureDevice.activeVideoMinFrameDuration = CMTimeMake(1, 60);\n    // 1.2 创建视频输入源\n    NSError *error=nil;\n    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&error];\n    // 1.3 将视频输入源添加到会话\n    if ([self.session canAddInput:self.videoInput]) {\n        [self.session addInput:self.videoInput];\n        \n    }\n}\n```\n#### 2. 音频的输入\n```\n// 2.1 获取音频输入设备\n    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];\n    NSError *error=nil;\n    // 2.2 创建音频输入源\n    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&error];\n    // 2.3 将音频输入源添加到会话\n    if ([self.session canAddInput:self.audioInput]) {\n        [self.session addInput:self.audioInput];\n    }\n```\n#### 3.输出源设置\n```\n- (void)setUpFileOut\n{\n    // 3.1初始化设备输出对象，用于获得输出数据\n    self.FileOutput=[[AVCaptureMovieFileOutput alloc]init];\n    \n    // 3.2设置输出对象的一些属性\n    AVCaptureConnection *captureConnection=[self.FileOutput connectionWithMediaType:AVMediaTypeVideo];\n    //设置防抖\n    //视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 AVCaptureConnection 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持：\n    if ([captureConnection isVideoStabilizationSupported ]) {\n        captureConnection.preferredVideoStabilizationMode=AVCaptureVideoStabilizationModeAuto;\n    }\n    //预览图层和视频方向保持一致\n    captureConnection.videoOrientation = [self.previewlayer connection].videoOrientation;\n    \n    // 3.3将设备输出添加到会话中\n    if ([_session canAddOutput:_FileOutput]) {\n        [_session addOutput:_FileOutput];\n    }\n}\n\n```\n#### 4. 视频预览层\n一进入视频录制界面，这个时候 session就已经在采集数据了，并把数据显示在预览层上，用户选择录制后，再将采集到的数据写入文件。\n```\n    - (void)setUpPreviewLayerWithType:(FMVideoViewType )type\n{\n    CGRect rect = CGRectZero;\n    switch (type) {\n        case Type1X1:\n            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);\n            break;\n        case Type4X3:\n            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);\n            break;\n        case TypeFullScreen:\n            rect = [UIScreen mainScreen].bounds;\n            break;\n        default:\n            rect = [UIScreen mainScreen].bounds;\n            break;\n    }\n    self.previewlayer.frame = rect;\n    [_superView.layer insertSublayer:self.previewlayer atIndex:0];\n}\n```\n#### 5. 开始采集画面\n```\n[self.session startRunning];\n```\n#### 6.开始录制\n```\n- (void)writeDataTofile\n{\n    NSString *videoPath = [self createVideoFilePath];\n    self.videoUrl = [NSURL fileURLWithPath:videoPath];\n    [self.FileOutput startRecordingToOutputFileURL:self.videoUrl recordingDelegate:self];\n    \n}\n```\n### 3.AVCaptureSession+AVAssetWriter\n\n流程：\n```\n1. 创建捕捉会话\n2. 设置视频的输入 和 输出\n3. 设置音频的输入 和 输出\n4. 添加视频预览层\n5. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据\n6. 初始化AVAssetWriter, 我们会拿到视频和音频的数据流，用AVAssetWriter写入文件，这一步需要我们自己实现。\n```\n#### 1. 创建捕捉会话\n需要确保在同一个队列，最好队列只创建一次\n```\n\tself.session = [[AVCaptureSession alloc] init];\n    if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) {//设置分辨率\n        _session.sessionPreset=AVCaptureSessionPreset640x480;\n    }\n```\n#### 2.设置视频的输入 和 输出\n```\n- (void)setUpVideo\n{\n    // 2.1 获取视频输入设备(摄像头)\n    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头\n    // 2.2 创建视频输入源\n    NSError *error=nil;\n    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&error];\n    // 2.3 将视频输入源添加到会话\n    if ([self.session canAddInput:self.videoInput]) {\n        [self.session addInput:self.videoInput];\n    }\n    \n    self.videoOutput = [[AVCaptureVideoDataOutput alloc] init];\n    self.videoOutput.alwaysDiscardsLateVideoFrames = YES; //立即丢弃旧帧，节省内存，默认YES\n    [self.videoOutput setSampleBufferDelegate:self queue:self.videoQueue];\n    if ([self.session canAddOutput:self.videoOutput]) {\n        [self.session addOutput:self.videoOutput];\n    }\n    \n}\n```\n#### 3. 设置音频的输入 和 输出\n```\n- (void)setUpAudio\n{\n    // 2.2 获取音频输入设备\n    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];\n    NSError *error=nil;\n    // 2.4 创建音频输入源\n    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&error];\n    // 2.6 将音频输入源添加到会话\n    if ([self.session canAddInput:self.audioInput]) {\n        [self.session addInput:self.audioInput];\n    }\n    \n    self.audioOutput = [[AVCaptureAudioDataOutput alloc] init];\n    [self.audioOutput setSampleBufferDelegate:self queue:self.videoQueue];\n    if([self.session canAddOutput:self.audioOutput]) {\n        [self.session addOutput:self.audioOutput];\n    }\n    \n}\n```\n#### 4. 添加视频预览层\n```\n  - (void)setUpPreviewLayerWithType:(FMVideoViewType )type\n{\n    CGRect rect = CGRectZero;\n    switch (type) {\n        case Type1X1:\n            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);\n            break;\n        case Type4X3:\n            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);\n            break;\n        case TypeFullScreen:\n            rect = [UIScreen mainScreen].bounds;\n            break;\n        default:\n            rect = [UIScreen mainScreen].bounds;\n            break;\n    }\n    \n    self.previewlayer.frame = rect;\n    [_superView.layer insertSublayer:self.previewlayer atIndex:0];\n}\n```\n#### 5. 开始采集画面\n\n```\n   [self.session startRunning];\n```\n#### 6. 初始化AVAssetWriter\nAVAssetWriter 写入数据的过程需要在子线程中执行，并且每次写入数据都需要保证在同一个线程。\n```\n- (void)setUpWriter\n{\n    self.videoUrl = [[NSURL alloc] initFileURLWithPath:[self createVideoFilePath]];\n    self.writeManager = [[AVAssetWriteManager alloc] initWithURL:self.videoUrl viewType:_viewType];\n    self.writeManager.delegate = self;\n    \n}\n```\n#### 7.拿到数据流后处理\n视频数据和音频数据需要分开处理\n```\n- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection\n{\n    @autoreleasepool {\n        \n        //视频\n        if (connection == [self.videoOutput connectionWithMediaType:AVMediaTypeVideo]) {\n            \n            if (!self.writeManager.outputVideoFormatDescription) {\n                @synchronized(self) {\n                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);\n                    self.writeManager.outputVideoFormatDescription = formatDescription;\n                }\n            } else {\n                @synchronized(self) {\n                    if (self.writeManager.writeState == FMRecordStateRecording) {\n                        [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeVideo];\n                    }\n                    \n                }\n            }\n            \n            \n        }\n        \n        //音频\n        if (connection == [self.audioOutput connectionWithMediaType:AVMediaTypeAudio]) {\n            if (!self.writeManager.outputAudioFormatDescription) {\n                @synchronized(self) {\n                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);\n                    self.writeManager.outputAudioFormatDescription = formatDescription;\n                }\n            }\n            @synchronized(self) {\n                \n                if (self.writeManager.writeState == FMRecordStateRecording) {\n                    [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeAudio];\n                }\n                \n            }\n            \n        }\n    }\n    \n}\n```\n\n我们拿到最原始的数据以后，可以对其进行各种参数的设置\n```\n- (void)setUpWriter\n{\n    self.assetWriter = [AVAssetWriter assetWriterWithURL:self.videoUrl fileType:AVFileTypeMPEG4 error:nil];\n    //写入视频大小\n    NSInteger numPixels = self.outputSize.width * self.outputSize.height;\n    //每像素比特\n    CGFloat bitsPerPixel = 6.0;\n    NSInteger bitsPerSecond = numPixels * bitsPerPixel;\n    \n    // 码率和帧率设置\n    NSDictionary *compressionProperties = @{ AVVideoAverageBitRateKey : @(bitsPerSecond),\n                                             AVVideoExpectedSourceFrameRateKey : @(30),\n                                             AVVideoMaxKeyFrameIntervalKey : @(30),\n                                             AVVideoProfileLevelKey : AVVideoProfileLevelH264BaselineAutoLevel };\n    \n    //视频属性\n    self.videoCompressionSettings = @{ AVVideoCodecKey : AVVideoCodecH264,\n                                       AVVideoScalingModeKey : AVVideoScalingModeResizeAspectFill,\n                                       AVVideoWidthKey : @(self.outputSize.height),\n                                       AVVideoHeightKey : @(self.outputSize.width),\n                                       AVVideoCompressionPropertiesKey : compressionProperties };\n\n    _assetWriterVideoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:self.videoCompressionSettings];\n    //expectsMediaDataInRealTime 必须设为yes，需要从capture session 实时获取数据\n    _assetWriterVideoInput.expectsMediaDataInRealTime = YES;\n    _assetWriterVideoInput.transform = CGAffineTransformMakeRotation(M_PI / 2.0);\n    \n    \n    // 音频设置\n    self.audioCompressionSettings = @{ AVEncoderBitRatePerChannelKey : @(28000),\n                                       AVFormatIDKey : @(kAudioFormatMPEG4AAC),\n                                       AVNumberOfChannelsKey : @(1),\n                                       AVSampleRateKey : @(22050) };\n    \n    \n    _assetWriterAudioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:self.audioCompressionSettings];\n    _assetWriterAudioInput.expectsMediaDataInRealTime = YES;\n    \n    \n    if ([_assetWriter canAddInput:_assetWriterVideoInput]) {\n        [_assetWriter addInput:_assetWriterVideoInput];\n    }else {\n        NSLog(@\"AssetWriter videoInput append Failed\");\n    }\n    if ([_assetWriter canAddInput:_assetWriterAudioInput]) {\n        [_assetWriter addInput:_assetWriterAudioInput];\n    }else {\n        NSLog(@\"AssetWriter audioInput Append Failed\");\n    }\n    \n    \n    self.writeState = FMRecordStateRecording;\n}\n```\n设置好参数以后，就可以写入文件了。AVAssetWriter数据写入的过程有点复杂，demo中我新建AVAssetWriteManager分离出AVAssetWriter，单独处理写数据，这样逻辑会清晰一点。\n\n\n### fileOut和writer的相同点和不同点\n从上面的两个流程大致可以看出来，\n相同点：数据采集都在AVCaptureSession中进行，视频和音频的输入都一样，画面的预览一致。\n不同点：\n输出不一致, AVCaptureMovieFileOutput 只需要一个输出即可，指定一个文件路后，视频和音频会写入到指定路径，不需要其他复杂的操作。\nAVAssetWriter 需要 AVCaptureVideoDataOutput 和 AVCaptureAudioDataOutput 两个单独的输出，拿到各自的输出数据后，然后自己进行相应的处理。\n\n可配参数不一致，AVAssetWriter可以配置更多的参数。\n\n视频剪裁不一致，AVCaptureMovieFileOutput 如果要剪裁视频，因为系统已经把数据写到文件中了，我们需要从文件中独到一个完整的视频，然后处理；而AVAssetWriter我们拿到的是数据流，还没有合成视频，对数据流进行处理，所以两则剪裁方式也是不一样。\n\n其他添加背景音乐，水印等也是不一样的，这里没有涉及就不介绍了。到这里也差不多了，文章也有点长了。这些是我自己整理资料总结出来的，不排除会有一些错误之处，供大家学习参考，希望有所收获。如果方便，还请为我star一个，也算是对我的支持。\n\n[demo地址](https://github.com/suifengqjn/VideoRecord)\n\n\n","source":"_posts/iOS三种录制视频方式详细对比.md","raw":"---\ntitle: iOS三种录制视频方式详细对比\ntags:\n  - iOS\n  - 视频\n  - 录制视频\ncategories:\n  - iOS技术\ndate: 2017-03-22 00:24:33\n---\n\n### 先附上参考资料\n\n[http://www.jianshu.com/p/16cb14f53933](http://www.jianshu.com/p/16cb14f53933)\n\n[https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html](https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html)\n\n[https://github.com/objcio/VideoCaptureDemo](https://github.com/objcio/VideoCaptureDemo)\n\n[https://github.com/gsixxxx/DTSmallVideo](https://github.com/gsixxxx/DTSmallVideo)\n\n[https://github.com/AndyFightting/VideoRecord](https://github.com/AndyFightting/VideoRecord)\n\n### 卷首吐槽语\n这还是第一次接触自定义界面录制视频，包括各种参数的设置，不得不说，录制视频这块，各种类，各种方法，蛮复杂的，网上的资料也是各种杂乱，想要弄清楚还真是得费一番功夫，我参考了大量资料，根据自己的思路整理了一遍，按照我的思路来，保证你看一遍就会，我这里只是简单的录制，压缩，剪裁，导出等功能，不设计滤镜，添加背景音乐，合并，字幕等等，重要的是这个流程，主流程会了，其他也就是锦上添花了。\n\n先附上dome [demo地址](https://github.com/suifengqjn/VideoRecord)\n\n### 脑图\n方便大家对三中录制方式有一个大概的了解，看一下这张图片。\n![基本属性与类](https://github.com/suifengqjn/demoimages/blob/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/1.png?raw=true)\n第一种采用系统的录制较为简单，详细介绍后面两种。\n<!-- more -->\n\n### 效果图\n![1](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c1.png) ![2](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c2.png) ![3](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c3.png) ![4](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c4.png) ![5](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c5.png) ![6](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c6.png)\n\ndemo中把三种方式单独分开，便于学习。支持闪光灯，切换镜头，录制不同尺寸的视频等。\n\n### 1.UIImagePickerController\n\n这种方式只能设置一些简单参数，自定义程度不高,只能自定义界面上的操作按钮，还有视频的画质等。\n\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    if ([self isVideoRecordingAvailable]) {\n        return;\n    }\n    self.sourceType = UIImagePickerControllerSourceTypeCamera;\n    self.mediaTypes = @[(NSString *)kUTTypeMovie];\n    self.delegate = self;\n    \n    //隐藏系统自带UI\n    self.showsCameraControls = NO;\n    //设置摄像头\n    [self switchCameraIsFront:NO];\n    //设置视频画质类别\n    self.videoQuality = UIImagePickerControllerQualityTypeMedium;\n    //设置散光灯类型\n    self.cameraFlashMode = UIImagePickerControllerCameraFlashModeAuto;\n    //设置录制的最大时长\n    self.videoMaximumDuration = 20;\n}\n- (BOOL)isVideoRecordingAvailable\n{\n    if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]){\n        NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];\n        if([availableMediaTypes containsObject:(NSString *)kUTTypeMovie]){\n            return YES;\n        }\n    }\n    return NO;\n}\n\n- (void)switchCameraIsFront:(BOOL)front\n{\n    if (front) {\n        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront]){\n            [self setCameraDevice:UIImagePickerControllerCameraDeviceFront];\n            \n        }\n    } else {\n        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceRear]){\n            [self setCameraDevice:UIImagePickerControllerCameraDeviceRear];\n            \n        }\n    }\n}\n```\n\n### 2.AVCaptureSession+AVCaptureMovieFileOutput\n\n流程：\n```\n1. 创建捕捉会话\n2. 设置视频的输入\n3. 设置音频的输入\n4. 输出源设置,这里视频，音频数据会合并到一起输出，在代理方法中国也可以单独拿到视频或者音频数据，给AVCaptureMovieFileOutput指定路径，开始录制之后就会向这个路径写入数据\n5. 添加视频预览层\n6. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据\n```\n\n#### 0. 创建捕捉会话\n```\n\tself.session = [[AVCaptureSession alloc] init];\n    if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) {//设置分辨率\n        _session.sessionPreset=AVCaptureSessionPreset640x480;\n    }\n```\n#### 1. 视频的输入\n```\n   - (void)setUpVideo\n{\n    // 1.1 获取视频输入设备(摄像头)\n    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头\n    \n    // 视频 HDR (高动态范围图像)\n    // videoCaptureDevice.videoHDREnabled = YES;\n    // 设置最大，最小帧速率\n    //videoCaptureDevice.activeVideoMinFrameDuration = CMTimeMake(1, 60);\n    // 1.2 创建视频输入源\n    NSError *error=nil;\n    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&error];\n    // 1.3 将视频输入源添加到会话\n    if ([self.session canAddInput:self.videoInput]) {\n        [self.session addInput:self.videoInput];\n        \n    }\n}\n```\n#### 2. 音频的输入\n```\n// 2.1 获取音频输入设备\n    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];\n    NSError *error=nil;\n    // 2.2 创建音频输入源\n    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&error];\n    // 2.3 将音频输入源添加到会话\n    if ([self.session canAddInput:self.audioInput]) {\n        [self.session addInput:self.audioInput];\n    }\n```\n#### 3.输出源设置\n```\n- (void)setUpFileOut\n{\n    // 3.1初始化设备输出对象，用于获得输出数据\n    self.FileOutput=[[AVCaptureMovieFileOutput alloc]init];\n    \n    // 3.2设置输出对象的一些属性\n    AVCaptureConnection *captureConnection=[self.FileOutput connectionWithMediaType:AVMediaTypeVideo];\n    //设置防抖\n    //视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 AVCaptureConnection 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持：\n    if ([captureConnection isVideoStabilizationSupported ]) {\n        captureConnection.preferredVideoStabilizationMode=AVCaptureVideoStabilizationModeAuto;\n    }\n    //预览图层和视频方向保持一致\n    captureConnection.videoOrientation = [self.previewlayer connection].videoOrientation;\n    \n    // 3.3将设备输出添加到会话中\n    if ([_session canAddOutput:_FileOutput]) {\n        [_session addOutput:_FileOutput];\n    }\n}\n\n```\n#### 4. 视频预览层\n一进入视频录制界面，这个时候 session就已经在采集数据了，并把数据显示在预览层上，用户选择录制后，再将采集到的数据写入文件。\n```\n    - (void)setUpPreviewLayerWithType:(FMVideoViewType )type\n{\n    CGRect rect = CGRectZero;\n    switch (type) {\n        case Type1X1:\n            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);\n            break;\n        case Type4X3:\n            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);\n            break;\n        case TypeFullScreen:\n            rect = [UIScreen mainScreen].bounds;\n            break;\n        default:\n            rect = [UIScreen mainScreen].bounds;\n            break;\n    }\n    self.previewlayer.frame = rect;\n    [_superView.layer insertSublayer:self.previewlayer atIndex:0];\n}\n```\n#### 5. 开始采集画面\n```\n[self.session startRunning];\n```\n#### 6.开始录制\n```\n- (void)writeDataTofile\n{\n    NSString *videoPath = [self createVideoFilePath];\n    self.videoUrl = [NSURL fileURLWithPath:videoPath];\n    [self.FileOutput startRecordingToOutputFileURL:self.videoUrl recordingDelegate:self];\n    \n}\n```\n### 3.AVCaptureSession+AVAssetWriter\n\n流程：\n```\n1. 创建捕捉会话\n2. 设置视频的输入 和 输出\n3. 设置音频的输入 和 输出\n4. 添加视频预览层\n5. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据\n6. 初始化AVAssetWriter, 我们会拿到视频和音频的数据流，用AVAssetWriter写入文件，这一步需要我们自己实现。\n```\n#### 1. 创建捕捉会话\n需要确保在同一个队列，最好队列只创建一次\n```\n\tself.session = [[AVCaptureSession alloc] init];\n    if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) {//设置分辨率\n        _session.sessionPreset=AVCaptureSessionPreset640x480;\n    }\n```\n#### 2.设置视频的输入 和 输出\n```\n- (void)setUpVideo\n{\n    // 2.1 获取视频输入设备(摄像头)\n    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头\n    // 2.2 创建视频输入源\n    NSError *error=nil;\n    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&error];\n    // 2.3 将视频输入源添加到会话\n    if ([self.session canAddInput:self.videoInput]) {\n        [self.session addInput:self.videoInput];\n    }\n    \n    self.videoOutput = [[AVCaptureVideoDataOutput alloc] init];\n    self.videoOutput.alwaysDiscardsLateVideoFrames = YES; //立即丢弃旧帧，节省内存，默认YES\n    [self.videoOutput setSampleBufferDelegate:self queue:self.videoQueue];\n    if ([self.session canAddOutput:self.videoOutput]) {\n        [self.session addOutput:self.videoOutput];\n    }\n    \n}\n```\n#### 3. 设置音频的输入 和 输出\n```\n- (void)setUpAudio\n{\n    // 2.2 获取音频输入设备\n    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];\n    NSError *error=nil;\n    // 2.4 创建音频输入源\n    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&error];\n    // 2.6 将音频输入源添加到会话\n    if ([self.session canAddInput:self.audioInput]) {\n        [self.session addInput:self.audioInput];\n    }\n    \n    self.audioOutput = [[AVCaptureAudioDataOutput alloc] init];\n    [self.audioOutput setSampleBufferDelegate:self queue:self.videoQueue];\n    if([self.session canAddOutput:self.audioOutput]) {\n        [self.session addOutput:self.audioOutput];\n    }\n    \n}\n```\n#### 4. 添加视频预览层\n```\n  - (void)setUpPreviewLayerWithType:(FMVideoViewType )type\n{\n    CGRect rect = CGRectZero;\n    switch (type) {\n        case Type1X1:\n            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);\n            break;\n        case Type4X3:\n            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);\n            break;\n        case TypeFullScreen:\n            rect = [UIScreen mainScreen].bounds;\n            break;\n        default:\n            rect = [UIScreen mainScreen].bounds;\n            break;\n    }\n    \n    self.previewlayer.frame = rect;\n    [_superView.layer insertSublayer:self.previewlayer atIndex:0];\n}\n```\n#### 5. 开始采集画面\n\n```\n   [self.session startRunning];\n```\n#### 6. 初始化AVAssetWriter\nAVAssetWriter 写入数据的过程需要在子线程中执行，并且每次写入数据都需要保证在同一个线程。\n```\n- (void)setUpWriter\n{\n    self.videoUrl = [[NSURL alloc] initFileURLWithPath:[self createVideoFilePath]];\n    self.writeManager = [[AVAssetWriteManager alloc] initWithURL:self.videoUrl viewType:_viewType];\n    self.writeManager.delegate = self;\n    \n}\n```\n#### 7.拿到数据流后处理\n视频数据和音频数据需要分开处理\n```\n- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection\n{\n    @autoreleasepool {\n        \n        //视频\n        if (connection == [self.videoOutput connectionWithMediaType:AVMediaTypeVideo]) {\n            \n            if (!self.writeManager.outputVideoFormatDescription) {\n                @synchronized(self) {\n                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);\n                    self.writeManager.outputVideoFormatDescription = formatDescription;\n                }\n            } else {\n                @synchronized(self) {\n                    if (self.writeManager.writeState == FMRecordStateRecording) {\n                        [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeVideo];\n                    }\n                    \n                }\n            }\n            \n            \n        }\n        \n        //音频\n        if (connection == [self.audioOutput connectionWithMediaType:AVMediaTypeAudio]) {\n            if (!self.writeManager.outputAudioFormatDescription) {\n                @synchronized(self) {\n                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);\n                    self.writeManager.outputAudioFormatDescription = formatDescription;\n                }\n            }\n            @synchronized(self) {\n                \n                if (self.writeManager.writeState == FMRecordStateRecording) {\n                    [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeAudio];\n                }\n                \n            }\n            \n        }\n    }\n    \n}\n```\n\n我们拿到最原始的数据以后，可以对其进行各种参数的设置\n```\n- (void)setUpWriter\n{\n    self.assetWriter = [AVAssetWriter assetWriterWithURL:self.videoUrl fileType:AVFileTypeMPEG4 error:nil];\n    //写入视频大小\n    NSInteger numPixels = self.outputSize.width * self.outputSize.height;\n    //每像素比特\n    CGFloat bitsPerPixel = 6.0;\n    NSInteger bitsPerSecond = numPixels * bitsPerPixel;\n    \n    // 码率和帧率设置\n    NSDictionary *compressionProperties = @{ AVVideoAverageBitRateKey : @(bitsPerSecond),\n                                             AVVideoExpectedSourceFrameRateKey : @(30),\n                                             AVVideoMaxKeyFrameIntervalKey : @(30),\n                                             AVVideoProfileLevelKey : AVVideoProfileLevelH264BaselineAutoLevel };\n    \n    //视频属性\n    self.videoCompressionSettings = @{ AVVideoCodecKey : AVVideoCodecH264,\n                                       AVVideoScalingModeKey : AVVideoScalingModeResizeAspectFill,\n                                       AVVideoWidthKey : @(self.outputSize.height),\n                                       AVVideoHeightKey : @(self.outputSize.width),\n                                       AVVideoCompressionPropertiesKey : compressionProperties };\n\n    _assetWriterVideoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:self.videoCompressionSettings];\n    //expectsMediaDataInRealTime 必须设为yes，需要从capture session 实时获取数据\n    _assetWriterVideoInput.expectsMediaDataInRealTime = YES;\n    _assetWriterVideoInput.transform = CGAffineTransformMakeRotation(M_PI / 2.0);\n    \n    \n    // 音频设置\n    self.audioCompressionSettings = @{ AVEncoderBitRatePerChannelKey : @(28000),\n                                       AVFormatIDKey : @(kAudioFormatMPEG4AAC),\n                                       AVNumberOfChannelsKey : @(1),\n                                       AVSampleRateKey : @(22050) };\n    \n    \n    _assetWriterAudioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:self.audioCompressionSettings];\n    _assetWriterAudioInput.expectsMediaDataInRealTime = YES;\n    \n    \n    if ([_assetWriter canAddInput:_assetWriterVideoInput]) {\n        [_assetWriter addInput:_assetWriterVideoInput];\n    }else {\n        NSLog(@\"AssetWriter videoInput append Failed\");\n    }\n    if ([_assetWriter canAddInput:_assetWriterAudioInput]) {\n        [_assetWriter addInput:_assetWriterAudioInput];\n    }else {\n        NSLog(@\"AssetWriter audioInput Append Failed\");\n    }\n    \n    \n    self.writeState = FMRecordStateRecording;\n}\n```\n设置好参数以后，就可以写入文件了。AVAssetWriter数据写入的过程有点复杂，demo中我新建AVAssetWriteManager分离出AVAssetWriter，单独处理写数据，这样逻辑会清晰一点。\n\n\n### fileOut和writer的相同点和不同点\n从上面的两个流程大致可以看出来，\n相同点：数据采集都在AVCaptureSession中进行，视频和音频的输入都一样，画面的预览一致。\n不同点：\n输出不一致, AVCaptureMovieFileOutput 只需要一个输出即可，指定一个文件路后，视频和音频会写入到指定路径，不需要其他复杂的操作。\nAVAssetWriter 需要 AVCaptureVideoDataOutput 和 AVCaptureAudioDataOutput 两个单独的输出，拿到各自的输出数据后，然后自己进行相应的处理。\n\n可配参数不一致，AVAssetWriter可以配置更多的参数。\n\n视频剪裁不一致，AVCaptureMovieFileOutput 如果要剪裁视频，因为系统已经把数据写到文件中了，我们需要从文件中独到一个完整的视频，然后处理；而AVAssetWriter我们拿到的是数据流，还没有合成视频，对数据流进行处理，所以两则剪裁方式也是不一样。\n\n其他添加背景音乐，水印等也是不一样的，这里没有涉及就不介绍了。到这里也差不多了，文章也有点长了。这些是我自己整理资料总结出来的，不排除会有一些错误之处，供大家学习参考，希望有所收获。如果方便，还请为我star一个，也算是对我的支持。\n\n[demo地址](https://github.com/suifengqjn/VideoRecord)\n\n\n","slug":"iOS三种录制视频方式详细对比","published":1,"updated":"2017-03-21T16:27:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5teb001alx60cmyuuct8","content":"<h3 id=\"先附上参考资料\"><a href=\"#先附上参考资料\" class=\"headerlink\" title=\"先附上参考资料\"></a>先附上参考资料</h3><p><a href=\"http://www.jianshu.com/p/16cb14f53933\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/16cb14f53933</a></p>\n<p><a href=\"https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html</a></p>\n<p><a href=\"https://github.com/objcio/VideoCaptureDemo\" target=\"_blank\" rel=\"external\">https://github.com/objcio/VideoCaptureDemo</a></p>\n<p><a href=\"https://github.com/gsixxxx/DTSmallVideo\" target=\"_blank\" rel=\"external\">https://github.com/gsixxxx/DTSmallVideo</a></p>\n<p><a href=\"https://github.com/AndyFightting/VideoRecord\" target=\"_blank\" rel=\"external\">https://github.com/AndyFightting/VideoRecord</a></p>\n<h3 id=\"卷首吐槽语\"><a href=\"#卷首吐槽语\" class=\"headerlink\" title=\"卷首吐槽语\"></a>卷首吐槽语</h3><p>这还是第一次接触自定义界面录制视频，包括各种参数的设置，不得不说，录制视频这块，各种类，各种方法，蛮复杂的，网上的资料也是各种杂乱，想要弄清楚还真是得费一番功夫，我参考了大量资料，根据自己的思路整理了一遍，按照我的思路来，保证你看一遍就会，我这里只是简单的录制，压缩，剪裁，导出等功能，不设计滤镜，添加背景音乐，合并，字幕等等，重要的是这个流程，主流程会了，其他也就是锦上添花了。</p>\n<p>先附上dome <a href=\"https://github.com/suifengqjn/VideoRecord\" target=\"_blank\" rel=\"external\">demo地址</a></p>\n<h3 id=\"脑图\"><a href=\"#脑图\" class=\"headerlink\" title=\"脑图\"></a>脑图</h3><p>方便大家对三中录制方式有一个大概的了解，看一下这张图片。<br><img src=\"https://github.com/suifengqjn/demoimages/blob/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/1.png?raw=true\" alt=\"基本属性与类\"><br>第一种采用系统的录制较为简单，详细介绍后面两种。<br><a id=\"more\"></a></p>\n<h3 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c1.png\" alt=\"1\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c2.png\" alt=\"2\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c3.png\" alt=\"3\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c4.png\" alt=\"4\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c5.png\" alt=\"5\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c6.png\" alt=\"6\"></p>\n<p>demo中把三种方式单独分开，便于学习。支持闪光灯，切换镜头，录制不同尺寸的视频等。</p>\n<h3 id=\"1-UIImagePickerController\"><a href=\"#1-UIImagePickerController\" class=\"headerlink\" title=\"1.UIImagePickerController\"></a>1.UIImagePickerController</h3><p>这种方式只能设置一些简单参数，自定义程度不高,只能自定义界面上的操作按钮，还有视频的画质等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    if ([self isVideoRecordingAvailable]) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.sourceType = UIImagePickerControllerSourceTypeCamera;</div><div class=\"line\">    self.mediaTypes = @[(NSString *)kUTTypeMovie];</div><div class=\"line\">    self.delegate = self;</div><div class=\"line\">    </div><div class=\"line\">    //隐藏系统自带UI</div><div class=\"line\">    self.showsCameraControls = NO;</div><div class=\"line\">    //设置摄像头</div><div class=\"line\">    [self switchCameraIsFront:NO];</div><div class=\"line\">    //设置视频画质类别</div><div class=\"line\">    self.videoQuality = UIImagePickerControllerQualityTypeMedium;</div><div class=\"line\">    //设置散光灯类型</div><div class=\"line\">    self.cameraFlashMode = UIImagePickerControllerCameraFlashModeAuto;</div><div class=\"line\">    //设置录制的最大时长</div><div class=\"line\">    self.videoMaximumDuration = 20;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isVideoRecordingAvailable</div><div class=\"line\">&#123;</div><div class=\"line\">    if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera])&#123;</div><div class=\"line\">        NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];</div><div class=\"line\">        if([availableMediaTypes containsObject:(NSString *)kUTTypeMovie])&#123;</div><div class=\"line\">            return YES;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)switchCameraIsFront:(BOOL)front</div><div class=\"line\">&#123;</div><div class=\"line\">    if (front) &#123;</div><div class=\"line\">        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront])&#123;</div><div class=\"line\">            [self setCameraDevice:UIImagePickerControllerCameraDeviceFront];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceRear])&#123;</div><div class=\"line\">            [self setCameraDevice:UIImagePickerControllerCameraDeviceRear];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-AVCaptureSession-AVCaptureMovieFileOutput\"><a href=\"#2-AVCaptureSession-AVCaptureMovieFileOutput\" class=\"headerlink\" title=\"2.AVCaptureSession+AVCaptureMovieFileOutput\"></a>2.AVCaptureSession+AVCaptureMovieFileOutput</h3><p>流程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 创建捕捉会话</div><div class=\"line\">2. 设置视频的输入</div><div class=\"line\">3. 设置音频的输入</div><div class=\"line\">4. 输出源设置,这里视频，音频数据会合并到一起输出，在代理方法中国也可以单独拿到视频或者音频数据，给AVCaptureMovieFileOutput指定路径，开始录制之后就会向这个路径写入数据</div><div class=\"line\">5. 添加视频预览层</div><div class=\"line\">6. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据</div></pre></td></tr></table></figure></p>\n<h4 id=\"0-创建捕捉会话\"><a href=\"#0-创建捕捉会话\" class=\"headerlink\" title=\"0. 创建捕捉会话\"></a>0. 创建捕捉会话</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.session = [[AVCaptureSession alloc] init];</div><div class=\"line\">   if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;//设置分辨率</div><div class=\"line\">       _session.sessionPreset=AVCaptureSessionPreset640x480;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"1-视频的输入\"><a href=\"#1-视频的输入\" class=\"headerlink\" title=\"1. 视频的输入\"></a>1. 视频的输入</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">   - (void)setUpVideo</div><div class=\"line\">&#123;</div><div class=\"line\">    // 1.1 获取视频输入设备(摄像头)</div><div class=\"line\">    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头</div><div class=\"line\">    </div><div class=\"line\">    // 视频 HDR (高动态范围图像)</div><div class=\"line\">    // videoCaptureDevice.videoHDREnabled = YES;</div><div class=\"line\">    // 设置最大，最小帧速率</div><div class=\"line\">    //videoCaptureDevice.activeVideoMinFrameDuration = CMTimeMake(1, 60);</div><div class=\"line\">    // 1.2 创建视频输入源</div><div class=\"line\">    NSError *error=nil;</div><div class=\"line\">    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&amp;error];</div><div class=\"line\">    // 1.3 将视频输入源添加到会话</div><div class=\"line\">    if ([self.session canAddInput:self.videoInput]) &#123;</div><div class=\"line\">        [self.session addInput:self.videoInput];</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-音频的输入\"><a href=\"#2-音频的输入\" class=\"headerlink\" title=\"2. 音频的输入\"></a>2. 音频的输入</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 2.1 获取音频输入设备</div><div class=\"line\">    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];</div><div class=\"line\">    NSError *error=nil;</div><div class=\"line\">    // 2.2 创建音频输入源</div><div class=\"line\">    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&amp;error];</div><div class=\"line\">    // 2.3 将音频输入源添加到会话</div><div class=\"line\">    if ([self.session canAddInput:self.audioInput]) &#123;</div><div class=\"line\">        [self.session addInput:self.audioInput];</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-输出源设置\"><a href=\"#3-输出源设置\" class=\"headerlink\" title=\"3.输出源设置\"></a>3.输出源设置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setUpFileOut</div><div class=\"line\">&#123;</div><div class=\"line\">    // 3.1初始化设备输出对象，用于获得输出数据</div><div class=\"line\">    self.FileOutput=[[AVCaptureMovieFileOutput alloc]init];</div><div class=\"line\">    </div><div class=\"line\">    // 3.2设置输出对象的一些属性</div><div class=\"line\">    AVCaptureConnection *captureConnection=[self.FileOutput connectionWithMediaType:AVMediaTypeVideo];</div><div class=\"line\">    //设置防抖</div><div class=\"line\">    //视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 AVCaptureConnection 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持：</div><div class=\"line\">    if ([captureConnection isVideoStabilizationSupported ]) &#123;</div><div class=\"line\">        captureConnection.preferredVideoStabilizationMode=AVCaptureVideoStabilizationModeAuto;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //预览图层和视频方向保持一致</div><div class=\"line\">    captureConnection.videoOrientation = [self.previewlayer connection].videoOrientation;</div><div class=\"line\">    </div><div class=\"line\">    // 3.3将设备输出添加到会话中</div><div class=\"line\">    if ([_session canAddOutput:_FileOutput]) &#123;</div><div class=\"line\">        [_session addOutput:_FileOutput];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-视频预览层\"><a href=\"#4-视频预览层\" class=\"headerlink\" title=\"4. 视频预览层\"></a>4. 视频预览层</h4><p>一进入视频录制界面，这个时候 session就已经在采集数据了，并把数据显示在预览层上，用户选择录制后，再将采集到的数据写入文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">    - (void)setUpPreviewLayerWithType:(FMVideoViewType )type</div><div class=\"line\">&#123;</div><div class=\"line\">    CGRect rect = CGRectZero;</div><div class=\"line\">    switch (type) &#123;</div><div class=\"line\">        case Type1X1:</div><div class=\"line\">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);</div><div class=\"line\">            break;</div><div class=\"line\">        case Type4X3:</div><div class=\"line\">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);</div><div class=\"line\">            break;</div><div class=\"line\">        case TypeFullScreen:</div><div class=\"line\">            rect = [UIScreen mainScreen].bounds;</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            rect = [UIScreen mainScreen].bounds;</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.previewlayer.frame = rect;</div><div class=\"line\">    [_superView.layer insertSublayer:self.previewlayer atIndex:0];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"5-开始采集画面\"><a href=\"#5-开始采集画面\" class=\"headerlink\" title=\"5. 开始采集画面\"></a>5. 开始采集画面</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.session startRunning];</div></pre></td></tr></table></figure>\n<h4 id=\"6-开始录制\"><a href=\"#6-开始录制\" class=\"headerlink\" title=\"6.开始录制\"></a>6.开始录制</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)writeDataTofile</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString *videoPath = [self createVideoFilePath];</div><div class=\"line\">    self.videoUrl = [NSURL fileURLWithPath:videoPath];</div><div class=\"line\">    [self.FileOutput startRecordingToOutputFileURL:self.videoUrl recordingDelegate:self];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-AVCaptureSession-AVAssetWriter\"><a href=\"#3-AVCaptureSession-AVAssetWriter\" class=\"headerlink\" title=\"3.AVCaptureSession+AVAssetWriter\"></a>3.AVCaptureSession+AVAssetWriter</h3><p>流程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 创建捕捉会话</div><div class=\"line\">2. 设置视频的输入 和 输出</div><div class=\"line\">3. 设置音频的输入 和 输出</div><div class=\"line\">4. 添加视频预览层</div><div class=\"line\">5. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据</div><div class=\"line\">6. 初始化AVAssetWriter, 我们会拿到视频和音频的数据流，用AVAssetWriter写入文件，这一步需要我们自己实现。</div></pre></td></tr></table></figure></p>\n<h4 id=\"1-创建捕捉会话\"><a href=\"#1-创建捕捉会话\" class=\"headerlink\" title=\"1. 创建捕捉会话\"></a>1. 创建捕捉会话</h4><p>需要确保在同一个队列，最好队列只创建一次<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.session = [[AVCaptureSession alloc] init];</div><div class=\"line\">   if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;//设置分辨率</div><div class=\"line\">       _session.sessionPreset=AVCaptureSessionPreset640x480;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-设置视频的输入-和-输出\"><a href=\"#2-设置视频的输入-和-输出\" class=\"headerlink\" title=\"2.设置视频的输入 和 输出\"></a>2.设置视频的输入 和 输出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setUpVideo</div><div class=\"line\">&#123;</div><div class=\"line\">    // 2.1 获取视频输入设备(摄像头)</div><div class=\"line\">    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头</div><div class=\"line\">    // 2.2 创建视频输入源</div><div class=\"line\">    NSError *error=nil;</div><div class=\"line\">    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&amp;error];</div><div class=\"line\">    // 2.3 将视频输入源添加到会话</div><div class=\"line\">    if ([self.session canAddInput:self.videoInput]) &#123;</div><div class=\"line\">        [self.session addInput:self.videoInput];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.videoOutput = [[AVCaptureVideoDataOutput alloc] init];</div><div class=\"line\">    self.videoOutput.alwaysDiscardsLateVideoFrames = YES; //立即丢弃旧帧，节省内存，默认YES</div><div class=\"line\">    [self.videoOutput setSampleBufferDelegate:self queue:self.videoQueue];</div><div class=\"line\">    if ([self.session canAddOutput:self.videoOutput]) &#123;</div><div class=\"line\">        [self.session addOutput:self.videoOutput];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-设置音频的输入-和-输出\"><a href=\"#3-设置音频的输入-和-输出\" class=\"headerlink\" title=\"3. 设置音频的输入 和 输出\"></a>3. 设置音频的输入 和 输出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setUpAudio</div><div class=\"line\">&#123;</div><div class=\"line\">    // 2.2 获取音频输入设备</div><div class=\"line\">    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];</div><div class=\"line\">    NSError *error=nil;</div><div class=\"line\">    // 2.4 创建音频输入源</div><div class=\"line\">    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&amp;error];</div><div class=\"line\">    // 2.6 将音频输入源添加到会话</div><div class=\"line\">    if ([self.session canAddInput:self.audioInput]) &#123;</div><div class=\"line\">        [self.session addInput:self.audioInput];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.audioOutput = [[AVCaptureAudioDataOutput alloc] init];</div><div class=\"line\">    [self.audioOutput setSampleBufferDelegate:self queue:self.videoQueue];</div><div class=\"line\">    if([self.session canAddOutput:self.audioOutput]) &#123;</div><div class=\"line\">        [self.session addOutput:self.audioOutput];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-添加视频预览层\"><a href=\"#4-添加视频预览层\" class=\"headerlink\" title=\"4. 添加视频预览层\"></a>4. 添加视频预览层</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">  - (void)setUpPreviewLayerWithType:(FMVideoViewType )type</div><div class=\"line\">&#123;</div><div class=\"line\">    CGRect rect = CGRectZero;</div><div class=\"line\">    switch (type) &#123;</div><div class=\"line\">        case Type1X1:</div><div class=\"line\">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);</div><div class=\"line\">            break;</div><div class=\"line\">        case Type4X3:</div><div class=\"line\">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);</div><div class=\"line\">            break;</div><div class=\"line\">        case TypeFullScreen:</div><div class=\"line\">            rect = [UIScreen mainScreen].bounds;</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            rect = [UIScreen mainScreen].bounds;</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.previewlayer.frame = rect;</div><div class=\"line\">    [_superView.layer insertSublayer:self.previewlayer atIndex:0];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5-开始采集画面-1\"><a href=\"#5-开始采集画面-1\" class=\"headerlink\" title=\"5. 开始采集画面\"></a>5. 开始采集画面</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.session startRunning];</div></pre></td></tr></table></figure>\n<h4 id=\"6-初始化AVAssetWriter\"><a href=\"#6-初始化AVAssetWriter\" class=\"headerlink\" title=\"6. 初始化AVAssetWriter\"></a>6. 初始化AVAssetWriter</h4><p>AVAssetWriter 写入数据的过程需要在子线程中执行，并且每次写入数据都需要保证在同一个线程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setUpWriter</div><div class=\"line\">&#123;</div><div class=\"line\">    self.videoUrl = [[NSURL alloc] initFileURLWithPath:[self createVideoFilePath]];</div><div class=\"line\">    self.writeManager = [[AVAssetWriteManager alloc] initWithURL:self.videoUrl viewType:_viewType];</div><div class=\"line\">    self.writeManager.delegate = self;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"7-拿到数据流后处理\"><a href=\"#7-拿到数据流后处理\" class=\"headerlink\" title=\"7.拿到数据流后处理\"></a>7.拿到数据流后处理</h4><p>视频数据和音频数据需要分开处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection</div><div class=\"line\">&#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        </div><div class=\"line\">        //视频</div><div class=\"line\">        if (connection == [self.videoOutput connectionWithMediaType:AVMediaTypeVideo]) &#123;</div><div class=\"line\">            </div><div class=\"line\">            if (!self.writeManager.outputVideoFormatDescription) &#123;</div><div class=\"line\">                @synchronized(self) &#123;</div><div class=\"line\">                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class=\"line\">                    self.writeManager.outputVideoFormatDescription = formatDescription;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                @synchronized(self) &#123;</div><div class=\"line\">                    if (self.writeManager.writeState == FMRecordStateRecording) &#123;</div><div class=\"line\">                        [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeVideo];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    </div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        //音频</div><div class=\"line\">        if (connection == [self.audioOutput connectionWithMediaType:AVMediaTypeAudio]) &#123;</div><div class=\"line\">            if (!self.writeManager.outputAudioFormatDescription) &#123;</div><div class=\"line\">                @synchronized(self) &#123;</div><div class=\"line\">                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class=\"line\">                    self.writeManager.outputAudioFormatDescription = formatDescription;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            @synchronized(self) &#123;</div><div class=\"line\">                </div><div class=\"line\">                if (self.writeManager.writeState == FMRecordStateRecording) &#123;</div><div class=\"line\">                    [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeAudio];</div><div class=\"line\">                &#125;</div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们拿到最原始的数据以后，可以对其进行各种参数的设置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setUpWriter</div><div class=\"line\">&#123;</div><div class=\"line\">    self.assetWriter = [AVAssetWriter assetWriterWithURL:self.videoUrl fileType:AVFileTypeMPEG4 error:nil];</div><div class=\"line\">    //写入视频大小</div><div class=\"line\">    NSInteger numPixels = self.outputSize.width * self.outputSize.height;</div><div class=\"line\">    //每像素比特</div><div class=\"line\">    CGFloat bitsPerPixel = 6.0;</div><div class=\"line\">    NSInteger bitsPerSecond = numPixels * bitsPerPixel;</div><div class=\"line\">    </div><div class=\"line\">    // 码率和帧率设置</div><div class=\"line\">    NSDictionary *compressionProperties = @&#123; AVVideoAverageBitRateKey : @(bitsPerSecond),</div><div class=\"line\">                                             AVVideoExpectedSourceFrameRateKey : @(30),</div><div class=\"line\">                                             AVVideoMaxKeyFrameIntervalKey : @(30),</div><div class=\"line\">                                             AVVideoProfileLevelKey : AVVideoProfileLevelH264BaselineAutoLevel &#125;;</div><div class=\"line\">    </div><div class=\"line\">    //视频属性</div><div class=\"line\">    self.videoCompressionSettings = @&#123; AVVideoCodecKey : AVVideoCodecH264,</div><div class=\"line\">                                       AVVideoScalingModeKey : AVVideoScalingModeResizeAspectFill,</div><div class=\"line\">                                       AVVideoWidthKey : @(self.outputSize.height),</div><div class=\"line\">                                       AVVideoHeightKey : @(self.outputSize.width),</div><div class=\"line\">                                       AVVideoCompressionPropertiesKey : compressionProperties &#125;;</div><div class=\"line\"></div><div class=\"line\">    _assetWriterVideoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:self.videoCompressionSettings];</div><div class=\"line\">    //expectsMediaDataInRealTime 必须设为yes，需要从capture session 实时获取数据</div><div class=\"line\">    _assetWriterVideoInput.expectsMediaDataInRealTime = YES;</div><div class=\"line\">    _assetWriterVideoInput.transform = CGAffineTransformMakeRotation(M_PI / 2.0);</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    // 音频设置</div><div class=\"line\">    self.audioCompressionSettings = @&#123; AVEncoderBitRatePerChannelKey : @(28000),</div><div class=\"line\">                                       AVFormatIDKey : @(kAudioFormatMPEG4AAC),</div><div class=\"line\">                                       AVNumberOfChannelsKey : @(1),</div><div class=\"line\">                                       AVSampleRateKey : @(22050) &#125;;</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    _assetWriterAudioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:self.audioCompressionSettings];</div><div class=\"line\">    _assetWriterAudioInput.expectsMediaDataInRealTime = YES;</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    if ([_assetWriter canAddInput:_assetWriterVideoInput]) &#123;</div><div class=\"line\">        [_assetWriter addInput:_assetWriterVideoInput];</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        NSLog(@&quot;AssetWriter videoInput append Failed&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ([_assetWriter canAddInput:_assetWriterAudioInput]) &#123;</div><div class=\"line\">        [_assetWriter addInput:_assetWriterAudioInput];</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        NSLog(@&quot;AssetWriter audioInput Append Failed&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    self.writeState = FMRecordStateRecording;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>设置好参数以后，就可以写入文件了。AVAssetWriter数据写入的过程有点复杂，demo中我新建AVAssetWriteManager分离出AVAssetWriter，单独处理写数据，这样逻辑会清晰一点。</p>\n<h3 id=\"fileOut和writer的相同点和不同点\"><a href=\"#fileOut和writer的相同点和不同点\" class=\"headerlink\" title=\"fileOut和writer的相同点和不同点\"></a>fileOut和writer的相同点和不同点</h3><p>从上面的两个流程大致可以看出来，<br>相同点：数据采集都在AVCaptureSession中进行，视频和音频的输入都一样，画面的预览一致。<br>不同点：<br>输出不一致, AVCaptureMovieFileOutput 只需要一个输出即可，指定一个文件路后，视频和音频会写入到指定路径，不需要其他复杂的操作。<br>AVAssetWriter 需要 AVCaptureVideoDataOutput 和 AVCaptureAudioDataOutput 两个单独的输出，拿到各自的输出数据后，然后自己进行相应的处理。</p>\n<p>可配参数不一致，AVAssetWriter可以配置更多的参数。</p>\n<p>视频剪裁不一致，AVCaptureMovieFileOutput 如果要剪裁视频，因为系统已经把数据写到文件中了，我们需要从文件中独到一个完整的视频，然后处理；而AVAssetWriter我们拿到的是数据流，还没有合成视频，对数据流进行处理，所以两则剪裁方式也是不一样。</p>\n<p>其他添加背景音乐，水印等也是不一样的，这里没有涉及就不介绍了。到这里也差不多了，文章也有点长了。这些是我自己整理资料总结出来的，不排除会有一些错误之处，供大家学习参考，希望有所收获。如果方便，还请为我star一个，也算是对我的支持。</p>\n<p><a href=\"https://github.com/suifengqjn/VideoRecord\" target=\"_blank\" rel=\"external\">demo地址</a></p>\n","excerpt":"<h3 id=\"先附上参考资料\"><a href=\"#先附上参考资料\" class=\"headerlink\" title=\"先附上参考资料\"></a>先附上参考资料</h3><p><a href=\"http://www.jianshu.com/p/16cb14f53933\">http://www.jianshu.com/p/16cb14f53933</a></p>\n<p><a href=\"https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html\">https://developer.apple.com/library/content/samplecode/AVSimpleEditoriOS/Introduction/Intro.html</a></p>\n<p><a href=\"https://github.com/objcio/VideoCaptureDemo\">https://github.com/objcio/VideoCaptureDemo</a></p>\n<p><a href=\"https://github.com/gsixxxx/DTSmallVideo\">https://github.com/gsixxxx/DTSmallVideo</a></p>\n<p><a href=\"https://github.com/AndyFightting/VideoRecord\">https://github.com/AndyFightting/VideoRecord</a></p>\n<h3 id=\"卷首吐槽语\"><a href=\"#卷首吐槽语\" class=\"headerlink\" title=\"卷首吐槽语\"></a>卷首吐槽语</h3><p>这还是第一次接触自定义界面录制视频，包括各种参数的设置，不得不说，录制视频这块，各种类，各种方法，蛮复杂的，网上的资料也是各种杂乱，想要弄清楚还真是得费一番功夫，我参考了大量资料，根据自己的思路整理了一遍，按照我的思路来，保证你看一遍就会，我这里只是简单的录制，压缩，剪裁，导出等功能，不设计滤镜，添加背景音乐，合并，字幕等等，重要的是这个流程，主流程会了，其他也就是锦上添花了。</p>\n<p>先附上dome <a href=\"https://github.com/suifengqjn/VideoRecord\">demo地址</a></p>\n<h3 id=\"脑图\"><a href=\"#脑图\" class=\"headerlink\" title=\"脑图\"></a>脑图</h3><p>方便大家对三中录制方式有一个大概的了解，看一下这张图片。<br><img src=\"https://github.com/suifengqjn/demoimages/blob/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/1.png?raw=true\" alt=\"基本属性与类\"><br>第一种采用系统的录制较为简单，详细介绍后面两种。<br>","more":"</p>\n<h3 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c1.png\" alt=\"1\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c2.png\" alt=\"2\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c3.png\" alt=\"3\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c4.png\" alt=\"4\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c5.png\" alt=\"5\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6/c6.png\" alt=\"6\"></p>\n<p>demo中把三种方式单独分开，便于学习。支持闪光灯，切换镜头，录制不同尺寸的视频等。</p>\n<h3 id=\"1-UIImagePickerController\"><a href=\"#1-UIImagePickerController\" class=\"headerlink\" title=\"1.UIImagePickerController\"></a>1.UIImagePickerController</h3><p>这种方式只能设置一些简单参数，自定义程度不高,只能自定义界面上的操作按钮，还有视频的画质等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    if ([self isVideoRecordingAvailable]) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.sourceType = UIImagePickerControllerSourceTypeCamera;</div><div class=\"line\">    self.mediaTypes = @[(NSString *)kUTTypeMovie];</div><div class=\"line\">    self.delegate = self;</div><div class=\"line\">    </div><div class=\"line\">    //隐藏系统自带UI</div><div class=\"line\">    self.showsCameraControls = NO;</div><div class=\"line\">    //设置摄像头</div><div class=\"line\">    [self switchCameraIsFront:NO];</div><div class=\"line\">    //设置视频画质类别</div><div class=\"line\">    self.videoQuality = UIImagePickerControllerQualityTypeMedium;</div><div class=\"line\">    //设置散光灯类型</div><div class=\"line\">    self.cameraFlashMode = UIImagePickerControllerCameraFlashModeAuto;</div><div class=\"line\">    //设置录制的最大时长</div><div class=\"line\">    self.videoMaximumDuration = 20;</div><div class=\"line\">&#125;</div><div class=\"line\">- (BOOL)isVideoRecordingAvailable</div><div class=\"line\">&#123;</div><div class=\"line\">    if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera])&#123;</div><div class=\"line\">        NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];</div><div class=\"line\">        if([availableMediaTypes containsObject:(NSString *)kUTTypeMovie])&#123;</div><div class=\"line\">            return YES;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)switchCameraIsFront:(BOOL)front</div><div class=\"line\">&#123;</div><div class=\"line\">    if (front) &#123;</div><div class=\"line\">        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront])&#123;</div><div class=\"line\">            [self setCameraDevice:UIImagePickerControllerCameraDeviceFront];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceRear])&#123;</div><div class=\"line\">            [self setCameraDevice:UIImagePickerControllerCameraDeviceRear];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-AVCaptureSession-AVCaptureMovieFileOutput\"><a href=\"#2-AVCaptureSession-AVCaptureMovieFileOutput\" class=\"headerlink\" title=\"2.AVCaptureSession+AVCaptureMovieFileOutput\"></a>2.AVCaptureSession+AVCaptureMovieFileOutput</h3><p>流程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 创建捕捉会话</div><div class=\"line\">2. 设置视频的输入</div><div class=\"line\">3. 设置音频的输入</div><div class=\"line\">4. 输出源设置,这里视频，音频数据会合并到一起输出，在代理方法中国也可以单独拿到视频或者音频数据，给AVCaptureMovieFileOutput指定路径，开始录制之后就会向这个路径写入数据</div><div class=\"line\">5. 添加视频预览层</div><div class=\"line\">6. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据</div></pre></td></tr></table></figure></p>\n<h4 id=\"0-创建捕捉会话\"><a href=\"#0-创建捕捉会话\" class=\"headerlink\" title=\"0. 创建捕捉会话\"></a>0. 创建捕捉会话</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.session = [[AVCaptureSession alloc] init];</div><div class=\"line\">   if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;//设置分辨率</div><div class=\"line\">       _session.sessionPreset=AVCaptureSessionPreset640x480;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"1-视频的输入\"><a href=\"#1-视频的输入\" class=\"headerlink\" title=\"1. 视频的输入\"></a>1. 视频的输入</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">   - (void)setUpVideo</div><div class=\"line\">&#123;</div><div class=\"line\">    // 1.1 获取视频输入设备(摄像头)</div><div class=\"line\">    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头</div><div class=\"line\">    </div><div class=\"line\">    // 视频 HDR (高动态范围图像)</div><div class=\"line\">    // videoCaptureDevice.videoHDREnabled = YES;</div><div class=\"line\">    // 设置最大，最小帧速率</div><div class=\"line\">    //videoCaptureDevice.activeVideoMinFrameDuration = CMTimeMake(1, 60);</div><div class=\"line\">    // 1.2 创建视频输入源</div><div class=\"line\">    NSError *error=nil;</div><div class=\"line\">    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&amp;error];</div><div class=\"line\">    // 1.3 将视频输入源添加到会话</div><div class=\"line\">    if ([self.session canAddInput:self.videoInput]) &#123;</div><div class=\"line\">        [self.session addInput:self.videoInput];</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-音频的输入\"><a href=\"#2-音频的输入\" class=\"headerlink\" title=\"2. 音频的输入\"></a>2. 音频的输入</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 2.1 获取音频输入设备</div><div class=\"line\">    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];</div><div class=\"line\">    NSError *error=nil;</div><div class=\"line\">    // 2.2 创建音频输入源</div><div class=\"line\">    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&amp;error];</div><div class=\"line\">    // 2.3 将音频输入源添加到会话</div><div class=\"line\">    if ([self.session canAddInput:self.audioInput]) &#123;</div><div class=\"line\">        [self.session addInput:self.audioInput];</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-输出源设置\"><a href=\"#3-输出源设置\" class=\"headerlink\" title=\"3.输出源设置\"></a>3.输出源设置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setUpFileOut</div><div class=\"line\">&#123;</div><div class=\"line\">    // 3.1初始化设备输出对象，用于获得输出数据</div><div class=\"line\">    self.FileOutput=[[AVCaptureMovieFileOutput alloc]init];</div><div class=\"line\">    </div><div class=\"line\">    // 3.2设置输出对象的一些属性</div><div class=\"line\">    AVCaptureConnection *captureConnection=[self.FileOutput connectionWithMediaType:AVMediaTypeVideo];</div><div class=\"line\">    //设置防抖</div><div class=\"line\">    //视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 AVCaptureConnection 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持：</div><div class=\"line\">    if ([captureConnection isVideoStabilizationSupported ]) &#123;</div><div class=\"line\">        captureConnection.preferredVideoStabilizationMode=AVCaptureVideoStabilizationModeAuto;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //预览图层和视频方向保持一致</div><div class=\"line\">    captureConnection.videoOrientation = [self.previewlayer connection].videoOrientation;</div><div class=\"line\">    </div><div class=\"line\">    // 3.3将设备输出添加到会话中</div><div class=\"line\">    if ([_session canAddOutput:_FileOutput]) &#123;</div><div class=\"line\">        [_session addOutput:_FileOutput];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-视频预览层\"><a href=\"#4-视频预览层\" class=\"headerlink\" title=\"4. 视频预览层\"></a>4. 视频预览层</h4><p>一进入视频录制界面，这个时候 session就已经在采集数据了，并把数据显示在预览层上，用户选择录制后，再将采集到的数据写入文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">    - (void)setUpPreviewLayerWithType:(FMVideoViewType )type</div><div class=\"line\">&#123;</div><div class=\"line\">    CGRect rect = CGRectZero;</div><div class=\"line\">    switch (type) &#123;</div><div class=\"line\">        case Type1X1:</div><div class=\"line\">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);</div><div class=\"line\">            break;</div><div class=\"line\">        case Type4X3:</div><div class=\"line\">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);</div><div class=\"line\">            break;</div><div class=\"line\">        case TypeFullScreen:</div><div class=\"line\">            rect = [UIScreen mainScreen].bounds;</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            rect = [UIScreen mainScreen].bounds;</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.previewlayer.frame = rect;</div><div class=\"line\">    [_superView.layer insertSublayer:self.previewlayer atIndex:0];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"5-开始采集画面\"><a href=\"#5-开始采集画面\" class=\"headerlink\" title=\"5. 开始采集画面\"></a>5. 开始采集画面</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.session startRunning];</div></pre></td></tr></table></figure>\n<h4 id=\"6-开始录制\"><a href=\"#6-开始录制\" class=\"headerlink\" title=\"6.开始录制\"></a>6.开始录制</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)writeDataTofile</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString *videoPath = [self createVideoFilePath];</div><div class=\"line\">    self.videoUrl = [NSURL fileURLWithPath:videoPath];</div><div class=\"line\">    [self.FileOutput startRecordingToOutputFileURL:self.videoUrl recordingDelegate:self];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-AVCaptureSession-AVAssetWriter\"><a href=\"#3-AVCaptureSession-AVAssetWriter\" class=\"headerlink\" title=\"3.AVCaptureSession+AVAssetWriter\"></a>3.AVCaptureSession+AVAssetWriter</h3><p>流程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 创建捕捉会话</div><div class=\"line\">2. 设置视频的输入 和 输出</div><div class=\"line\">3. 设置音频的输入 和 输出</div><div class=\"line\">4. 添加视频预览层</div><div class=\"line\">5. 开始采集数据，这个时候还没有写入数据，用户点击录制后就可以开始写入数据</div><div class=\"line\">6. 初始化AVAssetWriter, 我们会拿到视频和音频的数据流，用AVAssetWriter写入文件，这一步需要我们自己实现。</div></pre></td></tr></table></figure></p>\n<h4 id=\"1-创建捕捉会话\"><a href=\"#1-创建捕捉会话\" class=\"headerlink\" title=\"1. 创建捕捉会话\"></a>1. 创建捕捉会话</h4><p>需要确保在同一个队列，最好队列只创建一次<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.session = [[AVCaptureSession alloc] init];</div><div class=\"line\">   if ([_session canSetSessionPreset:AVCaptureSessionPreset640x480]) &#123;//设置分辨率</div><div class=\"line\">       _session.sessionPreset=AVCaptureSessionPreset640x480;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"2-设置视频的输入-和-输出\"><a href=\"#2-设置视频的输入-和-输出\" class=\"headerlink\" title=\"2.设置视频的输入 和 输出\"></a>2.设置视频的输入 和 输出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setUpVideo</div><div class=\"line\">&#123;</div><div class=\"line\">    // 2.1 获取视频输入设备(摄像头)</div><div class=\"line\">    AVCaptureDevice *videoCaptureDevice=[self getCameraDeviceWithPosition:AVCaptureDevicePositionBack];//取得后置摄像头</div><div class=\"line\">    // 2.2 创建视频输入源</div><div class=\"line\">    NSError *error=nil;</div><div class=\"line\">    self.videoInput= [[AVCaptureDeviceInput alloc] initWithDevice:videoCaptureDevice error:&amp;error];</div><div class=\"line\">    // 2.3 将视频输入源添加到会话</div><div class=\"line\">    if ([self.session canAddInput:self.videoInput]) &#123;</div><div class=\"line\">        [self.session addInput:self.videoInput];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.videoOutput = [[AVCaptureVideoDataOutput alloc] init];</div><div class=\"line\">    self.videoOutput.alwaysDiscardsLateVideoFrames = YES; //立即丢弃旧帧，节省内存，默认YES</div><div class=\"line\">    [self.videoOutput setSampleBufferDelegate:self queue:self.videoQueue];</div><div class=\"line\">    if ([self.session canAddOutput:self.videoOutput]) &#123;</div><div class=\"line\">        [self.session addOutput:self.videoOutput];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-设置音频的输入-和-输出\"><a href=\"#3-设置音频的输入-和-输出\" class=\"headerlink\" title=\"3. 设置音频的输入 和 输出\"></a>3. 设置音频的输入 和 输出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setUpAudio</div><div class=\"line\">&#123;</div><div class=\"line\">    // 2.2 获取音频输入设备</div><div class=\"line\">    AVCaptureDevice *audioCaptureDevice=[[AVCaptureDevice devicesWithMediaType:AVMediaTypeAudio] firstObject];</div><div class=\"line\">    NSError *error=nil;</div><div class=\"line\">    // 2.4 创建音频输入源</div><div class=\"line\">    self.audioInput = [[AVCaptureDeviceInput alloc] initWithDevice:audioCaptureDevice error:&amp;error];</div><div class=\"line\">    // 2.6 将音频输入源添加到会话</div><div class=\"line\">    if ([self.session canAddInput:self.audioInput]) &#123;</div><div class=\"line\">        [self.session addInput:self.audioInput];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.audioOutput = [[AVCaptureAudioDataOutput alloc] init];</div><div class=\"line\">    [self.audioOutput setSampleBufferDelegate:self queue:self.videoQueue];</div><div class=\"line\">    if([self.session canAddOutput:self.audioOutput]) &#123;</div><div class=\"line\">        [self.session addOutput:self.audioOutput];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"4-添加视频预览层\"><a href=\"#4-添加视频预览层\" class=\"headerlink\" title=\"4. 添加视频预览层\"></a>4. 添加视频预览层</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">  - (void)setUpPreviewLayerWithType:(FMVideoViewType )type</div><div class=\"line\">&#123;</div><div class=\"line\">    CGRect rect = CGRectZero;</div><div class=\"line\">    switch (type) &#123;</div><div class=\"line\">        case Type1X1:</div><div class=\"line\">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth);</div><div class=\"line\">            break;</div><div class=\"line\">        case Type4X3:</div><div class=\"line\">            rect = CGRectMake(0, 0, kScreenWidth, kScreenWidth*4/3);</div><div class=\"line\">            break;</div><div class=\"line\">        case TypeFullScreen:</div><div class=\"line\">            rect = [UIScreen mainScreen].bounds;</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            rect = [UIScreen mainScreen].bounds;</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    self.previewlayer.frame = rect;</div><div class=\"line\">    [_superView.layer insertSublayer:self.previewlayer atIndex:0];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5-开始采集画面-1\"><a href=\"#5-开始采集画面-1\" class=\"headerlink\" title=\"5. 开始采集画面\"></a>5. 开始采集画面</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.session startRunning];</div></pre></td></tr></table></figure>\n<h4 id=\"6-初始化AVAssetWriter\"><a href=\"#6-初始化AVAssetWriter\" class=\"headerlink\" title=\"6. 初始化AVAssetWriter\"></a>6. 初始化AVAssetWriter</h4><p>AVAssetWriter 写入数据的过程需要在子线程中执行，并且每次写入数据都需要保证在同一个线程。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setUpWriter</div><div class=\"line\">&#123;</div><div class=\"line\">    self.videoUrl = [[NSURL alloc] initFileURLWithPath:[self createVideoFilePath]];</div><div class=\"line\">    self.writeManager = [[AVAssetWriteManager alloc] initWithURL:self.videoUrl viewType:_viewType];</div><div class=\"line\">    self.writeManager.delegate = self;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"7-拿到数据流后处理\"><a href=\"#7-拿到数据流后处理\" class=\"headerlink\" title=\"7.拿到数据流后处理\"></a>7.拿到数据流后处理</h4><p>视频数据和音频数据需要分开处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection</div><div class=\"line\">&#123;</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        </div><div class=\"line\">        //视频</div><div class=\"line\">        if (connection == [self.videoOutput connectionWithMediaType:AVMediaTypeVideo]) &#123;</div><div class=\"line\">            </div><div class=\"line\">            if (!self.writeManager.outputVideoFormatDescription) &#123;</div><div class=\"line\">                @synchronized(self) &#123;</div><div class=\"line\">                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class=\"line\">                    self.writeManager.outputVideoFormatDescription = formatDescription;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                @synchronized(self) &#123;</div><div class=\"line\">                    if (self.writeManager.writeState == FMRecordStateRecording) &#123;</div><div class=\"line\">                        [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeVideo];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    </div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        //音频</div><div class=\"line\">        if (connection == [self.audioOutput connectionWithMediaType:AVMediaTypeAudio]) &#123;</div><div class=\"line\">            if (!self.writeManager.outputAudioFormatDescription) &#123;</div><div class=\"line\">                @synchronized(self) &#123;</div><div class=\"line\">                    CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);</div><div class=\"line\">                    self.writeManager.outputAudioFormatDescription = formatDescription;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            @synchronized(self) &#123;</div><div class=\"line\">                </div><div class=\"line\">                if (self.writeManager.writeState == FMRecordStateRecording) &#123;</div><div class=\"line\">                    [self.writeManager appendSampleBuffer:sampleBuffer ofMediaType:AVMediaTypeAudio];</div><div class=\"line\">                &#125;</div><div class=\"line\">                </div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们拿到最原始的数据以后，可以对其进行各种参数的设置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setUpWriter</div><div class=\"line\">&#123;</div><div class=\"line\">    self.assetWriter = [AVAssetWriter assetWriterWithURL:self.videoUrl fileType:AVFileTypeMPEG4 error:nil];</div><div class=\"line\">    //写入视频大小</div><div class=\"line\">    NSInteger numPixels = self.outputSize.width * self.outputSize.height;</div><div class=\"line\">    //每像素比特</div><div class=\"line\">    CGFloat bitsPerPixel = 6.0;</div><div class=\"line\">    NSInteger bitsPerSecond = numPixels * bitsPerPixel;</div><div class=\"line\">    </div><div class=\"line\">    // 码率和帧率设置</div><div class=\"line\">    NSDictionary *compressionProperties = @&#123; AVVideoAverageBitRateKey : @(bitsPerSecond),</div><div class=\"line\">                                             AVVideoExpectedSourceFrameRateKey : @(30),</div><div class=\"line\">                                             AVVideoMaxKeyFrameIntervalKey : @(30),</div><div class=\"line\">                                             AVVideoProfileLevelKey : AVVideoProfileLevelH264BaselineAutoLevel &#125;;</div><div class=\"line\">    </div><div class=\"line\">    //视频属性</div><div class=\"line\">    self.videoCompressionSettings = @&#123; AVVideoCodecKey : AVVideoCodecH264,</div><div class=\"line\">                                       AVVideoScalingModeKey : AVVideoScalingModeResizeAspectFill,</div><div class=\"line\">                                       AVVideoWidthKey : @(self.outputSize.height),</div><div class=\"line\">                                       AVVideoHeightKey : @(self.outputSize.width),</div><div class=\"line\">                                       AVVideoCompressionPropertiesKey : compressionProperties &#125;;</div><div class=\"line\"></div><div class=\"line\">    _assetWriterVideoInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:self.videoCompressionSettings];</div><div class=\"line\">    //expectsMediaDataInRealTime 必须设为yes，需要从capture session 实时获取数据</div><div class=\"line\">    _assetWriterVideoInput.expectsMediaDataInRealTime = YES;</div><div class=\"line\">    _assetWriterVideoInput.transform = CGAffineTransformMakeRotation(M_PI / 2.0);</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    // 音频设置</div><div class=\"line\">    self.audioCompressionSettings = @&#123; AVEncoderBitRatePerChannelKey : @(28000),</div><div class=\"line\">                                       AVFormatIDKey : @(kAudioFormatMPEG4AAC),</div><div class=\"line\">                                       AVNumberOfChannelsKey : @(1),</div><div class=\"line\">                                       AVSampleRateKey : @(22050) &#125;;</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    _assetWriterAudioInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:self.audioCompressionSettings];</div><div class=\"line\">    _assetWriterAudioInput.expectsMediaDataInRealTime = YES;</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    if ([_assetWriter canAddInput:_assetWriterVideoInput]) &#123;</div><div class=\"line\">        [_assetWriter addInput:_assetWriterVideoInput];</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        NSLog(@&quot;AssetWriter videoInput append Failed&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ([_assetWriter canAddInput:_assetWriterAudioInput]) &#123;</div><div class=\"line\">        [_assetWriter addInput:_assetWriterAudioInput];</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        NSLog(@&quot;AssetWriter audioInput Append Failed&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    self.writeState = FMRecordStateRecording;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>设置好参数以后，就可以写入文件了。AVAssetWriter数据写入的过程有点复杂，demo中我新建AVAssetWriteManager分离出AVAssetWriter，单独处理写数据，这样逻辑会清晰一点。</p>\n<h3 id=\"fileOut和writer的相同点和不同点\"><a href=\"#fileOut和writer的相同点和不同点\" class=\"headerlink\" title=\"fileOut和writer的相同点和不同点\"></a>fileOut和writer的相同点和不同点</h3><p>从上面的两个流程大致可以看出来，<br>相同点：数据采集都在AVCaptureSession中进行，视频和音频的输入都一样，画面的预览一致。<br>不同点：<br>输出不一致, AVCaptureMovieFileOutput 只需要一个输出即可，指定一个文件路后，视频和音频会写入到指定路径，不需要其他复杂的操作。<br>AVAssetWriter 需要 AVCaptureVideoDataOutput 和 AVCaptureAudioDataOutput 两个单独的输出，拿到各自的输出数据后，然后自己进行相应的处理。</p>\n<p>可配参数不一致，AVAssetWriter可以配置更多的参数。</p>\n<p>视频剪裁不一致，AVCaptureMovieFileOutput 如果要剪裁视频，因为系统已经把数据写到文件中了，我们需要从文件中独到一个完整的视频，然后处理；而AVAssetWriter我们拿到的是数据流，还没有合成视频，对数据流进行处理，所以两则剪裁方式也是不一样。</p>\n<p>其他添加背景音乐，水印等也是不一样的，这里没有涉及就不介绍了。到这里也差不多了，文章也有点长了。这些是我自己整理资料总结出来的，不排除会有一些错误之处，供大家学习参考，希望有所收获。如果方便，还请为我star一个，也算是对我的支持。</p>\n<p><a href=\"https://github.com/suifengqjn/VideoRecord\">demo地址</a></p>"},{"title":"iOS公共库","author":[{"name":"千寻墨","url":"http://www.jianshu.com/users/527ecf8c8753/latest_articles"}],"date":"2016-04-06T08:59:52.000Z","_content":"\n\n### 第一步\n\n>打开Xcode，file->new->WorkSpace,我们使用WorkSpace来管理工程和依赖库\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/1.png)\n\n<!-- more -->\n\n### 第二步\n\n>file->new->project->Application,创建我们的工程，创建好后关闭工程\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/2.png)\n\n### 第三步\n\n>file->new->project->Framework&Library->Cocoa Touch Framework,创建依赖库\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/3.png)\n\n### 第四步\n\n>新建一个Tool类，然后在Amy.h里面引入，引入的方式：`#import<Amy/Tool.h>`\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/4.png)\n\n### 第五步\n\n>回到我们的workspace目录，workspace，依赖库和工程最好放到同一目录下面。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/5.png)\n\n### 第六步\n\n>打开workspace，通过 `file-> AddFile to` 依次把工程和依赖添加到workspace中。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/6.png)\n\n### 第七步\n\n>在workspace中选中工程，然后点击Build Phases，选择 link Binary With Libraries 点击 + 号，添加Amy.framework\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/7.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/8.png)\n\t\n### 第八步\n\n>在我们的工程中可以引入依赖使用了。\n引入方式：`#import<Amy/Tool.h>`\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/9.png)\n\n\n\n","source":"_posts/iOS公共库.md","raw":"---\ntitle: iOS公共库\ntags:\n  - iOS\n  - 公共库\n  - workspace\ncategories:\n  - iOS技术\nauthor:\n  - name: 千寻墨\n    url: 'http://www.jianshu.com/users/527ecf8c8753/latest_articles'\ndate: 2016-04-06 16:59:52\n---\n\n\n### 第一步\n\n>打开Xcode，file->new->WorkSpace,我们使用WorkSpace来管理工程和依赖库\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/1.png)\n\n<!-- more -->\n\n### 第二步\n\n>file->new->project->Application,创建我们的工程，创建好后关闭工程\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/2.png)\n\n### 第三步\n\n>file->new->project->Framework&Library->Cocoa Touch Framework,创建依赖库\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/3.png)\n\n### 第四步\n\n>新建一个Tool类，然后在Amy.h里面引入，引入的方式：`#import<Amy/Tool.h>`\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/4.png)\n\n### 第五步\n\n>回到我们的workspace目录，workspace，依赖库和工程最好放到同一目录下面。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/5.png)\n\n### 第六步\n\n>打开workspace，通过 `file-> AddFile to` 依次把工程和依赖添加到workspace中。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/6.png)\n\n### 第七步\n\n>在workspace中选中工程，然后点击Build Phases，选择 link Binary With Libraries 点击 + 号，添加Amy.framework\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/7.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/8.png)\n\t\n### 第八步\n\n>在我们的工程中可以引入依赖使用了。\n引入方式：`#import<Amy/Tool.h>`\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/9.png)\n\n\n\n","slug":"iOS公共库","published":1,"updated":"2016-11-17T15:01:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5ted001clx60ceyj4jof","content":"<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><blockquote>\n<p>打开Xcode，file-&gt;new-&gt;WorkSpace,我们使用WorkSpace来管理工程和依赖库</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/1.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><blockquote>\n<p>file-&gt;new-&gt;project-&gt;Application,创建我们的工程，创建好后关闭工程</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/2.png\" alt=\"image\"></p>\n<h3 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><blockquote>\n<p>file-&gt;new-&gt;project-&gt;Framework&amp;Library-&gt;Cocoa Touch Framework,创建依赖库</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/3.png\" alt=\"image\"></p>\n<h3 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><blockquote>\n<p>新建一个Tool类，然后在Amy.h里面引入，引入的方式：<code>#import&lt;Amy/Tool.h&gt;</code></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/4.png\" alt=\"image\"></p>\n<h3 id=\"第五步\"><a href=\"#第五步\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><blockquote>\n<p>回到我们的workspace目录，workspace，依赖库和工程最好放到同一目录下面。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/5.png\" alt=\"image\"></p>\n<h3 id=\"第六步\"><a href=\"#第六步\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><blockquote>\n<p>打开workspace，通过 <code>file-&gt; AddFile to</code> 依次把工程和依赖添加到workspace中。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/6.png\" alt=\"image\"></p>\n<h3 id=\"第七步\"><a href=\"#第七步\" class=\"headerlink\" title=\"第七步\"></a>第七步</h3><blockquote>\n<p>在workspace中选中工程，然后点击Build Phases，选择 link Binary With Libraries 点击 + 号，添加Amy.framework</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/7.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/8.png\" alt=\"image\"></p>\n<h3 id=\"第八步\"><a href=\"#第八步\" class=\"headerlink\" title=\"第八步\"></a>第八步</h3><blockquote>\n<p>在我们的工程中可以引入依赖使用了。<br>引入方式：<code>#import&lt;Amy/Tool.h&gt;</code><br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/9.png\" alt=\"image\"></p>\n</blockquote>\n","excerpt":"<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><blockquote>\n<p>打开Xcode，file-&gt;new-&gt;WorkSpace,我们使用WorkSpace来管理工程和依赖库</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/1.png\" alt=\"image\"></p>","more":"<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><blockquote>\n<p>file-&gt;new-&gt;project-&gt;Application,创建我们的工程，创建好后关闭工程</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/2.png\" alt=\"image\"></p>\n<h3 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><blockquote>\n<p>file-&gt;new-&gt;project-&gt;Framework&amp;Library-&gt;Cocoa Touch Framework,创建依赖库</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/3.png\" alt=\"image\"></p>\n<h3 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><blockquote>\n<p>新建一个Tool类，然后在Amy.h里面引入，引入的方式：<code>#import&lt;Amy/Tool.h&gt;</code></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/4.png\" alt=\"image\"></p>\n<h3 id=\"第五步\"><a href=\"#第五步\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><blockquote>\n<p>回到我们的workspace目录，workspace，依赖库和工程最好放到同一目录下面。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/5.png\" alt=\"image\"></p>\n<h3 id=\"第六步\"><a href=\"#第六步\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><blockquote>\n<p>打开workspace，通过 <code>file-&gt; AddFile to</code> 依次把工程和依赖添加到workspace中。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/6.png\" alt=\"image\"></p>\n<h3 id=\"第七步\"><a href=\"#第七步\" class=\"headerlink\" title=\"第七步\"></a>第七步</h3><blockquote>\n<p>在workspace中选中工程，然后点击Build Phases，选择 link Binary With Libraries 点击 + 号，添加Amy.framework</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/7.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/8.png\" alt=\"image\"></p>\n<h3 id=\"第八步\"><a href=\"#第八步\" class=\"headerlink\" title=\"第八步\"></a>第八步</h3><blockquote>\n<p>在我们的工程中可以引入依赖使用了。<br>引入方式：<code>#import&lt;Amy/Tool.h&gt;</code><br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/9.png\" alt=\"image\"></p>\n</blockquote>"},{"title":"iOS开发小技巧","date":"2016-03-15T13:12:38.000Z","_content":"\niOS开发的一些奇巧淫技,\n\"奇巧淫技\"并非是一些稀奇古怪的技术要点，也不是什么所谓的黑科学，只是一些平时可能会用到但有些又并不是很容易查询得到的小tips.\n\n### 如何查看真机沙盒文件\n\n#### 一：安装iFunBox或IExployer\n\n#### 二：设置\n\n在xcode的上部导航栏里，选择window -> Devices,找到目标app![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/1.png),双击选中项目![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/2.png),\n\n<!-- more -->\n\n这样我们只能看到沙盒的目录结构,看不到实体文件。然后点击Download Container![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/3.png),下载后保存到桌面，右键显示包内容即可。\n\n\n\n###如何使用命令行进行打包?\n\n一： 使用原生xcodebuild、xcrun 打开终端 cd到当前项目,使用如下两条命令即可。\n#### 如果项目没有使用cocoapods:\nxcodebuild -project 项目名.xcodeproj -target 项目名 -configuration Release(生成项目名.app文件)\n<br>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/项目名.app -o ~/Desktop/项目名.ipa(-o前为.app文件路径，-o后为生成的.ipa路径)\n\n#### 如果使用cocoapods:\nxcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release\n<br>xcrun -sdk iphoneos -v PackageApplication 项目名.app路径 -o ~/Desktop/Demo.ipa\n\n\n二：使用xctool进行自动打包，是FaceBook开源的一个命令行工具，可使用brew安装（安装命令：sudo brew install xctool）\n#### 如果项目没有使用cocoapods:\nxctool -scheme Demo archive -archivePath \"Demo/“(会生成.xcarchive文件)\n<br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa\n#### 如果使用cocoapods:\nxctool -workspace Demo.xcworkspace -scheme Demo archive -archivePath \"Demo” \n<br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa\n\n### Xcode历史版本下载地址\n[https://developer.apple.com/downloads/](https://developer.apple.com/downloads/)\n\n\n### 加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)\nhttps://developer.apple.com/appstore/contact/appreviewteam/index.html\n也可以直接从ITunes右下角contact us也可以  但是无法填写相关文字描述\n\n\n### Autolayout及SizeClass示意图\n![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/4.png) ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/5.png) ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/6.png)\n\n\n### 窗口中有多个responder,如何快速释放键盘\n\n#### 一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];\n\n#### 二：[self.view endEditing:YES];\n\n\n### 如何去除UITableView中Group样式cell的边框\n\n#### 一： UIView *tempView = [[UIView alloc] init];\n  <br> [cell setBackgroundView:tempView];\n   <br>[cell setBackgroundColor:[UIColor clearColor]]; \n   \n#### 二：tableView.separatorColor=[UIColor clearColor];\n\n\n### 如何解决colorWithPatternImage设置view背景色太占内存问题\n\n  self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@\"main_landscape.jpg\"]];\n  <br>切换成self.view.layer.contents =[UIImage imageNamed:@\"name.png\"].CGImage;\n  \n### App升级后如何删除NSUserDefaults全部数据\n\nAPP升级后，UserDefaults中原有的plist是不会删除的，除非用户卸载APP<br>\nNSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];  \n[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];  \n\n### 如何修改图片颜色\n\n先设置图片的渲染模式为UIImageRenderingModeAlwaysTemplate，再设置tintcolor<br>\nself.imageView.image = [[UIImage imageNamed:@\"back\"] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\nself.imageView.tintColor = [UIColor redColor];\n<br>也可以在Asset catelog中设置render as<br> ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/7.png)\n\n### 如何放大图片使之不失真且不产生锯齿\n\n在Asset Catalog的Attribtues Pane中设置Single(前提是图片必须是矢量图) Vector为SingleVector<br>![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/8.png)\n\n\n### 如何在拉伸图片的时候使之不变形\n\n一：stretchableImageWithLeftCapWidth: topCapHeight:<br>\n二：在Xcode中选中图片，然后点击右下角的Show Slicing：<br>![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/9.gif)\n\n### Storyboard中如何正确设置控件透明度\n在直接设置alpha的情况下，如果上面有文字的话会随着透明度的变大而变得越来越不清楚。\n<br>此时应该这样设置 Background →0ther →0pacity\n\n### [UIScreen mainScreen].bounds获取屏幕大小不对的问题\n\\#define SCREEN_WIDTH  [UIScreen mainScreen].bounds.size.width<br>\n\\#define iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242,2208),[[UIScreen mainScreen] currentMode].size) : NO)<br>\n在标准模式下<br>\n6+：<br>\n[[UIScreen mainScreen] currentMode].size为{1242，2208}<br>\n[UIScreen mainScreen].bounds.size为{414，736}<br>\n6:<br>\n[[UIScreen mainScreen] currentMode].size为{750，1334}<br>\n[UIScreen mainScreen].bounds.size为{375，667}<br>\n\n放大模式下(设置->显示与亮度->显示模式) <br>\n6+:<br>\n[[UIScreen mainScreen] currentMode].size为{1125,2001}<br>\n[UIScreen mainScreen].bounds.size为{375,667}<br>\n6:<br>\n[[UIScreen mainScreen] currentMode].size为{640,1136}<br>\n[UIScreen mainScreen].bounds.size为{320,568}\n\n### Mac模式下如何将视频生成Gif文件\n#### 一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)\n\n#### 二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片<br>\n（ ffmpeg -i  news.mov -r 10 -f image2 文件夹名/%05d.png）\n<br>然后使用PicGIF (将多张图片生成gif文件)\n\n\n\n\n\n","source":"_posts/iOS开发小技巧.md","raw":"---\ntitle: iOS开发小技巧\ntags:\n  - iOS\n  - 缓存\ncategories:\n  - iOS技术\ndate: 2016-03-15 21:12:38\n---\n\niOS开发的一些奇巧淫技,\n\"奇巧淫技\"并非是一些稀奇古怪的技术要点，也不是什么所谓的黑科学，只是一些平时可能会用到但有些又并不是很容易查询得到的小tips.\n\n### 如何查看真机沙盒文件\n\n#### 一：安装iFunBox或IExployer\n\n#### 二：设置\n\n在xcode的上部导航栏里，选择window -> Devices,找到目标app![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/1.png),双击选中项目![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/2.png),\n\n<!-- more -->\n\n这样我们只能看到沙盒的目录结构,看不到实体文件。然后点击Download Container![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/3.png),下载后保存到桌面，右键显示包内容即可。\n\n\n\n###如何使用命令行进行打包?\n\n一： 使用原生xcodebuild、xcrun 打开终端 cd到当前项目,使用如下两条命令即可。\n#### 如果项目没有使用cocoapods:\nxcodebuild -project 项目名.xcodeproj -target 项目名 -configuration Release(生成项目名.app文件)\n<br>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/项目名.app -o ~/Desktop/项目名.ipa(-o前为.app文件路径，-o后为生成的.ipa路径)\n\n#### 如果使用cocoapods:\nxcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release\n<br>xcrun -sdk iphoneos -v PackageApplication 项目名.app路径 -o ~/Desktop/Demo.ipa\n\n\n二：使用xctool进行自动打包，是FaceBook开源的一个命令行工具，可使用brew安装（安装命令：sudo brew install xctool）\n#### 如果项目没有使用cocoapods:\nxctool -scheme Demo archive -archivePath \"Demo/“(会生成.xcarchive文件)\n<br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa\n#### 如果使用cocoapods:\nxctool -workspace Demo.xcworkspace -scheme Demo archive -archivePath \"Demo” \n<br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa\n\n### Xcode历史版本下载地址\n[https://developer.apple.com/downloads/](https://developer.apple.com/downloads/)\n\n\n### 加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)\nhttps://developer.apple.com/appstore/contact/appreviewteam/index.html\n也可以直接从ITunes右下角contact us也可以  但是无法填写相关文字描述\n\n\n### Autolayout及SizeClass示意图\n![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/4.png) ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/5.png) ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/6.png)\n\n\n### 窗口中有多个responder,如何快速释放键盘\n\n#### 一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];\n\n#### 二：[self.view endEditing:YES];\n\n\n### 如何去除UITableView中Group样式cell的边框\n\n#### 一： UIView *tempView = [[UIView alloc] init];\n  <br> [cell setBackgroundView:tempView];\n   <br>[cell setBackgroundColor:[UIColor clearColor]]; \n   \n#### 二：tableView.separatorColor=[UIColor clearColor];\n\n\n### 如何解决colorWithPatternImage设置view背景色太占内存问题\n\n  self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@\"main_landscape.jpg\"]];\n  <br>切换成self.view.layer.contents =[UIImage imageNamed:@\"name.png\"].CGImage;\n  \n### App升级后如何删除NSUserDefaults全部数据\n\nAPP升级后，UserDefaults中原有的plist是不会删除的，除非用户卸载APP<br>\nNSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];  \n[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];  \n\n### 如何修改图片颜色\n\n先设置图片的渲染模式为UIImageRenderingModeAlwaysTemplate，再设置tintcolor<br>\nself.imageView.image = [[UIImage imageNamed:@\"back\"] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\nself.imageView.tintColor = [UIColor redColor];\n<br>也可以在Asset catelog中设置render as<br> ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/7.png)\n\n### 如何放大图片使之不失真且不产生锯齿\n\n在Asset Catalog的Attribtues Pane中设置Single(前提是图片必须是矢量图) Vector为SingleVector<br>![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/8.png)\n\n\n### 如何在拉伸图片的时候使之不变形\n\n一：stretchableImageWithLeftCapWidth: topCapHeight:<br>\n二：在Xcode中选中图片，然后点击右下角的Show Slicing：<br>![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/9.gif)\n\n### Storyboard中如何正确设置控件透明度\n在直接设置alpha的情况下，如果上面有文字的话会随着透明度的变大而变得越来越不清楚。\n<br>此时应该这样设置 Background →0ther →0pacity\n\n### [UIScreen mainScreen].bounds获取屏幕大小不对的问题\n\\#define SCREEN_WIDTH  [UIScreen mainScreen].bounds.size.width<br>\n\\#define iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242,2208),[[UIScreen mainScreen] currentMode].size) : NO)<br>\n在标准模式下<br>\n6+：<br>\n[[UIScreen mainScreen] currentMode].size为{1242，2208}<br>\n[UIScreen mainScreen].bounds.size为{414，736}<br>\n6:<br>\n[[UIScreen mainScreen] currentMode].size为{750，1334}<br>\n[UIScreen mainScreen].bounds.size为{375，667}<br>\n\n放大模式下(设置->显示与亮度->显示模式) <br>\n6+:<br>\n[[UIScreen mainScreen] currentMode].size为{1125,2001}<br>\n[UIScreen mainScreen].bounds.size为{375,667}<br>\n6:<br>\n[[UIScreen mainScreen] currentMode].size为{640,1136}<br>\n[UIScreen mainScreen].bounds.size为{320,568}\n\n### Mac模式下如何将视频生成Gif文件\n#### 一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)\n\n#### 二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片<br>\n（ ffmpeg -i  news.mov -r 10 -f image2 文件夹名/%05d.png）\n<br>然后使用PicGIF (将多张图片生成gif文件)\n\n\n\n\n\n","slug":"iOS开发小技巧","published":1,"updated":"2016-11-17T15:03:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tef001glx60ytclyb1u","content":"<p>iOS开发的一些奇巧淫技,<br>“奇巧淫技”并非是一些稀奇古怪的技术要点，也不是什么所谓的黑科学，只是一些平时可能会用到但有些又并不是很容易查询得到的小tips.</p>\n<h3 id=\"如何查看真机沙盒文件\"><a href=\"#如何查看真机沙盒文件\" class=\"headerlink\" title=\"如何查看真机沙盒文件\"></a>如何查看真机沙盒文件</h3><h4 id=\"一：安装iFunBox或IExployer\"><a href=\"#一：安装iFunBox或IExployer\" class=\"headerlink\" title=\"一：安装iFunBox或IExployer\"></a>一：安装iFunBox或IExployer</h4><h4 id=\"二：设置\"><a href=\"#二：设置\" class=\"headerlink\" title=\"二：设置\"></a>二：设置</h4><p>在xcode的上部导航栏里，选择window -&gt; Devices,找到目标app<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/1.png\" alt=\"\">,双击选中项目<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/2.png\" alt=\"\">,</p>\n<a id=\"more\"></a>\n<p>这样我们只能看到沙盒的目录结构,看不到实体文件。然后点击Download Container<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/3.png\" alt=\"\">,下载后保存到桌面，右键显示包内容即可。</p>\n<p>###如何使用命令行进行打包?</p>\n<p>一： 使用原生xcodebuild、xcrun 打开终端 cd到当前项目,使用如下两条命令即可。</p>\n<h4 id=\"如果项目没有使用cocoapods\"><a href=\"#如果项目没有使用cocoapods\" class=\"headerlink\" title=\"如果项目没有使用cocoapods:\"></a>如果项目没有使用cocoapods:</h4><p>xcodebuild -project 项目名.xcodeproj -target 项目名 -configuration Release(生成项目名.app文件)<br><br>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/项目名.app -o ~/Desktop/项目名.ipa(-o前为.app文件路径，-o后为生成的.ipa路径)</p>\n<h4 id=\"如果使用cocoapods\"><a href=\"#如果使用cocoapods\" class=\"headerlink\" title=\"如果使用cocoapods:\"></a>如果使用cocoapods:</h4><p>xcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release<br><br>xcrun -sdk iphoneos -v PackageApplication 项目名.app路径 -o ~/Desktop/Demo.ipa</p>\n<p>二：使用xctool进行自动打包，是FaceBook开源的一个命令行工具，可使用brew安装（安装命令：sudo brew install xctool）</p>\n<h4 id=\"如果项目没有使用cocoapods-1\"><a href=\"#如果项目没有使用cocoapods-1\" class=\"headerlink\" title=\"如果项目没有使用cocoapods:\"></a>如果项目没有使用cocoapods:</h4><p>xctool -scheme Demo archive -archivePath “Demo/“(会生成.xcarchive文件)<br><br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa</p>\n<h4 id=\"如果使用cocoapods-1\"><a href=\"#如果使用cocoapods-1\" class=\"headerlink\" title=\"如果使用cocoapods:\"></a>如果使用cocoapods:</h4><p>xctool -workspace Demo.xcworkspace -scheme Demo archive -archivePath “Demo”<br><br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa</p>\n<h3 id=\"Xcode历史版本下载地址\"><a href=\"#Xcode历史版本下载地址\" class=\"headerlink\" title=\"Xcode历史版本下载地址\"></a>Xcode历史版本下载地址</h3><p><a href=\"https://developer.apple.com/downloads/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/downloads/</a></p>\n<h3 id=\"加急审核渠道链接-并非只是加急，包括向苹果申诉、修改appstore上相关信息等\"><a href=\"#加急审核渠道链接-并非只是加急，包括向苹果申诉、修改appstore上相关信息等\" class=\"headerlink\" title=\"加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)\"></a>加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)</h3><p><a href=\"https://developer.apple.com/appstore/contact/appreviewteam/index.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/appstore/contact/appreviewteam/index.html</a><br>也可以直接从ITunes右下角contact us也可以  但是无法填写相关文字描述</p>\n<h3 id=\"Autolayout及SizeClass示意图\"><a href=\"#Autolayout及SizeClass示意图\" class=\"headerlink\" title=\"Autolayout及SizeClass示意图\"></a>Autolayout及SizeClass示意图</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/4.png\" alt=\"\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/5.png\" alt=\"\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/6.png\" alt=\"\"></p>\n<h3 id=\"窗口中有多个responder-如何快速释放键盘\"><a href=\"#窗口中有多个responder-如何快速释放键盘\" class=\"headerlink\" title=\"窗口中有多个responder,如何快速释放键盘\"></a>窗口中有多个responder,如何快速释放键盘</h3><h4 id=\"一：-UIApplication-sharedApplication-sendAction-selector-resignFirstResponder-to-nil-from-nil-forEvent-nil\"><a href=\"#一：-UIApplication-sharedApplication-sendAction-selector-resignFirstResponder-to-nil-from-nil-forEvent-nil\" class=\"headerlink\" title=\"一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];\"></a>一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</h4><h4 id=\"二：-self-view-endEditing-YES\"><a href=\"#二：-self-view-endEditing-YES\" class=\"headerlink\" title=\"二：[self.view endEditing:YES];\"></a>二：[self.view endEditing:YES];</h4><h3 id=\"如何去除UITableView中Group样式cell的边框\"><a href=\"#如何去除UITableView中Group样式cell的边框\" class=\"headerlink\" title=\"如何去除UITableView中Group样式cell的边框\"></a>如何去除UITableView中Group样式cell的边框</h3><h4 id=\"一：-UIView-tempView-UIView-alloc-init\"><a href=\"#一：-UIView-tempView-UIView-alloc-init\" class=\"headerlink\" title=\"一： UIView *tempView = [[UIView alloc] init];\"></a>一： UIView *tempView = [[UIView alloc] init];</h4><p>  <br> [cell setBackgroundView:tempView];<br>   <br>[cell setBackgroundColor:[UIColor clearColor]]; </p>\n<h4 id=\"二：tableView-separatorColor-UIColor-clearColor\"><a href=\"#二：tableView-separatorColor-UIColor-clearColor\" class=\"headerlink\" title=\"二：tableView.separatorColor=[UIColor clearColor];\"></a>二：tableView.separatorColor=[UIColor clearColor];</h4><h3 id=\"如何解决colorWithPatternImage设置view背景色太占内存问题\"><a href=\"#如何解决colorWithPatternImage设置view背景色太占内存问题\" class=\"headerlink\" title=\"如何解决colorWithPatternImage设置view背景色太占内存问题\"></a>如何解决colorWithPatternImage设置view背景色太占内存问题</h3><p>  self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@”main_landscape.jpg”]];<br>  <br>切换成self.view.layer.contents =[UIImage imageNamed:@”name.png”].CGImage;</p>\n<h3 id=\"App升级后如何删除NSUserDefaults全部数据\"><a href=\"#App升级后如何删除NSUserDefaults全部数据\" class=\"headerlink\" title=\"App升级后如何删除NSUserDefaults全部数据\"></a>App升级后如何删除NSUserDefaults全部数据</h3><p>APP升级后，UserDefaults中原有的plist是不会删除的，除非用户卸载APP<br><br>NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];<br>[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];  </p>\n<h3 id=\"如何修改图片颜色\"><a href=\"#如何修改图片颜色\" class=\"headerlink\" title=\"如何修改图片颜色\"></a>如何修改图片颜色</h3><p>先设置图片的渲染模式为UIImageRenderingModeAlwaysTemplate，再设置tintcolor<br><br>self.imageView.image = [[UIImage imageNamed:@”back”] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];<br>self.imageView.tintColor = [UIColor redColor];<br><br>也可以在Asset catelog中设置render as<br> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/7.png\" alt=\"\"></p>\n<h3 id=\"如何放大图片使之不失真且不产生锯齿\"><a href=\"#如何放大图片使之不失真且不产生锯齿\" class=\"headerlink\" title=\"如何放大图片使之不失真且不产生锯齿\"></a>如何放大图片使之不失真且不产生锯齿</h3><p>在Asset Catalog的Attribtues Pane中设置Single(前提是图片必须是矢量图) Vector为SingleVector<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/8.png\" alt=\"\"></p>\n<h3 id=\"如何在拉伸图片的时候使之不变形\"><a href=\"#如何在拉伸图片的时候使之不变形\" class=\"headerlink\" title=\"如何在拉伸图片的时候使之不变形\"></a>如何在拉伸图片的时候使之不变形</h3><p>一：stretchableImageWithLeftCapWidth: topCapHeight:<br><br>二：在Xcode中选中图片，然后点击右下角的Show Slicing：<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/9.gif\" alt=\"\"></p>\n<h3 id=\"Storyboard中如何正确设置控件透明度\"><a href=\"#Storyboard中如何正确设置控件透明度\" class=\"headerlink\" title=\"Storyboard中如何正确设置控件透明度\"></a>Storyboard中如何正确设置控件透明度</h3><p>在直接设置alpha的情况下，如果上面有文字的话会随着透明度的变大而变得越来越不清楚。<br><br>此时应该这样设置 Background →0ther →0pacity</p>\n<h3 id=\"UIScreen-mainScreen-bounds获取屏幕大小不对的问题\"><a href=\"#UIScreen-mainScreen-bounds获取屏幕大小不对的问题\" class=\"headerlink\" title=\"[UIScreen mainScreen].bounds获取屏幕大小不对的问题\"></a>[UIScreen mainScreen].bounds获取屏幕大小不对的问题</h3><p>#define SCREEN_WIDTH  [UIScreen mainScreen].bounds.size.width<br><br>#define iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242,2208),[[UIScreen mainScreen] currentMode].size) : NO)<br><br>在标准模式下<br><br>6+：<br><br>[[UIScreen mainScreen] currentMode].size为{1242，2208}<br><br>[UIScreen mainScreen].bounds.size为{414，736}<br><br>6:<br><br>[[UIScreen mainScreen] currentMode].size为{750，1334}<br><br>[UIScreen mainScreen].bounds.size为{375，667}<br></p>\n<p>放大模式下(设置-&gt;显示与亮度-&gt;显示模式) <br><br>6+:<br><br>[[UIScreen mainScreen] currentMode].size为{1125,2001}<br><br>[UIScreen mainScreen].bounds.size为{375,667}<br><br>6:<br><br>[[UIScreen mainScreen] currentMode].size为{640,1136}<br><br>[UIScreen mainScreen].bounds.size为{320,568}</p>\n<h3 id=\"Mac模式下如何将视频生成Gif文件\"><a href=\"#Mac模式下如何将视频生成Gif文件\" class=\"headerlink\" title=\"Mac模式下如何将视频生成Gif文件\"></a>Mac模式下如何将视频生成Gif文件</h3><h4 id=\"一：使用GifBrewery直接将视频转为gif文件-安装GifBreweryw密码-www-macx-cn\"><a href=\"#一：使用GifBrewery直接将视频转为gif文件-安装GifBreweryw密码-www-macx-cn\" class=\"headerlink\" title=\"一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)\"></a>一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)</h4><h4 id=\"二：安装ffmpeg-brew-install-ffmpeg-使用ffmpeg使视频转为多张图片\"><a href=\"#二：安装ffmpeg-brew-install-ffmpeg-使用ffmpeg使视频转为多张图片\" class=\"headerlink\" title=\"二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片\"></a>二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片<br></h4><p>（ ffmpeg -i  news.mov -r 10 -f image2 文件夹名/%05d.png）<br><br>然后使用PicGIF (将多张图片生成gif文件)</p>\n","excerpt":"<p>iOS开发的一些奇巧淫技,<br>“奇巧淫技”并非是一些稀奇古怪的技术要点，也不是什么所谓的黑科学，只是一些平时可能会用到但有些又并不是很容易查询得到的小tips.</p>\n<h3 id=\"如何查看真机沙盒文件\"><a href=\"#如何查看真机沙盒文件\" class=\"headerlink\" title=\"如何查看真机沙盒文件\"></a>如何查看真机沙盒文件</h3><h4 id=\"一：安装iFunBox或IExployer\"><a href=\"#一：安装iFunBox或IExployer\" class=\"headerlink\" title=\"一：安装iFunBox或IExployer\"></a>一：安装iFunBox或IExployer</h4><h4 id=\"二：设置\"><a href=\"#二：设置\" class=\"headerlink\" title=\"二：设置\"></a>二：设置</h4><p>在xcode的上部导航栏里，选择window -&gt; Devices,找到目标app<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/1.png\" alt=\"\">,双击选中项目<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/2.png\" alt=\"\">,</p>","more":"<p>这样我们只能看到沙盒的目录结构,看不到实体文件。然后点击Download Container<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/3.png\" alt=\"\">,下载后保存到桌面，右键显示包内容即可。</p>\n<p>###如何使用命令行进行打包?</p>\n<p>一： 使用原生xcodebuild、xcrun 打开终端 cd到当前项目,使用如下两条命令即可。</p>\n<h4 id=\"如果项目没有使用cocoapods\"><a href=\"#如果项目没有使用cocoapods\" class=\"headerlink\" title=\"如果项目没有使用cocoapods:\"></a>如果项目没有使用cocoapods:</h4><p>xcodebuild -project 项目名.xcodeproj -target 项目名 -configuration Release(生成项目名.app文件)<br><br>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/项目名.app -o ~/Desktop/项目名.ipa(-o前为.app文件路径，-o后为生成的.ipa路径)</p>\n<h4 id=\"如果使用cocoapods\"><a href=\"#如果使用cocoapods\" class=\"headerlink\" title=\"如果使用cocoapods:\"></a>如果使用cocoapods:</h4><p>xcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release<br><br>xcrun -sdk iphoneos -v PackageApplication 项目名.app路径 -o ~/Desktop/Demo.ipa</p>\n<p>二：使用xctool进行自动打包，是FaceBook开源的一个命令行工具，可使用brew安装（安装命令：sudo brew install xctool）</p>\n<h4 id=\"如果项目没有使用cocoapods-1\"><a href=\"#如果项目没有使用cocoapods-1\" class=\"headerlink\" title=\"如果项目没有使用cocoapods:\"></a>如果项目没有使用cocoapods:</h4><p>xctool -scheme Demo archive -archivePath “Demo/“(会生成.xcarchive文件)<br><br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa</p>\n<h4 id=\"如果使用cocoapods-1\"><a href=\"#如果使用cocoapods-1\" class=\"headerlink\" title=\"如果使用cocoapods:\"></a>如果使用cocoapods:</h4><p>xctool -workspace Demo.xcworkspace -scheme Demo archive -archivePath “Demo”<br><br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa</p>\n<h3 id=\"Xcode历史版本下载地址\"><a href=\"#Xcode历史版本下载地址\" class=\"headerlink\" title=\"Xcode历史版本下载地址\"></a>Xcode历史版本下载地址</h3><p><a href=\"https://developer.apple.com/downloads/\">https://developer.apple.com/downloads/</a></p>\n<h3 id=\"加急审核渠道链接-并非只是加急，包括向苹果申诉、修改appstore上相关信息等\"><a href=\"#加急审核渠道链接-并非只是加急，包括向苹果申诉、修改appstore上相关信息等\" class=\"headerlink\" title=\"加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)\"></a>加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)</h3><p><a href=\"https://developer.apple.com/appstore/contact/appreviewteam/index.html\">https://developer.apple.com/appstore/contact/appreviewteam/index.html</a><br>也可以直接从ITunes右下角contact us也可以  但是无法填写相关文字描述</p>\n<h3 id=\"Autolayout及SizeClass示意图\"><a href=\"#Autolayout及SizeClass示意图\" class=\"headerlink\" title=\"Autolayout及SizeClass示意图\"></a>Autolayout及SizeClass示意图</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/4.png\" alt=\"\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/5.png\" alt=\"\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/6.png\" alt=\"\"></p>\n<h3 id=\"窗口中有多个responder-如何快速释放键盘\"><a href=\"#窗口中有多个responder-如何快速释放键盘\" class=\"headerlink\" title=\"窗口中有多个responder,如何快速释放键盘\"></a>窗口中有多个responder,如何快速释放键盘</h3><h4 id=\"一：-UIApplication-sharedApplication-sendAction-selector-resignFirstResponder-to-nil-from-nil-forEvent-nil\"><a href=\"#一：-UIApplication-sharedApplication-sendAction-selector-resignFirstResponder-to-nil-from-nil-forEvent-nil\" class=\"headerlink\" title=\"一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];\"></a>一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</h4><h4 id=\"二：-self-view-endEditing-YES\"><a href=\"#二：-self-view-endEditing-YES\" class=\"headerlink\" title=\"二：[self.view endEditing:YES];\"></a>二：[self.view endEditing:YES];</h4><h3 id=\"如何去除UITableView中Group样式cell的边框\"><a href=\"#如何去除UITableView中Group样式cell的边框\" class=\"headerlink\" title=\"如何去除UITableView中Group样式cell的边框\"></a>如何去除UITableView中Group样式cell的边框</h3><h4 id=\"一：-UIView-tempView-UIView-alloc-init\"><a href=\"#一：-UIView-tempView-UIView-alloc-init\" class=\"headerlink\" title=\"一： UIView *tempView = [[UIView alloc] init];\"></a>一： UIView *tempView = [[UIView alloc] init];</h4><p>  <br> [cell setBackgroundView:tempView];<br>   <br>[cell setBackgroundColor:[UIColor clearColor]]; </p>\n<h4 id=\"二：tableView-separatorColor-UIColor-clearColor\"><a href=\"#二：tableView-separatorColor-UIColor-clearColor\" class=\"headerlink\" title=\"二：tableView.separatorColor=[UIColor clearColor];\"></a>二：tableView.separatorColor=[UIColor clearColor];</h4><h3 id=\"如何解决colorWithPatternImage设置view背景色太占内存问题\"><a href=\"#如何解决colorWithPatternImage设置view背景色太占内存问题\" class=\"headerlink\" title=\"如何解决colorWithPatternImage设置view背景色太占内存问题\"></a>如何解决colorWithPatternImage设置view背景色太占内存问题</h3><p>  self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@”main_landscape.jpg”]];<br>  <br>切换成self.view.layer.contents =[UIImage imageNamed:@”name.png”].CGImage;</p>\n<h3 id=\"App升级后如何删除NSUserDefaults全部数据\"><a href=\"#App升级后如何删除NSUserDefaults全部数据\" class=\"headerlink\" title=\"App升级后如何删除NSUserDefaults全部数据\"></a>App升级后如何删除NSUserDefaults全部数据</h3><p>APP升级后，UserDefaults中原有的plist是不会删除的，除非用户卸载APP<br><br>NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];<br>[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];  </p>\n<h3 id=\"如何修改图片颜色\"><a href=\"#如何修改图片颜色\" class=\"headerlink\" title=\"如何修改图片颜色\"></a>如何修改图片颜色</h3><p>先设置图片的渲染模式为UIImageRenderingModeAlwaysTemplate，再设置tintcolor<br><br>self.imageView.image = [[UIImage imageNamed:@”back”] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];<br>self.imageView.tintColor = [UIColor redColor];<br><br>也可以在Asset catelog中设置render as<br> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/7.png\" alt=\"\"></p>\n<h3 id=\"如何放大图片使之不失真且不产生锯齿\"><a href=\"#如何放大图片使之不失真且不产生锯齿\" class=\"headerlink\" title=\"如何放大图片使之不失真且不产生锯齿\"></a>如何放大图片使之不失真且不产生锯齿</h3><p>在Asset Catalog的Attribtues Pane中设置Single(前提是图片必须是矢量图) Vector为SingleVector<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/8.png\" alt=\"\"></p>\n<h3 id=\"如何在拉伸图片的时候使之不变形\"><a href=\"#如何在拉伸图片的时候使之不变形\" class=\"headerlink\" title=\"如何在拉伸图片的时候使之不变形\"></a>如何在拉伸图片的时候使之不变形</h3><p>一：stretchableImageWithLeftCapWidth: topCapHeight:<br><br>二：在Xcode中选中图片，然后点击右下角的Show Slicing：<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/9.gif\" alt=\"\"></p>\n<h3 id=\"Storyboard中如何正确设置控件透明度\"><a href=\"#Storyboard中如何正确设置控件透明度\" class=\"headerlink\" title=\"Storyboard中如何正确设置控件透明度\"></a>Storyboard中如何正确设置控件透明度</h3><p>在直接设置alpha的情况下，如果上面有文字的话会随着透明度的变大而变得越来越不清楚。<br><br>此时应该这样设置 Background →0ther →0pacity</p>\n<h3 id=\"UIScreen-mainScreen-bounds获取屏幕大小不对的问题\"><a href=\"#UIScreen-mainScreen-bounds获取屏幕大小不对的问题\" class=\"headerlink\" title=\"[UIScreen mainScreen].bounds获取屏幕大小不对的问题\"></a>[UIScreen mainScreen].bounds获取屏幕大小不对的问题</h3><p>#define SCREEN_WIDTH  [UIScreen mainScreen].bounds.size.width<br><br>#define iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242,2208),[[UIScreen mainScreen] currentMode].size) : NO)<br><br>在标准模式下<br><br>6+：<br><br>[[UIScreen mainScreen] currentMode].size为{1242，2208}<br><br>[UIScreen mainScreen].bounds.size为{414，736}<br><br>6:<br><br>[[UIScreen mainScreen] currentMode].size为{750，1334}<br><br>[UIScreen mainScreen].bounds.size为{375，667}<br></p>\n<p>放大模式下(设置-&gt;显示与亮度-&gt;显示模式) <br><br>6+:<br><br>[[UIScreen mainScreen] currentMode].size为{1125,2001}<br><br>[UIScreen mainScreen].bounds.size为{375,667}<br><br>6:<br><br>[[UIScreen mainScreen] currentMode].size为{640,1136}<br><br>[UIScreen mainScreen].bounds.size为{320,568}</p>\n<h3 id=\"Mac模式下如何将视频生成Gif文件\"><a href=\"#Mac模式下如何将视频生成Gif文件\" class=\"headerlink\" title=\"Mac模式下如何将视频生成Gif文件\"></a>Mac模式下如何将视频生成Gif文件</h3><h4 id=\"一：使用GifBrewery直接将视频转为gif文件-安装GifBreweryw密码-www-macx-cn\"><a href=\"#一：使用GifBrewery直接将视频转为gif文件-安装GifBreweryw密码-www-macx-cn\" class=\"headerlink\" title=\"一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)\"></a>一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)</h4><h4 id=\"二：安装ffmpeg-brew-install-ffmpeg-使用ffmpeg使视频转为多张图片\"><a href=\"#二：安装ffmpeg-brew-install-ffmpeg-使用ffmpeg使视频转为多张图片\" class=\"headerlink\" title=\"二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片\"></a>二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片<br></h4><p>（ ffmpeg -i  news.mov -r 10 -f image2 文件夹名/%05d.png）<br><br>然后使用PicGIF (将多张图片生成gif文件)</p>"},{"title":"iOS性能监测","date":"2016-02-25T07:46:16.000Z","_content":"\niOS开发中，如果是由于占用内存或者cpu过高导致性能下降，使用Instruments比较容易那些造成性能低下的”罪魁祸首”，在开发测试阶段它可以帮助我们分析软件运行的性能消耗，但是这可定是远远不够的，我们需要一个工具，可以在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.\n\n### Time Profiler\n可以查看多个线程中每个方法的耗时。\n#### 对Xcode进行设置\n##### 1. 不设置该选项，只能看到一堆栈\n如果想要在TimeProfile中直观的查看方法耗时，需要对Xcode进行设置\n在Xcode->Build Setting->Debug Information Format中设置选项为：DWARF with DSYM File\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/1.png)\n<!--more-->\n#### 对TimeProfile进行设置\n##### 1.\n在TimeProfile的Call Tree中，右侧面板有三个检查器：record setting（记录设置）、display setting（展示设置）、还有extends detail（扩展详情） \n\n##### 2.\n我们选择display setting，并在该选择器中勾选Separate by Thread和Hide System Libraries（两个最基本的选项）\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/2.png)\n##### 3.\n这样就可以逐级查看每个方法的耗时了\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/3.png)\n\n### Allocations\n这里可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置。具体操作是在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation，切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation，这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。\n### Leak\n可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的Statistics>Allocation Summary能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。\n\n### UIImage\n这里要主要是会影响内存的开销，需要权衡下imagedNamed和imageWithContentsOfFile，了解两者特性后，在只需要显示一次的图片用后者，这样会减少内存的消耗，但是页面显示会增加Image IO的消耗，这个需要注意下。由于imageWithContentsOfFile不缓存，所以需要在每次页面显示前加载一次，这个IO的操作也是需要考虑权衡的一个点。\n\n### 页面加载\n如果一个页面内容过多，view过多，这样将长页面中的需要滚动才能看到的那个部分视图内容通过开启新的线程同步的加载。\n\n### 优化首次加载时间\n通过Time Profier可以查看到启动所占用的时间，如果太长可以通过Heaviest Stack Trace找到费时的方法进行改造。\n\n### 寻找卡顿的切入点\n>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在此处查阅到源代码http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的:\n<br />\n\n```\nint32_t __CFRunLoopRun()\n{\n    //通知即将进入runloop\n    __CFRunLoopDoObservers(KCFRunLoopEntry);\n    \n    do\n    {\n        // 通知将要处理timer和source\n        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);\n        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);\n        \n        __CFRunLoopDoBlocks();  //处理非延迟的主线程调用\n        __CFRunLoopDoSource0(); //处理UIEvent事件\n        \n        //GCD dispatch main queue\n        CheckIfExistMessagesInMainDispatchQueue();\n        \n        // 即将进入休眠\n        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);\n        \n        // 等待内核mach_msg事件\n        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();\n        \n        // Zzz...\n        \n        // 从等待中醒来\n        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);\n        \n        // 处理因timer的唤醒\n        if (wakeUpPort == timerPort)\n            __CFRunLoopDoTimers();\n        \n        // 处理异步方法唤醒,如dispatch_async\n        else if (wakeUpPort == mainDispatchQueuePort)\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()\n            \n        // UI刷新,动画显示\n        else\n            __CFRunLoopDoSource1();\n        \n        // 再次确保是否有同步的方法需要调用\n        __CFRunLoopDoBlocks();\n        \n    } while (!stop && !timeout);\n    \n    //通知即将退出runloop\n    __CFRunLoopDoObservers(CFRunLoopExit);\n}\n```\n<br />\n\n>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.\n\n<br />\n\n###量化卡顿的程度\n>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:\n>\n\n<br />\n\n```\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    MyClass *object = (__bridge MyClass*)info;\n    object->activity = activity;\n}\n\n- (void)registerObserver\n{\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                                            kCFRunLoopAllActivities,\n                                                            YES,\n                                                            0,\n                                                            &runLoopObserverCallBack,\n                                                            &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n}\n```\n<br />\n\n>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.\n为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:\n\n<br />\n\n```\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    PerformanceMonitor *moniotr = (__bridge PerformanceMonitor*)info;\n    \n    moniotr->activity = activity;\n    \n    dispatch_semaphore_t semaphore = moniotr->semaphore;\n    dispatch_semaphore_signal(semaphore);\n}\n- (void)startMonitor\n{\n    if (observer)\n        return;\n    \n    // 信号,Dispatch Semaphore保证同步\n    semaphore = dispatch_semaphore_create(0);\n    \n    // 注册RunLoop状态观察\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                       kCFRunLoopAllActivities,\n                                       YES,\n                                       0,\n                                       &runLoopObserverCallBack,\n                                       &context);\n    //将观察者添加到主线程runloop的common模式下的观察中\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n    \n    // 在子线程监控时长 开启一个持续的loop用来进行监控\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        while (YES)\n        {\n            //假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)\n            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));\n            if (st != 0)\n            {\n                if (!observer)\n                {\n                    timeoutCount = 0;\n                    semaphore = 0;\n                    activity = 0;\n                    return;\n                }\n                //两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够检测到是否卡顿\n                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)\n                {\n                    if (++timeoutCount < 5)\n                        continue;\n                    PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD\n                                                                                       symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];\n                    PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];\n                    NSData *data = [crashReporter generateLiveReport];\n                    PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];\n                    NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter\n                                                                              withTextFormat:PLCrashReportTextFormatiOS];\n                    //上传服务器\n                    NSLog(@\"此处发生卡顿:---%@\", report);\n                }//end activity\n            }// end semaphore wait\n            timeoutCount = 0;\n        }// end while\n    });\n}\n```\n### 记录卡顿的函数调用\n\n<br />\n\n>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:\n\n<br />\n\n```\nPLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD\n                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];\nPLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];\n\nNSData *data = [crashReporter generateLiveReport];\nPLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];\nNSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter\n                                                          withTextFormat:PLCrashReportTextFormatiOS];\n\n```\n当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑.\n\n[demo地址](https://github.com/suifengqjn/PerformanceMonitor)\n\n\n","source":"_posts/iOS性能监测.md","raw":"---\ntitle: iOS性能监测\ndate: 2016-02-25 15:46:16\ntags: [iOS, 性能]\ncategories: \n- iOS技术\n---\n\niOS开发中，如果是由于占用内存或者cpu过高导致性能下降，使用Instruments比较容易那些造成性能低下的”罪魁祸首”，在开发测试阶段它可以帮助我们分析软件运行的性能消耗，但是这可定是远远不够的，我们需要一个工具，可以在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.\n\n### Time Profiler\n可以查看多个线程中每个方法的耗时。\n#### 对Xcode进行设置\n##### 1. 不设置该选项，只能看到一堆栈\n如果想要在TimeProfile中直观的查看方法耗时，需要对Xcode进行设置\n在Xcode->Build Setting->Debug Information Format中设置选项为：DWARF with DSYM File\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/1.png)\n<!--more-->\n#### 对TimeProfile进行设置\n##### 1.\n在TimeProfile的Call Tree中，右侧面板有三个检查器：record setting（记录设置）、display setting（展示设置）、还有extends detail（扩展详情） \n\n##### 2.\n我们选择display setting，并在该选择器中勾选Separate by Thread和Hide System Libraries（两个最基本的选项）\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/2.png)\n##### 3.\n这样就可以逐级查看每个方法的耗时了\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/3.png)\n\n### Allocations\n这里可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置。具体操作是在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation，切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation，这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。\n### Leak\n可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的Statistics>Allocation Summary能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。\n\n### UIImage\n这里要主要是会影响内存的开销，需要权衡下imagedNamed和imageWithContentsOfFile，了解两者特性后，在只需要显示一次的图片用后者，这样会减少内存的消耗，但是页面显示会增加Image IO的消耗，这个需要注意下。由于imageWithContentsOfFile不缓存，所以需要在每次页面显示前加载一次，这个IO的操作也是需要考虑权衡的一个点。\n\n### 页面加载\n如果一个页面内容过多，view过多，这样将长页面中的需要滚动才能看到的那个部分视图内容通过开启新的线程同步的加载。\n\n### 优化首次加载时间\n通过Time Profier可以查看到启动所占用的时间，如果太长可以通过Heaviest Stack Trace找到费时的方法进行改造。\n\n### 寻找卡顿的切入点\n>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在此处查阅到源代码http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的:\n<br />\n\n```\nint32_t __CFRunLoopRun()\n{\n    //通知即将进入runloop\n    __CFRunLoopDoObservers(KCFRunLoopEntry);\n    \n    do\n    {\n        // 通知将要处理timer和source\n        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);\n        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);\n        \n        __CFRunLoopDoBlocks();  //处理非延迟的主线程调用\n        __CFRunLoopDoSource0(); //处理UIEvent事件\n        \n        //GCD dispatch main queue\n        CheckIfExistMessagesInMainDispatchQueue();\n        \n        // 即将进入休眠\n        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);\n        \n        // 等待内核mach_msg事件\n        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();\n        \n        // Zzz...\n        \n        // 从等待中醒来\n        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);\n        \n        // 处理因timer的唤醒\n        if (wakeUpPort == timerPort)\n            __CFRunLoopDoTimers();\n        \n        // 处理异步方法唤醒,如dispatch_async\n        else if (wakeUpPort == mainDispatchQueuePort)\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()\n            \n        // UI刷新,动画显示\n        else\n            __CFRunLoopDoSource1();\n        \n        // 再次确保是否有同步的方法需要调用\n        __CFRunLoopDoBlocks();\n        \n    } while (!stop && !timeout);\n    \n    //通知即将退出runloop\n    __CFRunLoopDoObservers(CFRunLoopExit);\n}\n```\n<br />\n\n>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.\n\n<br />\n\n###量化卡顿的程度\n>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:\n>\n\n<br />\n\n```\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    MyClass *object = (__bridge MyClass*)info;\n    object->activity = activity;\n}\n\n- (void)registerObserver\n{\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                                            kCFRunLoopAllActivities,\n                                                            YES,\n                                                            0,\n                                                            &runLoopObserverCallBack,\n                                                            &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n}\n```\n<br />\n\n>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.\n为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:\n\n<br />\n\n```\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    PerformanceMonitor *moniotr = (__bridge PerformanceMonitor*)info;\n    \n    moniotr->activity = activity;\n    \n    dispatch_semaphore_t semaphore = moniotr->semaphore;\n    dispatch_semaphore_signal(semaphore);\n}\n- (void)startMonitor\n{\n    if (observer)\n        return;\n    \n    // 信号,Dispatch Semaphore保证同步\n    semaphore = dispatch_semaphore_create(0);\n    \n    // 注册RunLoop状态观察\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                       kCFRunLoopAllActivities,\n                                       YES,\n                                       0,\n                                       &runLoopObserverCallBack,\n                                       &context);\n    //将观察者添加到主线程runloop的common模式下的观察中\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n    \n    // 在子线程监控时长 开启一个持续的loop用来进行监控\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        while (YES)\n        {\n            //假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)\n            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));\n            if (st != 0)\n            {\n                if (!observer)\n                {\n                    timeoutCount = 0;\n                    semaphore = 0;\n                    activity = 0;\n                    return;\n                }\n                //两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够检测到是否卡顿\n                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)\n                {\n                    if (++timeoutCount < 5)\n                        continue;\n                    PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD\n                                                                                       symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];\n                    PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];\n                    NSData *data = [crashReporter generateLiveReport];\n                    PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];\n                    NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter\n                                                                              withTextFormat:PLCrashReportTextFormatiOS];\n                    //上传服务器\n                    NSLog(@\"此处发生卡顿:---%@\", report);\n                }//end activity\n            }// end semaphore wait\n            timeoutCount = 0;\n        }// end while\n    });\n}\n```\n### 记录卡顿的函数调用\n\n<br />\n\n>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:\n\n<br />\n\n```\nPLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD\n                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];\nPLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];\n\nNSData *data = [crashReporter generateLiveReport];\nPLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];\nNSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter\n                                                          withTextFormat:PLCrashReportTextFormatiOS];\n\n```\n当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑.\n\n[demo地址](https://github.com/suifengqjn/PerformanceMonitor)\n\n\n","slug":"iOS性能监测","published":1,"updated":"2017-01-01T08:44:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5teg001ilx60ybc6to8e","content":"<p>iOS开发中，如果是由于占用内存或者cpu过高导致性能下降，使用Instruments比较容易那些造成性能低下的”罪魁祸首”，在开发测试阶段它可以帮助我们分析软件运行的性能消耗，但是这可定是远远不够的，我们需要一个工具，可以在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.</p>\n<h3 id=\"Time-Profiler\"><a href=\"#Time-Profiler\" class=\"headerlink\" title=\"Time Profiler\"></a>Time Profiler</h3><p>可以查看多个线程中每个方法的耗时。</p>\n<h4 id=\"对Xcode进行设置\"><a href=\"#对Xcode进行设置\" class=\"headerlink\" title=\"对Xcode进行设置\"></a>对Xcode进行设置</h4><h5 id=\"1-不设置该选项，只能看到一堆栈\"><a href=\"#1-不设置该选项，只能看到一堆栈\" class=\"headerlink\" title=\"1. 不设置该选项，只能看到一堆栈\"></a>1. 不设置该选项，只能看到一堆栈</h5><p>如果想要在TimeProfile中直观的查看方法耗时，需要对Xcode进行设置<br>在Xcode-&gt;Build Setting-&gt;Debug Information Format中设置选项为：DWARF with DSYM File<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/1.png\" alt=\"image\"><br><a id=\"more\"></a></p>\n<h4 id=\"对TimeProfile进行设置\"><a href=\"#对TimeProfile进行设置\" class=\"headerlink\" title=\"对TimeProfile进行设置\"></a>对TimeProfile进行设置</h4><h5 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h5><p>在TimeProfile的Call Tree中，右侧面板有三个检查器：record setting（记录设置）、display setting（展示设置）、还有extends detail（扩展详情） </p>\n<h5 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h5><p>我们选择display setting，并在该选择器中勾选Separate by Thread和Hide System Libraries（两个最基本的选项）<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/2.png\" alt=\"image\"></p>\n<h5 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h5><p>这样就可以逐级查看每个方法的耗时了<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/3.png\" alt=\"image\"></p>\n<h3 id=\"Allocations\"><a href=\"#Allocations\" class=\"headerlink\" title=\"Allocations\"></a>Allocations</h3><p>这里可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置。具体操作是在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation，切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation，这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。</p>\n<h3 id=\"Leak\"><a href=\"#Leak\" class=\"headerlink\" title=\"Leak\"></a>Leak</h3><p>可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的Statistics&gt;Allocation Summary能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。</p>\n<h3 id=\"UIImage\"><a href=\"#UIImage\" class=\"headerlink\" title=\"UIImage\"></a>UIImage</h3><p>这里要主要是会影响内存的开销，需要权衡下imagedNamed和imageWithContentsOfFile，了解两者特性后，在只需要显示一次的图片用后者，这样会减少内存的消耗，但是页面显示会增加Image IO的消耗，这个需要注意下。由于imageWithContentsOfFile不缓存，所以需要在每次页面显示前加载一次，这个IO的操作也是需要考虑权衡的一个点。</p>\n<h3 id=\"页面加载\"><a href=\"#页面加载\" class=\"headerlink\" title=\"页面加载\"></a>页面加载</h3><p>如果一个页面内容过多，view过多，这样将长页面中的需要滚动才能看到的那个部分视图内容通过开启新的线程同步的加载。</p>\n<h3 id=\"优化首次加载时间\"><a href=\"#优化首次加载时间\" class=\"headerlink\" title=\"优化首次加载时间\"></a>优化首次加载时间</h3><p>通过Time Profier可以查看到启动所占用的时间，如果太长可以通过Heaviest Stack Trace找到费时的方法进行改造。</p>\n<h3 id=\"寻找卡顿的切入点\"><a href=\"#寻找卡顿的切入点\" class=\"headerlink\" title=\"寻找卡顿的切入点\"></a>寻找卡顿的切入点</h3><blockquote>\n<p>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在此处查阅到源代码<a href=\"http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的\" target=\"_blank\" rel=\"external\">http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的</a>:<br><br></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">int32_t __CFRunLoopRun()</div><div class=\"line\">&#123;</div><div class=\"line\">    //通知即将进入runloop</div><div class=\"line\">    __CFRunLoopDoObservers(KCFRunLoopEntry);</div><div class=\"line\">    </div><div class=\"line\">    do</div><div class=\"line\">    &#123;</div><div class=\"line\">        // 通知将要处理timer和source</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopDoBlocks();  //处理非延迟的主线程调用</div><div class=\"line\">        __CFRunLoopDoSource0(); //处理UIEvent事件</div><div class=\"line\">        </div><div class=\"line\">        //GCD dispatch main queue</div><div class=\"line\">        CheckIfExistMessagesInMainDispatchQueue();</div><div class=\"line\">        </div><div class=\"line\">        // 即将进入休眠</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);</div><div class=\"line\">        </div><div class=\"line\">        // 等待内核mach_msg事件</div><div class=\"line\">        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();</div><div class=\"line\">        </div><div class=\"line\">        // Zzz...</div><div class=\"line\">        </div><div class=\"line\">        // 从等待中醒来</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);</div><div class=\"line\">        </div><div class=\"line\">        // 处理因timer的唤醒</div><div class=\"line\">        if (wakeUpPort == timerPort)</div><div class=\"line\">            __CFRunLoopDoTimers();</div><div class=\"line\">        </div><div class=\"line\">        // 处理异步方法唤醒,如dispatch_async</div><div class=\"line\">        else if (wakeUpPort == mainDispatchQueuePort)</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</div><div class=\"line\">            </div><div class=\"line\">        // UI刷新,动画显示</div><div class=\"line\">        else</div><div class=\"line\">            __CFRunLoopDoSource1();</div><div class=\"line\">        </div><div class=\"line\">        // 再次确保是否有同步的方法需要调用</div><div class=\"line\">        __CFRunLoopDoBlocks();</div><div class=\"line\">        </div><div class=\"line\">    &#125; while (!stop &amp;&amp; !timeout);</div><div class=\"line\">    </div><div class=\"line\">    //通知即将退出runloop</div><div class=\"line\">    __CFRunLoopDoObservers(CFRunLoopExit);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<blockquote>\n<p>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.</p>\n</blockquote>\n<p><br></p>\n<p>###量化卡顿的程度</p>\n<blockquote>\n<p>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:</p>\n</blockquote>\n<p><br></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    MyClass *object = (__bridge MyClass*)info;</div><div class=\"line\">    object-&gt;activity = activity;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)registerObserver</div><div class=\"line\">&#123;</div><div class=\"line\">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</div><div class=\"line\">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</div><div class=\"line\">                                                            kCFRunLoopAllActivities,</div><div class=\"line\">                                                            YES,</div><div class=\"line\">                                                            0,</div><div class=\"line\">                                                            &amp;runLoopObserverCallBack,</div><div class=\"line\">                                                            &amp;context);</div><div class=\"line\">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<blockquote>\n<p>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.<br>为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:</p>\n</blockquote>\n<p><br></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    PerformanceMonitor *moniotr = (__bridge PerformanceMonitor*)info;</div><div class=\"line\">    </div><div class=\"line\">    moniotr-&gt;activity = activity;</div><div class=\"line\">    </div><div class=\"line\">    dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</div><div class=\"line\">    dispatch_semaphore_signal(semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)startMonitor</div><div class=\"line\">&#123;</div><div class=\"line\">    if (observer)</div><div class=\"line\">        return;</div><div class=\"line\">    </div><div class=\"line\">    // 信号,Dispatch Semaphore保证同步</div><div class=\"line\">    semaphore = dispatch_semaphore_create(0);</div><div class=\"line\">    </div><div class=\"line\">    // 注册RunLoop状态观察</div><div class=\"line\">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</div><div class=\"line\">    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</div><div class=\"line\">                                       kCFRunLoopAllActivities,</div><div class=\"line\">                                       YES,</div><div class=\"line\">                                       0,</div><div class=\"line\">                                       &amp;runLoopObserverCallBack,</div><div class=\"line\">                                       &amp;context);</div><div class=\"line\">    //将观察者添加到主线程runloop的common模式下的观察中</div><div class=\"line\">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">    </div><div class=\"line\">    // 在子线程监控时长 开启一个持续的loop用来进行监控</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        while (YES)</div><div class=\"line\">        &#123;</div><div class=\"line\">            //假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</div><div class=\"line\">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</div><div class=\"line\">            if (st != 0)</div><div class=\"line\">            &#123;</div><div class=\"line\">                if (!observer)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    timeoutCount = 0;</div><div class=\"line\">                    semaphore = 0;</div><div class=\"line\">                    activity = 0;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                //两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够检测到是否卡顿</div><div class=\"line\">                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    if (++timeoutCount &lt; 5)</div><div class=\"line\">                        continue;</div><div class=\"line\">                    PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD</div><div class=\"line\">                                                                                       symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</div><div class=\"line\">                    PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];</div><div class=\"line\">                    NSData *data = [crashReporter generateLiveReport];</div><div class=\"line\">                    PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];</div><div class=\"line\">                    NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter</div><div class=\"line\">                                                                              withTextFormat:PLCrashReportTextFormatiOS];</div><div class=\"line\">                    //上传服务器</div><div class=\"line\">                    NSLog(@&quot;此处发生卡顿:---%@&quot;, report);</div><div class=\"line\">                &#125;//end activity</div><div class=\"line\">            &#125;// end semaphore wait</div><div class=\"line\">            timeoutCount = 0;</div><div class=\"line\">        &#125;// end while</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"记录卡顿的函数调用\"><a href=\"#记录卡顿的函数调用\" class=\"headerlink\" title=\"记录卡顿的函数调用\"></a>记录卡顿的函数调用</h3><p><br></p>\n<blockquote>\n<p>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:</p>\n</blockquote>\n<p><br></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD</div><div class=\"line\">                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</div><div class=\"line\">PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];</div><div class=\"line\"></div><div class=\"line\">NSData *data = [crashReporter generateLiveReport];</div><div class=\"line\">PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];</div><div class=\"line\">NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter</div><div class=\"line\">                                                          withTextFormat:PLCrashReportTextFormatiOS];</div></pre></td></tr></table></figure>\n<p>当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑.</p>\n<p><a href=\"https://github.com/suifengqjn/PerformanceMonitor\" target=\"_blank\" rel=\"external\">demo地址</a></p>\n","excerpt":"<p>iOS开发中，如果是由于占用内存或者cpu过高导致性能下降，使用Instruments比较容易那些造成性能低下的”罪魁祸首”，在开发测试阶段它可以帮助我们分析软件运行的性能消耗，但是这可定是远远不够的，我们需要一个工具，可以在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.</p>\n<h3 id=\"Time-Profiler\"><a href=\"#Time-Profiler\" class=\"headerlink\" title=\"Time Profiler\"></a>Time Profiler</h3><p>可以查看多个线程中每个方法的耗时。</p>\n<h4 id=\"对Xcode进行设置\"><a href=\"#对Xcode进行设置\" class=\"headerlink\" title=\"对Xcode进行设置\"></a>对Xcode进行设置</h4><h5 id=\"1-不设置该选项，只能看到一堆栈\"><a href=\"#1-不设置该选项，只能看到一堆栈\" class=\"headerlink\" title=\"1. 不设置该选项，只能看到一堆栈\"></a>1. 不设置该选项，只能看到一堆栈</h5><p>如果想要在TimeProfile中直观的查看方法耗时，需要对Xcode进行设置<br>在Xcode-&gt;Build Setting-&gt;Debug Information Format中设置选项为：DWARF with DSYM File<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/1.png\" alt=\"image\"><br>","more":"</p>\n<h4 id=\"对TimeProfile进行设置\"><a href=\"#对TimeProfile进行设置\" class=\"headerlink\" title=\"对TimeProfile进行设置\"></a>对TimeProfile进行设置</h4><h5 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h5><p>在TimeProfile的Call Tree中，右侧面板有三个检查器：record setting（记录设置）、display setting（展示设置）、还有extends detail（扩展详情） </p>\n<h5 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h5><p>我们选择display setting，并在该选择器中勾选Separate by Thread和Hide System Libraries（两个最基本的选项）<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/2.png\" alt=\"image\"></p>\n<h5 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h5><p>这样就可以逐级查看每个方法的耗时了<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/PerformanceMonitor/3.png\" alt=\"image\"></p>\n<h3 id=\"Allocations\"><a href=\"#Allocations\" class=\"headerlink\" title=\"Allocations\"></a>Allocations</h3><p>这里可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置。具体操作是在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation，切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation，这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。</p>\n<h3 id=\"Leak\"><a href=\"#Leak\" class=\"headerlink\" title=\"Leak\"></a>Leak</h3><p>可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的Statistics&gt;Allocation Summary能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。</p>\n<h3 id=\"UIImage\"><a href=\"#UIImage\" class=\"headerlink\" title=\"UIImage\"></a>UIImage</h3><p>这里要主要是会影响内存的开销，需要权衡下imagedNamed和imageWithContentsOfFile，了解两者特性后，在只需要显示一次的图片用后者，这样会减少内存的消耗，但是页面显示会增加Image IO的消耗，这个需要注意下。由于imageWithContentsOfFile不缓存，所以需要在每次页面显示前加载一次，这个IO的操作也是需要考虑权衡的一个点。</p>\n<h3 id=\"页面加载\"><a href=\"#页面加载\" class=\"headerlink\" title=\"页面加载\"></a>页面加载</h3><p>如果一个页面内容过多，view过多，这样将长页面中的需要滚动才能看到的那个部分视图内容通过开启新的线程同步的加载。</p>\n<h3 id=\"优化首次加载时间\"><a href=\"#优化首次加载时间\" class=\"headerlink\" title=\"优化首次加载时间\"></a>优化首次加载时间</h3><p>通过Time Profier可以查看到启动所占用的时间，如果太长可以通过Heaviest Stack Trace找到费时的方法进行改造。</p>\n<h3 id=\"寻找卡顿的切入点\"><a href=\"#寻找卡顿的切入点\" class=\"headerlink\" title=\"寻找卡顿的切入点\"></a>寻找卡顿的切入点</h3><blockquote>\n<p>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在此处查阅到源代码<a href=\"http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的\">http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的</a>:<br><br /></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">int32_t __CFRunLoopRun()</div><div class=\"line\">&#123;</div><div class=\"line\">    //通知即将进入runloop</div><div class=\"line\">    __CFRunLoopDoObservers(KCFRunLoopEntry);</div><div class=\"line\">    </div><div class=\"line\">    do</div><div class=\"line\">    &#123;</div><div class=\"line\">        // 通知将要处理timer和source</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopDoBlocks();  //处理非延迟的主线程调用</div><div class=\"line\">        __CFRunLoopDoSource0(); //处理UIEvent事件</div><div class=\"line\">        </div><div class=\"line\">        //GCD dispatch main queue</div><div class=\"line\">        CheckIfExistMessagesInMainDispatchQueue();</div><div class=\"line\">        </div><div class=\"line\">        // 即将进入休眠</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);</div><div class=\"line\">        </div><div class=\"line\">        // 等待内核mach_msg事件</div><div class=\"line\">        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();</div><div class=\"line\">        </div><div class=\"line\">        // Zzz...</div><div class=\"line\">        </div><div class=\"line\">        // 从等待中醒来</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);</div><div class=\"line\">        </div><div class=\"line\">        // 处理因timer的唤醒</div><div class=\"line\">        if (wakeUpPort == timerPort)</div><div class=\"line\">            __CFRunLoopDoTimers();</div><div class=\"line\">        </div><div class=\"line\">        // 处理异步方法唤醒,如dispatch_async</div><div class=\"line\">        else if (wakeUpPort == mainDispatchQueuePort)</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</div><div class=\"line\">            </div><div class=\"line\">        // UI刷新,动画显示</div><div class=\"line\">        else</div><div class=\"line\">            __CFRunLoopDoSource1();</div><div class=\"line\">        </div><div class=\"line\">        // 再次确保是否有同步的方法需要调用</div><div class=\"line\">        __CFRunLoopDoBlocks();</div><div class=\"line\">        </div><div class=\"line\">    &#125; while (!stop &amp;&amp; !timeout);</div><div class=\"line\">    </div><div class=\"line\">    //通知即将退出runloop</div><div class=\"line\">    __CFRunLoopDoObservers(CFRunLoopExit);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br /></p>\n<blockquote>\n<p>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.</p>\n</blockquote>\n<p><br /></p>\n<p>###量化卡顿的程度</p>\n<blockquote>\n<p>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:</p>\n</blockquote>\n<p><br /></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    MyClass *object = (__bridge MyClass*)info;</div><div class=\"line\">    object-&gt;activity = activity;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)registerObserver</div><div class=\"line\">&#123;</div><div class=\"line\">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</div><div class=\"line\">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</div><div class=\"line\">                                                            kCFRunLoopAllActivities,</div><div class=\"line\">                                                            YES,</div><div class=\"line\">                                                            0,</div><div class=\"line\">                                                            &amp;runLoopObserverCallBack,</div><div class=\"line\">                                                            &amp;context);</div><div class=\"line\">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br /></p>\n<blockquote>\n<p>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.<br>为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:</p>\n</blockquote>\n<p><br /></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    PerformanceMonitor *moniotr = (__bridge PerformanceMonitor*)info;</div><div class=\"line\">    </div><div class=\"line\">    moniotr-&gt;activity = activity;</div><div class=\"line\">    </div><div class=\"line\">    dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</div><div class=\"line\">    dispatch_semaphore_signal(semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)startMonitor</div><div class=\"line\">&#123;</div><div class=\"line\">    if (observer)</div><div class=\"line\">        return;</div><div class=\"line\">    </div><div class=\"line\">    // 信号,Dispatch Semaphore保证同步</div><div class=\"line\">    semaphore = dispatch_semaphore_create(0);</div><div class=\"line\">    </div><div class=\"line\">    // 注册RunLoop状态观察</div><div class=\"line\">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</div><div class=\"line\">    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</div><div class=\"line\">                                       kCFRunLoopAllActivities,</div><div class=\"line\">                                       YES,</div><div class=\"line\">                                       0,</div><div class=\"line\">                                       &amp;runLoopObserverCallBack,</div><div class=\"line\">                                       &amp;context);</div><div class=\"line\">    //将观察者添加到主线程runloop的common模式下的观察中</div><div class=\"line\">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">    </div><div class=\"line\">    // 在子线程监控时长 开启一个持续的loop用来进行监控</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        while (YES)</div><div class=\"line\">        &#123;</div><div class=\"line\">            //假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</div><div class=\"line\">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</div><div class=\"line\">            if (st != 0)</div><div class=\"line\">            &#123;</div><div class=\"line\">                if (!observer)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    timeoutCount = 0;</div><div class=\"line\">                    semaphore = 0;</div><div class=\"line\">                    activity = 0;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                //两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够检测到是否卡顿</div><div class=\"line\">                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    if (++timeoutCount &lt; 5)</div><div class=\"line\">                        continue;</div><div class=\"line\">                    PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD</div><div class=\"line\">                                                                                       symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</div><div class=\"line\">                    PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];</div><div class=\"line\">                    NSData *data = [crashReporter generateLiveReport];</div><div class=\"line\">                    PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];</div><div class=\"line\">                    NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter</div><div class=\"line\">                                                                              withTextFormat:PLCrashReportTextFormatiOS];</div><div class=\"line\">                    //上传服务器</div><div class=\"line\">                    NSLog(@&quot;此处发生卡顿:---%@&quot;, report);</div><div class=\"line\">                &#125;//end activity</div><div class=\"line\">            &#125;// end semaphore wait</div><div class=\"line\">            timeoutCount = 0;</div><div class=\"line\">        &#125;// end while</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"记录卡顿的函数调用\"><a href=\"#记录卡顿的函数调用\" class=\"headerlink\" title=\"记录卡顿的函数调用\"></a>记录卡顿的函数调用</h3><p><br /></p>\n<blockquote>\n<p>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:</p>\n</blockquote>\n<p><br /></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD</div><div class=\"line\">                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</div><div class=\"line\">PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];</div><div class=\"line\"></div><div class=\"line\">NSData *data = [crashReporter generateLiveReport];</div><div class=\"line\">PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];</div><div class=\"line\">NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter</div><div class=\"line\">                                                          withTextFormat:PLCrashReportTextFormatiOS];</div></pre></td></tr></table></figure>\n<p>当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑.</p>\n<p><a href=\"https://github.com/suifengqjn/PerformanceMonitor\">demo地址</a></p>"},{"title":"iOS数组防止越界crash","date":"2016-12-24T07:45:55.000Z","_content":"\n\n有时候项目中总是出现一些无法预知的情况，导致数组越界是程序crash，如果这种意外情况无法避免，那么只能从侧面采取保护措施。我先从网上找答案，我想其他人也肯定遇到过相同的情况，如果有好的解决方案，直接采用就可以了。但是实际上，网上搜索的结果令人有些失望。下面还是记录一下我自己的解决方案，以及和网上解决方案的差异。\n\n### crash的具体几种情况\n- 取值：index超出array的索引范围\n- 添加：插入的object为nil或者Null\n- 插入：index大于count、插入的object为nil或者Null\n- 删除：index超出array的索引范围\n- 替换：index超出array的索引范围、替换的object为nil或者Null\n\n### 解决思路\n任何代码都需要围绕\"高内聚，低耦合\"的思想来实现，尤其是这种工具类的代码，更是应该对原代码入侵越少越好。一个很容易想到的方法，就是采用runtime, 把array中的以上几种情况的方法替换成自己的方法，然后再执行方法的时候加以判断。而我在网上搜到的结果全是以这种方案解决的，不排除有更好的方法我没找到。附上一个我找到的代码比较详细的[demo](https://github.com/wanyakun/YKIntercepter)。我试了一下，效果是可以达到，不过我还是毫不犹豫的拒绝这种方式。直接替换了系统的方法必然会导致更多无法预知的问题。这些问题，我在后面会讲几个我遇到的。而我准备这样解决：\n<!--more-->\n- 这是系统原本的调用方式\n![这是系统原本的调用方式](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E8%B6%8A%E7%95%8Ccrash/12.png)\n\n- 这是改变之后的调用方式\n![这是改变之后的调用方式](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E8%B6%8A%E7%95%8Ccrash/13.png)\n\n我是先勾住array自带的方法，进行判断，如果没有越界等几种情况，再继续执行它自身的方法，相当于在执行方法前多了一步判断，而网上是直接把方法替换成自己的方法了，这里还是有本质的区别。\n\n### 具体实现原理\n这里举例说明 `NSArray` 的 `addObject:` 方法，其他也类似。\n#### 先定义一个静态变量\n`static IMP array_old_func_imap_object = NULL;`\n这个变量用来记录array自带方法的指针地址\n#### 获取方法，然后记录方法的指针地址\n```\nMethod old_func_imap_object = class_getInstanceMethod(NSClassFromString(@\"__NSArrayI\"), @selector(objectAtIndex:));\n            array_old_func_imap_object = method_getImplementation(old_func_imap_object);\n```\n#### 改变原方法的指针地址，并指向自定义方法\n`method_setImplementation(old_func_imap_object, [self methodForSelector:@selector(fm_objectAtIndex:)]);`\n#### 自定义方法的实现\n```\n- (id)fm_objectAtIndex:(NSUInteger)index {\n    if (index < [(NSArray*)self count]) {\n        return ((id(*)(id, SEL, NSUInteger))array_old_func_imap_object)(self, @selector(objectAtIndex:), index);\n    }\n    NSLog(@\"NArray objectAtIndex 失败--%@\", [NSThread callStackSymbols]);\n    return nil;\n}\n```\n#### 最后一步\n到这里已经差不多完成了，就剩最后一个问题了，就是怎么运用到项目中，让这个工具类继承自NSObject，把这个工具类写成一个单例，然后在load方法中调用单例。load 方法会在本类第一次使用的时候调用一次，所以，把这个工具类拖到项目中，不用写其他代码，就实现了以上的功能。\n```\n+ (void)load {\n    [FMDetecter sharedInstance];\n}\n\nstatic dispatch_once_t onceToken;\nstatic FMDetecter *sharedInstance;\n\n+ (instancetype)sharedInstance {\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[FMDetecter alloc] init];\n    });\n    return sharedInstance;\n}\n```\n这里有完整的代码，有兴趣可查看[demo](https://github.com/suifengqjn/FMArrarMonitor)\n\n### 实际出现的问题\n我用这两种方式都试了试，新建一个空项目，然后把上面几个方法都试一遍，似乎都没问题，然后我把他们公司的项目中，程序有时候卡死，还会crash，还是没法用，两种方式都有问题，找了找原因，发现NSArray和NSMutableArray的那几个方法，系统自己会调用很多很多次，极大的影响了性能，还有网友遇到了其他的问题：替换了objectAtIndex方法有输入的地方出来了软键盘按手机Home键就Crash了。简直无解，最后，还是决定写个分类，虽然low一点，毕竟还是能解决我的问题，并且不会带来新的问题。\n\n#### 这是给NSArray添加的方法 \n\n```\n#import \"NSArray+beyond.h\"\n\n@implementation NSArray (beyond)\n-(id)objectAtIndexCheck:(NSUInteger)index\n{\n    if (index < self.count) {\n        return [self objectAtIndex:index];\n    }\n    return nil;\n}\n@end\n```\n\n#### 这是给NSMutableArray添加的方法\n\n```\n#import \"NSMutableArray+beyond.h\"\n\n@implementation NSMutableArray (beyond)\n-(id)objectAtIndexCheck:(NSUInteger)index\n{\n    if (index < self.count) {\n        return [self objectAtIndex:index];\n    }\n    NSLog(@\"%@\", [NSThread callStackSymbols]);\n    return nil;\n}\n- (void)addObjectCheck:(id)anObject\n{\n    if (anObject != nil && [anObject isKindOfClass:[NSNull class]] == NO) {\n        [self addObject:anObject];\n    } else {\n        NSLog(@\"%@\", [NSThread callStackSymbols]);\n        \n    }\n}\n- (void)insertObjectCheck:(id)anObject atIndex:(NSUInteger)index\n{\n    if (index <= self.count && anObject != nil && [anObject isKindOfClass:[NSNull class]] == NO) {\n        [self insertObject:anObject atIndex:index];\n    } else {\n        NSLog(@\"%@\", [NSThread callStackSymbols]);\n        \n    }\n}\n\n- (void)removeObjectAtIndexCheck:(NSUInteger)index\n{\n    if (index < self.count) {\n        [self removeObjectAtIndex:index];\n    } else {\n        NSLog(@\"%@\", [NSThread callStackSymbols]);\n        \n    }\n}\n- (void)replaceObjectAtIndexCheck:(NSUInteger)index withObject:(id)anObject\n{\n    if (index < self.count && anObject != nil && [anObject isKindOfClass:[NSNull class]] == NO) {\n        [self replaceObjectAtIndex:index withObject:anObject];\n    } else {\n        NSLog(@\"%@\", [NSThread callStackSymbols]);\n        \n    }\n}\n@end\n```\n\n\n","source":"_posts/iOS数组防止越界crash.md","raw":"---\ntitle: iOS数组防止越界crash\ndate: 2016-12-24 15:45:55\ncategory:\n\t- iOS技术\ntags: [iOS, 越界, NSArray, NSMutableArray, crash]\n---\n\n\n有时候项目中总是出现一些无法预知的情况，导致数组越界是程序crash，如果这种意外情况无法避免，那么只能从侧面采取保护措施。我先从网上找答案，我想其他人也肯定遇到过相同的情况，如果有好的解决方案，直接采用就可以了。但是实际上，网上搜索的结果令人有些失望。下面还是记录一下我自己的解决方案，以及和网上解决方案的差异。\n\n### crash的具体几种情况\n- 取值：index超出array的索引范围\n- 添加：插入的object为nil或者Null\n- 插入：index大于count、插入的object为nil或者Null\n- 删除：index超出array的索引范围\n- 替换：index超出array的索引范围、替换的object为nil或者Null\n\n### 解决思路\n任何代码都需要围绕\"高内聚，低耦合\"的思想来实现，尤其是这种工具类的代码，更是应该对原代码入侵越少越好。一个很容易想到的方法，就是采用runtime, 把array中的以上几种情况的方法替换成自己的方法，然后再执行方法的时候加以判断。而我在网上搜到的结果全是以这种方案解决的，不排除有更好的方法我没找到。附上一个我找到的代码比较详细的[demo](https://github.com/wanyakun/YKIntercepter)。我试了一下，效果是可以达到，不过我还是毫不犹豫的拒绝这种方式。直接替换了系统的方法必然会导致更多无法预知的问题。这些问题，我在后面会讲几个我遇到的。而我准备这样解决：\n<!--more-->\n- 这是系统原本的调用方式\n![这是系统原本的调用方式](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E8%B6%8A%E7%95%8Ccrash/12.png)\n\n- 这是改变之后的调用方式\n![这是改变之后的调用方式](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E8%B6%8A%E7%95%8Ccrash/13.png)\n\n我是先勾住array自带的方法，进行判断，如果没有越界等几种情况，再继续执行它自身的方法，相当于在执行方法前多了一步判断，而网上是直接把方法替换成自己的方法了，这里还是有本质的区别。\n\n### 具体实现原理\n这里举例说明 `NSArray` 的 `addObject:` 方法，其他也类似。\n#### 先定义一个静态变量\n`static IMP array_old_func_imap_object = NULL;`\n这个变量用来记录array自带方法的指针地址\n#### 获取方法，然后记录方法的指针地址\n```\nMethod old_func_imap_object = class_getInstanceMethod(NSClassFromString(@\"__NSArrayI\"), @selector(objectAtIndex:));\n            array_old_func_imap_object = method_getImplementation(old_func_imap_object);\n```\n#### 改变原方法的指针地址，并指向自定义方法\n`method_setImplementation(old_func_imap_object, [self methodForSelector:@selector(fm_objectAtIndex:)]);`\n#### 自定义方法的实现\n```\n- (id)fm_objectAtIndex:(NSUInteger)index {\n    if (index < [(NSArray*)self count]) {\n        return ((id(*)(id, SEL, NSUInteger))array_old_func_imap_object)(self, @selector(objectAtIndex:), index);\n    }\n    NSLog(@\"NArray objectAtIndex 失败--%@\", [NSThread callStackSymbols]);\n    return nil;\n}\n```\n#### 最后一步\n到这里已经差不多完成了，就剩最后一个问题了，就是怎么运用到项目中，让这个工具类继承自NSObject，把这个工具类写成一个单例，然后在load方法中调用单例。load 方法会在本类第一次使用的时候调用一次，所以，把这个工具类拖到项目中，不用写其他代码，就实现了以上的功能。\n```\n+ (void)load {\n    [FMDetecter sharedInstance];\n}\n\nstatic dispatch_once_t onceToken;\nstatic FMDetecter *sharedInstance;\n\n+ (instancetype)sharedInstance {\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[FMDetecter alloc] init];\n    });\n    return sharedInstance;\n}\n```\n这里有完整的代码，有兴趣可查看[demo](https://github.com/suifengqjn/FMArrarMonitor)\n\n### 实际出现的问题\n我用这两种方式都试了试，新建一个空项目，然后把上面几个方法都试一遍，似乎都没问题，然后我把他们公司的项目中，程序有时候卡死，还会crash，还是没法用，两种方式都有问题，找了找原因，发现NSArray和NSMutableArray的那几个方法，系统自己会调用很多很多次，极大的影响了性能，还有网友遇到了其他的问题：替换了objectAtIndex方法有输入的地方出来了软键盘按手机Home键就Crash了。简直无解，最后，还是决定写个分类，虽然low一点，毕竟还是能解决我的问题，并且不会带来新的问题。\n\n#### 这是给NSArray添加的方法 \n\n```\n#import \"NSArray+beyond.h\"\n\n@implementation NSArray (beyond)\n-(id)objectAtIndexCheck:(NSUInteger)index\n{\n    if (index < self.count) {\n        return [self objectAtIndex:index];\n    }\n    return nil;\n}\n@end\n```\n\n#### 这是给NSMutableArray添加的方法\n\n```\n#import \"NSMutableArray+beyond.h\"\n\n@implementation NSMutableArray (beyond)\n-(id)objectAtIndexCheck:(NSUInteger)index\n{\n    if (index < self.count) {\n        return [self objectAtIndex:index];\n    }\n    NSLog(@\"%@\", [NSThread callStackSymbols]);\n    return nil;\n}\n- (void)addObjectCheck:(id)anObject\n{\n    if (anObject != nil && [anObject isKindOfClass:[NSNull class]] == NO) {\n        [self addObject:anObject];\n    } else {\n        NSLog(@\"%@\", [NSThread callStackSymbols]);\n        \n    }\n}\n- (void)insertObjectCheck:(id)anObject atIndex:(NSUInteger)index\n{\n    if (index <= self.count && anObject != nil && [anObject isKindOfClass:[NSNull class]] == NO) {\n        [self insertObject:anObject atIndex:index];\n    } else {\n        NSLog(@\"%@\", [NSThread callStackSymbols]);\n        \n    }\n}\n\n- (void)removeObjectAtIndexCheck:(NSUInteger)index\n{\n    if (index < self.count) {\n        [self removeObjectAtIndex:index];\n    } else {\n        NSLog(@\"%@\", [NSThread callStackSymbols]);\n        \n    }\n}\n- (void)replaceObjectAtIndexCheck:(NSUInteger)index withObject:(id)anObject\n{\n    if (index < self.count && anObject != nil && [anObject isKindOfClass:[NSNull class]] == NO) {\n        [self replaceObjectAtIndex:index withObject:anObject];\n    } else {\n        NSLog(@\"%@\", [NSThread callStackSymbols]);\n        \n    }\n}\n@end\n```\n\n\n","slug":"iOS数组防止越界crash","published":1,"updated":"2016-12-24T07:52:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5teh001mlx60t2aljd93","content":"<p>有时候项目中总是出现一些无法预知的情况，导致数组越界是程序crash，如果这种意外情况无法避免，那么只能从侧面采取保护措施。我先从网上找答案，我想其他人也肯定遇到过相同的情况，如果有好的解决方案，直接采用就可以了。但是实际上，网上搜索的结果令人有些失望。下面还是记录一下我自己的解决方案，以及和网上解决方案的差异。</p>\n<h3 id=\"crash的具体几种情况\"><a href=\"#crash的具体几种情况\" class=\"headerlink\" title=\"crash的具体几种情况\"></a>crash的具体几种情况</h3><ul>\n<li>取值：index超出array的索引范围</li>\n<li>添加：插入的object为nil或者Null</li>\n<li>插入：index大于count、插入的object为nil或者Null</li>\n<li>删除：index超出array的索引范围</li>\n<li>替换：index超出array的索引范围、替换的object为nil或者Null</li>\n</ul>\n<h3 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h3><p>任何代码都需要围绕”高内聚，低耦合”的思想来实现，尤其是这种工具类的代码，更是应该对原代码入侵越少越好。一个很容易想到的方法，就是采用runtime, 把array中的以上几种情况的方法替换成自己的方法，然后再执行方法的时候加以判断。而我在网上搜到的结果全是以这种方案解决的，不排除有更好的方法我没找到。附上一个我找到的代码比较详细的<a href=\"https://github.com/wanyakun/YKIntercepter\" target=\"_blank\" rel=\"external\">demo</a>。我试了一下，效果是可以达到，不过我还是毫不犹豫的拒绝这种方式。直接替换了系统的方法必然会导致更多无法预知的问题。这些问题，我在后面会讲几个我遇到的。而我准备这样解决：<br><a id=\"more\"></a></p>\n<ul>\n<li><p>这是系统原本的调用方式<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E8%B6%8A%E7%95%8Ccrash/12.png\" alt=\"这是系统原本的调用方式\"></p>\n</li>\n<li><p>这是改变之后的调用方式<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E8%B6%8A%E7%95%8Ccrash/13.png\" alt=\"这是改变之后的调用方式\"></p>\n</li>\n</ul>\n<p>我是先勾住array自带的方法，进行判断，如果没有越界等几种情况，再继续执行它自身的方法，相当于在执行方法前多了一步判断，而网上是直接把方法替换成自己的方法了，这里还是有本质的区别。</p>\n<h3 id=\"具体实现原理\"><a href=\"#具体实现原理\" class=\"headerlink\" title=\"具体实现原理\"></a>具体实现原理</h3><p>这里举例说明 <code>NSArray</code> 的 <code>addObject:</code> 方法，其他也类似。</p>\n<h4 id=\"先定义一个静态变量\"><a href=\"#先定义一个静态变量\" class=\"headerlink\" title=\"先定义一个静态变量\"></a>先定义一个静态变量</h4><p><code>static IMP array_old_func_imap_object = NULL;</code><br>这个变量用来记录array自带方法的指针地址</p>\n<h4 id=\"获取方法，然后记录方法的指针地址\"><a href=\"#获取方法，然后记录方法的指针地址\" class=\"headerlink\" title=\"获取方法，然后记录方法的指针地址\"></a>获取方法，然后记录方法的指针地址</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method old_func_imap_object = class_getInstanceMethod(NSClassFromString(@&quot;__NSArrayI&quot;), @selector(objectAtIndex:));</div><div class=\"line\">            array_old_func_imap_object = method_getImplementation(old_func_imap_object);</div></pre></td></tr></table></figure>\n<h4 id=\"改变原方法的指针地址，并指向自定义方法\"><a href=\"#改变原方法的指针地址，并指向自定义方法\" class=\"headerlink\" title=\"改变原方法的指针地址，并指向自定义方法\"></a>改变原方法的指针地址，并指向自定义方法</h4><p><code>method_setImplementation(old_func_imap_object, [self methodForSelector:@selector(fm_objectAtIndex:)]);</code></p>\n<h4 id=\"自定义方法的实现\"><a href=\"#自定义方法的实现\" class=\"headerlink\" title=\"自定义方法的实现\"></a>自定义方法的实现</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (id)fm_objectAtIndex:(NSUInteger)index &#123;</div><div class=\"line\">    if (index &lt; [(NSArray*)self count]) &#123;</div><div class=\"line\">        return ((id(*)(id, SEL, NSUInteger))array_old_func_imap_object)(self, @selector(objectAtIndex:), index);</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;NArray objectAtIndex 失败--%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"最后一步\"><a href=\"#最后一步\" class=\"headerlink\" title=\"最后一步\"></a>最后一步</h4><p>到这里已经差不多完成了，就剩最后一个问题了，就是怎么运用到项目中，让这个工具类继承自NSObject，把这个工具类写成一个单例，然后在load方法中调用单例。load 方法会在本类第一次使用的时候调用一次，所以，把这个工具类拖到项目中，不用写其他代码，就实现了以上的功能。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (void)load &#123;</div><div class=\"line\">    [FMDetecter sharedInstance];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static dispatch_once_t onceToken;</div><div class=\"line\">static FMDetecter *sharedInstance;</div><div class=\"line\"></div><div class=\"line\">+ (instancetype)sharedInstance &#123;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        sharedInstance = [[FMDetecter alloc] init];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return sharedInstance;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里有完整的代码，有兴趣可查看<a href=\"https://github.com/suifengqjn/FMArrarMonitor\" target=\"_blank\" rel=\"external\">demo</a></p>\n<h3 id=\"实际出现的问题\"><a href=\"#实际出现的问题\" class=\"headerlink\" title=\"实际出现的问题\"></a>实际出现的问题</h3><p>我用这两种方式都试了试，新建一个空项目，然后把上面几个方法都试一遍，似乎都没问题，然后我把他们公司的项目中，程序有时候卡死，还会crash，还是没法用，两种方式都有问题，找了找原因，发现NSArray和NSMutableArray的那几个方法，系统自己会调用很多很多次，极大的影响了性能，还有网友遇到了其他的问题：替换了objectAtIndex方法有输入的地方出来了软键盘按手机Home键就Crash了。简直无解，最后，还是决定写个分类，虽然low一点，毕竟还是能解决我的问题，并且不会带来新的问题。</p>\n<h4 id=\"这是给NSArray添加的方法\"><a href=\"#这是给NSArray添加的方法\" class=\"headerlink\" title=\"这是给NSArray添加的方法\"></a>这是给NSArray添加的方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;NSArray+beyond.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation NSArray (beyond)</div><div class=\"line\">-(id)objectAtIndexCheck:(NSUInteger)index</div><div class=\"line\">&#123;</div><div class=\"line\">    if (index &lt; self.count) &#123;</div><div class=\"line\">        return [self objectAtIndex:index];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"这是给NSMutableArray添加的方法\"><a href=\"#这是给NSMutableArray添加的方法\" class=\"headerlink\" title=\"这是给NSMutableArray添加的方法\"></a>这是给NSMutableArray添加的方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;NSMutableArray+beyond.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation NSMutableArray (beyond)</div><div class=\"line\">-(id)objectAtIndexCheck:(NSUInteger)index</div><div class=\"line\">&#123;</div><div class=\"line\">    if (index &lt; self.count) &#123;</div><div class=\"line\">        return [self objectAtIndex:index];</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)addObjectCheck:(id)anObject</div><div class=\"line\">&#123;</div><div class=\"line\">    if (anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123;</div><div class=\"line\">        [self addObject:anObject];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)insertObjectCheck:(id)anObject atIndex:(NSUInteger)index</div><div class=\"line\">&#123;</div><div class=\"line\">    if (index &lt;= self.count &amp;&amp; anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123;</div><div class=\"line\">        [self insertObject:anObject atIndex:index];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)removeObjectAtIndexCheck:(NSUInteger)index</div><div class=\"line\">&#123;</div><div class=\"line\">    if (index &lt; self.count) &#123;</div><div class=\"line\">        [self removeObjectAtIndex:index];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)replaceObjectAtIndexCheck:(NSUInteger)index withObject:(id)anObject</div><div class=\"line\">&#123;</div><div class=\"line\">    if (index &lt; self.count &amp;&amp; anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123;</div><div class=\"line\">        [self replaceObjectAtIndex:index withObject:anObject];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n","excerpt":"<p>有时候项目中总是出现一些无法预知的情况，导致数组越界是程序crash，如果这种意外情况无法避免，那么只能从侧面采取保护措施。我先从网上找答案，我想其他人也肯定遇到过相同的情况，如果有好的解决方案，直接采用就可以了。但是实际上，网上搜索的结果令人有些失望。下面还是记录一下我自己的解决方案，以及和网上解决方案的差异。</p>\n<h3 id=\"crash的具体几种情况\"><a href=\"#crash的具体几种情况\" class=\"headerlink\" title=\"crash的具体几种情况\"></a>crash的具体几种情况</h3><ul>\n<li>取值：index超出array的索引范围</li>\n<li>添加：插入的object为nil或者Null</li>\n<li>插入：index大于count、插入的object为nil或者Null</li>\n<li>删除：index超出array的索引范围</li>\n<li>替换：index超出array的索引范围、替换的object为nil或者Null</li>\n</ul>\n<h3 id=\"解决思路\"><a href=\"#解决思路\" class=\"headerlink\" title=\"解决思路\"></a>解决思路</h3><p>任何代码都需要围绕”高内聚，低耦合”的思想来实现，尤其是这种工具类的代码，更是应该对原代码入侵越少越好。一个很容易想到的方法，就是采用runtime, 把array中的以上几种情况的方法替换成自己的方法，然后再执行方法的时候加以判断。而我在网上搜到的结果全是以这种方案解决的，不排除有更好的方法我没找到。附上一个我找到的代码比较详细的<a href=\"https://github.com/wanyakun/YKIntercepter\">demo</a>。我试了一下，效果是可以达到，不过我还是毫不犹豫的拒绝这种方式。直接替换了系统的方法必然会导致更多无法预知的问题。这些问题，我在后面会讲几个我遇到的。而我准备这样解决：<br>","more":"</p>\n<ul>\n<li><p>这是系统原本的调用方式<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E8%B6%8A%E7%95%8Ccrash/12.png\" alt=\"这是系统原本的调用方式\"></p>\n</li>\n<li><p>这是改变之后的调用方式<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E8%B6%8A%E7%95%8Ccrash/13.png\" alt=\"这是改变之后的调用方式\"></p>\n</li>\n</ul>\n<p>我是先勾住array自带的方法，进行判断，如果没有越界等几种情况，再继续执行它自身的方法，相当于在执行方法前多了一步判断，而网上是直接把方法替换成自己的方法了，这里还是有本质的区别。</p>\n<h3 id=\"具体实现原理\"><a href=\"#具体实现原理\" class=\"headerlink\" title=\"具体实现原理\"></a>具体实现原理</h3><p>这里举例说明 <code>NSArray</code> 的 <code>addObject:</code> 方法，其他也类似。</p>\n<h4 id=\"先定义一个静态变量\"><a href=\"#先定义一个静态变量\" class=\"headerlink\" title=\"先定义一个静态变量\"></a>先定义一个静态变量</h4><p><code>static IMP array_old_func_imap_object = NULL;</code><br>这个变量用来记录array自带方法的指针地址</p>\n<h4 id=\"获取方法，然后记录方法的指针地址\"><a href=\"#获取方法，然后记录方法的指针地址\" class=\"headerlink\" title=\"获取方法，然后记录方法的指针地址\"></a>获取方法，然后记录方法的指针地址</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method old_func_imap_object = class_getInstanceMethod(NSClassFromString(@&quot;__NSArrayI&quot;), @selector(objectAtIndex:));</div><div class=\"line\">            array_old_func_imap_object = method_getImplementation(old_func_imap_object);</div></pre></td></tr></table></figure>\n<h4 id=\"改变原方法的指针地址，并指向自定义方法\"><a href=\"#改变原方法的指针地址，并指向自定义方法\" class=\"headerlink\" title=\"改变原方法的指针地址，并指向自定义方法\"></a>改变原方法的指针地址，并指向自定义方法</h4><p><code>method_setImplementation(old_func_imap_object, [self methodForSelector:@selector(fm_objectAtIndex:)]);</code></p>\n<h4 id=\"自定义方法的实现\"><a href=\"#自定义方法的实现\" class=\"headerlink\" title=\"自定义方法的实现\"></a>自定义方法的实现</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (id)fm_objectAtIndex:(NSUInteger)index &#123;</div><div class=\"line\">    if (index &lt; [(NSArray*)self count]) &#123;</div><div class=\"line\">        return ((id(*)(id, SEL, NSUInteger))array_old_func_imap_object)(self, @selector(objectAtIndex:), index);</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;NArray objectAtIndex 失败--%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"最后一步\"><a href=\"#最后一步\" class=\"headerlink\" title=\"最后一步\"></a>最后一步</h4><p>到这里已经差不多完成了，就剩最后一个问题了，就是怎么运用到项目中，让这个工具类继承自NSObject，把这个工具类写成一个单例，然后在load方法中调用单例。load 方法会在本类第一次使用的时候调用一次，所以，把这个工具类拖到项目中，不用写其他代码，就实现了以上的功能。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (void)load &#123;</div><div class=\"line\">    [FMDetecter sharedInstance];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static dispatch_once_t onceToken;</div><div class=\"line\">static FMDetecter *sharedInstance;</div><div class=\"line\"></div><div class=\"line\">+ (instancetype)sharedInstance &#123;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        sharedInstance = [[FMDetecter alloc] init];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return sharedInstance;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里有完整的代码，有兴趣可查看<a href=\"https://github.com/suifengqjn/FMArrarMonitor\">demo</a></p>\n<h3 id=\"实际出现的问题\"><a href=\"#实际出现的问题\" class=\"headerlink\" title=\"实际出现的问题\"></a>实际出现的问题</h3><p>我用这两种方式都试了试，新建一个空项目，然后把上面几个方法都试一遍，似乎都没问题，然后我把他们公司的项目中，程序有时候卡死，还会crash，还是没法用，两种方式都有问题，找了找原因，发现NSArray和NSMutableArray的那几个方法，系统自己会调用很多很多次，极大的影响了性能，还有网友遇到了其他的问题：替换了objectAtIndex方法有输入的地方出来了软键盘按手机Home键就Crash了。简直无解，最后，还是决定写个分类，虽然low一点，毕竟还是能解决我的问题，并且不会带来新的问题。</p>\n<h4 id=\"这是给NSArray添加的方法\"><a href=\"#这是给NSArray添加的方法\" class=\"headerlink\" title=\"这是给NSArray添加的方法\"></a>这是给NSArray添加的方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;NSArray+beyond.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation NSArray (beyond)</div><div class=\"line\">-(id)objectAtIndexCheck:(NSUInteger)index</div><div class=\"line\">&#123;</div><div class=\"line\">    if (index &lt; self.count) &#123;</div><div class=\"line\">        return [self objectAtIndex:index];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"这是给NSMutableArray添加的方法\"><a href=\"#这是给NSMutableArray添加的方法\" class=\"headerlink\" title=\"这是给NSMutableArray添加的方法\"></a>这是给NSMutableArray添加的方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;NSMutableArray+beyond.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation NSMutableArray (beyond)</div><div class=\"line\">-(id)objectAtIndexCheck:(NSUInteger)index</div><div class=\"line\">&#123;</div><div class=\"line\">    if (index &lt; self.count) &#123;</div><div class=\"line\">        return [self objectAtIndex:index];</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)addObjectCheck:(id)anObject</div><div class=\"line\">&#123;</div><div class=\"line\">    if (anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123;</div><div class=\"line\">        [self addObject:anObject];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)insertObjectCheck:(id)anObject atIndex:(NSUInteger)index</div><div class=\"line\">&#123;</div><div class=\"line\">    if (index &lt;= self.count &amp;&amp; anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123;</div><div class=\"line\">        [self insertObject:anObject atIndex:index];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)removeObjectAtIndexCheck:(NSUInteger)index</div><div class=\"line\">&#123;</div><div class=\"line\">    if (index &lt; self.count) &#123;</div><div class=\"line\">        [self removeObjectAtIndex:index];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)replaceObjectAtIndexCheck:(NSUInteger)index withObject:(id)anObject</div><div class=\"line\">&#123;</div><div class=\"line\">    if (index &lt; self.count &amp;&amp; anObject != nil &amp;&amp; [anObject isKindOfClass:[NSNull class]] == NO) &#123;</div><div class=\"line\">        [self replaceObjectAtIndex:index withObject:anObject];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        NSLog(@&quot;%@&quot;, [NSThread callStackSymbols]);</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>"},{"title":"iOS缓存机制-非结构化存储","date":"2016-03-12T11:43:33.000Z","_content":"\n对于一个优秀的app来说，缓存机制必不可少。图片，视频，音频等等各种类型的文件，怎么样去更好的管理这些数据，这对于我们开发者以及用户都是息息相关的。闲话不多说，先来看看几个github开源中牛逼的几个缓存框架。\n\n它们的使用方式都很类似，都是通过键值对(key-value)的形式进行存取，跟`NSUserDefaults`用法类似。\n\n以下排名按照性能由低到高：\n### 1.EGOCache\n \n 只提供磁盘缓存，没有内存缓存，一个比较简易的缓存框架。\n\n### 2.TMCache\n \n 最初由 Tumblr 开发，但现在已经不再维护了。TMMemoryCache 实现有很多 NSCache 并没有提供的功能，比如数量限制、总容量限制、存活时间限制、内存警告或应用退到后台时清空缓存等。TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行。它错误的用了大量异步 block 回调来实现存取功能，以至于产生了很大的性能和死锁问题。它有磁盘缓存和内存缓存两部分组成，个人感觉一般好点的缓存库都会由磁盘缓存和内存缓存两部分组成，在我们第一次存储一个文件到磁盘的时候，缓存库会帮我们复制一份到内存缓存中，可以让我们在下次使用该文件的时候可以更快的找到。我上家公司就是用的这个缓存框架，挺好用的，也没出什么问题。\n \n### 3.PINCache \n \n 是 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的一个内存缓存。它的功能和接口基本和 TMCache 一样，但修复了性能和死锁的问题。它同样也用 dispatch_semaphore 来保证线程安全，但去掉了dispatch_barrier_async，避免了线程切换带来的巨大开销，也避免了可能的死锁。相当于是TMCache的优化版，而且一直有更新。\n \n<!-- more -->\n \n### 4.YYCache\n \n YYMemoryCache相对于 PINMemoryCache 来说，去掉了异步访问的接口，尽量优化了同步访问的性能，用 OSSpinLock 来保证线程安全。另外，缓存内部用双向链表和 NSDictionary 实现了 LRU 淘汰算法,性能好一点。TMDiskCache, PINDiskCache, SDWebImage 等缓存，都是基于文件系统的，即一个 Value 对应一个文件，通过文件读写来缓存数据。他们的实现都比较简单，性能也都相近，缺点也是同样的：不方便扩展、没有元数据、难以实现较好的淘汰算法、数据统计缓慢。YYDiskCache 也是采用的 SQLite 配合文件的存储方式，在 iPhone 6 64G 上的性能基准测试结果见下图。在存取小数据 (NSNumber) 时，YYDiskCache 的性能远远高出基于文件存储的库；而较大数据的存取性能则比较接近了。但得益于 SQLite 存储的元数据，YYDiskCache 实现了 LRU 淘汰算法、更快的数据统计，更多的容量控制选项。\n \n ![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/KVCahce/1.png)\n \n YYCache相比较与前面几个，性能是最好的一个，但是差距也不是太大，而且他的使用需要依赖库，个人感觉用PinCache就可以了。\n 下面是我通过PinCache改进的KVCache，在PinCahce的基础上增加了以下几个功能。\n \n ```\n 1. 可以设置缓存上限，设置一定时间内定时清理缓存\n 2. 增加缓存类型，jpg，MP4，MP3，gif，等自动保存相应类型\n 3. 增加缓存区块，不同模块的文件可以缓存到各自对应的区域\n 4. 以上所有参数都可以根据自己的需求自行设置\n ```\n [demo地址](https://github.com/suifengqjn/KVCache)\n \n [github Blog同步更新](http://gcblog.gtihub.io)\n \n\n\n","source":"_posts/iOS缓存机制-非结构化存储.md","raw":"---\ntitle: iOS缓存机制-非结构化存储\ndate: 2016-03-12 19:43:33\ntags: [iOS, 缓存, 性能]\ncategories: \n- iOS技术\n---\n\n对于一个优秀的app来说，缓存机制必不可少。图片，视频，音频等等各种类型的文件，怎么样去更好的管理这些数据，这对于我们开发者以及用户都是息息相关的。闲话不多说，先来看看几个github开源中牛逼的几个缓存框架。\n\n它们的使用方式都很类似，都是通过键值对(key-value)的形式进行存取，跟`NSUserDefaults`用法类似。\n\n以下排名按照性能由低到高：\n### 1.EGOCache\n \n 只提供磁盘缓存，没有内存缓存，一个比较简易的缓存框架。\n\n### 2.TMCache\n \n 最初由 Tumblr 开发，但现在已经不再维护了。TMMemoryCache 实现有很多 NSCache 并没有提供的功能，比如数量限制、总容量限制、存活时间限制、内存警告或应用退到后台时清空缓存等。TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行。它错误的用了大量异步 block 回调来实现存取功能，以至于产生了很大的性能和死锁问题。它有磁盘缓存和内存缓存两部分组成，个人感觉一般好点的缓存库都会由磁盘缓存和内存缓存两部分组成，在我们第一次存储一个文件到磁盘的时候，缓存库会帮我们复制一份到内存缓存中，可以让我们在下次使用该文件的时候可以更快的找到。我上家公司就是用的这个缓存框架，挺好用的，也没出什么问题。\n \n### 3.PINCache \n \n 是 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的一个内存缓存。它的功能和接口基本和 TMCache 一样，但修复了性能和死锁的问题。它同样也用 dispatch_semaphore 来保证线程安全，但去掉了dispatch_barrier_async，避免了线程切换带来的巨大开销，也避免了可能的死锁。相当于是TMCache的优化版，而且一直有更新。\n \n<!-- more -->\n \n### 4.YYCache\n \n YYMemoryCache相对于 PINMemoryCache 来说，去掉了异步访问的接口，尽量优化了同步访问的性能，用 OSSpinLock 来保证线程安全。另外，缓存内部用双向链表和 NSDictionary 实现了 LRU 淘汰算法,性能好一点。TMDiskCache, PINDiskCache, SDWebImage 等缓存，都是基于文件系统的，即一个 Value 对应一个文件，通过文件读写来缓存数据。他们的实现都比较简单，性能也都相近，缺点也是同样的：不方便扩展、没有元数据、难以实现较好的淘汰算法、数据统计缓慢。YYDiskCache 也是采用的 SQLite 配合文件的存储方式，在 iPhone 6 64G 上的性能基准测试结果见下图。在存取小数据 (NSNumber) 时，YYDiskCache 的性能远远高出基于文件存储的库；而较大数据的存取性能则比较接近了。但得益于 SQLite 存储的元数据，YYDiskCache 实现了 LRU 淘汰算法、更快的数据统计，更多的容量控制选项。\n \n ![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/KVCahce/1.png)\n \n YYCache相比较与前面几个，性能是最好的一个，但是差距也不是太大，而且他的使用需要依赖库，个人感觉用PinCache就可以了。\n 下面是我通过PinCache改进的KVCache，在PinCahce的基础上增加了以下几个功能。\n \n ```\n 1. 可以设置缓存上限，设置一定时间内定时清理缓存\n 2. 增加缓存类型，jpg，MP4，MP3，gif，等自动保存相应类型\n 3. 增加缓存区块，不同模块的文件可以缓存到各自对应的区域\n 4. 以上所有参数都可以根据自己的需求自行设置\n ```\n [demo地址](https://github.com/suifengqjn/KVCache)\n \n [github Blog同步更新](http://gcblog.gtihub.io)\n \n\n\n","slug":"iOS缓存机制-非结构化存储","published":1,"updated":"2016-11-17T15:00:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tej001olx60pn4gbqpt","content":"<p>对于一个优秀的app来说，缓存机制必不可少。图片，视频，音频等等各种类型的文件，怎么样去更好的管理这些数据，这对于我们开发者以及用户都是息息相关的。闲话不多说，先来看看几个github开源中牛逼的几个缓存框架。</p>\n<p>它们的使用方式都很类似，都是通过键值对(key-value)的形式进行存取，跟<code>NSUserDefaults</code>用法类似。</p>\n<p>以下排名按照性能由低到高：</p>\n<h3 id=\"1-EGOCache\"><a href=\"#1-EGOCache\" class=\"headerlink\" title=\"1.EGOCache\"></a>1.EGOCache</h3><p> 只提供磁盘缓存，没有内存缓存，一个比较简易的缓存框架。</p>\n<h3 id=\"2-TMCache\"><a href=\"#2-TMCache\" class=\"headerlink\" title=\"2.TMCache\"></a>2.TMCache</h3><p> 最初由 Tumblr 开发，但现在已经不再维护了。TMMemoryCache 实现有很多 NSCache 并没有提供的功能，比如数量限制、总容量限制、存活时间限制、内存警告或应用退到后台时清空缓存等。TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行。它错误的用了大量异步 block 回调来实现存取功能，以至于产生了很大的性能和死锁问题。它有磁盘缓存和内存缓存两部分组成，个人感觉一般好点的缓存库都会由磁盘缓存和内存缓存两部分组成，在我们第一次存储一个文件到磁盘的时候，缓存库会帮我们复制一份到内存缓存中，可以让我们在下次使用该文件的时候可以更快的找到。我上家公司就是用的这个缓存框架，挺好用的，也没出什么问题。</p>\n<h3 id=\"3-PINCache\"><a href=\"#3-PINCache\" class=\"headerlink\" title=\"3.PINCache\"></a>3.PINCache</h3><p> 是 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的一个内存缓存。它的功能和接口基本和 TMCache 一样，但修复了性能和死锁的问题。它同样也用 dispatch_semaphore 来保证线程安全，但去掉了dispatch_barrier_async，避免了线程切换带来的巨大开销，也避免了可能的死锁。相当于是TMCache的优化版，而且一直有更新。</p>\n<a id=\"more\"></a>\n<h3 id=\"4-YYCache\"><a href=\"#4-YYCache\" class=\"headerlink\" title=\"4.YYCache\"></a>4.YYCache</h3><p> YYMemoryCache相对于 PINMemoryCache 来说，去掉了异步访问的接口，尽量优化了同步访问的性能，用 OSSpinLock 来保证线程安全。另外，缓存内部用双向链表和 NSDictionary 实现了 LRU 淘汰算法,性能好一点。TMDiskCache, PINDiskCache, SDWebImage 等缓存，都是基于文件系统的，即一个 Value 对应一个文件，通过文件读写来缓存数据。他们的实现都比较简单，性能也都相近，缺点也是同样的：不方便扩展、没有元数据、难以实现较好的淘汰算法、数据统计缓慢。YYDiskCache 也是采用的 SQLite 配合文件的存储方式，在 iPhone 6 64G 上的性能基准测试结果见下图。在存取小数据 (NSNumber) 时，YYDiskCache 的性能远远高出基于文件存储的库；而较大数据的存取性能则比较接近了。但得益于 SQLite 存储的元数据，YYDiskCache 实现了 LRU 淘汰算法、更快的数据统计，更多的容量控制选项。</p>\n<p> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/KVCahce/1.png\" alt=\"image\"></p>\n<p> YYCache相比较与前面几个，性能是最好的一个，但是差距也不是太大，而且他的使用需要依赖库，个人感觉用PinCache就可以了。<br> 下面是我通过PinCache改进的KVCache，在PinCahce的基础上增加了以下几个功能。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 可以设置缓存上限，设置一定时间内定时清理缓存</div><div class=\"line\">2. 增加缓存类型，jpg，MP4，MP3，gif，等自动保存相应类型</div><div class=\"line\">3. 增加缓存区块，不同模块的文件可以缓存到各自对应的区域</div><div class=\"line\">4. 以上所有参数都可以根据自己的需求自行设置</div></pre></td></tr></table></figure>\n<p> <a href=\"https://github.com/suifengqjn/KVCache\" target=\"_blank\" rel=\"external\">demo地址</a></p>\n<p> <a href=\"http://gcblog.gtihub.io\" target=\"_blank\" rel=\"external\">github Blog同步更新</a></p>\n","excerpt":"<p>对于一个优秀的app来说，缓存机制必不可少。图片，视频，音频等等各种类型的文件，怎么样去更好的管理这些数据，这对于我们开发者以及用户都是息息相关的。闲话不多说，先来看看几个github开源中牛逼的几个缓存框架。</p>\n<p>它们的使用方式都很类似，都是通过键值对(key-value)的形式进行存取，跟<code>NSUserDefaults</code>用法类似。</p>\n<p>以下排名按照性能由低到高：</p>\n<h3 id=\"1-EGOCache\"><a href=\"#1-EGOCache\" class=\"headerlink\" title=\"1.EGOCache\"></a>1.EGOCache</h3><p> 只提供磁盘缓存，没有内存缓存，一个比较简易的缓存框架。</p>\n<h3 id=\"2-TMCache\"><a href=\"#2-TMCache\" class=\"headerlink\" title=\"2.TMCache\"></a>2.TMCache</h3><p> 最初由 Tumblr 开发，但现在已经不再维护了。TMMemoryCache 实现有很多 NSCache 并没有提供的功能，比如数量限制、总容量限制、存活时间限制、内存警告或应用退到后台时清空缓存等。TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行。它错误的用了大量异步 block 回调来实现存取功能，以至于产生了很大的性能和死锁问题。它有磁盘缓存和内存缓存两部分组成，个人感觉一般好点的缓存库都会由磁盘缓存和内存缓存两部分组成，在我们第一次存储一个文件到磁盘的时候，缓存库会帮我们复制一份到内存缓存中，可以让我们在下次使用该文件的时候可以更快的找到。我上家公司就是用的这个缓存框架，挺好用的，也没出什么问题。</p>\n<h3 id=\"3-PINCache\"><a href=\"#3-PINCache\" class=\"headerlink\" title=\"3.PINCache\"></a>3.PINCache</h3><p> 是 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的一个内存缓存。它的功能和接口基本和 TMCache 一样，但修复了性能和死锁的问题。它同样也用 dispatch_semaphore 来保证线程安全，但去掉了dispatch_barrier_async，避免了线程切换带来的巨大开销，也避免了可能的死锁。相当于是TMCache的优化版，而且一直有更新。</p>","more":"<h3 id=\"4-YYCache\"><a href=\"#4-YYCache\" class=\"headerlink\" title=\"4.YYCache\"></a>4.YYCache</h3><p> YYMemoryCache相对于 PINMemoryCache 来说，去掉了异步访问的接口，尽量优化了同步访问的性能，用 OSSpinLock 来保证线程安全。另外，缓存内部用双向链表和 NSDictionary 实现了 LRU 淘汰算法,性能好一点。TMDiskCache, PINDiskCache, SDWebImage 等缓存，都是基于文件系统的，即一个 Value 对应一个文件，通过文件读写来缓存数据。他们的实现都比较简单，性能也都相近，缺点也是同样的：不方便扩展、没有元数据、难以实现较好的淘汰算法、数据统计缓慢。YYDiskCache 也是采用的 SQLite 配合文件的存储方式，在 iPhone 6 64G 上的性能基准测试结果见下图。在存取小数据 (NSNumber) 时，YYDiskCache 的性能远远高出基于文件存储的库；而较大数据的存取性能则比较接近了。但得益于 SQLite 存储的元数据，YYDiskCache 实现了 LRU 淘汰算法、更快的数据统计，更多的容量控制选项。</p>\n<p> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/KVCahce/1.png\" alt=\"image\"></p>\n<p> YYCache相比较与前面几个，性能是最好的一个，但是差距也不是太大，而且他的使用需要依赖库，个人感觉用PinCache就可以了。<br> 下面是我通过PinCache改进的KVCache，在PinCahce的基础上增加了以下几个功能。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 可以设置缓存上限，设置一定时间内定时清理缓存</div><div class=\"line\">2. 增加缓存类型，jpg，MP4，MP3，gif，等自动保存相应类型</div><div class=\"line\">3. 增加缓存区块，不同模块的文件可以缓存到各自对应的区域</div><div class=\"line\">4. 以上所有参数都可以根据自己的需求自行设置</div></pre></td></tr></table></figure>\n<p> <a href=\"https://github.com/suifengqjn/KVCache\">demo地址</a></p>\n<p> <a href=\"http://gcblog.gtihub.io\">github Blog同步更新</a></p>"},{"title":"iOS视频边下边播--缓存视频数据流","date":"2016-02-25T08:01:50.000Z","_content":"\ngoogle搜索“iOS视频变下边播”，有好几篇博客写到了实现方法，其实只有一篇，其他都是copy的，不过他们都是使用的本地代理服务器的方式，原理很简单，但是缺点也很明显，需要自己写一个本地代理服务器或者使用第三方库httpSever。如果使用httpSever作为本地代理服务器，如果只缓存一个视频是没有问题的，如果缓存多个视频互相切换，本地代理服务器提供的数据很不稳定，crash概率非常大。\n***\n\n这里我采用ios7以后系统自带的方法实现视频边下边播，这里的边下边播不是单独开一个子线程去下载，而是把视频播放的数据给保存到本地。简而言之，就是使用一遍的流量，既播放了视频，也保存了视频。\n\n```\n用到的框架：<AVFoundation/AVFoundation.h>\n\n用到的播放器：AVplayer\n```\n\n先说一下avplayer自身的播放原理，当我们给播放器设置好url等一些参数后，播放器就会向url所在的服务器发送请求(请求参数有两个值，一个是offset偏移量，另一个是length长度，其实就相当于NSRange一样)，服务器就根据range参数给播放器返回数据。这就是大致的原理，当然实际的过程还是略微比较复杂。\n***\n\n</br>\n\n### 一:下面进入主题\n#### 产品需求：\n - 1.支持正常播放器的一切功能，包括暂停、播放和拖拽\n - 2.如果视频加载完成且完整，将视频文件保存到本地cache，下一次播放本地cache中的视频，不再请求网络数据\n - 3.如果视频没有加载完（半路关闭或者拖拽）就不用保存到本地cache\n \n<!-- more -->\n\n#### 实现方案:\n\n - 需要在视频播放器和服务器之间添加一层类似代理的机制，视频播放器不再直接访问服务器，而是访问代理对象，代理对象去访问服务器获得数据，之后返回给视频播放器，同时代理对象根据一定的策略缓存数据。\n\n- 2.AVURLAsset中的resourceLoader可以实现这个机制，resourceLoader的delegate就是上述的代理对象。\n\n- 3.视频播放器在开始播放之前首先检测是本地cache中是否有此视频，如果没有才通过代理获得数据，如果有，则直接播放本地cache中的视频即可。\n\n#### 视频播放器需要实现的功能\n\n - 1.有开始暂停按钮\n\n - 2.显示播放进度及总时长\n\n - 3.可以通过拖拽从任意位置开始播放视频\n\n - 4.视频加载中的过程和加载失败需要有相应的提示\n\n#### 代理对象需要实现的功能\n\n - 1.接收视频播放器的请求，并根据请求的range向服务器请求本地没有获得的数据\n\n - 2.缓存向服务器请求回的数据到本地\n\n - 3.如果向服务器的请求出现错误，需要通知给视频播放器，以便视频播放器对用户进行提示\n\t\n\t\n### 二：具体流程\n\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/TBPlayer/1.png)\n\n\n#### 视频播放器处理流程\n\n - 1.当开始播放视频时，通过视频url判断本地cache中是否已经缓存当前视频，如果有，则直接播放本地cache中视频\n\n - 2.如果本地cache中没有视频，则视频播放器向代理请求数据\n\n - 3.加载视频时展示正在加载的提示（菊花转）\n\n - 4.如果可以正常播放视频，则去掉加载提示，播放视频，如果加载失败，去掉加载提示并显示失败提示\n\n - 5.在播放过程中如果由于网络过慢或拖拽原因导致没有播放数据时，要展示加载提示，跳转到第4步\n\n#### 代理对象处理流程\n\n - 1.当视频播放器向代理请求dataRequest时，判断代理是否已经向服务器发起了请求，如果没有，则发起下载整个视频文件的请求\n\n - 2.如果代理已经和服务器建立链接，则判断当前的dataRequest请求的offset是否大于当前已经缓存的文件的offset，如果大于则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向后拖拽，并且超过了已缓存的数据时才会出现）\n\n - 3.如果当前的dataRequest请求的offset小于已经缓存的文件的offset，同时大于代理向服务器请求的range的offset，说明有一部分已经缓存的数据可以传给播放器，则将这部分数据返回给播放器（此时应该是由于播放器向前拖拽，请求的数据已经缓存过才会出现）\n\n - 4.如果当前的dataRequest请求的offset小于代理向服务器请求的range的offset，则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向前拖拽，并且超过了已缓存的数据时才会出现）\n\n - 5.只要代理重新向服务器发起请求，就会导致缓存的数据不连续，则加载结束后不用将缓存的数据放入本地cache\n\n - 6.如果代理和服务器的链接超时，重试一次，如果还是错误则通知播放器网络错误\n\n - 7.如果服务器返回其他错误，则代理通知播放器网络错误\n\n### 三：resourceLoader的难点处理\n```\n- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest\n{\n    [self.pendingRequests addObject:loadingRequest];\n    [self dealWithLoadingRequest:loadingRequest];\n    \n    return YES;\n}\n```\n播放器发出的数据请求从这里开始，我们保存从这里发出的所有请求存放到数组，自己来处理这些请求，当一个请求完成后，对请求发出finishLoading消息，并从数组中移除。正常状态下，当播放器发出下一个请求的时候，会把上一个请求给finish。\n\n下面这个方法发出的请求说明播放器自己关闭了这个请求，我们不需要再对这个请求进行处理，系统每次结束一个旧的请求，便必然会发出一个或多个新的请求，除了播放器已经获得整个视频完整的数据，这时候就不会再发起请求。\n\n```\n- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest\n{\n    [self.pendingRequests removeObject:loadingRequest];\n    \n}\n```\n下面这个方法是对播放器发出的请求进行填充数据\n\n```\n- (BOOL)respondWithDataForRequest:(AVAssetResourceLoadingDataRequest *)dataRequest\n{\n    long long startOffset = dataRequest.requestedOffset;\n\n    if (dataRequest.currentOffset != 0) {\n        startOffset = dataRequest.currentOffset;\n    }\n    \n    if ((self.task.offset +self.task.downLoadingOffset) < startOffset)\n    {\n        //NSLog(@\"NO DATA FOR REQUEST\");\n        return NO;\n    }\n    \n    if (startOffset < self.task.offset) {\n        return NO;\n    }\n    \n    NSData *filedata = [NSData dataWithContentsOfURL:[NSURL fileURLWithPath:_videoPath] options:NSDataReadingMappedIfSafe error:nil];\n    \n    // This is the total data we have from startOffset to whatever has been downloaded so far\n    NSUInteger unreadBytes = self.task.downLoadingOffset - ((NSInteger)startOffset - self.task.offset);\n    \n    // Respond with whatever is available if we can't satisfy the request fully yet\n    NSUInteger numberOfBytesToRespondWith = MIN((NSUInteger)dataRequest.requestedLength, unreadBytes);\n    \n    \n    [dataRequest respondWithData:[filedata subdataWithRange:NSMakeRange((NSUInteger)startOffset- self.task.offset, (NSUInteger)numberOfBytesToRespondWith)]];\n    \n    \n    \n    long long endOffset = startOffset + dataRequest.requestedLength;\n    BOOL didRespondFully = (self.task.offset + self.task.downLoadingOffset) >= endOffset;\n\n    return didRespondFully;\n  \n    \n}\n```\n\n这是对存放所有的请求的数组进行处理\n\n```\n- (void)processPendingRequests\n{\n    NSMutableArray *requestsCompleted = [NSMutableArray array];  //请求完成的数组\n    //每次下载一块数据都是一次请求，把这些请求放到数组，遍历数组\n    for (AVAssetResourceLoadingRequest *loadingRequest in self.pendingRequests)\n    {\n        [self fillInContentInformation:loadingRequest.contentInformationRequest]; //对每次请求加上长度，文件类型等信息\n        \n        BOOL didRespondCompletely = [self respondWithDataForRequest:loadingRequest.dataRequest]; //判断此次请求的数据是否处理完全\n        \n        if (didRespondCompletely) {\n\n            [requestsCompleted addObject:loadingRequest];  //如果完整，把此次请求放进 请求完成的数组\n            [loadingRequest finishLoading];\n            \n        }\n    }\n\n    [self.pendingRequests removeObjectsInArray:requestsCompleted];   //在所有请求的数组中移除已经完成的\n    \n}\n```\nresourceLoader的难点基本上就是上面这点了，说到播放器，下面便顺便讲下AVPlayer的难点。\n\n### 四：难点：对播放器状态的捕获\n- 1.举个简单的例子，视频总长度60分，现在缓冲的数据才10分钟，然后拖动到20分钟的位置进行播放，在网速较慢的时候，视频从当前位置开始播放，必然会出现一段时间的卡顿，为了有一个更好的用户体验，在卡顿的时候，我们需要加一个菊花转的状态，现在问题就来了。\n\n\n- 2.在拖动到未缓冲区域内，是否需要加菊花转，如果加，要显示多久再消失，而且如果在网速很慢的时候，播放器如果等了太久，哪怕最后有数据了，播放器也已经“死”了，它自己无法恢复播放，这个时候需要我们人为的去恢复播放，如果恢复播放不成功，那么过一段时间需要再次恢复播放，是否恢复播放成功，这里也需要捕获其状态。所以，如果要有一个好的用户体验，我们需要时时知道播放器的状态。\n\n有两个状态需要捕获，一个是正在缓冲，一个是正在播放，监听播放的“playbackBufferEmpty”属性就可以捕获正在缓冲状态，播放器的时间监听器则可以捕获正在播放状态，我的demo中一共有4个状态：\n\n```\ntypedef NS_ENUM(NSInteger, TBPlayerState) {\n    TBPlayerStateBuffering = 1,\n    TBPlayerStatePlaying   = 2,\n    TBPlayerStateStopped   = 3,\n    TBPlayerStatePause     = 4\n};\n```\n这样可以对播放器更好的把握和处理了。\n然后说一说在缓冲时候的处理，以及缓冲后多久去播放，处理方法：\n进入缓冲状态后，缓冲2秒后去手动播放，如果播放不成功（缓冲的数据太少，还不足以播放），那就再缓冲2秒再次播放，如此循环，看详细代码：\n\n```\n- (void)bufferingSomeSecond\n{\n    // playbackBufferEmpty会反复进入，因此在bufferingOneSecond延时播放执行完之前再调用bufferingSomeSecond都忽略\n    static BOOL isBuffering = NO;\n    if (isBuffering) {\n        return;\n    }\n    isBuffering = YES;\n    \n    // 需要先暂停一小会之后再播放，否则网络状况不好的时候时间在走，声音播放不出来\n    [self.player pause];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        \n        // 如果此时用户已经暂停了，则不再需要开启播放了\n        if (self.isPauseByUser) {\n            isBuffering = NO;\n            return;\n        }\n        \n        [self.player play];\n        // 如果执行了play还是没有播放则说明还没有缓存好，则再次缓存一段时间\n        isBuffering = NO;\n        if (!self.currentPlayerItem.isPlaybackLikelyToKeepUp) {\n            [self bufferingSomeSecond];\n        }\n    });\n}\n```\n这个demo花了我很长的时间，实现这个demo我也遇到了很多坑最后才完成的，现在我奉献出来，也许对你会有所帮助。如果你觉得不错，还请为我Star一个，也算是对我的支持和鼓励。\n\n[demo下载地址](https://github.com/suifengqjn/TBPlayer)\n也可以去我的简书博客查看更多文章\n[博客地址](http://www.jianshu.com/users/527ecf8c8753/latest_articles)\n","source":"_posts/iOS视频边下边播-缓存视频数据流.md","raw":"---\ntitle: iOS视频边下边播--缓存视频数据流\ndate: 2016-02-25 16:01:50\ntags: [iOS, AVplayer]\ncategories: \n- iOS技术\n---\n\ngoogle搜索“iOS视频变下边播”，有好几篇博客写到了实现方法，其实只有一篇，其他都是copy的，不过他们都是使用的本地代理服务器的方式，原理很简单，但是缺点也很明显，需要自己写一个本地代理服务器或者使用第三方库httpSever。如果使用httpSever作为本地代理服务器，如果只缓存一个视频是没有问题的，如果缓存多个视频互相切换，本地代理服务器提供的数据很不稳定，crash概率非常大。\n***\n\n这里我采用ios7以后系统自带的方法实现视频边下边播，这里的边下边播不是单独开一个子线程去下载，而是把视频播放的数据给保存到本地。简而言之，就是使用一遍的流量，既播放了视频，也保存了视频。\n\n```\n用到的框架：<AVFoundation/AVFoundation.h>\n\n用到的播放器：AVplayer\n```\n\n先说一下avplayer自身的播放原理，当我们给播放器设置好url等一些参数后，播放器就会向url所在的服务器发送请求(请求参数有两个值，一个是offset偏移量，另一个是length长度，其实就相当于NSRange一样)，服务器就根据range参数给播放器返回数据。这就是大致的原理，当然实际的过程还是略微比较复杂。\n***\n\n</br>\n\n### 一:下面进入主题\n#### 产品需求：\n - 1.支持正常播放器的一切功能，包括暂停、播放和拖拽\n - 2.如果视频加载完成且完整，将视频文件保存到本地cache，下一次播放本地cache中的视频，不再请求网络数据\n - 3.如果视频没有加载完（半路关闭或者拖拽）就不用保存到本地cache\n \n<!-- more -->\n\n#### 实现方案:\n\n - 需要在视频播放器和服务器之间添加一层类似代理的机制，视频播放器不再直接访问服务器，而是访问代理对象，代理对象去访问服务器获得数据，之后返回给视频播放器，同时代理对象根据一定的策略缓存数据。\n\n- 2.AVURLAsset中的resourceLoader可以实现这个机制，resourceLoader的delegate就是上述的代理对象。\n\n- 3.视频播放器在开始播放之前首先检测是本地cache中是否有此视频，如果没有才通过代理获得数据，如果有，则直接播放本地cache中的视频即可。\n\n#### 视频播放器需要实现的功能\n\n - 1.有开始暂停按钮\n\n - 2.显示播放进度及总时长\n\n - 3.可以通过拖拽从任意位置开始播放视频\n\n - 4.视频加载中的过程和加载失败需要有相应的提示\n\n#### 代理对象需要实现的功能\n\n - 1.接收视频播放器的请求，并根据请求的range向服务器请求本地没有获得的数据\n\n - 2.缓存向服务器请求回的数据到本地\n\n - 3.如果向服务器的请求出现错误，需要通知给视频播放器，以便视频播放器对用户进行提示\n\t\n\t\n### 二：具体流程\n\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/TBPlayer/1.png)\n\n\n#### 视频播放器处理流程\n\n - 1.当开始播放视频时，通过视频url判断本地cache中是否已经缓存当前视频，如果有，则直接播放本地cache中视频\n\n - 2.如果本地cache中没有视频，则视频播放器向代理请求数据\n\n - 3.加载视频时展示正在加载的提示（菊花转）\n\n - 4.如果可以正常播放视频，则去掉加载提示，播放视频，如果加载失败，去掉加载提示并显示失败提示\n\n - 5.在播放过程中如果由于网络过慢或拖拽原因导致没有播放数据时，要展示加载提示，跳转到第4步\n\n#### 代理对象处理流程\n\n - 1.当视频播放器向代理请求dataRequest时，判断代理是否已经向服务器发起了请求，如果没有，则发起下载整个视频文件的请求\n\n - 2.如果代理已经和服务器建立链接，则判断当前的dataRequest请求的offset是否大于当前已经缓存的文件的offset，如果大于则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向后拖拽，并且超过了已缓存的数据时才会出现）\n\n - 3.如果当前的dataRequest请求的offset小于已经缓存的文件的offset，同时大于代理向服务器请求的range的offset，说明有一部分已经缓存的数据可以传给播放器，则将这部分数据返回给播放器（此时应该是由于播放器向前拖拽，请求的数据已经缓存过才会出现）\n\n - 4.如果当前的dataRequest请求的offset小于代理向服务器请求的range的offset，则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向前拖拽，并且超过了已缓存的数据时才会出现）\n\n - 5.只要代理重新向服务器发起请求，就会导致缓存的数据不连续，则加载结束后不用将缓存的数据放入本地cache\n\n - 6.如果代理和服务器的链接超时，重试一次，如果还是错误则通知播放器网络错误\n\n - 7.如果服务器返回其他错误，则代理通知播放器网络错误\n\n### 三：resourceLoader的难点处理\n```\n- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest\n{\n    [self.pendingRequests addObject:loadingRequest];\n    [self dealWithLoadingRequest:loadingRequest];\n    \n    return YES;\n}\n```\n播放器发出的数据请求从这里开始，我们保存从这里发出的所有请求存放到数组，自己来处理这些请求，当一个请求完成后，对请求发出finishLoading消息，并从数组中移除。正常状态下，当播放器发出下一个请求的时候，会把上一个请求给finish。\n\n下面这个方法发出的请求说明播放器自己关闭了这个请求，我们不需要再对这个请求进行处理，系统每次结束一个旧的请求，便必然会发出一个或多个新的请求，除了播放器已经获得整个视频完整的数据，这时候就不会再发起请求。\n\n```\n- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest\n{\n    [self.pendingRequests removeObject:loadingRequest];\n    \n}\n```\n下面这个方法是对播放器发出的请求进行填充数据\n\n```\n- (BOOL)respondWithDataForRequest:(AVAssetResourceLoadingDataRequest *)dataRequest\n{\n    long long startOffset = dataRequest.requestedOffset;\n\n    if (dataRequest.currentOffset != 0) {\n        startOffset = dataRequest.currentOffset;\n    }\n    \n    if ((self.task.offset +self.task.downLoadingOffset) < startOffset)\n    {\n        //NSLog(@\"NO DATA FOR REQUEST\");\n        return NO;\n    }\n    \n    if (startOffset < self.task.offset) {\n        return NO;\n    }\n    \n    NSData *filedata = [NSData dataWithContentsOfURL:[NSURL fileURLWithPath:_videoPath] options:NSDataReadingMappedIfSafe error:nil];\n    \n    // This is the total data we have from startOffset to whatever has been downloaded so far\n    NSUInteger unreadBytes = self.task.downLoadingOffset - ((NSInteger)startOffset - self.task.offset);\n    \n    // Respond with whatever is available if we can't satisfy the request fully yet\n    NSUInteger numberOfBytesToRespondWith = MIN((NSUInteger)dataRequest.requestedLength, unreadBytes);\n    \n    \n    [dataRequest respondWithData:[filedata subdataWithRange:NSMakeRange((NSUInteger)startOffset- self.task.offset, (NSUInteger)numberOfBytesToRespondWith)]];\n    \n    \n    \n    long long endOffset = startOffset + dataRequest.requestedLength;\n    BOOL didRespondFully = (self.task.offset + self.task.downLoadingOffset) >= endOffset;\n\n    return didRespondFully;\n  \n    \n}\n```\n\n这是对存放所有的请求的数组进行处理\n\n```\n- (void)processPendingRequests\n{\n    NSMutableArray *requestsCompleted = [NSMutableArray array];  //请求完成的数组\n    //每次下载一块数据都是一次请求，把这些请求放到数组，遍历数组\n    for (AVAssetResourceLoadingRequest *loadingRequest in self.pendingRequests)\n    {\n        [self fillInContentInformation:loadingRequest.contentInformationRequest]; //对每次请求加上长度，文件类型等信息\n        \n        BOOL didRespondCompletely = [self respondWithDataForRequest:loadingRequest.dataRequest]; //判断此次请求的数据是否处理完全\n        \n        if (didRespondCompletely) {\n\n            [requestsCompleted addObject:loadingRequest];  //如果完整，把此次请求放进 请求完成的数组\n            [loadingRequest finishLoading];\n            \n        }\n    }\n\n    [self.pendingRequests removeObjectsInArray:requestsCompleted];   //在所有请求的数组中移除已经完成的\n    \n}\n```\nresourceLoader的难点基本上就是上面这点了，说到播放器，下面便顺便讲下AVPlayer的难点。\n\n### 四：难点：对播放器状态的捕获\n- 1.举个简单的例子，视频总长度60分，现在缓冲的数据才10分钟，然后拖动到20分钟的位置进行播放，在网速较慢的时候，视频从当前位置开始播放，必然会出现一段时间的卡顿，为了有一个更好的用户体验，在卡顿的时候，我们需要加一个菊花转的状态，现在问题就来了。\n\n\n- 2.在拖动到未缓冲区域内，是否需要加菊花转，如果加，要显示多久再消失，而且如果在网速很慢的时候，播放器如果等了太久，哪怕最后有数据了，播放器也已经“死”了，它自己无法恢复播放，这个时候需要我们人为的去恢复播放，如果恢复播放不成功，那么过一段时间需要再次恢复播放，是否恢复播放成功，这里也需要捕获其状态。所以，如果要有一个好的用户体验，我们需要时时知道播放器的状态。\n\n有两个状态需要捕获，一个是正在缓冲，一个是正在播放，监听播放的“playbackBufferEmpty”属性就可以捕获正在缓冲状态，播放器的时间监听器则可以捕获正在播放状态，我的demo中一共有4个状态：\n\n```\ntypedef NS_ENUM(NSInteger, TBPlayerState) {\n    TBPlayerStateBuffering = 1,\n    TBPlayerStatePlaying   = 2,\n    TBPlayerStateStopped   = 3,\n    TBPlayerStatePause     = 4\n};\n```\n这样可以对播放器更好的把握和处理了。\n然后说一说在缓冲时候的处理，以及缓冲后多久去播放，处理方法：\n进入缓冲状态后，缓冲2秒后去手动播放，如果播放不成功（缓冲的数据太少，还不足以播放），那就再缓冲2秒再次播放，如此循环，看详细代码：\n\n```\n- (void)bufferingSomeSecond\n{\n    // playbackBufferEmpty会反复进入，因此在bufferingOneSecond延时播放执行完之前再调用bufferingSomeSecond都忽略\n    static BOOL isBuffering = NO;\n    if (isBuffering) {\n        return;\n    }\n    isBuffering = YES;\n    \n    // 需要先暂停一小会之后再播放，否则网络状况不好的时候时间在走，声音播放不出来\n    [self.player pause];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        \n        // 如果此时用户已经暂停了，则不再需要开启播放了\n        if (self.isPauseByUser) {\n            isBuffering = NO;\n            return;\n        }\n        \n        [self.player play];\n        // 如果执行了play还是没有播放则说明还没有缓存好，则再次缓存一段时间\n        isBuffering = NO;\n        if (!self.currentPlayerItem.isPlaybackLikelyToKeepUp) {\n            [self bufferingSomeSecond];\n        }\n    });\n}\n```\n这个demo花了我很长的时间，实现这个demo我也遇到了很多坑最后才完成的，现在我奉献出来，也许对你会有所帮助。如果你觉得不错，还请为我Star一个，也算是对我的支持和鼓励。\n\n[demo下载地址](https://github.com/suifengqjn/TBPlayer)\n也可以去我的简书博客查看更多文章\n[博客地址](http://www.jianshu.com/users/527ecf8c8753/latest_articles)\n","slug":"iOS视频边下边播-缓存视频数据流","published":1,"updated":"2016-11-17T14:59:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tek001rlx60j706nmxc","content":"<p>google搜索“iOS视频变下边播”，有好几篇博客写到了实现方法，其实只有一篇，其他都是copy的，不过他们都是使用的本地代理服务器的方式，原理很简单，但是缺点也很明显，需要自己写一个本地代理服务器或者使用第三方库httpSever。如果使用httpSever作为本地代理服务器，如果只缓存一个视频是没有问题的，如果缓存多个视频互相切换，本地代理服务器提供的数据很不稳定，crash概率非常大。</p>\n<hr>\n<p>这里我采用ios7以后系统自带的方法实现视频边下边播，这里的边下边播不是单独开一个子线程去下载，而是把视频播放的数据给保存到本地。简而言之，就是使用一遍的流量，既播放了视频，也保存了视频。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">用到的框架：&lt;AVFoundation/AVFoundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">用到的播放器：AVplayer</div></pre></td></tr></table></figure>\n<p>先说一下avplayer自身的播放原理，当我们给播放器设置好url等一些参数后，播放器就会向url所在的服务器发送请求(请求参数有两个值，一个是offset偏移量，另一个是length长度，其实就相当于NSRange一样)，服务器就根据range参数给播放器返回数据。这就是大致的原理，当然实际的过程还是略微比较复杂。</p>\n<hr>\n<p><br></p>\n<h3 id=\"一-下面进入主题\"><a href=\"#一-下面进入主题\" class=\"headerlink\" title=\"一:下面进入主题\"></a>一:下面进入主题</h3><h4 id=\"产品需求：\"><a href=\"#产品需求：\" class=\"headerlink\" title=\"产品需求：\"></a>产品需求：</h4><ul>\n<li>1.支持正常播放器的一切功能，包括暂停、播放和拖拽</li>\n<li>2.如果视频加载完成且完整，将视频文件保存到本地cache，下一次播放本地cache中的视频，不再请求网络数据</li>\n<li>3.如果视频没有加载完（半路关闭或者拖拽）就不用保存到本地cache</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案:\"></a>实现方案:</h4><ul>\n<li>需要在视频播放器和服务器之间添加一层类似代理的机制，视频播放器不再直接访问服务器，而是访问代理对象，代理对象去访问服务器获得数据，之后返回给视频播放器，同时代理对象根据一定的策略缓存数据。</li>\n</ul>\n<ul>\n<li><p>2.AVURLAsset中的resourceLoader可以实现这个机制，resourceLoader的delegate就是上述的代理对象。</p>\n</li>\n<li><p>3.视频播放器在开始播放之前首先检测是本地cache中是否有此视频，如果没有才通过代理获得数据，如果有，则直接播放本地cache中的视频即可。</p>\n</li>\n</ul>\n<h4 id=\"视频播放器需要实现的功能\"><a href=\"#视频播放器需要实现的功能\" class=\"headerlink\" title=\"视频播放器需要实现的功能\"></a>视频播放器需要实现的功能</h4><ul>\n<li><p>1.有开始暂停按钮</p>\n</li>\n<li><p>2.显示播放进度及总时长</p>\n</li>\n<li><p>3.可以通过拖拽从任意位置开始播放视频</p>\n</li>\n<li><p>4.视频加载中的过程和加载失败需要有相应的提示</p>\n</li>\n</ul>\n<h4 id=\"代理对象需要实现的功能\"><a href=\"#代理对象需要实现的功能\" class=\"headerlink\" title=\"代理对象需要实现的功能\"></a>代理对象需要实现的功能</h4><ul>\n<li><p>1.接收视频播放器的请求，并根据请求的range向服务器请求本地没有获得的数据</p>\n</li>\n<li><p>2.缓存向服务器请求回的数据到本地</p>\n</li>\n<li><p>3.如果向服务器的请求出现错误，需要通知给视频播放器，以便视频播放器对用户进行提示</p>\n</li>\n</ul>\n<h3 id=\"二：具体流程\"><a href=\"#二：具体流程\" class=\"headerlink\" title=\"二：具体流程\"></a>二：具体流程</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/TBPlayer/1.png\" alt=\"image\"></p>\n<h4 id=\"视频播放器处理流程\"><a href=\"#视频播放器处理流程\" class=\"headerlink\" title=\"视频播放器处理流程\"></a>视频播放器处理流程</h4><ul>\n<li><p>1.当开始播放视频时，通过视频url判断本地cache中是否已经缓存当前视频，如果有，则直接播放本地cache中视频</p>\n</li>\n<li><p>2.如果本地cache中没有视频，则视频播放器向代理请求数据</p>\n</li>\n<li><p>3.加载视频时展示正在加载的提示（菊花转）</p>\n</li>\n<li><p>4.如果可以正常播放视频，则去掉加载提示，播放视频，如果加载失败，去掉加载提示并显示失败提示</p>\n</li>\n<li><p>5.在播放过程中如果由于网络过慢或拖拽原因导致没有播放数据时，要展示加载提示，跳转到第4步</p>\n</li>\n</ul>\n<h4 id=\"代理对象处理流程\"><a href=\"#代理对象处理流程\" class=\"headerlink\" title=\"代理对象处理流程\"></a>代理对象处理流程</h4><ul>\n<li><p>1.当视频播放器向代理请求dataRequest时，判断代理是否已经向服务器发起了请求，如果没有，则发起下载整个视频文件的请求</p>\n</li>\n<li><p>2.如果代理已经和服务器建立链接，则判断当前的dataRequest请求的offset是否大于当前已经缓存的文件的offset，如果大于则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向后拖拽，并且超过了已缓存的数据时才会出现）</p>\n</li>\n<li><p>3.如果当前的dataRequest请求的offset小于已经缓存的文件的offset，同时大于代理向服务器请求的range的offset，说明有一部分已经缓存的数据可以传给播放器，则将这部分数据返回给播放器（此时应该是由于播放器向前拖拽，请求的数据已经缓存过才会出现）</p>\n</li>\n<li><p>4.如果当前的dataRequest请求的offset小于代理向服务器请求的range的offset，则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向前拖拽，并且超过了已缓存的数据时才会出现）</p>\n</li>\n<li><p>5.只要代理重新向服务器发起请求，就会导致缓存的数据不连续，则加载结束后不用将缓存的数据放入本地cache</p>\n</li>\n<li><p>6.如果代理和服务器的链接超时，重试一次，如果还是错误则通知播放器网络错误</p>\n</li>\n<li><p>7.如果服务器返回其他错误，则代理通知播放器网络错误</p>\n</li>\n</ul>\n<h3 id=\"三：resourceLoader的难点处理\"><a href=\"#三：resourceLoader的难点处理\" class=\"headerlink\" title=\"三：resourceLoader的难点处理\"></a>三：resourceLoader的难点处理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.pendingRequests addObject:loadingRequest];</div><div class=\"line\">    [self dealWithLoadingRequest:loadingRequest];</div><div class=\"line\">    </div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>播放器发出的数据请求从这里开始，我们保存从这里发出的所有请求存放到数组，自己来处理这些请求，当一个请求完成后，对请求发出finishLoading消息，并从数组中移除。正常状态下，当播放器发出下一个请求的时候，会把上一个请求给finish。</p>\n<p>下面这个方法发出的请求说明播放器自己关闭了这个请求，我们不需要再对这个请求进行处理，系统每次结束一个旧的请求，便必然会发出一个或多个新的请求，除了播放器已经获得整个视频完整的数据，这时候就不会再发起请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.pendingRequests removeObject:loadingRequest];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面这个方法是对播放器发出的请求进行填充数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)respondWithDataForRequest:(AVAssetResourceLoadingDataRequest *)dataRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    long long startOffset = dataRequest.requestedOffset;</div><div class=\"line\"></div><div class=\"line\">    if (dataRequest.currentOffset != 0) &#123;</div><div class=\"line\">        startOffset = dataRequest.currentOffset;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if ((self.task.offset +self.task.downLoadingOffset) &lt; startOffset)</div><div class=\"line\">    &#123;</div><div class=\"line\">        //NSLog(@&quot;NO DATA FOR REQUEST&quot;);</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (startOffset &lt; self.task.offset) &#123;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    NSData *filedata = [NSData dataWithContentsOfURL:[NSURL fileURLWithPath:_videoPath] options:NSDataReadingMappedIfSafe error:nil];</div><div class=\"line\">    </div><div class=\"line\">    // This is the total data we have from startOffset to whatever has been downloaded so far</div><div class=\"line\">    NSUInteger unreadBytes = self.task.downLoadingOffset - ((NSInteger)startOffset - self.task.offset);</div><div class=\"line\">    </div><div class=\"line\">    // Respond with whatever is available if we can&apos;t satisfy the request fully yet</div><div class=\"line\">    NSUInteger numberOfBytesToRespondWith = MIN((NSUInteger)dataRequest.requestedLength, unreadBytes);</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    [dataRequest respondWithData:[filedata subdataWithRange:NSMakeRange((NSUInteger)startOffset- self.task.offset, (NSUInteger)numberOfBytesToRespondWith)]];</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    long long endOffset = startOffset + dataRequest.requestedLength;</div><div class=\"line\">    BOOL didRespondFully = (self.task.offset + self.task.downLoadingOffset) &gt;= endOffset;</div><div class=\"line\"></div><div class=\"line\">    return didRespondFully;</div><div class=\"line\">  </div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是对存放所有的请求的数组进行处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)processPendingRequests</div><div class=\"line\">&#123;</div><div class=\"line\">    NSMutableArray *requestsCompleted = [NSMutableArray array];  //请求完成的数组</div><div class=\"line\">    //每次下载一块数据都是一次请求，把这些请求放到数组，遍历数组</div><div class=\"line\">    for (AVAssetResourceLoadingRequest *loadingRequest in self.pendingRequests)</div><div class=\"line\">    &#123;</div><div class=\"line\">        [self fillInContentInformation:loadingRequest.contentInformationRequest]; //对每次请求加上长度，文件类型等信息</div><div class=\"line\">        </div><div class=\"line\">        BOOL didRespondCompletely = [self respondWithDataForRequest:loadingRequest.dataRequest]; //判断此次请求的数据是否处理完全</div><div class=\"line\">        </div><div class=\"line\">        if (didRespondCompletely) &#123;</div><div class=\"line\"></div><div class=\"line\">            [requestsCompleted addObject:loadingRequest];  //如果完整，把此次请求放进 请求完成的数组</div><div class=\"line\">            [loadingRequest finishLoading];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    [self.pendingRequests removeObjectsInArray:requestsCompleted];   //在所有请求的数组中移除已经完成的</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>resourceLoader的难点基本上就是上面这点了，说到播放器，下面便顺便讲下AVPlayer的难点。</p>\n<h3 id=\"四：难点：对播放器状态的捕获\"><a href=\"#四：难点：对播放器状态的捕获\" class=\"headerlink\" title=\"四：难点：对播放器状态的捕获\"></a>四：难点：对播放器状态的捕获</h3><ul>\n<li>1.举个简单的例子，视频总长度60分，现在缓冲的数据才10分钟，然后拖动到20分钟的位置进行播放，在网速较慢的时候，视频从当前位置开始播放，必然会出现一段时间的卡顿，为了有一个更好的用户体验，在卡顿的时候，我们需要加一个菊花转的状态，现在问题就来了。</li>\n</ul>\n<ul>\n<li>2.在拖动到未缓冲区域内，是否需要加菊花转，如果加，要显示多久再消失，而且如果在网速很慢的时候，播放器如果等了太久，哪怕最后有数据了，播放器也已经“死”了，它自己无法恢复播放，这个时候需要我们人为的去恢复播放，如果恢复播放不成功，那么过一段时间需要再次恢复播放，是否恢复播放成功，这里也需要捕获其状态。所以，如果要有一个好的用户体验，我们需要时时知道播放器的状态。</li>\n</ul>\n<p>有两个状态需要捕获，一个是正在缓冲，一个是正在播放，监听播放的“playbackBufferEmpty”属性就可以捕获正在缓冲状态，播放器的时间监听器则可以捕获正在播放状态，我的demo中一共有4个状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, TBPlayerState) &#123;</div><div class=\"line\">    TBPlayerStateBuffering = 1,</div><div class=\"line\">    TBPlayerStatePlaying   = 2,</div><div class=\"line\">    TBPlayerStateStopped   = 3,</div><div class=\"line\">    TBPlayerStatePause     = 4</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样可以对播放器更好的把握和处理了。<br>然后说一说在缓冲时候的处理，以及缓冲后多久去播放，处理方法：<br>进入缓冲状态后，缓冲2秒后去手动播放，如果播放不成功（缓冲的数据太少，还不足以播放），那就再缓冲2秒再次播放，如此循环，看详细代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)bufferingSomeSecond</div><div class=\"line\">&#123;</div><div class=\"line\">    // playbackBufferEmpty会反复进入，因此在bufferingOneSecond延时播放执行完之前再调用bufferingSomeSecond都忽略</div><div class=\"line\">    static BOOL isBuffering = NO;</div><div class=\"line\">    if (isBuffering) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isBuffering = YES;</div><div class=\"line\">    </div><div class=\"line\">    // 需要先暂停一小会之后再播放，否则网络状况不好的时候时间在走，声音播放不出来</div><div class=\"line\">    [self.player pause];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        // 如果此时用户已经暂停了，则不再需要开启播放了</div><div class=\"line\">        if (self.isPauseByUser) &#123;</div><div class=\"line\">            isBuffering = NO;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        [self.player play];</div><div class=\"line\">        // 如果执行了play还是没有播放则说明还没有缓存好，则再次缓存一段时间</div><div class=\"line\">        isBuffering = NO;</div><div class=\"line\">        if (!self.currentPlayerItem.isPlaybackLikelyToKeepUp) &#123;</div><div class=\"line\">            [self bufferingSomeSecond];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个demo花了我很长的时间，实现这个demo我也遇到了很多坑最后才完成的，现在我奉献出来，也许对你会有所帮助。如果你觉得不错，还请为我Star一个，也算是对我的支持和鼓励。</p>\n<p><a href=\"https://github.com/suifengqjn/TBPlayer\" target=\"_blank\" rel=\"external\">demo下载地址</a><br>也可以去我的简书博客查看更多文章<br><a href=\"http://www.jianshu.com/users/527ecf8c8753/latest_articles\" target=\"_blank\" rel=\"external\">博客地址</a></p>\n","excerpt":"<p>google搜索“iOS视频变下边播”，有好几篇博客写到了实现方法，其实只有一篇，其他都是copy的，不过他们都是使用的本地代理服务器的方式，原理很简单，但是缺点也很明显，需要自己写一个本地代理服务器或者使用第三方库httpSever。如果使用httpSever作为本地代理服务器，如果只缓存一个视频是没有问题的，如果缓存多个视频互相切换，本地代理服务器提供的数据很不稳定，crash概率非常大。</p>\n<hr>\n<p>这里我采用ios7以后系统自带的方法实现视频边下边播，这里的边下边播不是单独开一个子线程去下载，而是把视频播放的数据给保存到本地。简而言之，就是使用一遍的流量，既播放了视频，也保存了视频。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">用到的框架：&lt;AVFoundation/AVFoundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">用到的播放器：AVplayer</div></pre></td></tr></table></figure>\n<p>先说一下avplayer自身的播放原理，当我们给播放器设置好url等一些参数后，播放器就会向url所在的服务器发送请求(请求参数有两个值，一个是offset偏移量，另一个是length长度，其实就相当于NSRange一样)，服务器就根据range参数给播放器返回数据。这就是大致的原理，当然实际的过程还是略微比较复杂。</p>\n<hr>\n<p></br></p>\n<h3 id=\"一-下面进入主题\"><a href=\"#一-下面进入主题\" class=\"headerlink\" title=\"一:下面进入主题\"></a>一:下面进入主题</h3><h4 id=\"产品需求：\"><a href=\"#产品需求：\" class=\"headerlink\" title=\"产品需求：\"></a>产品需求：</h4><ul>\n<li>1.支持正常播放器的一切功能，包括暂停、播放和拖拽</li>\n<li>2.如果视频加载完成且完整，将视频文件保存到本地cache，下一次播放本地cache中的视频，不再请求网络数据</li>\n<li>3.如果视频没有加载完（半路关闭或者拖拽）就不用保存到本地cache</li>\n</ul>","more":"<h4 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案:\"></a>实现方案:</h4><ul>\n<li>需要在视频播放器和服务器之间添加一层类似代理的机制，视频播放器不再直接访问服务器，而是访问代理对象，代理对象去访问服务器获得数据，之后返回给视频播放器，同时代理对象根据一定的策略缓存数据。</li>\n</ul>\n<ul>\n<li><p>2.AVURLAsset中的resourceLoader可以实现这个机制，resourceLoader的delegate就是上述的代理对象。</p>\n</li>\n<li><p>3.视频播放器在开始播放之前首先检测是本地cache中是否有此视频，如果没有才通过代理获得数据，如果有，则直接播放本地cache中的视频即可。</p>\n</li>\n</ul>\n<h4 id=\"视频播放器需要实现的功能\"><a href=\"#视频播放器需要实现的功能\" class=\"headerlink\" title=\"视频播放器需要实现的功能\"></a>视频播放器需要实现的功能</h4><ul>\n<li><p>1.有开始暂停按钮</p>\n</li>\n<li><p>2.显示播放进度及总时长</p>\n</li>\n<li><p>3.可以通过拖拽从任意位置开始播放视频</p>\n</li>\n<li><p>4.视频加载中的过程和加载失败需要有相应的提示</p>\n</li>\n</ul>\n<h4 id=\"代理对象需要实现的功能\"><a href=\"#代理对象需要实现的功能\" class=\"headerlink\" title=\"代理对象需要实现的功能\"></a>代理对象需要实现的功能</h4><ul>\n<li><p>1.接收视频播放器的请求，并根据请求的range向服务器请求本地没有获得的数据</p>\n</li>\n<li><p>2.缓存向服务器请求回的数据到本地</p>\n</li>\n<li><p>3.如果向服务器的请求出现错误，需要通知给视频播放器，以便视频播放器对用户进行提示</p>\n</li>\n</ul>\n<h3 id=\"二：具体流程\"><a href=\"#二：具体流程\" class=\"headerlink\" title=\"二：具体流程\"></a>二：具体流程</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/TBPlayer/1.png\" alt=\"image\"></p>\n<h4 id=\"视频播放器处理流程\"><a href=\"#视频播放器处理流程\" class=\"headerlink\" title=\"视频播放器处理流程\"></a>视频播放器处理流程</h4><ul>\n<li><p>1.当开始播放视频时，通过视频url判断本地cache中是否已经缓存当前视频，如果有，则直接播放本地cache中视频</p>\n</li>\n<li><p>2.如果本地cache中没有视频，则视频播放器向代理请求数据</p>\n</li>\n<li><p>3.加载视频时展示正在加载的提示（菊花转）</p>\n</li>\n<li><p>4.如果可以正常播放视频，则去掉加载提示，播放视频，如果加载失败，去掉加载提示并显示失败提示</p>\n</li>\n<li><p>5.在播放过程中如果由于网络过慢或拖拽原因导致没有播放数据时，要展示加载提示，跳转到第4步</p>\n</li>\n</ul>\n<h4 id=\"代理对象处理流程\"><a href=\"#代理对象处理流程\" class=\"headerlink\" title=\"代理对象处理流程\"></a>代理对象处理流程</h4><ul>\n<li><p>1.当视频播放器向代理请求dataRequest时，判断代理是否已经向服务器发起了请求，如果没有，则发起下载整个视频文件的请求</p>\n</li>\n<li><p>2.如果代理已经和服务器建立链接，则判断当前的dataRequest请求的offset是否大于当前已经缓存的文件的offset，如果大于则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向后拖拽，并且超过了已缓存的数据时才会出现）</p>\n</li>\n<li><p>3.如果当前的dataRequest请求的offset小于已经缓存的文件的offset，同时大于代理向服务器请求的range的offset，说明有一部分已经缓存的数据可以传给播放器，则将这部分数据返回给播放器（此时应该是由于播放器向前拖拽，请求的数据已经缓存过才会出现）</p>\n</li>\n<li><p>4.如果当前的dataRequest请求的offset小于代理向服务器请求的range的offset，则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向前拖拽，并且超过了已缓存的数据时才会出现）</p>\n</li>\n<li><p>5.只要代理重新向服务器发起请求，就会导致缓存的数据不连续，则加载结束后不用将缓存的数据放入本地cache</p>\n</li>\n<li><p>6.如果代理和服务器的链接超时，重试一次，如果还是错误则通知播放器网络错误</p>\n</li>\n<li><p>7.如果服务器返回其他错误，则代理通知播放器网络错误</p>\n</li>\n</ul>\n<h3 id=\"三：resourceLoader的难点处理\"><a href=\"#三：resourceLoader的难点处理\" class=\"headerlink\" title=\"三：resourceLoader的难点处理\"></a>三：resourceLoader的难点处理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.pendingRequests addObject:loadingRequest];</div><div class=\"line\">    [self dealWithLoadingRequest:loadingRequest];</div><div class=\"line\">    </div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>播放器发出的数据请求从这里开始，我们保存从这里发出的所有请求存放到数组，自己来处理这些请求，当一个请求完成后，对请求发出finishLoading消息，并从数组中移除。正常状态下，当播放器发出下一个请求的时候，会把上一个请求给finish。</p>\n<p>下面这个方法发出的请求说明播放器自己关闭了这个请求，我们不需要再对这个请求进行处理，系统每次结束一个旧的请求，便必然会发出一个或多个新的请求，除了播放器已经获得整个视频完整的数据，这时候就不会再发起请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.pendingRequests removeObject:loadingRequest];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面这个方法是对播放器发出的请求进行填充数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)respondWithDataForRequest:(AVAssetResourceLoadingDataRequest *)dataRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    long long startOffset = dataRequest.requestedOffset;</div><div class=\"line\"></div><div class=\"line\">    if (dataRequest.currentOffset != 0) &#123;</div><div class=\"line\">        startOffset = dataRequest.currentOffset;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if ((self.task.offset +self.task.downLoadingOffset) &lt; startOffset)</div><div class=\"line\">    &#123;</div><div class=\"line\">        //NSLog(@&quot;NO DATA FOR REQUEST&quot;);</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (startOffset &lt; self.task.offset) &#123;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    NSData *filedata = [NSData dataWithContentsOfURL:[NSURL fileURLWithPath:_videoPath] options:NSDataReadingMappedIfSafe error:nil];</div><div class=\"line\">    </div><div class=\"line\">    // This is the total data we have from startOffset to whatever has been downloaded so far</div><div class=\"line\">    NSUInteger unreadBytes = self.task.downLoadingOffset - ((NSInteger)startOffset - self.task.offset);</div><div class=\"line\">    </div><div class=\"line\">    // Respond with whatever is available if we can&apos;t satisfy the request fully yet</div><div class=\"line\">    NSUInteger numberOfBytesToRespondWith = MIN((NSUInteger)dataRequest.requestedLength, unreadBytes);</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    [dataRequest respondWithData:[filedata subdataWithRange:NSMakeRange((NSUInteger)startOffset- self.task.offset, (NSUInteger)numberOfBytesToRespondWith)]];</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    long long endOffset = startOffset + dataRequest.requestedLength;</div><div class=\"line\">    BOOL didRespondFully = (self.task.offset + self.task.downLoadingOffset) &gt;= endOffset;</div><div class=\"line\"></div><div class=\"line\">    return didRespondFully;</div><div class=\"line\">  </div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是对存放所有的请求的数组进行处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)processPendingRequests</div><div class=\"line\">&#123;</div><div class=\"line\">    NSMutableArray *requestsCompleted = [NSMutableArray array];  //请求完成的数组</div><div class=\"line\">    //每次下载一块数据都是一次请求，把这些请求放到数组，遍历数组</div><div class=\"line\">    for (AVAssetResourceLoadingRequest *loadingRequest in self.pendingRequests)</div><div class=\"line\">    &#123;</div><div class=\"line\">        [self fillInContentInformation:loadingRequest.contentInformationRequest]; //对每次请求加上长度，文件类型等信息</div><div class=\"line\">        </div><div class=\"line\">        BOOL didRespondCompletely = [self respondWithDataForRequest:loadingRequest.dataRequest]; //判断此次请求的数据是否处理完全</div><div class=\"line\">        </div><div class=\"line\">        if (didRespondCompletely) &#123;</div><div class=\"line\"></div><div class=\"line\">            [requestsCompleted addObject:loadingRequest];  //如果完整，把此次请求放进 请求完成的数组</div><div class=\"line\">            [loadingRequest finishLoading];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    [self.pendingRequests removeObjectsInArray:requestsCompleted];   //在所有请求的数组中移除已经完成的</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>resourceLoader的难点基本上就是上面这点了，说到播放器，下面便顺便讲下AVPlayer的难点。</p>\n<h3 id=\"四：难点：对播放器状态的捕获\"><a href=\"#四：难点：对播放器状态的捕获\" class=\"headerlink\" title=\"四：难点：对播放器状态的捕获\"></a>四：难点：对播放器状态的捕获</h3><ul>\n<li>1.举个简单的例子，视频总长度60分，现在缓冲的数据才10分钟，然后拖动到20分钟的位置进行播放，在网速较慢的时候，视频从当前位置开始播放，必然会出现一段时间的卡顿，为了有一个更好的用户体验，在卡顿的时候，我们需要加一个菊花转的状态，现在问题就来了。</li>\n</ul>\n<ul>\n<li>2.在拖动到未缓冲区域内，是否需要加菊花转，如果加，要显示多久再消失，而且如果在网速很慢的时候，播放器如果等了太久，哪怕最后有数据了，播放器也已经“死”了，它自己无法恢复播放，这个时候需要我们人为的去恢复播放，如果恢复播放不成功，那么过一段时间需要再次恢复播放，是否恢复播放成功，这里也需要捕获其状态。所以，如果要有一个好的用户体验，我们需要时时知道播放器的状态。</li>\n</ul>\n<p>有两个状态需要捕获，一个是正在缓冲，一个是正在播放，监听播放的“playbackBufferEmpty”属性就可以捕获正在缓冲状态，播放器的时间监听器则可以捕获正在播放状态，我的demo中一共有4个状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, TBPlayerState) &#123;</div><div class=\"line\">    TBPlayerStateBuffering = 1,</div><div class=\"line\">    TBPlayerStatePlaying   = 2,</div><div class=\"line\">    TBPlayerStateStopped   = 3,</div><div class=\"line\">    TBPlayerStatePause     = 4</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样可以对播放器更好的把握和处理了。<br>然后说一说在缓冲时候的处理，以及缓冲后多久去播放，处理方法：<br>进入缓冲状态后，缓冲2秒后去手动播放，如果播放不成功（缓冲的数据太少，还不足以播放），那就再缓冲2秒再次播放，如此循环，看详细代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)bufferingSomeSecond</div><div class=\"line\">&#123;</div><div class=\"line\">    // playbackBufferEmpty会反复进入，因此在bufferingOneSecond延时播放执行完之前再调用bufferingSomeSecond都忽略</div><div class=\"line\">    static BOOL isBuffering = NO;</div><div class=\"line\">    if (isBuffering) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isBuffering = YES;</div><div class=\"line\">    </div><div class=\"line\">    // 需要先暂停一小会之后再播放，否则网络状况不好的时候时间在走，声音播放不出来</div><div class=\"line\">    [self.player pause];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        // 如果此时用户已经暂停了，则不再需要开启播放了</div><div class=\"line\">        if (self.isPauseByUser) &#123;</div><div class=\"line\">            isBuffering = NO;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        [self.player play];</div><div class=\"line\">        // 如果执行了play还是没有播放则说明还没有缓存好，则再次缓存一段时间</div><div class=\"line\">        isBuffering = NO;</div><div class=\"line\">        if (!self.currentPlayerItem.isPlaybackLikelyToKeepUp) &#123;</div><div class=\"line\">            [self bufferingSomeSecond];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个demo花了我很长的时间，实现这个demo我也遇到了很多坑最后才完成的，现在我奉献出来，也许对你会有所帮助。如果你觉得不错，还请为我Star一个，也算是对我的支持和鼓励。</p>\n<p><a href=\"https://github.com/suifengqjn/TBPlayer\">demo下载地址</a><br>也可以去我的简书博客查看更多文章<br><a href=\"http://www.jianshu.com/users/527ecf8c8753/latest_articles\">博客地址</a></p>"},{"title":"instruments实践","date":"2017-01-01T09:24:39.000Z","_content":"\n前段时间写项目，突然跳到某一个页面crash了，然后我重新又进来几次，然后又没问题了，以为这是个\"意外\"，也没在意，一段时间后，又发生了一次crash，还是同一个页面，我意识到这不是偶然了，然后开始找原因。关于instruments的使用也看过很多次了，但是一直没怎么用，正好这次用它解决了一个问题，顺便记录一下。在猜测某个页面有问题的情况下，我一般的思路是这样的：\n\n### 第一步：查看dealloc\n看这个页面有没有被释放，在dealloc打上断点，发现页面确实已经释放了，排除这个可能，进行下一步。\n<!--more-->\n### 第二步：查看内存,cpu\n![查看运行状态的内存cpu](https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/1.png)\n\n我先后两次进入到这个页面，发现刚进入这个页面的瞬间内存飚的很高，然后瞬间又降下来，到这里问题已经变得明显了，这个页面确实存在问题，下面就需要深入的寻找问题所在。\n\n### 第三步：Profile\n直接在上图的右上角点击 Profile in instruments,\n![查看运行状态的内存cpu](https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/2.png)\n进入instruments后，我还是重复之前的操作，进入这个问题页面，还是发现了内存飙高的情况，然后我在下面的堆栈里找，发现怎么也找不到到底是哪个方法引起的。\n![查看运行状态的内存cpu](https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/3.png)\n然后我发现上面的内存图上有条线可以拖动，然后我就把它拖到内存最高的地方，然后再去下面找，发现还是找不到。\n![查看运行状态的内存cpu](https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/4.png)\n最后，我尝试在内存飙高的同时，点击左上角暂停运行，然后再下面的堆栈中继续找，这回终于找到了，是我自己的一个类渲染UI的时候导致的内存问题，找到具体的原因，解决起来也就轻松了。光看果然是没有用的，重要的还是要实践。\n\nleak 右侧几个属性选项\n![几个属性含义](https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/7.png)\n\nSeparate by Thread（建议选择）   按照线程分类查看哪些占用cpu最多\nInvert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。\nHidden System Librares (建议选择)   隐藏系统类库方法\nFlatten Recursion （一般不选）：选上它会将调用栈里递归函数作为一个入口。\nHide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。\n\n\n","source":"_posts/instruments实践.md","raw":"---\ntitle: instruments实践\ndate: 2017-01-01 17:24:39\ntags: [iOS, instruments, crash, 性能]\ncategories: \n- iOS技术\n---\n\n前段时间写项目，突然跳到某一个页面crash了，然后我重新又进来几次，然后又没问题了，以为这是个\"意外\"，也没在意，一段时间后，又发生了一次crash，还是同一个页面，我意识到这不是偶然了，然后开始找原因。关于instruments的使用也看过很多次了，但是一直没怎么用，正好这次用它解决了一个问题，顺便记录一下。在猜测某个页面有问题的情况下，我一般的思路是这样的：\n\n### 第一步：查看dealloc\n看这个页面有没有被释放，在dealloc打上断点，发现页面确实已经释放了，排除这个可能，进行下一步。\n<!--more-->\n### 第二步：查看内存,cpu\n![查看运行状态的内存cpu](https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/1.png)\n\n我先后两次进入到这个页面，发现刚进入这个页面的瞬间内存飚的很高，然后瞬间又降下来，到这里问题已经变得明显了，这个页面确实存在问题，下面就需要深入的寻找问题所在。\n\n### 第三步：Profile\n直接在上图的右上角点击 Profile in instruments,\n![查看运行状态的内存cpu](https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/2.png)\n进入instruments后，我还是重复之前的操作，进入这个问题页面，还是发现了内存飙高的情况，然后我在下面的堆栈里找，发现怎么也找不到到底是哪个方法引起的。\n![查看运行状态的内存cpu](https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/3.png)\n然后我发现上面的内存图上有条线可以拖动，然后我就把它拖到内存最高的地方，然后再去下面找，发现还是找不到。\n![查看运行状态的内存cpu](https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/4.png)\n最后，我尝试在内存飙高的同时，点击左上角暂停运行，然后再下面的堆栈中继续找，这回终于找到了，是我自己的一个类渲染UI的时候导致的内存问题，找到具体的原因，解决起来也就轻松了。光看果然是没有用的，重要的还是要实践。\n\nleak 右侧几个属性选项\n![几个属性含义](https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/7.png)\n\nSeparate by Thread（建议选择）   按照线程分类查看哪些占用cpu最多\nInvert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。\nHidden System Librares (建议选择)   隐藏系统类库方法\nFlatten Recursion （一般不选）：选上它会将调用栈里递归函数作为一个入口。\nHide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。\n\n\n","slug":"instruments实践","published":1,"updated":"2017-05-23T16:00:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tem001vlx60yiah7cna","content":"<p>前段时间写项目，突然跳到某一个页面crash了，然后我重新又进来几次，然后又没问题了，以为这是个”意外”，也没在意，一段时间后，又发生了一次crash，还是同一个页面，我意识到这不是偶然了，然后开始找原因。关于instruments的使用也看过很多次了，但是一直没怎么用，正好这次用它解决了一个问题，顺便记录一下。在猜测某个页面有问题的情况下，我一般的思路是这样的：</p>\n<h3 id=\"第一步：查看dealloc\"><a href=\"#第一步：查看dealloc\" class=\"headerlink\" title=\"第一步：查看dealloc\"></a>第一步：查看dealloc</h3><p>看这个页面有没有被释放，在dealloc打上断点，发现页面确实已经释放了，排除这个可能，进行下一步。<br><a id=\"more\"></a></p>\n<h3 id=\"第二步：查看内存-cpu\"><a href=\"#第二步：查看内存-cpu\" class=\"headerlink\" title=\"第二步：查看内存,cpu\"></a>第二步：查看内存,cpu</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/1.png\" alt=\"查看运行状态的内存cpu\"></p>\n<p>我先后两次进入到这个页面，发现刚进入这个页面的瞬间内存飚的很高，然后瞬间又降下来，到这里问题已经变得明显了，这个页面确实存在问题，下面就需要深入的寻找问题所在。</p>\n<h3 id=\"第三步：Profile\"><a href=\"#第三步：Profile\" class=\"headerlink\" title=\"第三步：Profile\"></a>第三步：Profile</h3><p>直接在上图的右上角点击 Profile in instruments,<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/2.png\" alt=\"查看运行状态的内存cpu\"><br>进入instruments后，我还是重复之前的操作，进入这个问题页面，还是发现了内存飙高的情况，然后我在下面的堆栈里找，发现怎么也找不到到底是哪个方法引起的。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/3.png\" alt=\"查看运行状态的内存cpu\"><br>然后我发现上面的内存图上有条线可以拖动，然后我就把它拖到内存最高的地方，然后再去下面找，发现还是找不到。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/4.png\" alt=\"查看运行状态的内存cpu\"><br>最后，我尝试在内存飙高的同时，点击左上角暂停运行，然后再下面的堆栈中继续找，这回终于找到了，是我自己的一个类渲染UI的时候导致的内存问题，找到具体的原因，解决起来也就轻松了。光看果然是没有用的，重要的还是要实践。</p>\n<p>leak 右侧几个属性选项<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/7.png\" alt=\"几个属性含义\"></p>\n<p>Separate by Thread（建议选择）   按照线程分类查看哪些占用cpu最多<br>Invert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。<br>Hidden System Librares (建议选择)   隐藏系统类库方法<br>Flatten Recursion （一般不选）：选上它会将调用栈里递归函数作为一个入口。<br>Hide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。</p>\n","excerpt":"<p>前段时间写项目，突然跳到某一个页面crash了，然后我重新又进来几次，然后又没问题了，以为这是个”意外”，也没在意，一段时间后，又发生了一次crash，还是同一个页面，我意识到这不是偶然了，然后开始找原因。关于instruments的使用也看过很多次了，但是一直没怎么用，正好这次用它解决了一个问题，顺便记录一下。在猜测某个页面有问题的情况下，我一般的思路是这样的：</p>\n<h3 id=\"第一步：查看dealloc\"><a href=\"#第一步：查看dealloc\" class=\"headerlink\" title=\"第一步：查看dealloc\"></a>第一步：查看dealloc</h3><p>看这个页面有没有被释放，在dealloc打上断点，发现页面确实已经释放了，排除这个可能，进行下一步。<br>","more":"</p>\n<h3 id=\"第二步：查看内存-cpu\"><a href=\"#第二步：查看内存-cpu\" class=\"headerlink\" title=\"第二步：查看内存,cpu\"></a>第二步：查看内存,cpu</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/1.png\" alt=\"查看运行状态的内存cpu\"></p>\n<p>我先后两次进入到这个页面，发现刚进入这个页面的瞬间内存飚的很高，然后瞬间又降下来，到这里问题已经变得明显了，这个页面确实存在问题，下面就需要深入的寻找问题所在。</p>\n<h3 id=\"第三步：Profile\"><a href=\"#第三步：Profile\" class=\"headerlink\" title=\"第三步：Profile\"></a>第三步：Profile</h3><p>直接在上图的右上角点击 Profile in instruments,<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/2.png\" alt=\"查看运行状态的内存cpu\"><br>进入instruments后，我还是重复之前的操作，进入这个问题页面，还是发现了内存飙高的情况，然后我在下面的堆栈里找，发现怎么也找不到到底是哪个方法引起的。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/3.png\" alt=\"查看运行状态的内存cpu\"><br>然后我发现上面的内存图上有条线可以拖动，然后我就把它拖到内存最高的地方，然后再去下面找，发现还是找不到。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/4.png\" alt=\"查看运行状态的内存cpu\"><br>最后，我尝试在内存飙高的同时，点击左上角暂停运行，然后再下面的堆栈中继续找，这回终于找到了，是我自己的一个类渲染UI的时候导致的内存问题，找到具体的原因，解决起来也就轻松了。光看果然是没有用的，重要的还是要实践。</p>\n<p>leak 右侧几个属性选项<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/instruments/7.png\" alt=\"几个属性含义\"></p>\n<p>Separate by Thread（建议选择）   按照线程分类查看哪些占用cpu最多<br>Invert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。<br>Hidden System Librares (建议选择)   隐藏系统类库方法<br>Flatten Recursion （一般不选）：选上它会将调用栈里递归函数作为一个入口。<br>Hide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。</p>"},{"title":"mongodb+golang+mac","date":"2018-07-09T12:01:50.000Z","_content":"\n### MongoDB简介\n\nMongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。\n\n### NoSql数据库的CAP理论\n\nCAP理论，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。\n<!--more-->\n![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/blog/cap.png)\n\n* 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）\n* 可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）\n* 分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。\n\n### 安装MongoDB\n\n用OSX 的 brew 来安装 mongodb\n`brew install mongodb` 或者 `sudo brew install mongodb`\n\n如果要安装支持 TLS/SSL 命令如下：\n`brew install mongodb --with-openssl`\n\n查看是否安装成功\n`mongod -version`\n如果显示版本信息，说明已经安装成功\n\n### 启动mongo\n\nmongo默认会在根目录 /data/db 下启动服务，所以需要先创建此路径。\n`sudo mkdir -p /data/db`\n\n然后开启服务\n`mongod`\n\n或者开启指定路径的服务\n`mongod --dbpath=xxx`\n\n新开一个终端，输入命令\n`mongo`\n进入mongo系统\n\n再次输入命令测试\n`show dbs`\n显示如下\n\n```\n> show dbs\nadmin   0.000GB\nconfig  0.000GB\nlocal   0.000GB\n```\n即已成功运行\n\n### 基本命令\n\n显示数据库\n`show dbs`\n显示数据表\n`show collections`\n选择或者创建 mydb数据表\n`use mydb`\n\n#### 增\n\n如果没有 user表 会自动创建\n`db.user.save({\"name\":\"zhangsan\",\"age\":2})`\n\n#### 删\n\n删除数据表\n`db.user.drop()`\n\n删除数据库\n`use mydb`\n`db.dropDatasase()`\n\n删除记录\n`db.user.remove({\"name\":\"zhangsan\"})`\n\n#### 查\n\n查所有\n`db.user.find()`\n查 age=2\n`db.user.find({\"age\":2})`\n\n#### 改\n\n只改动某一项值\n\n```\ndb.user.update({\"_id\" : ObjectId(\"5b41c89323c223baaa7d4ef1\")},{$set:{\"name\":\"wangwu\"}})\n```\n\n如果没有set，相当于覆盖这条记录\n\n### golang中使用mongo\n\n![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/blog/mongo.png)\n\n### golang demo\n\n\n```\npackage main\n\nimport (\n\t\"gopkg.in/mgo.v2\"\n\t\"gopkg.in/mgo.v2/bson\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tID    bson.ObjectId `_id`\n\tName string\n\tAge int\n}\n\nconst  (\n\tdbUrl = \"127.0.0.1:27017\"\n)\n\nfunc main(){\n\n\tsession,err := mgo.Dial(dbUrl)\n\n\tif err != err {\n\t\tprintln(err)\n\t}\n\tdefer session.Close()\n\tsession.SetMode(mgo.Monotonic, true) //设置一致性模式\n\n\t//选择数据库\n\tdb := session.DB(\"mydb\")\n\n\t//选择数据表\n\tcollection := db.C(\"user\")\n\n\t//增  单条插入\n\tp1 := Person{bson.NewObjectId(),\"lisi2\", 12}\n\tp2 := Person{bson.NewObjectId(),\"lisi2\", 12}\n\n\terr = collection.Insert(&p1, &p2)\n\n\t//批量插入\n\tvar arr []interface{}\n\tarr = append(arr, p1)\n\tarr = append(arr, p2)\n\terr = collection.Insert(arr...)\n\tif err != err {\n\t\tprintln(err)\n\t}\n\n\t//查第一条\n\tresult := Person{}\n\tcollection.Find(bson.M{\"age\":12}).One(&result)\n\tfmt.Println(\"restlt\",result)\n\n\t//查多条\n\tresults := []Person{}\n\tcollection.Find(bson.M{\"age\":12}).All(&results)\n\tfmt.Println(\"results\",results, len(results))\n\n\n\t//查表中数据总数\n\tcount, _:= collection.Find(nil).Count()\n\tfmt.Println(count)\n\n\t//查所有\n\tarr2 := make([]Person, 0)\n\titerNew := collection.Find(nil).Iter()\n\terr = iterNew.All(&arr2)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"arr2\",arr2)\n\n\t//改(不加set就是覆盖)\n\tcollection.Update(bson.M{\"name\":\"zhangsan\"}, bson.M{\"$set\":bson.M{\"age\":22}})\n\tcollection.Update(bson.M{\"age\":22},bson.M{\"$set\":bson.M{\"age\":23}})\n\tcollection.Update(bson.M{\"name\":\"lisi\"}, bson.M{\"name\":\"lisi2\",\"age\":22})\n\n\t//批量更新\n\tcollection.UpdateAll(bson.M{\"age\":22}, bson.M{\"$set\":bson.M{\"age\":44}})\n\n\n\t//删\n\n\t//删除符合条件的第一条\n\t//collection.Remove(bson.M{\"name\": \"lisi2\"})\n\n\t//删除所有\n\t_, err = collection.RemoveAll(bson.M{\"name\": \"lisi\"})\n\tif err != err {\n\t\tprintln(err)\n\t}\n\n\n\n\t//根据ID删除\n\tvar wangwu = Person{}\n\tcollection.Find(bson.M{\"name\":\"wangwu\"}).One(&wangwu)\n\tfmt.Println(wangwu, wangwu.ID.Hex(), wangwu.ID.String())\n\terr =collection.RemoveId(wangwu.ID)\n\tfmt.Println(\"delete\",err)\n\t\n\t//删除集合\n  //collection.DropCollection()\n\n\n}\n\n```\n\n","source":"_posts/mac下使用golang操作mongodb.md","raw":"---\ntitle: mongodb+golang+mac\ncategories:\n  - go\ntags:\n  - mongodb\n  - 数据库\n  - 分布式\ndate: 2018-07-09 20:01:50\n---\n\n### MongoDB简介\n\nMongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。\n\n### NoSql数据库的CAP理论\n\nCAP理论，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。\n<!--more-->\n![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/blog/cap.png)\n\n* 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）\n* 可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）\n* 分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。\n\n### 安装MongoDB\n\n用OSX 的 brew 来安装 mongodb\n`brew install mongodb` 或者 `sudo brew install mongodb`\n\n如果要安装支持 TLS/SSL 命令如下：\n`brew install mongodb --with-openssl`\n\n查看是否安装成功\n`mongod -version`\n如果显示版本信息，说明已经安装成功\n\n### 启动mongo\n\nmongo默认会在根目录 /data/db 下启动服务，所以需要先创建此路径。\n`sudo mkdir -p /data/db`\n\n然后开启服务\n`mongod`\n\n或者开启指定路径的服务\n`mongod --dbpath=xxx`\n\n新开一个终端，输入命令\n`mongo`\n进入mongo系统\n\n再次输入命令测试\n`show dbs`\n显示如下\n\n```\n> show dbs\nadmin   0.000GB\nconfig  0.000GB\nlocal   0.000GB\n```\n即已成功运行\n\n### 基本命令\n\n显示数据库\n`show dbs`\n显示数据表\n`show collections`\n选择或者创建 mydb数据表\n`use mydb`\n\n#### 增\n\n如果没有 user表 会自动创建\n`db.user.save({\"name\":\"zhangsan\",\"age\":2})`\n\n#### 删\n\n删除数据表\n`db.user.drop()`\n\n删除数据库\n`use mydb`\n`db.dropDatasase()`\n\n删除记录\n`db.user.remove({\"name\":\"zhangsan\"})`\n\n#### 查\n\n查所有\n`db.user.find()`\n查 age=2\n`db.user.find({\"age\":2})`\n\n#### 改\n\n只改动某一项值\n\n```\ndb.user.update({\"_id\" : ObjectId(\"5b41c89323c223baaa7d4ef1\")},{$set:{\"name\":\"wangwu\"}})\n```\n\n如果没有set，相当于覆盖这条记录\n\n### golang中使用mongo\n\n![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/blog/mongo.png)\n\n### golang demo\n\n\n```\npackage main\n\nimport (\n\t\"gopkg.in/mgo.v2\"\n\t\"gopkg.in/mgo.v2/bson\"\n\t\"fmt\"\n)\n\ntype Person struct {\n\tID    bson.ObjectId `_id`\n\tName string\n\tAge int\n}\n\nconst  (\n\tdbUrl = \"127.0.0.1:27017\"\n)\n\nfunc main(){\n\n\tsession,err := mgo.Dial(dbUrl)\n\n\tif err != err {\n\t\tprintln(err)\n\t}\n\tdefer session.Close()\n\tsession.SetMode(mgo.Monotonic, true) //设置一致性模式\n\n\t//选择数据库\n\tdb := session.DB(\"mydb\")\n\n\t//选择数据表\n\tcollection := db.C(\"user\")\n\n\t//增  单条插入\n\tp1 := Person{bson.NewObjectId(),\"lisi2\", 12}\n\tp2 := Person{bson.NewObjectId(),\"lisi2\", 12}\n\n\terr = collection.Insert(&p1, &p2)\n\n\t//批量插入\n\tvar arr []interface{}\n\tarr = append(arr, p1)\n\tarr = append(arr, p2)\n\terr = collection.Insert(arr...)\n\tif err != err {\n\t\tprintln(err)\n\t}\n\n\t//查第一条\n\tresult := Person{}\n\tcollection.Find(bson.M{\"age\":12}).One(&result)\n\tfmt.Println(\"restlt\",result)\n\n\t//查多条\n\tresults := []Person{}\n\tcollection.Find(bson.M{\"age\":12}).All(&results)\n\tfmt.Println(\"results\",results, len(results))\n\n\n\t//查表中数据总数\n\tcount, _:= collection.Find(nil).Count()\n\tfmt.Println(count)\n\n\t//查所有\n\tarr2 := make([]Person, 0)\n\titerNew := collection.Find(nil).Iter()\n\terr = iterNew.All(&arr2)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"arr2\",arr2)\n\n\t//改(不加set就是覆盖)\n\tcollection.Update(bson.M{\"name\":\"zhangsan\"}, bson.M{\"$set\":bson.M{\"age\":22}})\n\tcollection.Update(bson.M{\"age\":22},bson.M{\"$set\":bson.M{\"age\":23}})\n\tcollection.Update(bson.M{\"name\":\"lisi\"}, bson.M{\"name\":\"lisi2\",\"age\":22})\n\n\t//批量更新\n\tcollection.UpdateAll(bson.M{\"age\":22}, bson.M{\"$set\":bson.M{\"age\":44}})\n\n\n\t//删\n\n\t//删除符合条件的第一条\n\t//collection.Remove(bson.M{\"name\": \"lisi2\"})\n\n\t//删除所有\n\t_, err = collection.RemoveAll(bson.M{\"name\": \"lisi\"})\n\tif err != err {\n\t\tprintln(err)\n\t}\n\n\n\n\t//根据ID删除\n\tvar wangwu = Person{}\n\tcollection.Find(bson.M{\"name\":\"wangwu\"}).One(&wangwu)\n\tfmt.Println(wangwu, wangwu.ID.Hex(), wangwu.ID.String())\n\terr =collection.RemoveId(wangwu.ID)\n\tfmt.Println(\"delete\",err)\n\t\n\t//删除集合\n  //collection.DropCollection()\n\n\n}\n\n```\n\n","slug":"mac下使用golang操作mongodb","published":1,"updated":"2018-07-09T13:02:50.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5teo001zlx60ds8v0ro6","content":"<h3 id=\"MongoDB简介\"><a href=\"#MongoDB简介\" class=\"headerlink\" title=\"MongoDB简介\"></a>MongoDB简介</h3><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</p>\n<h3 id=\"NoSql数据库的CAP理论\"><a href=\"#NoSql数据库的CAP理论\" class=\"headerlink\" title=\"NoSql数据库的CAP理论\"></a>NoSql数据库的CAP理论</h3><p>CAP理论，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。<br><a id=\"more\"></a><br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/blog/cap.png\" alt=\"\"></p>\n<ul>\n<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>\n<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>\n<li>分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>\n</ul>\n<h3 id=\"安装MongoDB\"><a href=\"#安装MongoDB\" class=\"headerlink\" title=\"安装MongoDB\"></a>安装MongoDB</h3><p>用OSX 的 brew 来安装 mongodb<br><code>brew install mongodb</code> 或者 <code>sudo brew install mongodb</code></p>\n<p>如果要安装支持 TLS/SSL 命令如下：<br><code>brew install mongodb --with-openssl</code></p>\n<p>查看是否安装成功<br><code>mongod -version</code><br>如果显示版本信息，说明已经安装成功</p>\n<h3 id=\"启动mongo\"><a href=\"#启动mongo\" class=\"headerlink\" title=\"启动mongo\"></a>启动mongo</h3><p>mongo默认会在根目录 /data/db 下启动服务，所以需要先创建此路径。<br><code>sudo mkdir -p /data/db</code></p>\n<p>然后开启服务<br><code>mongod</code></p>\n<p>或者开启指定路径的服务<br><code>mongod --dbpath=xxx</code></p>\n<p>新开一个终端，输入命令<br><code>mongo</code><br>进入mongo系统</p>\n<p>再次输入命令测试<br><code>show dbs</code><br>显示如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; show dbs</div><div class=\"line\">admin   0.000GB</div><div class=\"line\">config  0.000GB</div><div class=\"line\">local   0.000GB</div></pre></td></tr></table></figure>\n<p>即已成功运行</p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><p>显示数据库<br><code>show dbs</code><br>显示数据表<br><code>show collections</code><br>选择或者创建 mydb数据表<br><code>use mydb</code></p>\n<h4 id=\"增\"><a href=\"#增\" class=\"headerlink\" title=\"增\"></a>增</h4><p>如果没有 user表 会自动创建<br><code>db.user.save({&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:2})</code></p>\n<h4 id=\"删\"><a href=\"#删\" class=\"headerlink\" title=\"删\"></a>删</h4><p>删除数据表<br><code>db.user.drop()</code></p>\n<p>删除数据库<br><code>use mydb</code><br><code>db.dropDatasase()</code></p>\n<p>删除记录<br><code>db.user.remove({&quot;name&quot;:&quot;zhangsan&quot;})</code></p>\n<h4 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h4><p>查所有<br><code>db.user.find()</code><br>查 age=2<br><code>db.user.find({&quot;age&quot;:2})</code></p>\n<h4 id=\"改\"><a href=\"#改\" class=\"headerlink\" title=\"改\"></a>改</h4><p>只改动某一项值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.user.update(&#123;&quot;_id&quot; : ObjectId(&quot;5b41c89323c223baaa7d4ef1&quot;)&#125;,&#123;$set:&#123;&quot;name&quot;:&quot;wangwu&quot;&#125;&#125;)</div></pre></td></tr></table></figure>\n<p>如果没有set，相当于覆盖这条记录</p>\n<h3 id=\"golang中使用mongo\"><a href=\"#golang中使用mongo\" class=\"headerlink\" title=\"golang中使用mongo\"></a>golang中使用mongo</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/blog/mongo.png\" alt=\"\"></p>\n<h3 id=\"golang-demo\"><a href=\"#golang-demo\" class=\"headerlink\" title=\"golang demo\"></a>golang demo</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;gopkg.in/mgo.v2&quot;</div><div class=\"line\">\t&quot;gopkg.in/mgo.v2/bson&quot;</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">type Person struct &#123;</div><div class=\"line\">\tID    bson.ObjectId `_id`</div><div class=\"line\">\tName string</div><div class=\"line\">\tAge int</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const  (</div><div class=\"line\">\tdbUrl = &quot;127.0.0.1:27017&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">func main()&#123;</div><div class=\"line\"></div><div class=\"line\">\tsession,err := mgo.Dial(dbUrl)</div><div class=\"line\"></div><div class=\"line\">\tif err != err &#123;</div><div class=\"line\">\t\tprintln(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tdefer session.Close()</div><div class=\"line\">\tsession.SetMode(mgo.Monotonic, true) //设置一致性模式</div><div class=\"line\"></div><div class=\"line\">\t//选择数据库</div><div class=\"line\">\tdb := session.DB(&quot;mydb&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//选择数据表</div><div class=\"line\">\tcollection := db.C(&quot;user&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//增  单条插入</div><div class=\"line\">\tp1 := Person&#123;bson.NewObjectId(),&quot;lisi2&quot;, 12&#125;</div><div class=\"line\">\tp2 := Person&#123;bson.NewObjectId(),&quot;lisi2&quot;, 12&#125;</div><div class=\"line\"></div><div class=\"line\">\terr = collection.Insert(&amp;p1, &amp;p2)</div><div class=\"line\"></div><div class=\"line\">\t//批量插入</div><div class=\"line\">\tvar arr []interface&#123;&#125;</div><div class=\"line\">\tarr = append(arr, p1)</div><div class=\"line\">\tarr = append(arr, p2)</div><div class=\"line\">\terr = collection.Insert(arr...)</div><div class=\"line\">\tif err != err &#123;</div><div class=\"line\">\t\tprintln(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t//查第一条</div><div class=\"line\">\tresult := Person&#123;&#125;</div><div class=\"line\">\tcollection.Find(bson.M&#123;&quot;age&quot;:12&#125;).One(&amp;result)</div><div class=\"line\">\tfmt.Println(&quot;restlt&quot;,result)</div><div class=\"line\"></div><div class=\"line\">\t//查多条</div><div class=\"line\">\tresults := []Person&#123;&#125;</div><div class=\"line\">\tcollection.Find(bson.M&#123;&quot;age&quot;:12&#125;).All(&amp;results)</div><div class=\"line\">\tfmt.Println(&quot;results&quot;,results, len(results))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//查表中数据总数</div><div class=\"line\">\tcount, _:= collection.Find(nil).Count()</div><div class=\"line\">\tfmt.Println(count)</div><div class=\"line\"></div><div class=\"line\">\t//查所有</div><div class=\"line\">\tarr2 := make([]Person, 0)</div><div class=\"line\">\titerNew := collection.Find(nil).Iter()</div><div class=\"line\">\terr = iterNew.All(&amp;arr2)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tpanic(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(&quot;arr2&quot;,arr2)</div><div class=\"line\"></div><div class=\"line\">\t//改(不加set就是覆盖)</div><div class=\"line\">\tcollection.Update(bson.M&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;, bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:22&#125;&#125;)</div><div class=\"line\">\tcollection.Update(bson.M&#123;&quot;age&quot;:22&#125;,bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:23&#125;&#125;)</div><div class=\"line\">\tcollection.Update(bson.M&#123;&quot;name&quot;:&quot;lisi&quot;&#125;, bson.M&#123;&quot;name&quot;:&quot;lisi2&quot;,&quot;age&quot;:22&#125;)</div><div class=\"line\"></div><div class=\"line\">\t//批量更新</div><div class=\"line\">\tcollection.UpdateAll(bson.M&#123;&quot;age&quot;:22&#125;, bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:44&#125;&#125;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//删</div><div class=\"line\"></div><div class=\"line\">\t//删除符合条件的第一条</div><div class=\"line\">\t//collection.Remove(bson.M&#123;&quot;name&quot;: &quot;lisi2&quot;&#125;)</div><div class=\"line\"></div><div class=\"line\">\t//删除所有</div><div class=\"line\">\t_, err = collection.RemoveAll(bson.M&#123;&quot;name&quot;: &quot;lisi&quot;&#125;)</div><div class=\"line\">\tif err != err &#123;</div><div class=\"line\">\t\tprintln(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//根据ID删除</div><div class=\"line\">\tvar wangwu = Person&#123;&#125;</div><div class=\"line\">\tcollection.Find(bson.M&#123;&quot;name&quot;:&quot;wangwu&quot;&#125;).One(&amp;wangwu)</div><div class=\"line\">\tfmt.Println(wangwu, wangwu.ID.Hex(), wangwu.ID.String())</div><div class=\"line\">\terr =collection.RemoveId(wangwu.ID)</div><div class=\"line\">\tfmt.Println(&quot;delete&quot;,err)</div><div class=\"line\">\t</div><div class=\"line\">\t//删除集合</div><div class=\"line\">  //collection.DropCollection()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<h3 id=\"MongoDB简介\"><a href=\"#MongoDB简介\" class=\"headerlink\" title=\"MongoDB简介\"></a>MongoDB简介</h3><p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</p>\n<h3 id=\"NoSql数据库的CAP理论\"><a href=\"#NoSql数据库的CAP理论\" class=\"headerlink\" title=\"NoSql数据库的CAP理论\"></a>NoSql数据库的CAP理论</h3><p>CAP理论，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。<br>","more":"<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/blog/cap.png\" alt=\"\"></p>\n<ul>\n<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>\n<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>\n<li>分区容错性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>\n</ul>\n<h3 id=\"安装MongoDB\"><a href=\"#安装MongoDB\" class=\"headerlink\" title=\"安装MongoDB\"></a>安装MongoDB</h3><p>用OSX 的 brew 来安装 mongodb<br><code>brew install mongodb</code> 或者 <code>sudo brew install mongodb</code></p>\n<p>如果要安装支持 TLS/SSL 命令如下：<br><code>brew install mongodb --with-openssl</code></p>\n<p>查看是否安装成功<br><code>mongod -version</code><br>如果显示版本信息，说明已经安装成功</p>\n<h3 id=\"启动mongo\"><a href=\"#启动mongo\" class=\"headerlink\" title=\"启动mongo\"></a>启动mongo</h3><p>mongo默认会在根目录 /data/db 下启动服务，所以需要先创建此路径。<br><code>sudo mkdir -p /data/db</code></p>\n<p>然后开启服务<br><code>mongod</code></p>\n<p>或者开启指定路径的服务<br><code>mongod --dbpath=xxx</code></p>\n<p>新开一个终端，输入命令<br><code>mongo</code><br>进入mongo系统</p>\n<p>再次输入命令测试<br><code>show dbs</code><br>显示如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; show dbs</div><div class=\"line\">admin   0.000GB</div><div class=\"line\">config  0.000GB</div><div class=\"line\">local   0.000GB</div></pre></td></tr></table></figure>\n<p>即已成功运行</p>\n<h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><p>显示数据库<br><code>show dbs</code><br>显示数据表<br><code>show collections</code><br>选择或者创建 mydb数据表<br><code>use mydb</code></p>\n<h4 id=\"增\"><a href=\"#增\" class=\"headerlink\" title=\"增\"></a>增</h4><p>如果没有 user表 会自动创建<br><code>db.user.save({&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:2})</code></p>\n<h4 id=\"删\"><a href=\"#删\" class=\"headerlink\" title=\"删\"></a>删</h4><p>删除数据表<br><code>db.user.drop()</code></p>\n<p>删除数据库<br><code>use mydb</code><br><code>db.dropDatasase()</code></p>\n<p>删除记录<br><code>db.user.remove({&quot;name&quot;:&quot;zhangsan&quot;})</code></p>\n<h4 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h4><p>查所有<br><code>db.user.find()</code><br>查 age=2<br><code>db.user.find({&quot;age&quot;:2})</code></p>\n<h4 id=\"改\"><a href=\"#改\" class=\"headerlink\" title=\"改\"></a>改</h4><p>只改动某一项值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">db.user.update(&#123;&quot;_id&quot; : ObjectId(&quot;5b41c89323c223baaa7d4ef1&quot;)&#125;,&#123;$set:&#123;&quot;name&quot;:&quot;wangwu&quot;&#125;&#125;)</div></pre></td></tr></table></figure>\n<p>如果没有set，相当于覆盖这条记录</p>\n<h3 id=\"golang中使用mongo\"><a href=\"#golang中使用mongo\" class=\"headerlink\" title=\"golang中使用mongo\"></a>golang中使用mongo</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/blog/mongo.png\" alt=\"\"></p>\n<h3 id=\"golang-demo\"><a href=\"#golang-demo\" class=\"headerlink\" title=\"golang demo\"></a>golang demo</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;gopkg.in/mgo.v2&quot;</div><div class=\"line\">\t&quot;gopkg.in/mgo.v2/bson&quot;</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">type Person struct &#123;</div><div class=\"line\">\tID    bson.ObjectId `_id`</div><div class=\"line\">\tName string</div><div class=\"line\">\tAge int</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">const  (</div><div class=\"line\">\tdbUrl = &quot;127.0.0.1:27017&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">func main()&#123;</div><div class=\"line\"></div><div class=\"line\">\tsession,err := mgo.Dial(dbUrl)</div><div class=\"line\"></div><div class=\"line\">\tif err != err &#123;</div><div class=\"line\">\t\tprintln(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tdefer session.Close()</div><div class=\"line\">\tsession.SetMode(mgo.Monotonic, true) //设置一致性模式</div><div class=\"line\"></div><div class=\"line\">\t//选择数据库</div><div class=\"line\">\tdb := session.DB(&quot;mydb&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//选择数据表</div><div class=\"line\">\tcollection := db.C(&quot;user&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//增  单条插入</div><div class=\"line\">\tp1 := Person&#123;bson.NewObjectId(),&quot;lisi2&quot;, 12&#125;</div><div class=\"line\">\tp2 := Person&#123;bson.NewObjectId(),&quot;lisi2&quot;, 12&#125;</div><div class=\"line\"></div><div class=\"line\">\terr = collection.Insert(&amp;p1, &amp;p2)</div><div class=\"line\"></div><div class=\"line\">\t//批量插入</div><div class=\"line\">\tvar arr []interface&#123;&#125;</div><div class=\"line\">\tarr = append(arr, p1)</div><div class=\"line\">\tarr = append(arr, p2)</div><div class=\"line\">\terr = collection.Insert(arr...)</div><div class=\"line\">\tif err != err &#123;</div><div class=\"line\">\t\tprintln(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t//查第一条</div><div class=\"line\">\tresult := Person&#123;&#125;</div><div class=\"line\">\tcollection.Find(bson.M&#123;&quot;age&quot;:12&#125;).One(&amp;result)</div><div class=\"line\">\tfmt.Println(&quot;restlt&quot;,result)</div><div class=\"line\"></div><div class=\"line\">\t//查多条</div><div class=\"line\">\tresults := []Person&#123;&#125;</div><div class=\"line\">\tcollection.Find(bson.M&#123;&quot;age&quot;:12&#125;).All(&amp;results)</div><div class=\"line\">\tfmt.Println(&quot;results&quot;,results, len(results))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//查表中数据总数</div><div class=\"line\">\tcount, _:= collection.Find(nil).Count()</div><div class=\"line\">\tfmt.Println(count)</div><div class=\"line\"></div><div class=\"line\">\t//查所有</div><div class=\"line\">\tarr2 := make([]Person, 0)</div><div class=\"line\">\titerNew := collection.Find(nil).Iter()</div><div class=\"line\">\terr = iterNew.All(&amp;arr2)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tpanic(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(&quot;arr2&quot;,arr2)</div><div class=\"line\"></div><div class=\"line\">\t//改(不加set就是覆盖)</div><div class=\"line\">\tcollection.Update(bson.M&#123;&quot;name&quot;:&quot;zhangsan&quot;&#125;, bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:22&#125;&#125;)</div><div class=\"line\">\tcollection.Update(bson.M&#123;&quot;age&quot;:22&#125;,bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:23&#125;&#125;)</div><div class=\"line\">\tcollection.Update(bson.M&#123;&quot;name&quot;:&quot;lisi&quot;&#125;, bson.M&#123;&quot;name&quot;:&quot;lisi2&quot;,&quot;age&quot;:22&#125;)</div><div class=\"line\"></div><div class=\"line\">\t//批量更新</div><div class=\"line\">\tcollection.UpdateAll(bson.M&#123;&quot;age&quot;:22&#125;, bson.M&#123;&quot;$set&quot;:bson.M&#123;&quot;age&quot;:44&#125;&#125;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//删</div><div class=\"line\"></div><div class=\"line\">\t//删除符合条件的第一条</div><div class=\"line\">\t//collection.Remove(bson.M&#123;&quot;name&quot;: &quot;lisi2&quot;&#125;)</div><div class=\"line\"></div><div class=\"line\">\t//删除所有</div><div class=\"line\">\t_, err = collection.RemoveAll(bson.M&#123;&quot;name&quot;: &quot;lisi&quot;&#125;)</div><div class=\"line\">\tif err != err &#123;</div><div class=\"line\">\t\tprintln(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//根据ID删除</div><div class=\"line\">\tvar wangwu = Person&#123;&#125;</div><div class=\"line\">\tcollection.Find(bson.M&#123;&quot;name&quot;:&quot;wangwu&quot;&#125;).One(&amp;wangwu)</div><div class=\"line\">\tfmt.Println(wangwu, wangwu.ID.Hex(), wangwu.ID.String())</div><div class=\"line\">\terr =collection.RemoveId(wangwu.ID)</div><div class=\"line\">\tfmt.Println(&quot;delete&quot;,err)</div><div class=\"line\">\t</div><div class=\"line\">\t//删除集合</div><div class=\"line\">  //collection.DropCollection()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"mac下安装go及环境变量配置","date":"2018-04-04T09:10:56.000Z","_content":"\n\n以下命令都是直接在根目录下执行即可\n\n### 方法一：homebrew\n\n`homebrew`是Mac系统下面目前使用最多的管理软件的工具，目前已支持Go，可以通过命令直接安装Go,不过在这之前需要先安装`homebrew`\n\n安装命令\n```\n$ brew update && brew upgrade\n$ brew install go\n```\n安装完输入 `go env` 查看环境信息\n\n```\nGOARCH=\"amd64\"\nGOBIN=\"\"\nGOCACHE=\"/Users/qianjianeng/Library/Caches/go-build\"\nGOEXE=\"\"\nGOHOSTARCH=\"amd64\"\nGOHOSTOS=\"darwin\"\nGOOS=\"darwin\"\nGOPATH=\"/Users/qianjianeng/go\"\nGORACE=\"\"\nGOROOT=\"/usr/local/Cellar/go/1.10/libexec\"\nGOTMPDIR=\"\"\nGOTOOLDIR=\"/usr/local/Cellar/go/1.10/libexec/pkg/tool/darwin_amd64\"\nGCCGO=\"gccgo\"\nCC=\"clang\"\nCXX=\"clang++\"\nCGO_ENABLED=\"1\"\nCGO_CFLAGS=\"-g -O2\"\nCGO_CPPFLAGS=\"\"\nCGO_CXXFLAGS=\"-g -O2\"\nCGO_FFLAGS=\"-g -O2\"\nCGO_LDFLAGS=\"-g -O2\"\nPKG_CONFIG=\"pkg-config\"\nGOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/vj/0nsxxzqd3cgdqnwkzqxqg6zr0000gn/T/go-build786549549=/tmp/go-build -gno-record-gcc-switches -fno-common\"\n```\n<!--more-->\n\n### 方法二：pkg包安装\n\n直接去官方下载安装包，然后双击安装,之后同样地输入`go env`、`go version`等查看是否安装。\n\n### 环境变量配置\n\n#### 打开`bash_profile`\n\n`$ open .bash_profile`\n#### 如果不存在创建bash_profile\n`$ vim ~/.bash_profile`\n\n#### 添加go环境变量\n\n如果是第一种安装方法，只需要指定一下GOPATH即可。为了让自己的程序编译之后在命令行任何地方能直接执行，再加入GOPATH下的bin即可：\n```\n#This is my personal bash_profile,when loaded at login.\n#===2015-08-15===\n\n#GOPATH\nexport GOPATH=$HOME/Documents/go_workspace\n\n#GOPATH bin\nexport PATH=$PATH:$GOPATH/bin\n```\n但是第二种方法安装之后输入go可能会显示ommand not found: go，所以需要在.bash_profile中指定GOROOT下的bin：\n```\n#This is my personal bash_profile,when loaded at login.\n#===2015-08-15===\n#GOROOT\nexport GOROOT=/usr/local/go\n\n#GOPATH\nexport GOPATH=$HOME/Documents/go_workspace\n\n#GOROOT bin\nexport PATH=$PATH:$GOROOT/bin\n\n#GOPATH bin\nexport PATH=$PATH:$GOPATH/bin\n```\n\n一般环境变量更改后，重启后生效。在重启终端的时候就会自动执行.bash_profile文件。\n如果想立刻生效，则可执行下面的语句：\n\n`$ source .bash_profile`\n\n### 注意\n\n如果打开终端没有生效，就把上面添加go环境变量的语句追加到~/.zshrc中：\n\n`$ open .zshrc`\n\n\n","source":"_posts/mac下安装go及环境变量配置.md","raw":"---\ntitle: mac下安装go及环境变量配置\ncategories:\n  - go\ntags:\n  - go\n  - 环境变量\ndate: 2018-04-04 17:10:56\n---\n\n\n以下命令都是直接在根目录下执行即可\n\n### 方法一：homebrew\n\n`homebrew`是Mac系统下面目前使用最多的管理软件的工具，目前已支持Go，可以通过命令直接安装Go,不过在这之前需要先安装`homebrew`\n\n安装命令\n```\n$ brew update && brew upgrade\n$ brew install go\n```\n安装完输入 `go env` 查看环境信息\n\n```\nGOARCH=\"amd64\"\nGOBIN=\"\"\nGOCACHE=\"/Users/qianjianeng/Library/Caches/go-build\"\nGOEXE=\"\"\nGOHOSTARCH=\"amd64\"\nGOHOSTOS=\"darwin\"\nGOOS=\"darwin\"\nGOPATH=\"/Users/qianjianeng/go\"\nGORACE=\"\"\nGOROOT=\"/usr/local/Cellar/go/1.10/libexec\"\nGOTMPDIR=\"\"\nGOTOOLDIR=\"/usr/local/Cellar/go/1.10/libexec/pkg/tool/darwin_amd64\"\nGCCGO=\"gccgo\"\nCC=\"clang\"\nCXX=\"clang++\"\nCGO_ENABLED=\"1\"\nCGO_CFLAGS=\"-g -O2\"\nCGO_CPPFLAGS=\"\"\nCGO_CXXFLAGS=\"-g -O2\"\nCGO_FFLAGS=\"-g -O2\"\nCGO_LDFLAGS=\"-g -O2\"\nPKG_CONFIG=\"pkg-config\"\nGOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/vj/0nsxxzqd3cgdqnwkzqxqg6zr0000gn/T/go-build786549549=/tmp/go-build -gno-record-gcc-switches -fno-common\"\n```\n<!--more-->\n\n### 方法二：pkg包安装\n\n直接去官方下载安装包，然后双击安装,之后同样地输入`go env`、`go version`等查看是否安装。\n\n### 环境变量配置\n\n#### 打开`bash_profile`\n\n`$ open .bash_profile`\n#### 如果不存在创建bash_profile\n`$ vim ~/.bash_profile`\n\n#### 添加go环境变量\n\n如果是第一种安装方法，只需要指定一下GOPATH即可。为了让自己的程序编译之后在命令行任何地方能直接执行，再加入GOPATH下的bin即可：\n```\n#This is my personal bash_profile,when loaded at login.\n#===2015-08-15===\n\n#GOPATH\nexport GOPATH=$HOME/Documents/go_workspace\n\n#GOPATH bin\nexport PATH=$PATH:$GOPATH/bin\n```\n但是第二种方法安装之后输入go可能会显示ommand not found: go，所以需要在.bash_profile中指定GOROOT下的bin：\n```\n#This is my personal bash_profile,when loaded at login.\n#===2015-08-15===\n#GOROOT\nexport GOROOT=/usr/local/go\n\n#GOPATH\nexport GOPATH=$HOME/Documents/go_workspace\n\n#GOROOT bin\nexport PATH=$PATH:$GOROOT/bin\n\n#GOPATH bin\nexport PATH=$PATH:$GOPATH/bin\n```\n\n一般环境变量更改后，重启后生效。在重启终端的时候就会自动执行.bash_profile文件。\n如果想立刻生效，则可执行下面的语句：\n\n`$ source .bash_profile`\n\n### 注意\n\n如果打开终端没有生效，就把上面添加go环境变量的语句追加到~/.zshrc中：\n\n`$ open .zshrc`\n\n\n","slug":"mac下安装go及环境变量配置","published":1,"updated":"2018-05-04T09:13:19.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tet0023lx600fifjlhz","content":"<p>以下命令都是直接在根目录下执行即可</p>\n<h3 id=\"方法一：homebrew\"><a href=\"#方法一：homebrew\" class=\"headerlink\" title=\"方法一：homebrew\"></a>方法一：homebrew</h3><p><code>homebrew</code>是Mac系统下面目前使用最多的管理软件的工具，目前已支持Go，可以通过命令直接安装Go,不过在这之前需要先安装<code>homebrew</code></p>\n<p>安装命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ brew update &amp;&amp; brew upgrade</div><div class=\"line\">$ brew install go</div></pre></td></tr></table></figure></p>\n<p>安装完输入 <code>go env</code> 查看环境信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">GOARCH=&quot;amd64&quot;</div><div class=\"line\">GOBIN=&quot;&quot;</div><div class=\"line\">GOCACHE=&quot;/Users/qianjianeng/Library/Caches/go-build&quot;</div><div class=\"line\">GOEXE=&quot;&quot;</div><div class=\"line\">GOHOSTARCH=&quot;amd64&quot;</div><div class=\"line\">GOHOSTOS=&quot;darwin&quot;</div><div class=\"line\">GOOS=&quot;darwin&quot;</div><div class=\"line\">GOPATH=&quot;/Users/qianjianeng/go&quot;</div><div class=\"line\">GORACE=&quot;&quot;</div><div class=\"line\">GOROOT=&quot;/usr/local/Cellar/go/1.10/libexec&quot;</div><div class=\"line\">GOTMPDIR=&quot;&quot;</div><div class=\"line\">GOTOOLDIR=&quot;/usr/local/Cellar/go/1.10/libexec/pkg/tool/darwin_amd64&quot;</div><div class=\"line\">GCCGO=&quot;gccgo&quot;</div><div class=\"line\">CC=&quot;clang&quot;</div><div class=\"line\">CXX=&quot;clang++&quot;</div><div class=\"line\">CGO_ENABLED=&quot;1&quot;</div><div class=\"line\">CGO_CFLAGS=&quot;-g -O2&quot;</div><div class=\"line\">CGO_CPPFLAGS=&quot;&quot;</div><div class=\"line\">CGO_CXXFLAGS=&quot;-g -O2&quot;</div><div class=\"line\">CGO_FFLAGS=&quot;-g -O2&quot;</div><div class=\"line\">CGO_LDFLAGS=&quot;-g -O2&quot;</div><div class=\"line\">PKG_CONFIG=&quot;pkg-config&quot;</div><div class=\"line\">GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/vj/0nsxxzqd3cgdqnwkzqxqg6zr0000gn/T/go-build786549549=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"方法二：pkg包安装\"><a href=\"#方法二：pkg包安装\" class=\"headerlink\" title=\"方法二：pkg包安装\"></a>方法二：pkg包安装</h3><p>直接去官方下载安装包，然后双击安装,之后同样地输入<code>go env</code>、<code>go version</code>等查看是否安装。</p>\n<h3 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h3><h4 id=\"打开bash-profile\"><a href=\"#打开bash-profile\" class=\"headerlink\" title=\"打开bash_profile\"></a>打开<code>bash_profile</code></h4><p><code>$ open .bash_profile</code></p>\n<h4 id=\"如果不存在创建bash-profile\"><a href=\"#如果不存在创建bash-profile\" class=\"headerlink\" title=\"如果不存在创建bash_profile\"></a>如果不存在创建bash_profile</h4><p><code>$ vim ~/.bash_profile</code></p>\n<h4 id=\"添加go环境变量\"><a href=\"#添加go环境变量\" class=\"headerlink\" title=\"添加go环境变量\"></a>添加go环境变量</h4><p>如果是第一种安装方法，只需要指定一下GOPATH即可。为了让自己的程序编译之后在命令行任何地方能直接执行，再加入GOPATH下的bin即可：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#This is my personal bash_profile,when loaded at login.</div><div class=\"line\">#===2015-08-15===</div><div class=\"line\"></div><div class=\"line\">#GOPATH</div><div class=\"line\">export GOPATH=$HOME/Documents/go_workspace</div><div class=\"line\"></div><div class=\"line\">#GOPATH bin</div><div class=\"line\">export PATH=$PATH:$GOPATH/bin</div></pre></td></tr></table></figure></p>\n<p>但是第二种方法安装之后输入go可能会显示ommand not found: go，所以需要在.bash_profile中指定GOROOT下的bin：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">#This is my personal bash_profile,when loaded at login.</div><div class=\"line\">#===2015-08-15===</div><div class=\"line\">#GOROOT</div><div class=\"line\">export GOROOT=/usr/local/go</div><div class=\"line\"></div><div class=\"line\">#GOPATH</div><div class=\"line\">export GOPATH=$HOME/Documents/go_workspace</div><div class=\"line\"></div><div class=\"line\">#GOROOT bin</div><div class=\"line\">export PATH=$PATH:$GOROOT/bin</div><div class=\"line\"></div><div class=\"line\">#GOPATH bin</div><div class=\"line\">export PATH=$PATH:$GOPATH/bin</div></pre></td></tr></table></figure></p>\n<p>一般环境变量更改后，重启后生效。在重启终端的时候就会自动执行.bash_profile文件。<br>如果想立刻生效，则可执行下面的语句：</p>\n<p><code>$ source .bash_profile</code></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>如果打开终端没有生效，就把上面添加go环境变量的语句追加到~/.zshrc中：</p>\n<p><code>$ open .zshrc</code></p>\n","excerpt":"<p>以下命令都是直接在根目录下执行即可</p>\n<h3 id=\"方法一：homebrew\"><a href=\"#方法一：homebrew\" class=\"headerlink\" title=\"方法一：homebrew\"></a>方法一：homebrew</h3><p><code>homebrew</code>是Mac系统下面目前使用最多的管理软件的工具，目前已支持Go，可以通过命令直接安装Go,不过在这之前需要先安装<code>homebrew</code></p>\n<p>安装命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ brew update &amp;&amp; brew upgrade</div><div class=\"line\">$ brew install go</div></pre></td></tr></table></figure></p>\n<p>安装完输入 <code>go env</code> 查看环境信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">GOARCH=&quot;amd64&quot;</div><div class=\"line\">GOBIN=&quot;&quot;</div><div class=\"line\">GOCACHE=&quot;/Users/qianjianeng/Library/Caches/go-build&quot;</div><div class=\"line\">GOEXE=&quot;&quot;</div><div class=\"line\">GOHOSTARCH=&quot;amd64&quot;</div><div class=\"line\">GOHOSTOS=&quot;darwin&quot;</div><div class=\"line\">GOOS=&quot;darwin&quot;</div><div class=\"line\">GOPATH=&quot;/Users/qianjianeng/go&quot;</div><div class=\"line\">GORACE=&quot;&quot;</div><div class=\"line\">GOROOT=&quot;/usr/local/Cellar/go/1.10/libexec&quot;</div><div class=\"line\">GOTMPDIR=&quot;&quot;</div><div class=\"line\">GOTOOLDIR=&quot;/usr/local/Cellar/go/1.10/libexec/pkg/tool/darwin_amd64&quot;</div><div class=\"line\">GCCGO=&quot;gccgo&quot;</div><div class=\"line\">CC=&quot;clang&quot;</div><div class=\"line\">CXX=&quot;clang++&quot;</div><div class=\"line\">CGO_ENABLED=&quot;1&quot;</div><div class=\"line\">CGO_CFLAGS=&quot;-g -O2&quot;</div><div class=\"line\">CGO_CPPFLAGS=&quot;&quot;</div><div class=\"line\">CGO_CXXFLAGS=&quot;-g -O2&quot;</div><div class=\"line\">CGO_FFLAGS=&quot;-g -O2&quot;</div><div class=\"line\">CGO_LDFLAGS=&quot;-g -O2&quot;</div><div class=\"line\">PKG_CONFIG=&quot;pkg-config&quot;</div><div class=\"line\">GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/vj/0nsxxzqd3cgdqnwkzqxqg6zr0000gn/T/go-build786549549=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;</div></pre></td></tr></table></figure>","more":"<h3 id=\"方法二：pkg包安装\"><a href=\"#方法二：pkg包安装\" class=\"headerlink\" title=\"方法二：pkg包安装\"></a>方法二：pkg包安装</h3><p>直接去官方下载安装包，然后双击安装,之后同样地输入<code>go env</code>、<code>go version</code>等查看是否安装。</p>\n<h3 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h3><h4 id=\"打开bash-profile\"><a href=\"#打开bash-profile\" class=\"headerlink\" title=\"打开bash_profile\"></a>打开<code>bash_profile</code></h4><p><code>$ open .bash_profile</code></p>\n<h4 id=\"如果不存在创建bash-profile\"><a href=\"#如果不存在创建bash-profile\" class=\"headerlink\" title=\"如果不存在创建bash_profile\"></a>如果不存在创建bash_profile</h4><p><code>$ vim ~/.bash_profile</code></p>\n<h4 id=\"添加go环境变量\"><a href=\"#添加go环境变量\" class=\"headerlink\" title=\"添加go环境变量\"></a>添加go环境变量</h4><p>如果是第一种安装方法，只需要指定一下GOPATH即可。为了让自己的程序编译之后在命令行任何地方能直接执行，再加入GOPATH下的bin即可：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">#This is my personal bash_profile,when loaded at login.</div><div class=\"line\">#===2015-08-15===</div><div class=\"line\"></div><div class=\"line\">#GOPATH</div><div class=\"line\">export GOPATH=$HOME/Documents/go_workspace</div><div class=\"line\"></div><div class=\"line\">#GOPATH bin</div><div class=\"line\">export PATH=$PATH:$GOPATH/bin</div></pre></td></tr></table></figure></p>\n<p>但是第二种方法安装之后输入go可能会显示ommand not found: go，所以需要在.bash_profile中指定GOROOT下的bin：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">#This is my personal bash_profile,when loaded at login.</div><div class=\"line\">#===2015-08-15===</div><div class=\"line\">#GOROOT</div><div class=\"line\">export GOROOT=/usr/local/go</div><div class=\"line\"></div><div class=\"line\">#GOPATH</div><div class=\"line\">export GOPATH=$HOME/Documents/go_workspace</div><div class=\"line\"></div><div class=\"line\">#GOROOT bin</div><div class=\"line\">export PATH=$PATH:$GOROOT/bin</div><div class=\"line\"></div><div class=\"line\">#GOPATH bin</div><div class=\"line\">export PATH=$PATH:$GOPATH/bin</div></pre></td></tr></table></figure></p>\n<p>一般环境变量更改后，重启后生效。在重启终端的时候就会自动执行.bash_profile文件。<br>如果想立刻生效，则可执行下面的语句：</p>\n<p><code>$ source .bash_profile</code></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>如果打开终端没有生效，就把上面添加go环境变量的语句追加到~/.zshrc中：</p>\n<p><code>$ open .zshrc</code></p>"},{"title":"runtime详解","author":[{"name":"千寻墨","url":"http://www.jianshu.com/users/527ecf8c8753/latest_articles"}],"date":"2016-04-16T08:59:52.000Z","_content":"\n公司项目用到一个三方开源库，里面有个bug，不能改动源码，我想来想去，只能通过runtime这个万能的手段来解决。但是runtime 并不怎么会用，怎么办，马上学习呗。说到runtime，它是Objective-c里面最核心的技术，被人们传呼的神乎其神，但是感觉有一层神秘的面纱笼罩其上，毕竟使用场景不多，相信大多数开发者都不会熟练的运用。而网络上也有无数的文章来讲解runtime，但是真的非常的乱，非常的碎片化，很少有讲解的比较全面的。\n   \n最初是在onevcat的博客上看到runtime的[runtime的博客](https://onevcat.com/2012/04/objective-c-runtime/)，说句实话，看完后我还是蒙的，这里面主要讲了一下runtime 比较核心的功能-Method Swizzling，不过看完后还是有些不知如何下手的感觉。下面是我自己对runtime的整理，从零开始，由浅入深，并且带了几个runtime实际的应用场景。看完之后，你可以再回过头来看喵神的这篇文章，应该就能看的懂了。\n\n### 一：基本概念\nRuntime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在[这里](http://opensource.apple.com//source/objc4/)下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。\n\n* RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。\n* 对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。\n* OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。\n* 只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。\n\n### 二：runtime的具体实现\n我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。\n每一个oc的方法，底层必然有一个与之对应的runtime方法。\n<!-- more -->\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/1.png)\n\n- 当我们用OC写下这样一段代码\n`[tableView cellForRowAtIndexPath:indexPath];`\n\n- 在编译时RunTime会将上述代码转化成[发送消息]\n`objc_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath);`\n\n### 三:常见方法\n\n `unsigned int count; `\n \n - 获取属性列表\n \n ```\nobjc_property_t *propertyList = class_copyPropertyList([self class], &count);\n    for (unsigned int i=0; i<count; i++) {\n        const char *propertyName = property_getName(propertyList[i]);\n        NSLog(@\"property---->%@\", [NSString stringWithUTF8String:propertyName]);\n    }\n```\n\n - 获取方法列表\n \n ```\n    Method *methodList = class_copyMethodList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Method method = methodList[i];\n        NSLog(@\"method---->%@\", NSStringFromSelector(method_getName(method)));\n    }\n```\n\n- 获取成员变量列表\n    \n  ```  \n  Ivar *ivarList = class_copyIvarList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Ivar myIvar = ivarList[i];\n        const char *ivarName = ivar_getName(myIvar);\n        NSLog(@\"Ivar---->%@\", [NSString stringWithUTF8String:ivarName]);\n    } \n  ```\n \n- 获取协议列表\n \n ```   \n __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Protocol *myProtocal = protocolList[i];\n        const char *protocolName = protocol_getName(myProtocal);\n        NSLog(@\"protocol---->%@\", [NSString stringWithUTF8String:protocolName]);\n    }\n  ``` \n  \n>现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法\n\n- 获得类方法\n\n```\nClass PersonClass = object_getClass([Person class]);\nSEL oriSEL = @selector(test1);\nMethod oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);\n```   \n\n- 获得实例方法\n  \n```\nClass PersonClass = object_getClass([xiaoming class]);\nSEL oriSEL = @selector(test2);\nMethod cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);\n```   \n- 添加方法\n\n```\nBOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n```\n\n- 替换原方法实现\n\n```\nclass_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n```\n- 交换两个方法\n\n```\nmethod_exchangeImplementations(oriMethod, cusMethod);\n```\n    \n    \n    \n### 四：常见作用\n- 动态的添加对象的成员变量和方法\n- 动态交换两个方法的实现\n- 拦截并替换方法\n- 在方法上增加额外功能\n- 实现NSCoding的自动归档和解档\n- 实现字典转模型的自动转换\n\n### 五：代码实现\n要使用runtime，要先引入头文件`#import <objc/runtime.h>`\n这些代码的实例有浅入深逐步讲解，最后附上一个我在公司项目中遇到的一个实际问题。\n\n#### 1. 动态变量控制\n   在程序中，xiaoming的age是10，后来被runtime变成了20，来看看runtime是怎么做到的。\n   \n##### 1.动态获取XiaoMing类中的所有属性[当然包括私有]  \n\n\t`Ivar *ivar = class_copyIvarList([self.xiaoming class], &count);`  \n\n##### 2.遍历属性找到对应name字段  \n\n\t`const char *varName = ivar_getName(var);`\n\n##### 3.修改对应的字段值成20 \n\t\n\t`object_setIvar(self.xiaoMing, var, @\"20\");`  \n\t\n##### 4.代码参考\n\n```\n-(void)answer{\n    \tunsigned int count = 0;\n    \tIvar *ivar = class_copyIvarList([self.xiaoMing class], &count);\n    \tfor (int i = 0; i<count; i++) {\n        \tIvar var = ivar[i];\n        \tconst char *varName = ivar_getName(var);\n        \tNSString *name = [NSString stringWithUTF8String:varName];\n        \tif ([name isEqualToString:@\"_age\"]) {\n            \tobject_setIvar(self.xiaoMing, var, @\"20\");\n            \tbreak;\n        \t}\n    \t}\n    \tNSLog(@\"XiaoMing's age is %@\",self.xiaoMing.age);\n\t}\n```\n\n#### 2.动态添加方法\n\n在程序当中，假设XiaoMing的中没有`guess`这个方法，后来被Runtime添加一个名字叫guess的方法，最终再调用guess方法做出相应。那么，Runtime是如何做到的呢？  \n  \n##### 1.动态给XiaoMing类中添加guess方法：  \n\n```\n\tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, \"v@:\");\n```\n\n这里参数地方说明一下：\n\n>(IMP)guessAnswer 意思是guessAnswer的地址指针;\n>\"v@:\" 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;\n>“v@:@@” 意思是，两个参数的没有返回值。  \n\n\n##### 2.调用guess方法响应事件：  \n\n\t[self.xiaoMing performSelector:@selector(guess)];\n\n##### 3.编写guessAnswer的实现：  \n\t\n\t\n\tvoid guessAnswer(id self,SEL _cmd){\n    \tNSLog(@\"i am from beijing\");   \n\t} \n\t\n\n这个有两个地方留意一下：\n* void的前面没有+、-号，因为只是C的代码。\n* 必须有两个指定参数(id self,SEL _cmd)  \n\n##### 4.代码参考\n\n```  \n\t-(void)answer{\n    \tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, \"v@:\");\n    \tif ([self.xiaoMing respondsToSelector:@selector(guess)]) {\n        \n        \t[self.xiaoMing performSelector:@selector(guess)];\n        \n    \t} else{\n        \tNSLog(@\"Sorry,I don't know\");\n    \t}\n\t}\n\n\tvoid guessAnswer(id self,SEL _cmd){\n   \n    \tNSLog(@\"i am from beijing\");\n    \n\t}\n```\n\n#### 3：动态交换两个方法的实现\n\n在程序当中，假设XiaoMing的中有`test1` 和 `test2`这两个方法，后来被Runtime交换方法后，每次调动`test1` 的时候就会去执行`test2`，调动`test2` 的时候就会去执行`test1`， 。那么，Runtime是如何做到的呢？\n\n##### 1. 获取这个类中的两个方法并交换\n\n```\nMethod m1 = class_getInstanceMethod([self.xiaoMing class], @selector(test1));\n    Method m2 = class_getInstanceMethod([self.xiaoMing class], @selector(test2));\n    method_exchangeImplementations(m1, m2);\n```\n交换方法之后，以后每次调用这两个方法都会交换方法的实现\n\n#### 4：拦截并替换方法\n\n在程序当中，假设XiaoMing的中有`test1`这个方法，但是由于某种原因，我们要改变这个方法的实现，但是又不能去动它的源代码(正如一些开源库出现问题的时候)，这个时候runtime就派上用场了。\n\n我们先增加一个tool类，然后写一个我们自己实现的方法-change，\n通过runtime把test1替换成change。\n\n```\nClass PersionClass = object_getClass([Person class]);\nClass toolClass = object_getClass([tool class]);\n\n    ////源方法的SEL和Method\n    \n    SEL oriSEL = @selector(test1);\n    Method oriMethod = class_getInstanceMethod(PersionClass, oriSEL);\n    \n    ////交换方法的SEL和Method\n    \n    SEL cusSEL = @selector(change);\n    Method cusMethod = class_getInstanceMethod(toolClass, cusSEL);\n    \n    ////先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况\n    \n    BOOL addSucc = class_addMethod(PersionClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n    if (addSucc) {\n          // 添加成功：将源方法的实现替换到交换方法的实现     \n        class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n               \n    }else {\n    //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即\nmethod_exchangeImplementations(oriMethod, cusMethod);  \n  }\n \n```\n\n#### 5：在方法上增加额外功能\n\n有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决：\n\n```\n@implementation UIButton (Hook)\n\n+ (void)load {\n\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n\n        Class selfClass = [self class];\n\n        SEL oriSEL = @selector(sendAction:to:forEvent:);\n        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);\n\n        SEL cusSEL = @selector(mySendAction:to:forEvent:);\n        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);\n\n        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n        if (addSucc) {\n            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n        }else {\n            method_exchangeImplementations(oriMethod, cusMethod);\n        }\n\n    });\n}\n\n- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {\n    [CountTool addClickCount];\n    [self mySendAction:action to:target forEvent:event];\n}\n\n@end\n```\n\nload方法会在类第一次加载的时候被调用,调用的时间比较靠前，适合在这个方法里做方法交换,方法交换应该被保证，在程序中只会执行一次。\n\n#### 6.实现NSCoding的自动归档和解档\n\n如果你实现过自定义模型数据持久化的过程，那么你也肯定明白，如果一个模型有许多个属性，那么我们需要对每个属性都实现一遍`encodeObject` 和 `decodeObjectForKey`方法，如果这样的模型又有很多个，这还真的是一个十分麻烦的事情。下面来看看简单的实现方式。\n假设现在有一个Movie类，有3个属性，它的`h`文件这这样的\n\n```\n#import <Foundation/Foundation.h>\n\n//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding\n@interface Movie : NSObject<NSCoding>\n\n@property (nonatomic, copy) NSString *movieId;\n@property (nonatomic, copy) NSString *movieName;\n@property (nonatomic, copy) NSString *pic_url;\n\n@end\n\n```\n\n如果是正常写法， `m`文件应该是这样的：\n\n```\n#import \"Movie.h\"\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)aCoder\n{\n    [aCoder encodeObject:_movieId forKey:@\"id\"];\n    [aCoder encodeObject:_movieName forKey:@\"name\"];\n    [aCoder encodeObject:_pic_url forKey:@\"url\"];\n    \n}\n\n- (id)initWithCoder:(NSCoder *)aDecoder\n{\n    if (self = [super init]) {\n        self.movieId = [aDecoder decodeObjectForKey:@\"id\"];\n        self.movieName = [aDecoder decodeObjectForKey:@\"name\"];\n        self.pic_url = [aDecoder decodeObjectForKey:@\"url\"];\n    }\n    return self;\n}\n@end\n```\n如果这里有100个属性，那么我们也只能把100个属性都给写一遍。\n不过你会使用runtime后，这里就有更简便的方法。\n下面看看runtime的实现方式：\n\n```\n#import \"Movie.h\"\n#import <objc/runtime.h>\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)encoder\n\n{\n    unsigned int count = 0;\n    Ivar *ivars = class_copyIvarList([Movie class], &count);\n    \n    for (int i = 0; i<count; i++) {\n        // 取出i位置对应的成员变量\n        Ivar ivar = ivars[i];\n        // 查看成员变量\n        const char *name = ivar_getName(ivar);\n        // 归档\n        NSString *key = [NSString stringWithUTF8String:name];\n        id value = [self valueForKey:key];\n        [encoder encodeObject:value forKey:key];\n    }\n    free(ivars);\n}\n\n- (id)initWithCoder:(NSCoder *)decoder\n{\n    if (self = [super init]) {\n        unsigned int count = 0;\n        Ivar *ivars = class_copyIvarList([Movie class], &count);\n        for (int i = 0; i<count; i++) {\n        // 取出i位置对应的成员变量\n        Ivar ivar = ivars[i];\n        // 查看成员变量\n        const char *name = ivar_getName(ivar);\n       // 归档\n       NSString *key = [NSString stringWithUTF8String:name];\n      id value = [decoder decodeObjectForKey:key];\n       // 设置到成员变量身上\n        [self setValue:value forKey:key];\n            \n        }\n        free(ivars);\n    } \n    return self;\n}\n@end\n```\n\n这样的方式实现，不管有多少个属性，写这几行代码就搞定了。怎么，还嫌麻烦，下面看看更加简便的方法：两句代码搞定。\n我们把`encodeWithCoder` 和 `initWithCoder`这两个方法抽成宏\n\n```\n#import \"Movie.h\"\n#import <objc/runtime.h>\n\n#define encodeRuntime(A) \\\n\\\nunsigned int count = 0;\\\nIvar *ivars = class_copyIvarList([A class], &count);\\\nfor (int i = 0; i<count; i++) {\\\nIvar ivar = ivars[i];\\\nconst char *name = ivar_getName(ivar);\\\nNSString *key = [NSString stringWithUTF8String:name];\\\nid value = [self valueForKey:key];\\\n[encoder encodeObject:value forKey:key];\\\n}\\\nfree(ivars);\\\n\\\n\n\n\n#define initCoderRuntime(A) \\\n\\\nif (self = [super init]) {\\\nunsigned int count = 0;\\\nIvar *ivars = class_copyIvarList([A class], &count);\\\nfor (int i = 0; i<count; i++) {\\\nIvar ivar = ivars[i];\\\nconst char *name = ivar_getName(ivar);\\\nNSString *key = [NSString stringWithUTF8String:name];\\\nid value = [decoder decodeObjectForKey:key];\\\n[self setValue:value forKey:key];\\\n}\\\nfree(ivars);\\\n}\\\nreturn self;\\\n\\\n\n\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)encoder\n\n{\n    encodeRuntime(Movie)\n}\n\n- (id)initWithCoder:(NSCoder *)decoder\n{\n    initCoderRuntime(Movie)\n}\n@end\n```\n我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。\n\n#### 7.实现字典转模型的自动转换\n\n字典转模型的应用可以说是每个app必然会使用的场景,虽然实现的方式略有不同，但是原理都是一致的：遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。\n像几个出名的开源库：JSONModel,MJExtension等都是通过这种方式实现的。\n\n- 先实现最外层的属性转换\n\n```\n   // 创建对应模型对象\n    id objc = [[self alloc] init];\n\n    unsigned int count = 0;\n\n    // 1.获取成员属性数组\n    Ivar *ivarList = class_copyIvarList(self, &count);\n\n    // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值\n    for (int i = 0; i < count; i++) {\n\n        // 2.1 获取成员属性\n        Ivar ivar = ivarList[i];\n\n        // 2.2 获取成员属性名 C -> OC 字符串\n       NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];\n\n        // 2.3 _成员属性名 => 字典key\n        NSString *key = [ivarName substringFromIndex:1];\n\n        // 2.4 去字典中取出对应value给模型属性赋值\n        id value = dict[key];\n\n        // 获取成员属性类型\n        NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n        }\n```\n\n如果模型比较简单，只有NSString，NSNumber等，这样就可以搞定了。但是如果模型含有NSArray，或者NSDictionary等，那么我们还需要进行第二步转换。\n\n- 内层数组，字典的转换\n\n```\nif ([value isKindOfClass:[NSDictionary class]] && ![ivarType containsString:@\"NS\"]) { \n\n             //  是字典对象,并且属性名对应类型是自定义类型\n            // 处理类型字符串 @\\\"User\\\" -> User\n            ivarType = [ivarType stringByReplacingOccurrencesOfString:@\"@\" withString:@\"\"];\n            ivarType = [ivarType stringByReplacingOccurrencesOfString:@\"\\\"\" withString:@\"\"];\n            // 自定义对象,并且值是字典\n            // value:user字典 -> User模型\n            // 获取模型(user)类对象\n            Class modalClass = NSClassFromString(ivarType);\n\n            // 字典转模型\n            if (modalClass) {\n                // 字典转模型 user\n                value = [modalClass objectWithDict:value];\n            }\n\n        }\n        \n        if ([value isKindOfClass:[NSArray class]]) {\n            // 判断对应类有没有实现字典数组转模型数组的协议\n            if ([self respondsToSelector:@selector(arrayContainModelClass)]) {\n\n                // 转换成id类型，就能调用任何对象的方法\n                id idSelf = self;\n\n                // 获取数组中字典对应的模型\n                NSString *type =  [idSelf arrayContainModelClass][key];\n\n                // 生成模型\n                Class classModel = NSClassFromString(type);\n                NSMutableArray *arrM = [NSMutableArray array];\n                // 遍历字典数组，生成模型数组\n                for (NSDictionary *dict in value) {\n                    // 字典转模型\n                    id model =  [classModel objectWithDict:dict];\n                    [arrM addObject:model];\n                }\n\n                // 把模型数组赋值给value\n                value = arrM;\n\n            }\n        }\n```\n我自己觉得系统自带的KVC模式字典转模型就挺好的，假设movie是一个模型对象，dict 是一个需要转化的 `[movie setValuesForKeysWithDictionary:dict];` 这个是系统自带的字典转模型方法，个人感觉也还是挺好用的，不过使用这个方法的时候需要在模型里面再实现一个方法才行，\n`- (void)setValue:(id)value forUndefinedKey:(NSString *)key` 重写这个方法为了实现两个目的：1. 模型中的属性和字典中的key不一致的情况，比如字典中有个`id`,我们需要把它赋值给`uid`属性；2. 字典中属性比模型的属性还多的情况。\n如果出现以上两种情况而没有实现这个方法的话，程序就会崩溃。\n这个方法的实现：\n\n```\n- (void)setValue:(id)value forUndefinedKey:(NSString *)key\n{\n    if ([key isEqualToString:@\"id\"]) {\n        self.uid = value;\n    }\n}\n```\n### 六.几个参数概念\n\n以上的几种方法应该算是runtime在实际场景中所应用的大部分的情况了，平常的编码中差不多足够用了。\n如果从头仔细看到尾，相信你基本的用法应该会了，虽然会用是主要的目的，有几个基本的参数概念还是要了解一下的。\n\n#### 1.objc_msgSend \n \n ```\n /* Basic Messaging Primitives\n *\n * On some architectures, use objc_msgSend_stret for some struct return types.\n * On some architectures, use objc_msgSend_fpret for some float return types.\n * On some architectures, use objc_msgSend_fp2ret for some float return types.\n *\n * These functions must be cast to an appropriate function pointer type \n * before being called. \n */\n ```\n\n这是官方的声明，从这个函数的注释可以看出来了，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用`objc_msgSend_stret`来发送返回值类型为结构体的消息，使用`objc_msgSend_fpret`来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用objc_msgSend_fp2ret来发送返回值类型为浮点类型的消息。\n最关键的一点：无论何时，要调用`objc_msgSend`函数，必须要将函数强制转换成合适的函数指针类型才能调用。\n从`objc_msgSend`函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。\n其实编译器会根据情况在`objc_msgSend`, `objc_msgSend_stret`, `objc_msgSendSuper`, 或 `objc_msgSendSuper_stret`四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有`”Super”`的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有`”stret”`的函数。\n\n#### 2.SEL\n\n`objc_msgSend`函数第二个参数类型为SEL，它是`selector在Objc`中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:\n`typedef struct objc_selector *SEL`;\n其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令`@selector()`或者 Runtime 系统的`sel_registerName`函数来获得一个SEL类型的方法选择器。\n不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法)，Cocoa 中有好多长长的方法哦。\n#### 3.id\n`objc_msgSend`第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：\n`typedef struct objc_object *id`;\n那objc_object又是啥呢：\n`struct objc_object { Class isa; }`;\n`objc_object`结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。\nPS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见[官方文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html).\n#### 4.Class\n之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：\n`typedef struct objc_class *Class`;\nobjc_class里面的东西多着呢：\n\n```\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n#if  !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。\n在`objc_class`结构体中：`ivars是objc_ivar_list`指针；`methodLists`是指向`objc_method_list`指针的指针。也就是说可以动态修改 `*methodLists` 的值来添加成员方法，这也是Category实现的原理.\n\n上面讲到的所有东西都在Demo里，如果你觉得不错，还请为我的Demo star一个。\n[demo下载](https://github.com/suifengqjn/runtime)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/2.png)\n\n\n\n\n\n\n","source":"_posts/runtime详解.md","raw":"\n---\ntitle: runtime详解\ntags:\n  - iOS\n  - runtime\n  - Method Swizzling\ncategories:\n  - iOS技术\nauthor:\n  - name: 千寻墨\n    url: 'http://www.jianshu.com/users/527ecf8c8753/latest_articles'\ndate: 2016-04-16 16:59:52\n---\n\n公司项目用到一个三方开源库，里面有个bug，不能改动源码，我想来想去，只能通过runtime这个万能的手段来解决。但是runtime 并不怎么会用，怎么办，马上学习呗。说到runtime，它是Objective-c里面最核心的技术，被人们传呼的神乎其神，但是感觉有一层神秘的面纱笼罩其上，毕竟使用场景不多，相信大多数开发者都不会熟练的运用。而网络上也有无数的文章来讲解runtime，但是真的非常的乱，非常的碎片化，很少有讲解的比较全面的。\n   \n最初是在onevcat的博客上看到runtime的[runtime的博客](https://onevcat.com/2012/04/objective-c-runtime/)，说句实话，看完后我还是蒙的，这里面主要讲了一下runtime 比较核心的功能-Method Swizzling，不过看完后还是有些不知如何下手的感觉。下面是我自己对runtime的整理，从零开始，由浅入深，并且带了几个runtime实际的应用场景。看完之后，你可以再回过头来看喵神的这篇文章，应该就能看的懂了。\n\n### 一：基本概念\nRuntime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在[这里](http://opensource.apple.com//source/objc4/)下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。\n\n* RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。\n* 对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。\n* OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。\n* 只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。\n\n### 二：runtime的具体实现\n我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。\n每一个oc的方法，底层必然有一个与之对应的runtime方法。\n<!-- more -->\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/1.png)\n\n- 当我们用OC写下这样一段代码\n`[tableView cellForRowAtIndexPath:indexPath];`\n\n- 在编译时RunTime会将上述代码转化成[发送消息]\n`objc_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath);`\n\n### 三:常见方法\n\n `unsigned int count; `\n \n - 获取属性列表\n \n ```\nobjc_property_t *propertyList = class_copyPropertyList([self class], &count);\n    for (unsigned int i=0; i<count; i++) {\n        const char *propertyName = property_getName(propertyList[i]);\n        NSLog(@\"property---->%@\", [NSString stringWithUTF8String:propertyName]);\n    }\n```\n\n - 获取方法列表\n \n ```\n    Method *methodList = class_copyMethodList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Method method = methodList[i];\n        NSLog(@\"method---->%@\", NSStringFromSelector(method_getName(method)));\n    }\n```\n\n- 获取成员变量列表\n    \n  ```  \n  Ivar *ivarList = class_copyIvarList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Ivar myIvar = ivarList[i];\n        const char *ivarName = ivar_getName(myIvar);\n        NSLog(@\"Ivar---->%@\", [NSString stringWithUTF8String:ivarName]);\n    } \n  ```\n \n- 获取协议列表\n \n ```   \n __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Protocol *myProtocal = protocolList[i];\n        const char *protocolName = protocol_getName(myProtocal);\n        NSLog(@\"protocol---->%@\", [NSString stringWithUTF8String:protocolName]);\n    }\n  ``` \n  \n>现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法\n\n- 获得类方法\n\n```\nClass PersonClass = object_getClass([Person class]);\nSEL oriSEL = @selector(test1);\nMethod oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);\n```   \n\n- 获得实例方法\n  \n```\nClass PersonClass = object_getClass([xiaoming class]);\nSEL oriSEL = @selector(test2);\nMethod cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);\n```   \n- 添加方法\n\n```\nBOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n```\n\n- 替换原方法实现\n\n```\nclass_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n```\n- 交换两个方法\n\n```\nmethod_exchangeImplementations(oriMethod, cusMethod);\n```\n    \n    \n    \n### 四：常见作用\n- 动态的添加对象的成员变量和方法\n- 动态交换两个方法的实现\n- 拦截并替换方法\n- 在方法上增加额外功能\n- 实现NSCoding的自动归档和解档\n- 实现字典转模型的自动转换\n\n### 五：代码实现\n要使用runtime，要先引入头文件`#import <objc/runtime.h>`\n这些代码的实例有浅入深逐步讲解，最后附上一个我在公司项目中遇到的一个实际问题。\n\n#### 1. 动态变量控制\n   在程序中，xiaoming的age是10，后来被runtime变成了20，来看看runtime是怎么做到的。\n   \n##### 1.动态获取XiaoMing类中的所有属性[当然包括私有]  \n\n\t`Ivar *ivar = class_copyIvarList([self.xiaoming class], &count);`  \n\n##### 2.遍历属性找到对应name字段  \n\n\t`const char *varName = ivar_getName(var);`\n\n##### 3.修改对应的字段值成20 \n\t\n\t`object_setIvar(self.xiaoMing, var, @\"20\");`  \n\t\n##### 4.代码参考\n\n```\n-(void)answer{\n    \tunsigned int count = 0;\n    \tIvar *ivar = class_copyIvarList([self.xiaoMing class], &count);\n    \tfor (int i = 0; i<count; i++) {\n        \tIvar var = ivar[i];\n        \tconst char *varName = ivar_getName(var);\n        \tNSString *name = [NSString stringWithUTF8String:varName];\n        \tif ([name isEqualToString:@\"_age\"]) {\n            \tobject_setIvar(self.xiaoMing, var, @\"20\");\n            \tbreak;\n        \t}\n    \t}\n    \tNSLog(@\"XiaoMing's age is %@\",self.xiaoMing.age);\n\t}\n```\n\n#### 2.动态添加方法\n\n在程序当中，假设XiaoMing的中没有`guess`这个方法，后来被Runtime添加一个名字叫guess的方法，最终再调用guess方法做出相应。那么，Runtime是如何做到的呢？  \n  \n##### 1.动态给XiaoMing类中添加guess方法：  \n\n```\n\tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, \"v@:\");\n```\n\n这里参数地方说明一下：\n\n>(IMP)guessAnswer 意思是guessAnswer的地址指针;\n>\"v@:\" 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;\n>“v@:@@” 意思是，两个参数的没有返回值。  \n\n\n##### 2.调用guess方法响应事件：  \n\n\t[self.xiaoMing performSelector:@selector(guess)];\n\n##### 3.编写guessAnswer的实现：  \n\t\n\t\n\tvoid guessAnswer(id self,SEL _cmd){\n    \tNSLog(@\"i am from beijing\");   \n\t} \n\t\n\n这个有两个地方留意一下：\n* void的前面没有+、-号，因为只是C的代码。\n* 必须有两个指定参数(id self,SEL _cmd)  \n\n##### 4.代码参考\n\n```  \n\t-(void)answer{\n    \tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, \"v@:\");\n    \tif ([self.xiaoMing respondsToSelector:@selector(guess)]) {\n        \n        \t[self.xiaoMing performSelector:@selector(guess)];\n        \n    \t} else{\n        \tNSLog(@\"Sorry,I don't know\");\n    \t}\n\t}\n\n\tvoid guessAnswer(id self,SEL _cmd){\n   \n    \tNSLog(@\"i am from beijing\");\n    \n\t}\n```\n\n#### 3：动态交换两个方法的实现\n\n在程序当中，假设XiaoMing的中有`test1` 和 `test2`这两个方法，后来被Runtime交换方法后，每次调动`test1` 的时候就会去执行`test2`，调动`test2` 的时候就会去执行`test1`， 。那么，Runtime是如何做到的呢？\n\n##### 1. 获取这个类中的两个方法并交换\n\n```\nMethod m1 = class_getInstanceMethod([self.xiaoMing class], @selector(test1));\n    Method m2 = class_getInstanceMethod([self.xiaoMing class], @selector(test2));\n    method_exchangeImplementations(m1, m2);\n```\n交换方法之后，以后每次调用这两个方法都会交换方法的实现\n\n#### 4：拦截并替换方法\n\n在程序当中，假设XiaoMing的中有`test1`这个方法，但是由于某种原因，我们要改变这个方法的实现，但是又不能去动它的源代码(正如一些开源库出现问题的时候)，这个时候runtime就派上用场了。\n\n我们先增加一个tool类，然后写一个我们自己实现的方法-change，\n通过runtime把test1替换成change。\n\n```\nClass PersionClass = object_getClass([Person class]);\nClass toolClass = object_getClass([tool class]);\n\n    ////源方法的SEL和Method\n    \n    SEL oriSEL = @selector(test1);\n    Method oriMethod = class_getInstanceMethod(PersionClass, oriSEL);\n    \n    ////交换方法的SEL和Method\n    \n    SEL cusSEL = @selector(change);\n    Method cusMethod = class_getInstanceMethod(toolClass, cusSEL);\n    \n    ////先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况\n    \n    BOOL addSucc = class_addMethod(PersionClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n    if (addSucc) {\n          // 添加成功：将源方法的实现替换到交换方法的实现     \n        class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n               \n    }else {\n    //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即\nmethod_exchangeImplementations(oriMethod, cusMethod);  \n  }\n \n```\n\n#### 5：在方法上增加额外功能\n\n有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决：\n\n```\n@implementation UIButton (Hook)\n\n+ (void)load {\n\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n\n        Class selfClass = [self class];\n\n        SEL oriSEL = @selector(sendAction:to:forEvent:);\n        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);\n\n        SEL cusSEL = @selector(mySendAction:to:forEvent:);\n        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);\n\n        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n        if (addSucc) {\n            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n        }else {\n            method_exchangeImplementations(oriMethod, cusMethod);\n        }\n\n    });\n}\n\n- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {\n    [CountTool addClickCount];\n    [self mySendAction:action to:target forEvent:event];\n}\n\n@end\n```\n\nload方法会在类第一次加载的时候被调用,调用的时间比较靠前，适合在这个方法里做方法交换,方法交换应该被保证，在程序中只会执行一次。\n\n#### 6.实现NSCoding的自动归档和解档\n\n如果你实现过自定义模型数据持久化的过程，那么你也肯定明白，如果一个模型有许多个属性，那么我们需要对每个属性都实现一遍`encodeObject` 和 `decodeObjectForKey`方法，如果这样的模型又有很多个，这还真的是一个十分麻烦的事情。下面来看看简单的实现方式。\n假设现在有一个Movie类，有3个属性，它的`h`文件这这样的\n\n```\n#import <Foundation/Foundation.h>\n\n//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding\n@interface Movie : NSObject<NSCoding>\n\n@property (nonatomic, copy) NSString *movieId;\n@property (nonatomic, copy) NSString *movieName;\n@property (nonatomic, copy) NSString *pic_url;\n\n@end\n\n```\n\n如果是正常写法， `m`文件应该是这样的：\n\n```\n#import \"Movie.h\"\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)aCoder\n{\n    [aCoder encodeObject:_movieId forKey:@\"id\"];\n    [aCoder encodeObject:_movieName forKey:@\"name\"];\n    [aCoder encodeObject:_pic_url forKey:@\"url\"];\n    \n}\n\n- (id)initWithCoder:(NSCoder *)aDecoder\n{\n    if (self = [super init]) {\n        self.movieId = [aDecoder decodeObjectForKey:@\"id\"];\n        self.movieName = [aDecoder decodeObjectForKey:@\"name\"];\n        self.pic_url = [aDecoder decodeObjectForKey:@\"url\"];\n    }\n    return self;\n}\n@end\n```\n如果这里有100个属性，那么我们也只能把100个属性都给写一遍。\n不过你会使用runtime后，这里就有更简便的方法。\n下面看看runtime的实现方式：\n\n```\n#import \"Movie.h\"\n#import <objc/runtime.h>\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)encoder\n\n{\n    unsigned int count = 0;\n    Ivar *ivars = class_copyIvarList([Movie class], &count);\n    \n    for (int i = 0; i<count; i++) {\n        // 取出i位置对应的成员变量\n        Ivar ivar = ivars[i];\n        // 查看成员变量\n        const char *name = ivar_getName(ivar);\n        // 归档\n        NSString *key = [NSString stringWithUTF8String:name];\n        id value = [self valueForKey:key];\n        [encoder encodeObject:value forKey:key];\n    }\n    free(ivars);\n}\n\n- (id)initWithCoder:(NSCoder *)decoder\n{\n    if (self = [super init]) {\n        unsigned int count = 0;\n        Ivar *ivars = class_copyIvarList([Movie class], &count);\n        for (int i = 0; i<count; i++) {\n        // 取出i位置对应的成员变量\n        Ivar ivar = ivars[i];\n        // 查看成员变量\n        const char *name = ivar_getName(ivar);\n       // 归档\n       NSString *key = [NSString stringWithUTF8String:name];\n      id value = [decoder decodeObjectForKey:key];\n       // 设置到成员变量身上\n        [self setValue:value forKey:key];\n            \n        }\n        free(ivars);\n    } \n    return self;\n}\n@end\n```\n\n这样的方式实现，不管有多少个属性，写这几行代码就搞定了。怎么，还嫌麻烦，下面看看更加简便的方法：两句代码搞定。\n我们把`encodeWithCoder` 和 `initWithCoder`这两个方法抽成宏\n\n```\n#import \"Movie.h\"\n#import <objc/runtime.h>\n\n#define encodeRuntime(A) \\\n\\\nunsigned int count = 0;\\\nIvar *ivars = class_copyIvarList([A class], &count);\\\nfor (int i = 0; i<count; i++) {\\\nIvar ivar = ivars[i];\\\nconst char *name = ivar_getName(ivar);\\\nNSString *key = [NSString stringWithUTF8String:name];\\\nid value = [self valueForKey:key];\\\n[encoder encodeObject:value forKey:key];\\\n}\\\nfree(ivars);\\\n\\\n\n\n\n#define initCoderRuntime(A) \\\n\\\nif (self = [super init]) {\\\nunsigned int count = 0;\\\nIvar *ivars = class_copyIvarList([A class], &count);\\\nfor (int i = 0; i<count; i++) {\\\nIvar ivar = ivars[i];\\\nconst char *name = ivar_getName(ivar);\\\nNSString *key = [NSString stringWithUTF8String:name];\\\nid value = [decoder decodeObjectForKey:key];\\\n[self setValue:value forKey:key];\\\n}\\\nfree(ivars);\\\n}\\\nreturn self;\\\n\\\n\n\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)encoder\n\n{\n    encodeRuntime(Movie)\n}\n\n- (id)initWithCoder:(NSCoder *)decoder\n{\n    initCoderRuntime(Movie)\n}\n@end\n```\n我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。\n\n#### 7.实现字典转模型的自动转换\n\n字典转模型的应用可以说是每个app必然会使用的场景,虽然实现的方式略有不同，但是原理都是一致的：遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。\n像几个出名的开源库：JSONModel,MJExtension等都是通过这种方式实现的。\n\n- 先实现最外层的属性转换\n\n```\n   // 创建对应模型对象\n    id objc = [[self alloc] init];\n\n    unsigned int count = 0;\n\n    // 1.获取成员属性数组\n    Ivar *ivarList = class_copyIvarList(self, &count);\n\n    // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值\n    for (int i = 0; i < count; i++) {\n\n        // 2.1 获取成员属性\n        Ivar ivar = ivarList[i];\n\n        // 2.2 获取成员属性名 C -> OC 字符串\n       NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];\n\n        // 2.3 _成员属性名 => 字典key\n        NSString *key = [ivarName substringFromIndex:1];\n\n        // 2.4 去字典中取出对应value给模型属性赋值\n        id value = dict[key];\n\n        // 获取成员属性类型\n        NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n        }\n```\n\n如果模型比较简单，只有NSString，NSNumber等，这样就可以搞定了。但是如果模型含有NSArray，或者NSDictionary等，那么我们还需要进行第二步转换。\n\n- 内层数组，字典的转换\n\n```\nif ([value isKindOfClass:[NSDictionary class]] && ![ivarType containsString:@\"NS\"]) { \n\n             //  是字典对象,并且属性名对应类型是自定义类型\n            // 处理类型字符串 @\\\"User\\\" -> User\n            ivarType = [ivarType stringByReplacingOccurrencesOfString:@\"@\" withString:@\"\"];\n            ivarType = [ivarType stringByReplacingOccurrencesOfString:@\"\\\"\" withString:@\"\"];\n            // 自定义对象,并且值是字典\n            // value:user字典 -> User模型\n            // 获取模型(user)类对象\n            Class modalClass = NSClassFromString(ivarType);\n\n            // 字典转模型\n            if (modalClass) {\n                // 字典转模型 user\n                value = [modalClass objectWithDict:value];\n            }\n\n        }\n        \n        if ([value isKindOfClass:[NSArray class]]) {\n            // 判断对应类有没有实现字典数组转模型数组的协议\n            if ([self respondsToSelector:@selector(arrayContainModelClass)]) {\n\n                // 转换成id类型，就能调用任何对象的方法\n                id idSelf = self;\n\n                // 获取数组中字典对应的模型\n                NSString *type =  [idSelf arrayContainModelClass][key];\n\n                // 生成模型\n                Class classModel = NSClassFromString(type);\n                NSMutableArray *arrM = [NSMutableArray array];\n                // 遍历字典数组，生成模型数组\n                for (NSDictionary *dict in value) {\n                    // 字典转模型\n                    id model =  [classModel objectWithDict:dict];\n                    [arrM addObject:model];\n                }\n\n                // 把模型数组赋值给value\n                value = arrM;\n\n            }\n        }\n```\n我自己觉得系统自带的KVC模式字典转模型就挺好的，假设movie是一个模型对象，dict 是一个需要转化的 `[movie setValuesForKeysWithDictionary:dict];` 这个是系统自带的字典转模型方法，个人感觉也还是挺好用的，不过使用这个方法的时候需要在模型里面再实现一个方法才行，\n`- (void)setValue:(id)value forUndefinedKey:(NSString *)key` 重写这个方法为了实现两个目的：1. 模型中的属性和字典中的key不一致的情况，比如字典中有个`id`,我们需要把它赋值给`uid`属性；2. 字典中属性比模型的属性还多的情况。\n如果出现以上两种情况而没有实现这个方法的话，程序就会崩溃。\n这个方法的实现：\n\n```\n- (void)setValue:(id)value forUndefinedKey:(NSString *)key\n{\n    if ([key isEqualToString:@\"id\"]) {\n        self.uid = value;\n    }\n}\n```\n### 六.几个参数概念\n\n以上的几种方法应该算是runtime在实际场景中所应用的大部分的情况了，平常的编码中差不多足够用了。\n如果从头仔细看到尾，相信你基本的用法应该会了，虽然会用是主要的目的，有几个基本的参数概念还是要了解一下的。\n\n#### 1.objc_msgSend \n \n ```\n /* Basic Messaging Primitives\n *\n * On some architectures, use objc_msgSend_stret for some struct return types.\n * On some architectures, use objc_msgSend_fpret for some float return types.\n * On some architectures, use objc_msgSend_fp2ret for some float return types.\n *\n * These functions must be cast to an appropriate function pointer type \n * before being called. \n */\n ```\n\n这是官方的声明，从这个函数的注释可以看出来了，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用`objc_msgSend_stret`来发送返回值类型为结构体的消息，使用`objc_msgSend_fpret`来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用objc_msgSend_fp2ret来发送返回值类型为浮点类型的消息。\n最关键的一点：无论何时，要调用`objc_msgSend`函数，必须要将函数强制转换成合适的函数指针类型才能调用。\n从`objc_msgSend`函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。\n其实编译器会根据情况在`objc_msgSend`, `objc_msgSend_stret`, `objc_msgSendSuper`, 或 `objc_msgSendSuper_stret`四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有`”Super”`的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有`”stret”`的函数。\n\n#### 2.SEL\n\n`objc_msgSend`函数第二个参数类型为SEL，它是`selector在Objc`中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:\n`typedef struct objc_selector *SEL`;\n其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令`@selector()`或者 Runtime 系统的`sel_registerName`函数来获得一个SEL类型的方法选择器。\n不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法)，Cocoa 中有好多长长的方法哦。\n#### 3.id\n`objc_msgSend`第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：\n`typedef struct objc_object *id`;\n那objc_object又是啥呢：\n`struct objc_object { Class isa; }`;\n`objc_object`结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。\nPS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见[官方文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html).\n#### 4.Class\n之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：\n`typedef struct objc_class *Class`;\nobjc_class里面的东西多着呢：\n\n```\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n#if  !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。\n在`objc_class`结构体中：`ivars是objc_ivar_list`指针；`methodLists`是指向`objc_method_list`指针的指针。也就是说可以动态修改 `*methodLists` 的值来添加成员方法，这也是Category实现的原理.\n\n上面讲到的所有东西都在Demo里，如果你觉得不错，还请为我的Demo star一个。\n[demo下载](https://github.com/suifengqjn/runtime)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/2.png)\n\n\n\n\n\n\n","slug":"runtime详解","published":1,"updated":"2016-11-17T13:48:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tew0027lx602qvlfbkf","content":"<p>公司项目用到一个三方开源库，里面有个bug，不能改动源码，我想来想去，只能通过runtime这个万能的手段来解决。但是runtime 并不怎么会用，怎么办，马上学习呗。说到runtime，它是Objective-c里面最核心的技术，被人们传呼的神乎其神，但是感觉有一层神秘的面纱笼罩其上，毕竟使用场景不多，相信大多数开发者都不会熟练的运用。而网络上也有无数的文章来讲解runtime，但是真的非常的乱，非常的碎片化，很少有讲解的比较全面的。</p>\n<p>最初是在onevcat的博客上看到runtime的<a href=\"https://onevcat.com/2012/04/objective-c-runtime/\" target=\"_blank\" rel=\"external\">runtime的博客</a>，说句实话，看完后我还是蒙的，这里面主要讲了一下runtime 比较核心的功能-Method Swizzling，不过看完后还是有些不知如何下手的感觉。下面是我自己对runtime的整理，从零开始，由浅入深，并且带了几个runtime实际的应用场景。看完之后，你可以再回过头来看喵神的这篇文章，应该就能看的懂了。</p>\n<h3 id=\"一：基本概念\"><a href=\"#一：基本概念\" class=\"headerlink\" title=\"一：基本概念\"></a>一：基本概念</h3><p>Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href=\"http://opensource.apple.com//source/objc4/\" target=\"_blank\" rel=\"external\">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。</p>\n<ul>\n<li>RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。</li>\n<li>对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。</li>\n<li>OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。</li>\n<li>只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。</li>\n</ul>\n<h3 id=\"二：runtime的具体实现\"><a href=\"#二：runtime的具体实现\" class=\"headerlink\" title=\"二：runtime的具体实现\"></a>二：runtime的具体实现</h3><p>我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。<br>每一个oc的方法，底层必然有一个与之对应的runtime方法。<br><a id=\"more\"></a><br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/1.png\" alt=\"image\"></p>\n<ul>\n<li><p>当我们用OC写下这样一段代码<br><code>[tableView cellForRowAtIndexPath:indexPath];</code></p>\n</li>\n<li><p>在编译时RunTime会将上述代码转化成[发送消息]<br><code>objc_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath);</code></p>\n</li>\n</ul>\n<h3 id=\"三-常见方法\"><a href=\"#三-常见方法\" class=\"headerlink\" title=\"三:常见方法\"></a>三:常见方法</h3><p> <code>unsigned int count;</code></p>\n<ul>\n<li><p>获取属性列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</div><div class=\"line\">    for (unsigned int i=0; i&lt;count; i++) &#123;</div><div class=\"line\">        const char *propertyName = property_getName(propertyList[i]);</div><div class=\"line\">        NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取方法列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method *methodList = class_copyMethodList([self class], &amp;count);</div><div class=\"line\">for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">    Method method = methodList[i];</div><div class=\"line\">    NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>获取成员变量列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Ivar *ivarList = class_copyIvarList([self class], &amp;count);</div><div class=\"line\">  for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">      Ivar myIvar = ivarList[i];</div><div class=\"line\">      const char *ivarName = ivar_getName(myIvar);</div><div class=\"line\">      NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>获取协议列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</div><div class=\"line\">    for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">        Protocol *myProtocal = protocolList[i];</div><div class=\"line\">        const char *protocolName = protocol_getName(myProtocal);</div><div class=\"line\">        NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</div><div class=\"line\">    &#125;</div><div class=\"line\">  ``` </div><div class=\"line\">  </div><div class=\"line\">&gt;现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法</div><div class=\"line\"></div><div class=\"line\">- 获得类方法</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Class PersonClass = object_getClass([Person class]);<br>SEL oriSEL = @selector(test1);<br>Method oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 获得实例方法</div></pre></td></tr></table></figure></p>\n<p>Class PersonClass = object_getClass([xiaoming class]);<br>SEL oriSEL = @selector(test2);<br>Method cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 添加方法</div></pre></td></tr></table></figure></p>\n<p>BOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 替换原方法实现</div></pre></td></tr></table></figure></p>\n<p>class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 交换两个方法</div></pre></td></tr></table></figure></p>\n<p>method_exchangeImplementations(oriMethod, cusMethod);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">### 四：常见作用</div><div class=\"line\">- 动态的添加对象的成员变量和方法</div><div class=\"line\">- 动态交换两个方法的实现</div><div class=\"line\">- 拦截并替换方法</div><div class=\"line\">- 在方法上增加额外功能</div><div class=\"line\">- 实现NSCoding的自动归档和解档</div><div class=\"line\">- 实现字典转模型的自动转换</div><div class=\"line\"></div><div class=\"line\">### 五：代码实现</div><div class=\"line\">要使用runtime，要先引入头文件`#import &lt;objc/runtime.h&gt;`</div><div class=\"line\">这些代码的实例有浅入深逐步讲解，最后附上一个我在公司项目中遇到的一个实际问题。</div><div class=\"line\"></div><div class=\"line\">#### 1. 动态变量控制</div><div class=\"line\">   在程序中，xiaoming的age是10，后来被runtime变成了20，来看看runtime是怎么做到的。</div><div class=\"line\">   </div><div class=\"line\">##### 1.动态获取XiaoMing类中的所有属性[当然包括私有]  </div><div class=\"line\"></div><div class=\"line\">\t`Ivar *ivar = class_copyIvarList([self.xiaoming class], &amp;count);`  </div><div class=\"line\"></div><div class=\"line\">##### 2.遍历属性找到对应name字段  </div><div class=\"line\"></div><div class=\"line\">\t`const char *varName = ivar_getName(var);`</div><div class=\"line\"></div><div class=\"line\">##### 3.修改对应的字段值成20 </div><div class=\"line\">\t</div><div class=\"line\">\t`object_setIvar(self.xiaoMing, var, @&quot;20&quot;);`  </div><div class=\"line\">\t</div><div class=\"line\">##### 4.代码参考</div></pre></td></tr></table></figure></p>\n<p>-(void)answer{<br>        unsigned int count = 0;<br>        Ivar <em>ivar = class_copyIvarList([self.xiaoMing class], &amp;count);<br>        for (int i = 0; i&lt;count; i++) {<br>            Ivar var = ivar[i];<br>            const char </em>varName = ivar_getName(var);<br>            NSString *name = [NSString stringWithUTF8String:varName];<br>            if ([name isEqualToString:@”_age”]) {<br>                object_setIvar(self.xiaoMing, var, @”20”);<br>                break;<br>            }<br>        }<br>        NSLog(@”XiaoMing’s age is %@”,self.xiaoMing.age);<br>    }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 2.动态添加方法</div><div class=\"line\"></div><div class=\"line\">在程序当中，假设XiaoMing的中没有`guess`这个方法，后来被Runtime添加一个名字叫guess的方法，最终再调用guess方法做出相应。那么，Runtime是如何做到的呢？  </div><div class=\"line\">  </div><div class=\"line\">##### 1.动态给XiaoMing类中添加guess方法：</div></pre></td></tr></table></figure></p>\n<pre><code>class_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这里参数地方说明一下：</div><div class=\"line\"></div><div class=\"line\">&gt;(IMP)guessAnswer 意思是guessAnswer的地址指针;</div><div class=\"line\">&gt;&quot;v@:&quot; 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;</div><div class=\"line\">&gt;“v@:@@” 意思是，两个参数的没有返回值。  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">##### 2.调用guess方法响应事件：  </div><div class=\"line\"></div><div class=\"line\">\t[self.xiaoMing performSelector:@selector(guess)];</div><div class=\"line\"></div><div class=\"line\">##### 3.编写guessAnswer的实现：  </div><div class=\"line\">\t</div><div class=\"line\">\t</div><div class=\"line\">\tvoid guessAnswer(id self,SEL _cmd)&#123;</div><div class=\"line\">    \tNSLog(@&quot;i am from beijing&quot;);   </div><div class=\"line\">\t&#125; </div><div class=\"line\">\t</div><div class=\"line\"></div><div class=\"line\">这个有两个地方留意一下：</div><div class=\"line\">* void的前面没有+、-号，因为只是C的代码。</div><div class=\"line\">* 必须有两个指定参数(id self,SEL _cmd)  </div><div class=\"line\"></div><div class=\"line\">##### 4.代码参考</div><div class=\"line\"></div><div class=\"line\">```  </div><div class=\"line\">\t-(void)answer&#123;</div><div class=\"line\">    \tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;);</div><div class=\"line\">    \tif ([self.xiaoMing respondsToSelector:@selector(guess)]) &#123;</div><div class=\"line\">        </div><div class=\"line\">        \t[self.xiaoMing performSelector:@selector(guess)];</div><div class=\"line\">        </div><div class=\"line\">    \t&#125; else&#123;</div><div class=\"line\">        \tNSLog(@&quot;Sorry,I don&apos;t know&quot;);</div><div class=\"line\">    \t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tvoid guessAnswer(id self,SEL _cmd)&#123;</div><div class=\"line\">   </div><div class=\"line\">    \tNSLog(@&quot;i am from beijing&quot;);</div><div class=\"line\">    </div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3：动态交换两个方法的实现\"><a href=\"#3：动态交换两个方法的实现\" class=\"headerlink\" title=\"3：动态交换两个方法的实现\"></a>3：动态交换两个方法的实现</h4><p>在程序当中，假设XiaoMing的中有<code>test1</code> 和 <code>test2</code>这两个方法，后来被Runtime交换方法后，每次调动<code>test1</code> 的时候就会去执行<code>test2</code>，调动<code>test2</code> 的时候就会去执行<code>test1</code>， 。那么，Runtime是如何做到的呢？</p>\n<h5 id=\"1-获取这个类中的两个方法并交换\"><a href=\"#1-获取这个类中的两个方法并交换\" class=\"headerlink\" title=\"1. 获取这个类中的两个方法并交换\"></a>1. 获取这个类中的两个方法并交换</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method m1 = class_getInstanceMethod([self.xiaoMing class], @selector(test1));</div><div class=\"line\">    Method m2 = class_getInstanceMethod([self.xiaoMing class], @selector(test2));</div><div class=\"line\">    method_exchangeImplementations(m1, m2);</div></pre></td></tr></table></figure>\n<p>交换方法之后，以后每次调用这两个方法都会交换方法的实现</p>\n<h4 id=\"4：拦截并替换方法\"><a href=\"#4：拦截并替换方法\" class=\"headerlink\" title=\"4：拦截并替换方法\"></a>4：拦截并替换方法</h4><p>在程序当中，假设XiaoMing的中有<code>test1</code>这个方法，但是由于某种原因，我们要改变这个方法的实现，但是又不能去动它的源代码(正如一些开源库出现问题的时候)，这个时候runtime就派上用场了。</p>\n<p>我们先增加一个tool类，然后写一个我们自己实现的方法-change，<br>通过runtime把test1替换成change。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class PersionClass = object_getClass([Person class]);</div><div class=\"line\">Class toolClass = object_getClass([tool class]);</div><div class=\"line\"></div><div class=\"line\">    ////源方法的SEL和Method</div><div class=\"line\">    </div><div class=\"line\">    SEL oriSEL = @selector(test1);</div><div class=\"line\">    Method oriMethod = class_getInstanceMethod(PersionClass, oriSEL);</div><div class=\"line\">    </div><div class=\"line\">    ////交换方法的SEL和Method</div><div class=\"line\">    </div><div class=\"line\">    SEL cusSEL = @selector(change);</div><div class=\"line\">    Method cusMethod = class_getInstanceMethod(toolClass, cusSEL);</div><div class=\"line\">    </div><div class=\"line\">    ////先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况</div><div class=\"line\">    </div><div class=\"line\">    BOOL addSucc = class_addMethod(PersionClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class=\"line\">    if (addSucc) &#123;</div><div class=\"line\">          // 添加成功：将源方法的实现替换到交换方法的实现     </div><div class=\"line\">        class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class=\"line\">               </div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">    //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即</div><div class=\"line\">method_exchangeImplementations(oriMethod, cusMethod);  </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5：在方法上增加额外功能\"><a href=\"#5：在方法上增加额外功能\" class=\"headerlink\" title=\"5：在方法上增加额外功能\"></a>5：在方法上增加额外功能</h4><p>有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation UIButton (Hook)</div><div class=\"line\"></div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\"></div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\"></div><div class=\"line\">        Class selfClass = [self class];</div><div class=\"line\"></div><div class=\"line\">        SEL oriSEL = @selector(sendAction:to:forEvent:);</div><div class=\"line\">        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</div><div class=\"line\"></div><div class=\"line\">        SEL cusSEL = @selector(mySendAction:to:forEvent:);</div><div class=\"line\">        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</div><div class=\"line\"></div><div class=\"line\">        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class=\"line\">        if (addSucc) &#123;</div><div class=\"line\">            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class=\"line\">        &#125;else &#123;</div><div class=\"line\">            method_exchangeImplementations(oriMethod, cusMethod);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</div><div class=\"line\">    [CountTool addClickCount];</div><div class=\"line\">    [self mySendAction:action to:target forEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>load方法会在类第一次加载的时候被调用,调用的时间比较靠前，适合在这个方法里做方法交换,方法交换应该被保证，在程序中只会执行一次。</p>\n<h4 id=\"6-实现NSCoding的自动归档和解档\"><a href=\"#6-实现NSCoding的自动归档和解档\" class=\"headerlink\" title=\"6.实现NSCoding的自动归档和解档\"></a>6.实现NSCoding的自动归档和解档</h4><p>如果你实现过自定义模型数据持久化的过程，那么你也肯定明白，如果一个模型有许多个属性，那么我们需要对每个属性都实现一遍<code>encodeObject</code> 和 <code>decodeObjectForKey</code>方法，如果这样的模型又有很多个，这还真的是一个十分麻烦的事情。下面来看看简单的实现方式。<br>假设现在有一个Movie类，有3个属性，它的<code>h</code>文件这这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding</div><div class=\"line\">@interface Movie : NSObject&lt;NSCoding&gt;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, copy) NSString *movieId;</div><div class=\"line\">@property (nonatomic, copy) NSString *movieName;</div><div class=\"line\">@property (nonatomic, copy) NSString *pic_url;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>如果是正常写法， <code>m</code>文件应该是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)aCoder</div><div class=\"line\">&#123;</div><div class=\"line\">    [aCoder encodeObject:_movieId forKey:@&quot;id&quot;];</div><div class=\"line\">    [aCoder encodeObject:_movieName forKey:@&quot;name&quot;];</div><div class=\"line\">    [aCoder encodeObject:_pic_url forKey:@&quot;url&quot;];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)aDecoder</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init]) &#123;</div><div class=\"line\">        self.movieId = [aDecoder decodeObjectForKey:@&quot;id&quot;];</div><div class=\"line\">        self.movieName = [aDecoder decodeObjectForKey:@&quot;name&quot;];</div><div class=\"line\">        self.pic_url = [aDecoder decodeObjectForKey:@&quot;url&quot;];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>如果这里有100个属性，那么我们也只能把100个属性都给写一遍。<br>不过你会使用runtime后，这里就有更简便的方法。<br>下面看看runtime的实现方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)encoder</div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    unsigned int count = 0;</div><div class=\"line\">    Ivar *ivars = class_copyIvarList([Movie class], &amp;count);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i&lt;count; i++) &#123;</div><div class=\"line\">        // 取出i位置对应的成员变量</div><div class=\"line\">        Ivar ivar = ivars[i];</div><div class=\"line\">        // 查看成员变量</div><div class=\"line\">        const char *name = ivar_getName(ivar);</div><div class=\"line\">        // 归档</div><div class=\"line\">        NSString *key = [NSString stringWithUTF8String:name];</div><div class=\"line\">        id value = [self valueForKey:key];</div><div class=\"line\">        [encoder encodeObject:value forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(ivars);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)decoder</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init]) &#123;</div><div class=\"line\">        unsigned int count = 0;</div><div class=\"line\">        Ivar *ivars = class_copyIvarList([Movie class], &amp;count);</div><div class=\"line\">        for (int i = 0; i&lt;count; i++) &#123;</div><div class=\"line\">        // 取出i位置对应的成员变量</div><div class=\"line\">        Ivar ivar = ivars[i];</div><div class=\"line\">        // 查看成员变量</div><div class=\"line\">        const char *name = ivar_getName(ivar);</div><div class=\"line\">       // 归档</div><div class=\"line\">       NSString *key = [NSString stringWithUTF8String:name];</div><div class=\"line\">      id value = [decoder decodeObjectForKey:key];</div><div class=\"line\">       // 设置到成员变量身上</div><div class=\"line\">        [self setValue:value forKey:key];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        free(ivars);</div><div class=\"line\">    &#125; </div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这样的方式实现，不管有多少个属性，写这几行代码就搞定了。怎么，还嫌麻烦，下面看看更加简便的方法：两句代码搞定。<br>我们把<code>encodeWithCoder</code> 和 <code>initWithCoder</code>这两个方法抽成宏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">#define encodeRuntime(A) \\</div><div class=\"line\">\\</div><div class=\"line\">unsigned int count = 0;\\</div><div class=\"line\">Ivar *ivars = class_copyIvarList([A class], &amp;count);\\</div><div class=\"line\">for (int i = 0; i&lt;count; i++) &#123;\\</div><div class=\"line\">Ivar ivar = ivars[i];\\</div><div class=\"line\">const char *name = ivar_getName(ivar);\\</div><div class=\"line\">NSString *key = [NSString stringWithUTF8String:name];\\</div><div class=\"line\">id value = [self valueForKey:key];\\</div><div class=\"line\">[encoder encodeObject:value forKey:key];\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">free(ivars);\\</div><div class=\"line\">\\</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#define initCoderRuntime(A) \\</div><div class=\"line\">\\</div><div class=\"line\">if (self = [super init]) &#123;\\</div><div class=\"line\">unsigned int count = 0;\\</div><div class=\"line\">Ivar *ivars = class_copyIvarList([A class], &amp;count);\\</div><div class=\"line\">for (int i = 0; i&lt;count; i++) &#123;\\</div><div class=\"line\">Ivar ivar = ivars[i];\\</div><div class=\"line\">const char *name = ivar_getName(ivar);\\</div><div class=\"line\">NSString *key = [NSString stringWithUTF8String:name];\\</div><div class=\"line\">id value = [decoder decodeObjectForKey:key];\\</div><div class=\"line\">[self setValue:value forKey:key];\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">free(ivars);\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">return self;\\</div><div class=\"line\">\\</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)encoder</div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    encodeRuntime(Movie)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)decoder</div><div class=\"line\">&#123;</div><div class=\"line\">    initCoderRuntime(Movie)</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。</p>\n<h4 id=\"7-实现字典转模型的自动转换\"><a href=\"#7-实现字典转模型的自动转换\" class=\"headerlink\" title=\"7.实现字典转模型的自动转换\"></a>7.实现字典转模型的自动转换</h4><p>字典转模型的应用可以说是每个app必然会使用的场景,虽然实现的方式略有不同，但是原理都是一致的：遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。<br>像几个出名的开源库：JSONModel,MJExtension等都是通过这种方式实现的。</p>\n<ul>\n<li>先实现最外层的属性转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建对应模型对象</div><div class=\"line\"> id objc = [[self alloc] init];</div><div class=\"line\"></div><div class=\"line\"> unsigned int count = 0;</div><div class=\"line\"></div><div class=\"line\"> // 1.获取成员属性数组</div><div class=\"line\"> Ivar *ivarList = class_copyIvarList(self, &amp;count);</div><div class=\"line\"></div><div class=\"line\"> // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值</div><div class=\"line\"> for (int i = 0; i &lt; count; i++) &#123;</div><div class=\"line\"></div><div class=\"line\">     // 2.1 获取成员属性</div><div class=\"line\">     Ivar ivar = ivarList[i];</div><div class=\"line\"></div><div class=\"line\">     // 2.2 获取成员属性名 C -&gt; OC 字符串</div><div class=\"line\">    NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class=\"line\"></div><div class=\"line\">     // 2.3 _成员属性名 =&gt; 字典key</div><div class=\"line\">     NSString *key = [ivarName substringFromIndex:1];</div><div class=\"line\"></div><div class=\"line\">     // 2.4 去字典中取出对应value给模型属性赋值</div><div class=\"line\">     id value = dict[key];</div><div class=\"line\"></div><div class=\"line\">     // 获取成员属性类型</div><div class=\"line\">     NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure>\n<p>如果模型比较简单，只有NSString，NSNumber等，这样就可以搞定了。但是如果模型含有NSArray，或者NSDictionary等，那么我们还需要进行第二步转换。</p>\n<ul>\n<li>内层数组，字典的转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType containsString:@&quot;NS&quot;]) &#123; </div><div class=\"line\"></div><div class=\"line\">             //  是字典对象,并且属性名对应类型是自定义类型</div><div class=\"line\">            // 处理类型字符串 @\\&quot;User\\&quot; -&gt; User</div><div class=\"line\">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;];</div><div class=\"line\">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\\&quot;&quot; withString:@&quot;&quot;];</div><div class=\"line\">            // 自定义对象,并且值是字典</div><div class=\"line\">            // value:user字典 -&gt; User模型</div><div class=\"line\">            // 获取模型(user)类对象</div><div class=\"line\">            Class modalClass = NSClassFromString(ivarType);</div><div class=\"line\"></div><div class=\"line\">            // 字典转模型</div><div class=\"line\">            if (modalClass) &#123;</div><div class=\"line\">                // 字典转模型 user</div><div class=\"line\">                value = [modalClass objectWithDict:value];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if ([value isKindOfClass:[NSArray class]]) &#123;</div><div class=\"line\">            // 判断对应类有没有实现字典数组转模型数组的协议</div><div class=\"line\">            if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;</div><div class=\"line\"></div><div class=\"line\">                // 转换成id类型，就能调用任何对象的方法</div><div class=\"line\">                id idSelf = self;</div><div class=\"line\"></div><div class=\"line\">                // 获取数组中字典对应的模型</div><div class=\"line\">                NSString *type =  [idSelf arrayContainModelClass][key];</div><div class=\"line\"></div><div class=\"line\">                // 生成模型</div><div class=\"line\">                Class classModel = NSClassFromString(type);</div><div class=\"line\">                NSMutableArray *arrM = [NSMutableArray array];</div><div class=\"line\">                // 遍历字典数组，生成模型数组</div><div class=\"line\">                for (NSDictionary *dict in value) &#123;</div><div class=\"line\">                    // 字典转模型</div><div class=\"line\">                    id model =  [classModel objectWithDict:dict];</div><div class=\"line\">                    [arrM addObject:model];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // 把模型数组赋值给value</div><div class=\"line\">                value = arrM;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>我自己觉得系统自带的KVC模式字典转模型就挺好的，假设movie是一个模型对象，dict 是一个需要转化的 <code>[movie setValuesForKeysWithDictionary:dict];</code> 这个是系统自带的字典转模型方法，个人感觉也还是挺好用的，不过使用这个方法的时候需要在模型里面再实现一个方法才行，<br><code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code> 重写这个方法为了实现两个目的：1. 模型中的属性和字典中的key不一致的情况，比如字典中有个<code>id</code>,我们需要把它赋值给<code>uid</code>属性；2. 字典中属性比模型的属性还多的情况。<br>如果出现以上两种情况而没有实现这个方法的话，程序就会崩溃。<br>这个方法的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setValue:(id)value forUndefinedKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    if ([key isEqualToString:@&quot;id&quot;]) &#123;</div><div class=\"line\">        self.uid = value;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"六-几个参数概念\"><a href=\"#六-几个参数概念\" class=\"headerlink\" title=\"六.几个参数概念\"></a>六.几个参数概念</h3><p>以上的几种方法应该算是runtime在实际场景中所应用的大部分的情况了，平常的编码中差不多足够用了。<br>如果从头仔细看到尾，相信你基本的用法应该会了，虽然会用是主要的目的，有几个基本的参数概念还是要了解一下的。</p>\n<h4 id=\"1-objc-msgSend\"><a href=\"#1-objc-msgSend\" class=\"headerlink\" title=\"1.objc_msgSend\"></a>1.objc_msgSend</h4> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* Basic Messaging Primitives</div><div class=\"line\">*</div><div class=\"line\">* On some architectures, use objc_msgSend_stret for some struct return types.</div><div class=\"line\">* On some architectures, use objc_msgSend_fpret for some float return types.</div><div class=\"line\">* On some architectures, use objc_msgSend_fp2ret for some float return types.</div><div class=\"line\">*</div><div class=\"line\">* These functions must be cast to an appropriate function pointer type </div><div class=\"line\">* before being called. </div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<p>这是官方的声明，从这个函数的注释可以看出来了，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用<code>objc_msgSend_stret</code>来发送返回值类型为结构体的消息，使用<code>objc_msgSend_fpret</code>来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用objc_msgSend_fp2ret来发送返回值类型为浮点类型的消息。<br>最关键的一点：无论何时，要调用<code>objc_msgSend</code>函数，必须要将函数强制转换成合适的函数指针类型才能调用。<br>从<code>objc_msgSend</code>函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。<br>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>”Super”</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>”stret”</code>的函数。</p>\n<h4 id=\"2-SEL\"><a href=\"#2-SEL\" class=\"headerlink\" title=\"2.SEL\"></a>2.SEL</h4><p><code>objc_msgSend</code>函数第二个参数类型为SEL，它是<code>selector在Objc</code>中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:<br><code>typedef struct objc_selector *SEL</code>;<br>其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令<code>@selector()</code>或者 Runtime 系统的<code>sel_registerName</code>函数来获得一个SEL类型的方法选择器。<br>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法)，Cocoa 中有好多长长的方法哦。</p>\n<h4 id=\"3-id\"><a href=\"#3-id\" class=\"headerlink\" title=\"3.id\"></a>3.id</h4><p><code>objc_msgSend</code>第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：<br><code>typedef struct objc_object *id</code>;<br>那objc_object又是啥呢：<br><code>struct objc_object { Class isa; }</code>;<br><code>objc_object</code>结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。<br>PS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html\" target=\"_blank\" rel=\"external\">官方文档</a>.</p>\n<h4 id=\"4-Class\"><a href=\"#4-Class\" class=\"headerlink\" title=\"4.Class\"></a>4.Class</h4><p>之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：<br><code>typedef struct objc_class *Class</code>;<br>objc_class里面的东西多着呢：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">#if  !__OBJC2__</div><div class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class=\"line\">    const char *name                                         OBJC2_UNAVAILABLE;</div><div class=\"line\">    long version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    long info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>\n<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。<br>在<code>objc_class</code>结构体中：<code>ivars是objc_ivar_list</code>指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。也就是说可以动态修改 <code>*methodLists</code> 的值来添加成员方法，这也是Category实现的原理.</p>\n<p>上面讲到的所有东西都在Demo里，如果你觉得不错，还请为我的Demo star一个。<br><a href=\"https://github.com/suifengqjn/runtime\" target=\"_blank\" rel=\"external\">demo下载</a></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/2.png\" alt=\"image\"></p>\n","excerpt":"<p>公司项目用到一个三方开源库，里面有个bug，不能改动源码，我想来想去，只能通过runtime这个万能的手段来解决。但是runtime 并不怎么会用，怎么办，马上学习呗。说到runtime，它是Objective-c里面最核心的技术，被人们传呼的神乎其神，但是感觉有一层神秘的面纱笼罩其上，毕竟使用场景不多，相信大多数开发者都不会熟练的运用。而网络上也有无数的文章来讲解runtime，但是真的非常的乱，非常的碎片化，很少有讲解的比较全面的。</p>\n<p>最初是在onevcat的博客上看到runtime的<a href=\"https://onevcat.com/2012/04/objective-c-runtime/\">runtime的博客</a>，说句实话，看完后我还是蒙的，这里面主要讲了一下runtime 比较核心的功能-Method Swizzling，不过看完后还是有些不知如何下手的感觉。下面是我自己对runtime的整理，从零开始，由浅入深，并且带了几个runtime实际的应用场景。看完之后，你可以再回过头来看喵神的这篇文章，应该就能看的懂了。</p>\n<h3 id=\"一：基本概念\"><a href=\"#一：基本概念\" class=\"headerlink\" title=\"一：基本概念\"></a>一：基本概念</h3><p>Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href=\"http://opensource.apple.com//source/objc4/\">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。</p>\n<ul>\n<li>RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。</li>\n<li>对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。</li>\n<li>OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。</li>\n<li>只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。</li>\n</ul>\n<h3 id=\"二：runtime的具体实现\"><a href=\"#二：runtime的具体实现\" class=\"headerlink\" title=\"二：runtime的具体实现\"></a>二：runtime的具体实现</h3><p>我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。<br>每一个oc的方法，底层必然有一个与之对应的runtime方法。<br>","more":"<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/1.png\" alt=\"image\"></p>\n<ul>\n<li><p>当我们用OC写下这样一段代码<br><code>[tableView cellForRowAtIndexPath:indexPath];</code></p>\n</li>\n<li><p>在编译时RunTime会将上述代码转化成[发送消息]<br><code>objc_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath);</code></p>\n</li>\n</ul>\n<h3 id=\"三-常见方法\"><a href=\"#三-常见方法\" class=\"headerlink\" title=\"三:常见方法\"></a>三:常见方法</h3><p> <code>unsigned int count;</code></p>\n<ul>\n<li><p>获取属性列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</div><div class=\"line\">    for (unsigned int i=0; i&lt;count; i++) &#123;</div><div class=\"line\">        const char *propertyName = property_getName(propertyList[i]);</div><div class=\"line\">        NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取方法列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method *methodList = class_copyMethodList([self class], &amp;count);</div><div class=\"line\">for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">    Method method = methodList[i];</div><div class=\"line\">    NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>获取成员变量列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Ivar *ivarList = class_copyIvarList([self class], &amp;count);</div><div class=\"line\">  for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">      Ivar myIvar = ivarList[i];</div><div class=\"line\">      const char *ivarName = ivar_getName(myIvar);</div><div class=\"line\">      NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>获取协议列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</div><div class=\"line\">    for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">        Protocol *myProtocal = protocolList[i];</div><div class=\"line\">        const char *protocolName = protocol_getName(myProtocal);</div><div class=\"line\">        NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</div><div class=\"line\">    &#125;</div><div class=\"line\">  ``` </div><div class=\"line\">  </div><div class=\"line\">&gt;现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法</div><div class=\"line\"></div><div class=\"line\">- 获得类方法</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Class PersonClass = object_getClass([Person class]);<br>SEL oriSEL = @selector(test1);<br>Method oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 获得实例方法</div></pre></td></tr></table></figure></p>\n<p>Class PersonClass = object_getClass([xiaoming class]);<br>SEL oriSEL = @selector(test2);<br>Method cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 添加方法</div></pre></td></tr></table></figure></p>\n<p>BOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 替换原方法实现</div></pre></td></tr></table></figure></p>\n<p>class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 交换两个方法</div></pre></td></tr></table></figure></p>\n<p>method_exchangeImplementations(oriMethod, cusMethod);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">### 四：常见作用</div><div class=\"line\">- 动态的添加对象的成员变量和方法</div><div class=\"line\">- 动态交换两个方法的实现</div><div class=\"line\">- 拦截并替换方法</div><div class=\"line\">- 在方法上增加额外功能</div><div class=\"line\">- 实现NSCoding的自动归档和解档</div><div class=\"line\">- 实现字典转模型的自动转换</div><div class=\"line\"></div><div class=\"line\">### 五：代码实现</div><div class=\"line\">要使用runtime，要先引入头文件`#import &lt;objc/runtime.h&gt;`</div><div class=\"line\">这些代码的实例有浅入深逐步讲解，最后附上一个我在公司项目中遇到的一个实际问题。</div><div class=\"line\"></div><div class=\"line\">#### 1. 动态变量控制</div><div class=\"line\">   在程序中，xiaoming的age是10，后来被runtime变成了20，来看看runtime是怎么做到的。</div><div class=\"line\">   </div><div class=\"line\">##### 1.动态获取XiaoMing类中的所有属性[当然包括私有]  </div><div class=\"line\"></div><div class=\"line\">\t`Ivar *ivar = class_copyIvarList([self.xiaoming class], &amp;count);`  </div><div class=\"line\"></div><div class=\"line\">##### 2.遍历属性找到对应name字段  </div><div class=\"line\"></div><div class=\"line\">\t`const char *varName = ivar_getName(var);`</div><div class=\"line\"></div><div class=\"line\">##### 3.修改对应的字段值成20 </div><div class=\"line\">\t</div><div class=\"line\">\t`object_setIvar(self.xiaoMing, var, @&quot;20&quot;);`  </div><div class=\"line\">\t</div><div class=\"line\">##### 4.代码参考</div></pre></td></tr></table></figure></p>\n<p>-(void)answer{<br>        unsigned int count = 0;<br>        Ivar <em>ivar = class_copyIvarList([self.xiaoMing class], &amp;count);<br>        for (int i = 0; i&lt;count; i++) {<br>            Ivar var = ivar[i];<br>            const char </em>varName = ivar_getName(var);<br>            NSString *name = [NSString stringWithUTF8String:varName];<br>            if ([name isEqualToString:@”_age”]) {<br>                object_setIvar(self.xiaoMing, var, @”20”);<br>                break;<br>            }<br>        }<br>        NSLog(@”XiaoMing’s age is %@”,self.xiaoMing.age);<br>    }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 2.动态添加方法</div><div class=\"line\"></div><div class=\"line\">在程序当中，假设XiaoMing的中没有`guess`这个方法，后来被Runtime添加一个名字叫guess的方法，最终再调用guess方法做出相应。那么，Runtime是如何做到的呢？  </div><div class=\"line\">  </div><div class=\"line\">##### 1.动态给XiaoMing类中添加guess方法：</div></pre></td></tr></table></figure></p>\n<pre><code>class_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这里参数地方说明一下：</div><div class=\"line\"></div><div class=\"line\">&gt;(IMP)guessAnswer 意思是guessAnswer的地址指针;</div><div class=\"line\">&gt;&quot;v@:&quot; 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;</div><div class=\"line\">&gt;“v@:@@” 意思是，两个参数的没有返回值。  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">##### 2.调用guess方法响应事件：  </div><div class=\"line\"></div><div class=\"line\">\t[self.xiaoMing performSelector:@selector(guess)];</div><div class=\"line\"></div><div class=\"line\">##### 3.编写guessAnswer的实现：  </div><div class=\"line\">\t</div><div class=\"line\">\t</div><div class=\"line\">\tvoid guessAnswer(id self,SEL _cmd)&#123;</div><div class=\"line\">    \tNSLog(@&quot;i am from beijing&quot;);   </div><div class=\"line\">\t&#125; </div><div class=\"line\">\t</div><div class=\"line\"></div><div class=\"line\">这个有两个地方留意一下：</div><div class=\"line\">* void的前面没有+、-号，因为只是C的代码。</div><div class=\"line\">* 必须有两个指定参数(id self,SEL _cmd)  </div><div class=\"line\"></div><div class=\"line\">##### 4.代码参考</div><div class=\"line\"></div><div class=\"line\">```  </div><div class=\"line\">\t-(void)answer&#123;</div><div class=\"line\">    \tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;);</div><div class=\"line\">    \tif ([self.xiaoMing respondsToSelector:@selector(guess)]) &#123;</div><div class=\"line\">        </div><div class=\"line\">        \t[self.xiaoMing performSelector:@selector(guess)];</div><div class=\"line\">        </div><div class=\"line\">    \t&#125; else&#123;</div><div class=\"line\">        \tNSLog(@&quot;Sorry,I don&apos;t know&quot;);</div><div class=\"line\">    \t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tvoid guessAnswer(id self,SEL _cmd)&#123;</div><div class=\"line\">   </div><div class=\"line\">    \tNSLog(@&quot;i am from beijing&quot;);</div><div class=\"line\">    </div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3：动态交换两个方法的实现\"><a href=\"#3：动态交换两个方法的实现\" class=\"headerlink\" title=\"3：动态交换两个方法的实现\"></a>3：动态交换两个方法的实现</h4><p>在程序当中，假设XiaoMing的中有<code>test1</code> 和 <code>test2</code>这两个方法，后来被Runtime交换方法后，每次调动<code>test1</code> 的时候就会去执行<code>test2</code>，调动<code>test2</code> 的时候就会去执行<code>test1</code>， 。那么，Runtime是如何做到的呢？</p>\n<h5 id=\"1-获取这个类中的两个方法并交换\"><a href=\"#1-获取这个类中的两个方法并交换\" class=\"headerlink\" title=\"1. 获取这个类中的两个方法并交换\"></a>1. 获取这个类中的两个方法并交换</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method m1 = class_getInstanceMethod([self.xiaoMing class], @selector(test1));</div><div class=\"line\">    Method m2 = class_getInstanceMethod([self.xiaoMing class], @selector(test2));</div><div class=\"line\">    method_exchangeImplementations(m1, m2);</div></pre></td></tr></table></figure>\n<p>交换方法之后，以后每次调用这两个方法都会交换方法的实现</p>\n<h4 id=\"4：拦截并替换方法\"><a href=\"#4：拦截并替换方法\" class=\"headerlink\" title=\"4：拦截并替换方法\"></a>4：拦截并替换方法</h4><p>在程序当中，假设XiaoMing的中有<code>test1</code>这个方法，但是由于某种原因，我们要改变这个方法的实现，但是又不能去动它的源代码(正如一些开源库出现问题的时候)，这个时候runtime就派上用场了。</p>\n<p>我们先增加一个tool类，然后写一个我们自己实现的方法-change，<br>通过runtime把test1替换成change。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class PersionClass = object_getClass([Person class]);</div><div class=\"line\">Class toolClass = object_getClass([tool class]);</div><div class=\"line\"></div><div class=\"line\">    ////源方法的SEL和Method</div><div class=\"line\">    </div><div class=\"line\">    SEL oriSEL = @selector(test1);</div><div class=\"line\">    Method oriMethod = class_getInstanceMethod(PersionClass, oriSEL);</div><div class=\"line\">    </div><div class=\"line\">    ////交换方法的SEL和Method</div><div class=\"line\">    </div><div class=\"line\">    SEL cusSEL = @selector(change);</div><div class=\"line\">    Method cusMethod = class_getInstanceMethod(toolClass, cusSEL);</div><div class=\"line\">    </div><div class=\"line\">    ////先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况</div><div class=\"line\">    </div><div class=\"line\">    BOOL addSucc = class_addMethod(PersionClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class=\"line\">    if (addSucc) &#123;</div><div class=\"line\">          // 添加成功：将源方法的实现替换到交换方法的实现     </div><div class=\"line\">        class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class=\"line\">               </div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">    //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即</div><div class=\"line\">method_exchangeImplementations(oriMethod, cusMethod);  </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5：在方法上增加额外功能\"><a href=\"#5：在方法上增加额外功能\" class=\"headerlink\" title=\"5：在方法上增加额外功能\"></a>5：在方法上增加额外功能</h4><p>有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation UIButton (Hook)</div><div class=\"line\"></div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\"></div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\"></div><div class=\"line\">        Class selfClass = [self class];</div><div class=\"line\"></div><div class=\"line\">        SEL oriSEL = @selector(sendAction:to:forEvent:);</div><div class=\"line\">        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</div><div class=\"line\"></div><div class=\"line\">        SEL cusSEL = @selector(mySendAction:to:forEvent:);</div><div class=\"line\">        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</div><div class=\"line\"></div><div class=\"line\">        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class=\"line\">        if (addSucc) &#123;</div><div class=\"line\">            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class=\"line\">        &#125;else &#123;</div><div class=\"line\">            method_exchangeImplementations(oriMethod, cusMethod);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</div><div class=\"line\">    [CountTool addClickCount];</div><div class=\"line\">    [self mySendAction:action to:target forEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>load方法会在类第一次加载的时候被调用,调用的时间比较靠前，适合在这个方法里做方法交换,方法交换应该被保证，在程序中只会执行一次。</p>\n<h4 id=\"6-实现NSCoding的自动归档和解档\"><a href=\"#6-实现NSCoding的自动归档和解档\" class=\"headerlink\" title=\"6.实现NSCoding的自动归档和解档\"></a>6.实现NSCoding的自动归档和解档</h4><p>如果你实现过自定义模型数据持久化的过程，那么你也肯定明白，如果一个模型有许多个属性，那么我们需要对每个属性都实现一遍<code>encodeObject</code> 和 <code>decodeObjectForKey</code>方法，如果这样的模型又有很多个，这还真的是一个十分麻烦的事情。下面来看看简单的实现方式。<br>假设现在有一个Movie类，有3个属性，它的<code>h</code>文件这这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding</div><div class=\"line\">@interface Movie : NSObject&lt;NSCoding&gt;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, copy) NSString *movieId;</div><div class=\"line\">@property (nonatomic, copy) NSString *movieName;</div><div class=\"line\">@property (nonatomic, copy) NSString *pic_url;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>如果是正常写法， <code>m</code>文件应该是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)aCoder</div><div class=\"line\">&#123;</div><div class=\"line\">    [aCoder encodeObject:_movieId forKey:@&quot;id&quot;];</div><div class=\"line\">    [aCoder encodeObject:_movieName forKey:@&quot;name&quot;];</div><div class=\"line\">    [aCoder encodeObject:_pic_url forKey:@&quot;url&quot;];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)aDecoder</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init]) &#123;</div><div class=\"line\">        self.movieId = [aDecoder decodeObjectForKey:@&quot;id&quot;];</div><div class=\"line\">        self.movieName = [aDecoder decodeObjectForKey:@&quot;name&quot;];</div><div class=\"line\">        self.pic_url = [aDecoder decodeObjectForKey:@&quot;url&quot;];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>如果这里有100个属性，那么我们也只能把100个属性都给写一遍。<br>不过你会使用runtime后，这里就有更简便的方法。<br>下面看看runtime的实现方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)encoder</div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    unsigned int count = 0;</div><div class=\"line\">    Ivar *ivars = class_copyIvarList([Movie class], &amp;count);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i&lt;count; i++) &#123;</div><div class=\"line\">        // 取出i位置对应的成员变量</div><div class=\"line\">        Ivar ivar = ivars[i];</div><div class=\"line\">        // 查看成员变量</div><div class=\"line\">        const char *name = ivar_getName(ivar);</div><div class=\"line\">        // 归档</div><div class=\"line\">        NSString *key = [NSString stringWithUTF8String:name];</div><div class=\"line\">        id value = [self valueForKey:key];</div><div class=\"line\">        [encoder encodeObject:value forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(ivars);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)decoder</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init]) &#123;</div><div class=\"line\">        unsigned int count = 0;</div><div class=\"line\">        Ivar *ivars = class_copyIvarList([Movie class], &amp;count);</div><div class=\"line\">        for (int i = 0; i&lt;count; i++) &#123;</div><div class=\"line\">        // 取出i位置对应的成员变量</div><div class=\"line\">        Ivar ivar = ivars[i];</div><div class=\"line\">        // 查看成员变量</div><div class=\"line\">        const char *name = ivar_getName(ivar);</div><div class=\"line\">       // 归档</div><div class=\"line\">       NSString *key = [NSString stringWithUTF8String:name];</div><div class=\"line\">      id value = [decoder decodeObjectForKey:key];</div><div class=\"line\">       // 设置到成员变量身上</div><div class=\"line\">        [self setValue:value forKey:key];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        free(ivars);</div><div class=\"line\">    &#125; </div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这样的方式实现，不管有多少个属性，写这几行代码就搞定了。怎么，还嫌麻烦，下面看看更加简便的方法：两句代码搞定。<br>我们把<code>encodeWithCoder</code> 和 <code>initWithCoder</code>这两个方法抽成宏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">#define encodeRuntime(A) \\</div><div class=\"line\">\\</div><div class=\"line\">unsigned int count = 0;\\</div><div class=\"line\">Ivar *ivars = class_copyIvarList([A class], &amp;count);\\</div><div class=\"line\">for (int i = 0; i&lt;count; i++) &#123;\\</div><div class=\"line\">Ivar ivar = ivars[i];\\</div><div class=\"line\">const char *name = ivar_getName(ivar);\\</div><div class=\"line\">NSString *key = [NSString stringWithUTF8String:name];\\</div><div class=\"line\">id value = [self valueForKey:key];\\</div><div class=\"line\">[encoder encodeObject:value forKey:key];\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">free(ivars);\\</div><div class=\"line\">\\</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#define initCoderRuntime(A) \\</div><div class=\"line\">\\</div><div class=\"line\">if (self = [super init]) &#123;\\</div><div class=\"line\">unsigned int count = 0;\\</div><div class=\"line\">Ivar *ivars = class_copyIvarList([A class], &amp;count);\\</div><div class=\"line\">for (int i = 0; i&lt;count; i++) &#123;\\</div><div class=\"line\">Ivar ivar = ivars[i];\\</div><div class=\"line\">const char *name = ivar_getName(ivar);\\</div><div class=\"line\">NSString *key = [NSString stringWithUTF8String:name];\\</div><div class=\"line\">id value = [decoder decodeObjectForKey:key];\\</div><div class=\"line\">[self setValue:value forKey:key];\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">free(ivars);\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">return self;\\</div><div class=\"line\">\\</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)encoder</div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    encodeRuntime(Movie)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)decoder</div><div class=\"line\">&#123;</div><div class=\"line\">    initCoderRuntime(Movie)</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。</p>\n<h4 id=\"7-实现字典转模型的自动转换\"><a href=\"#7-实现字典转模型的自动转换\" class=\"headerlink\" title=\"7.实现字典转模型的自动转换\"></a>7.实现字典转模型的自动转换</h4><p>字典转模型的应用可以说是每个app必然会使用的场景,虽然实现的方式略有不同，但是原理都是一致的：遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。<br>像几个出名的开源库：JSONModel,MJExtension等都是通过这种方式实现的。</p>\n<ul>\n<li>先实现最外层的属性转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建对应模型对象</div><div class=\"line\"> id objc = [[self alloc] init];</div><div class=\"line\"></div><div class=\"line\"> unsigned int count = 0;</div><div class=\"line\"></div><div class=\"line\"> // 1.获取成员属性数组</div><div class=\"line\"> Ivar *ivarList = class_copyIvarList(self, &amp;count);</div><div class=\"line\"></div><div class=\"line\"> // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值</div><div class=\"line\"> for (int i = 0; i &lt; count; i++) &#123;</div><div class=\"line\"></div><div class=\"line\">     // 2.1 获取成员属性</div><div class=\"line\">     Ivar ivar = ivarList[i];</div><div class=\"line\"></div><div class=\"line\">     // 2.2 获取成员属性名 C -&gt; OC 字符串</div><div class=\"line\">    NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class=\"line\"></div><div class=\"line\">     // 2.3 _成员属性名 =&gt; 字典key</div><div class=\"line\">     NSString *key = [ivarName substringFromIndex:1];</div><div class=\"line\"></div><div class=\"line\">     // 2.4 去字典中取出对应value给模型属性赋值</div><div class=\"line\">     id value = dict[key];</div><div class=\"line\"></div><div class=\"line\">     // 获取成员属性类型</div><div class=\"line\">     NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure>\n<p>如果模型比较简单，只有NSString，NSNumber等，这样就可以搞定了。但是如果模型含有NSArray，或者NSDictionary等，那么我们还需要进行第二步转换。</p>\n<ul>\n<li>内层数组，字典的转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType containsString:@&quot;NS&quot;]) &#123; </div><div class=\"line\"></div><div class=\"line\">             //  是字典对象,并且属性名对应类型是自定义类型</div><div class=\"line\">            // 处理类型字符串 @\\&quot;User\\&quot; -&gt; User</div><div class=\"line\">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;];</div><div class=\"line\">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\\&quot;&quot; withString:@&quot;&quot;];</div><div class=\"line\">            // 自定义对象,并且值是字典</div><div class=\"line\">            // value:user字典 -&gt; User模型</div><div class=\"line\">            // 获取模型(user)类对象</div><div class=\"line\">            Class modalClass = NSClassFromString(ivarType);</div><div class=\"line\"></div><div class=\"line\">            // 字典转模型</div><div class=\"line\">            if (modalClass) &#123;</div><div class=\"line\">                // 字典转模型 user</div><div class=\"line\">                value = [modalClass objectWithDict:value];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if ([value isKindOfClass:[NSArray class]]) &#123;</div><div class=\"line\">            // 判断对应类有没有实现字典数组转模型数组的协议</div><div class=\"line\">            if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;</div><div class=\"line\"></div><div class=\"line\">                // 转换成id类型，就能调用任何对象的方法</div><div class=\"line\">                id idSelf = self;</div><div class=\"line\"></div><div class=\"line\">                // 获取数组中字典对应的模型</div><div class=\"line\">                NSString *type =  [idSelf arrayContainModelClass][key];</div><div class=\"line\"></div><div class=\"line\">                // 生成模型</div><div class=\"line\">                Class classModel = NSClassFromString(type);</div><div class=\"line\">                NSMutableArray *arrM = [NSMutableArray array];</div><div class=\"line\">                // 遍历字典数组，生成模型数组</div><div class=\"line\">                for (NSDictionary *dict in value) &#123;</div><div class=\"line\">                    // 字典转模型</div><div class=\"line\">                    id model =  [classModel objectWithDict:dict];</div><div class=\"line\">                    [arrM addObject:model];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // 把模型数组赋值给value</div><div class=\"line\">                value = arrM;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>我自己觉得系统自带的KVC模式字典转模型就挺好的，假设movie是一个模型对象，dict 是一个需要转化的 <code>[movie setValuesForKeysWithDictionary:dict];</code> 这个是系统自带的字典转模型方法，个人感觉也还是挺好用的，不过使用这个方法的时候需要在模型里面再实现一个方法才行，<br><code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code> 重写这个方法为了实现两个目的：1. 模型中的属性和字典中的key不一致的情况，比如字典中有个<code>id</code>,我们需要把它赋值给<code>uid</code>属性；2. 字典中属性比模型的属性还多的情况。<br>如果出现以上两种情况而没有实现这个方法的话，程序就会崩溃。<br>这个方法的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setValue:(id)value forUndefinedKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    if ([key isEqualToString:@&quot;id&quot;]) &#123;</div><div class=\"line\">        self.uid = value;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"六-几个参数概念\"><a href=\"#六-几个参数概念\" class=\"headerlink\" title=\"六.几个参数概念\"></a>六.几个参数概念</h3><p>以上的几种方法应该算是runtime在实际场景中所应用的大部分的情况了，平常的编码中差不多足够用了。<br>如果从头仔细看到尾，相信你基本的用法应该会了，虽然会用是主要的目的，有几个基本的参数概念还是要了解一下的。</p>\n<h4 id=\"1-objc-msgSend\"><a href=\"#1-objc-msgSend\" class=\"headerlink\" title=\"1.objc_msgSend\"></a>1.objc_msgSend</h4> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* Basic Messaging Primitives</div><div class=\"line\">*</div><div class=\"line\">* On some architectures, use objc_msgSend_stret for some struct return types.</div><div class=\"line\">* On some architectures, use objc_msgSend_fpret for some float return types.</div><div class=\"line\">* On some architectures, use objc_msgSend_fp2ret for some float return types.</div><div class=\"line\">*</div><div class=\"line\">* These functions must be cast to an appropriate function pointer type </div><div class=\"line\">* before being called. </div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<p>这是官方的声明，从这个函数的注释可以看出来了，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用<code>objc_msgSend_stret</code>来发送返回值类型为结构体的消息，使用<code>objc_msgSend_fpret</code>来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用objc_msgSend_fp2ret来发送返回值类型为浮点类型的消息。<br>最关键的一点：无论何时，要调用<code>objc_msgSend</code>函数，必须要将函数强制转换成合适的函数指针类型才能调用。<br>从<code>objc_msgSend</code>函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。<br>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>”Super”</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>”stret”</code>的函数。</p>\n<h4 id=\"2-SEL\"><a href=\"#2-SEL\" class=\"headerlink\" title=\"2.SEL\"></a>2.SEL</h4><p><code>objc_msgSend</code>函数第二个参数类型为SEL，它是<code>selector在Objc</code>中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:<br><code>typedef struct objc_selector *SEL</code>;<br>其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令<code>@selector()</code>或者 Runtime 系统的<code>sel_registerName</code>函数来获得一个SEL类型的方法选择器。<br>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法)，Cocoa 中有好多长长的方法哦。</p>\n<h4 id=\"3-id\"><a href=\"#3-id\" class=\"headerlink\" title=\"3.id\"></a>3.id</h4><p><code>objc_msgSend</code>第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：<br><code>typedef struct objc_object *id</code>;<br>那objc_object又是啥呢：<br><code>struct objc_object { Class isa; }</code>;<br><code>objc_object</code>结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。<br>PS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html\">官方文档</a>.</p>\n<h4 id=\"4-Class\"><a href=\"#4-Class\" class=\"headerlink\" title=\"4.Class\"></a>4.Class</h4><p>之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：<br><code>typedef struct objc_class *Class</code>;<br>objc_class里面的东西多着呢：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">#if  !__OBJC2__</div><div class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class=\"line\">    const char *name                                         OBJC2_UNAVAILABLE;</div><div class=\"line\">    long version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    long info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>\n<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。<br>在<code>objc_class</code>结构体中：<code>ivars是objc_ivar_list</code>指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。也就是说可以动态修改 <code>*methodLists</code> 的值来添加成员方法，这也是Category实现的原理.</p>\n<p>上面讲到的所有东西都在Demo里，如果你觉得不错，还请为我的Demo star一个。<br><a href=\"https://github.com/suifengqjn/runtime\">demo下载</a></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/2.png\" alt=\"image\"></p>"},{"title":"swift自动布局","date":"2016-11-24T15:48:09.000Z","_content":"\n### 苹果原生自动布局\n\n- 自动布局核心公式\n\n` view1.attr1 = view2.attr2 * multiplier + constant`\n\n- 自动布局构造函数\n\n``` \nNSLayoutConstraint(item: 视图,\n\tattribute: 约束属性，\n\trelatedBy: 约束关系，\n\ttoItem: 参照视图,\n\tattribute: 参照属性,\n\tmultiplier:乘积,\n\tconstant:约束数值\n)\n\n```\n<!--more-->\n\n- 如果指定 宽 高 约束\n  - 参照视图设置为 nil\n  - 参照属性选择 .notAnAttribute\n  \n- 自动布局类函数\n\n```\nNSLayoutConstraint.constraints(withVisualFormat: VLF公式,\n options:[], \n metrics: 约束数值字典[String : 数值], \n views: 视图字典[String : 子视图]\n )\n```\n\n- VFL 可视化格式化语言\n  - H 水平方向\n  - V 垂直方向\n  - | 边界\n  - [] 包含控件的名称字符串，对应关系在`views`字典中定义\n  - () 定义控件的宽/高，可以在`metrics`中指定\n>tip：VFL 通常用于连续参照关系，如果遇到居中对齐，通常使用直接参照\n\n","source":"_posts/swift自动布局.md","raw":"---\ntitle: swift自动布局\ndate: 2016-11-24 23:48:09\ncategories:\n  - Swfit\ntags:\n  - Swift\n  - 自动布局\n---\n\n### 苹果原生自动布局\n\n- 自动布局核心公式\n\n` view1.attr1 = view2.attr2 * multiplier + constant`\n\n- 自动布局构造函数\n\n``` \nNSLayoutConstraint(item: 视图,\n\tattribute: 约束属性，\n\trelatedBy: 约束关系，\n\ttoItem: 参照视图,\n\tattribute: 参照属性,\n\tmultiplier:乘积,\n\tconstant:约束数值\n)\n\n```\n<!--more-->\n\n- 如果指定 宽 高 约束\n  - 参照视图设置为 nil\n  - 参照属性选择 .notAnAttribute\n  \n- 自动布局类函数\n\n```\nNSLayoutConstraint.constraints(withVisualFormat: VLF公式,\n options:[], \n metrics: 约束数值字典[String : 数值], \n views: 视图字典[String : 子视图]\n )\n```\n\n- VFL 可视化格式化语言\n  - H 水平方向\n  - V 垂直方向\n  - | 边界\n  - [] 包含控件的名称字符串，对应关系在`views`字典中定义\n  - () 定义控件的宽/高，可以在`metrics`中指定\n>tip：VFL 通常用于连续参照关系，如果遇到居中对齐，通常使用直接参照\n\n","slug":"swift自动布局","published":1,"updated":"2016-12-03T16:47:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tez002blx60efos7j92","content":"<h3 id=\"苹果原生自动布局\"><a href=\"#苹果原生自动布局\" class=\"headerlink\" title=\"苹果原生自动布局\"></a>苹果原生自动布局</h3><ul>\n<li>自动布局核心公式</li>\n</ul>\n<p><code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>\n<ul>\n<li>自动布局构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSLayoutConstraint(item: 视图,</div><div class=\"line\">\tattribute: 约束属性，</div><div class=\"line\">\trelatedBy: 约束关系，</div><div class=\"line\">\ttoItem: 参照视图,</div><div class=\"line\">\tattribute: 参照属性,</div><div class=\"line\">\tmultiplier:乘积,</div><div class=\"line\">\tconstant:约束数值</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ul>\n<li><p>如果指定 宽 高 约束</p>\n<ul>\n<li>参照视图设置为 nil</li>\n<li>参照属性选择 .notAnAttribute</li>\n</ul>\n</li>\n<li><p>自动布局类函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSLayoutConstraint.constraints(withVisualFormat: VLF公式,</div><div class=\"line\"> options:[], </div><div class=\"line\"> metrics: 约束数值字典[String : 数值], </div><div class=\"line\"> views: 视图字典[String : 子视图]</div><div class=\"line\"> )</div></pre></td></tr></table></figure>\n<ul>\n<li>VFL 可视化格式化语言<ul>\n<li>H 水平方向</li>\n<li>V 垂直方向</li>\n<li>| 边界</li>\n<li>[] 包含控件的名称字符串，对应关系在<code>views</code>字典中定义</li>\n<li>() 定义控件的宽/高，可以在<code>metrics</code>中指定<blockquote>\n<p>tip：VFL 通常用于连续参照关系，如果遇到居中对齐，通常使用直接参照</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n","excerpt":"<h3 id=\"苹果原生自动布局\"><a href=\"#苹果原生自动布局\" class=\"headerlink\" title=\"苹果原生自动布局\"></a>苹果原生自动布局</h3><ul>\n<li>自动布局核心公式</li>\n</ul>\n<p><code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>\n<ul>\n<li>自动布局构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSLayoutConstraint(item: 视图,</div><div class=\"line\">\tattribute: 约束属性，</div><div class=\"line\">\trelatedBy: 约束关系，</div><div class=\"line\">\ttoItem: 参照视图,</div><div class=\"line\">\tattribute: 参照属性,</div><div class=\"line\">\tmultiplier:乘积,</div><div class=\"line\">\tconstant:约束数值</div><div class=\"line\">)</div></pre></td></tr></table></figure>","more":"<ul>\n<li><p>如果指定 宽 高 约束</p>\n<ul>\n<li>参照视图设置为 nil</li>\n<li>参照属性选择 .notAnAttribute</li>\n</ul>\n</li>\n<li><p>自动布局类函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSLayoutConstraint.constraints(withVisualFormat: VLF公式,</div><div class=\"line\"> options:[], </div><div class=\"line\"> metrics: 约束数值字典[String : 数值], </div><div class=\"line\"> views: 视图字典[String : 子视图]</div><div class=\"line\"> )</div></pre></td></tr></table></figure>\n<ul>\n<li>VFL 可视化格式化语言<ul>\n<li>H 水平方向</li>\n<li>V 垂直方向</li>\n<li>| 边界</li>\n<li>[] 包含控件的名称字符串，对应关系在<code>views</code>字典中定义</li>\n<li>() 定义控件的宽/高，可以在<code>metrics</code>中指定<blockquote>\n<p>tip：VFL 通常用于连续参照关系，如果遇到居中对齐，通常使用直接参照</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"slice","date":"2018-05-04T03:45:23.000Z","_content":"\n\n切片的几种常用操作，reslice, append, copy, delete, insert, 排序, 取最值等，这几种基本上可以解决日常开发的绝大部分的问题了。\n\n### slice声明和创建\n\nslice 本身不是数组，它指向数组的底层\n作为变长数组饿替代方案，可以关联底层数组的全部或者局部\n可以直接创建，一般用make(), 也可以从底层数组获取生成\n如果多个slice 指向相同的底层数组，一个值的改变会影响全部\n\n<!--more-->\n\n```\nfunc sliceCreate() {\n\n\t//声明 slice 如果只是声明，只有指针初始地址，容量为0\n\tvar slice1 []int\n\n\tfmt.Printf(\"slice1  %p\\n\", slice1)\n\n\t//添加元素后，容量超出上限，内存地址重新分配\n\tslice1 = []int{1, 2, 3}\n\n\tfmt.Printf(\"slice1  %p\\n\", slice1)\n\n\t//声明并赋值\n\n\tvar s2 = []string{\"a\", \"b\", \"c\"}\n\tfmt.Println(s2)\n\n\tvar arr = [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tfmt.Print(\"s2  \\n\", arr)\n\n\t// 取第二个元素\n\tslice2 := arr[1]\n\tfmt.Println(slice2)\n\n\t//取第5到10个元素\n\tslice3 := arr[5:10] // slice范围取值的时候，前面闭区间，后面开区间\n\tfmt.Println(slice3)\n\n\t//从第5个元素取到最后  的两种写法\n\tslice4 := arr[5:len(arr)]\n\tslice5 := arr[5:]\n\tfmt.Println(slice4, slice5)\n\n\t//取前5个元素\n\tslice6 := arr[:5]\n\tfmt.Print(\"\\n\", slice6)\n\n\t//使用make 创建slice\n\t//存放的元素是int类型，初始容量是3, 容量超过10再次开辟内存空间，并且容量翻倍\n\t// 如果不给初始容量，默认的初始容量就是当前元素个数\n\ts1 := make([]int, 3, 10)\n\tfmt.Print(\"\\n\", len(s1), cap(s1))\n}\n```\n\n输出\n\n```\nslice1  0x0\nslice1  0xc4200182c0\n[a b c]\ns2  \n[0 1 2 3 4 5 6 7 8 9]1\n[5 6 7 8 9]\n[5 6 7 8 9] [5 6 7 8 9]\n\n[0 1 2 3 4]\n3 10\n```\n\n### ReSlice\n\n```\nfunc ResliceTest() {\n\t\n\t// reslice索引 以 被slice 为准\n\t// 索引不可以超过cap值\n\n\tvar a = []byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}\n\n\t// 切片区间取值 包含起始值， 不包含终止值 相当与 闭开区间\n\t//取出 cde\n\tvar s1 = a[2:5]\n\tfmt.Println(string(s1))\n\tfmt.Println(len(s1), cap(s1))\n\n\t//从 s1中取出de\n\tvar s2 = s1[1:3]\n\tfmt.Print(\"\\n\", string(s2))\n\n\t// 虽然s1 指向 a中的 c 到 e, 由于a的内存是连续， 可以从s1中取到数组的末尾\n\n\tvar s3 = s1[0:cap(s1)]\n\tfmt.Print(\"\\n s3 = \", string(s3))\n\n}\n```\n\n```\ncde\n3 6\n\nde\n s3 = cdefgh\n```\n\n### Append\n\n可以在slice尾部追加元素\n可以将一个slice追加到另一个slice\nslice2 追加到slice1 后，如果容量超过slice1，则slice1容量将重新分配，内存地址也改变\n```\nfunc appendTest() {\n\n\ts1 := make([]int, 3, 6)\n\tfmt.Printf(\"%p\\n\", s1)\n\n\ts1 = append(s1, 1, 2, 3) //s1 还没有超出容量，内存地址不变\n\tfmt.Printf(\"%v---%p\\n\", s1, s1)\n\n\ts1 = append(s1, 9) //超出容量，内存地址改变\n\tfmt.Printf(\"%v %p\\n\", s1, s1)\n\n\tvar arr = []int{1, 2, 3, 4, 5}\n\tvar slice2 = arr[2:5] //3, 4, 5\n\tvar slice3 = arr[1:3] //2, 3\n\n\tfmt.Println(slice2, slice3) //重叠部分是3\n\n\tslice2[0] = 9 //改变重叠部分的值， 其他所有对应的值都会改变\n\tfmt.Println(arr, slice2, slice3)\n\n\tslice3 = append(slice3, 1, 2, 2, 2, 2, 2) //超出slice3原本的容量，内存地址重新分配，其他对象重叠部分的元素就不会改变\n\tfmt.Println(slice3)\n}\n```\n\n```\n0xc42001c0c0\n[0 0 0 1 2 3]---0xc42001c0c0\n[0 0 0 1 2 3 9] 0xc420078060\n[3 4 5] [2 3]\n[1 2 9 4 5] [9 4 5] [2 9]\n[2 9 1 2 2 2 2 2]\n```\n\n### Copy\n\n```\nfunc copyTest() {\n\n\t//copy 会把重叠部分的元素给覆盖\n\tvar s1 = []int{1, 2, 3, 4, 5, 6, 7}\n\tvar s2 = []int{7, 8, 9}\n\t// 短的copy到长的情况\n\tcopy(s1, s2) //把s2 copy 到s1 中\n\tfmt.Println(\"s1---\", s1)\n\n\t// 长的copy到短的情况\n\tvar s3 = []int{1, 2, 3, 4, 5, 6, 7}\n\tvar s4 = []int{7, 8, 9}\n\tcopy(s4, s3)\n\tfmt.Println(\"s4---\", s4)\n\n\tvar s5 = []int{1, 2, 3, 4, 5, 6, 7}\n\tvar s6 = []int{7, 8, 9}\n\t//将制定元素copy到指定位置\n\tcopy(s5[2:4], s6[1:3])\n\tfmt.Println(\"s5---\", s5)\n\n}\n```\n\n```\ns1--- [7 8 9 4 5 6 7]\ns4--- [1 2 3]\ns5--- [1 2 8 9 5 6 7]\n```\n\n### delete\n\ngo官方没有提供删除的方法，只能自己实现，实现的方法有多种，这里给出一种简洁的实现方式\n\n```\nfunc sliceDelete() {\n\n\tvar slice = []string{\"a\", \"b\", \"c\", \"d\"}\n\n\tfmt.Println(removeString(slice, 2)\n}\n\n//删除函数\nfunc removeString(s []string, i int) []string {\n\n\treturn append(s[:i], s[i+1:]...)\n\n}\n```\n\n输出\n\n```\n[a b d]\n```\n\n### insert\n\n官方还是没有提供插入的方法，需要自己实现，如果用`append`实现，`append`每次操作都会复制创建一个新的底层数组，会比较耗性能，这里采用反射实现\n这里需要引入`reflect`\n\n```\nfunc silceInsert() {\n\n\ta := []int{1, 2, 3, 4, 5}\n\tfmt.Println(a)\n\tfmt.Println(\"插入元素后\", Insert(a, 3, 0))\n\n\tb := []string{\"a\", \"b\", \"c\", \"d\", \"e\"}\n\tfmt.Println(b)\n\tfmt.Println(\"插入元素后\", Insert(b, 3, \"x\"))\n\n\tc := []interface{}{1, \"a\", true, 3.2, 'a'}\n\tfmt.Println(c)\n\tfmt.Println(\"插入元素后\", Insert(c, 3, false))\n\n}\n\nfunc Insert(slice interface{}, pos int, value interface{}) interface{} {\n\tv := reflect.ValueOf(slice)\n\tv = reflect.Append(v, reflect.ValueOf(value))\n\treflect.Copy(v.Slice(pos+1, v.Len()), v.Slice(pos, v.Len()))\n\tv.Index(pos).Set(reflect.ValueOf(value))\n\treturn v.Interface()\n}\n```\n\n```\n[1 2 3 4 5]\n插入元素后 [1 2 3 0 4 5]\n[a b c d e]\n插入元素后 [a b c x d e]\n[1 a true 3.2 97]\n插入元素后 [1 a true false 3.2 97]\n```\n\n\n### 排序\n\n几种常见的排序方法：冒泡算法，选择排序，插入排序，快速排序，不过对于排序，官方倒是给出了方法，可以直接使用，需要引入`sort`\n\n#### 升序排序\n\n对于 int 、 float64 和 string 数组或是分片的排序， go 分别提供了 sort.Ints() 、 sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序。\n\n```\nfunc sliceSort() {\n\n\tintList := []int{2, 4, 3, 5, 7, 6, 9, 8, 1, 0}\n\tfloat8List := []float64{4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14}\n\tstringList := []string{\"a\", \"c\", \"b\", \"d\", \"f\", \"i\", \"z\", \"x\", \"w\", \"y\"}\n\n\tsort.Ints(intList)\n\tsort.Float64s(float8List)\n\tsort.Strings(stringList)\n\n\tfmt.Printf(\"%v\\n%v\\n%v\\n\", intList, float8List, stringList)\n}\n```\n\n```\n[0 1 2 3 4 5 6 7 8 9]\n[3.14 4.2 5.9 10 12.3 27.81828 31.4 50.4 99.9]\n[a b c d f i w x y z]\n```\n\n#### 降序排序\n\nint 、 float64 和 string 都有默认的升序排序函数， 现在问题是如果降序如何 ？ 有其他语言编程经验的人都知道，只需要交换 cmp 的比较法则就可以了， go 的实现是类似的，然而又有所不同。 go 中对某个 Type 的对象 obj 排序， 可以使用 sort.Sort(obj) 即可，就是需要对 Type 类型绑定三个方法 ： Len() 求长度、Less(i,j) 比较第 i 和 第 j 个元素大小的函数、 Swap(i,j) 交换第 i 和第 j 个元素的函数。sort 包下的三个类型 IntSlice 、 Float64Slice 、 StringSlice 分别实现了这三个方法， 对应排序的是 [] int 、 [] float64 和 [] string 。如果期望逆序排序， 只需要将对应的 Less 函数简单修改一下即可。\n\ngo 的 sort 包可以使用 sort.Reverse(slice) 来调换 slice.Interface.Less ，也就是比较函数，所以， int 、 float64 和 string 的逆序排序函数可以这么写：\n\n```\nfunc sliceSort2() {\n\tintList := []int{2, 4, 3, 5, 7, 6, 9, 8, 1, 0}\n\tfloat8List := []float64{4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14}\n\tstringList := []string{\"a\", \"c\", \"b\", \"d\", \"f\", \"i\", \"z\", \"x\", \"w\", \"y\"}\n\n\tsort.Sort(sort.Reverse(sort.IntSlice(intList)))\n\tsort.Sort(sort.Reverse(sort.Float64Slice(float8List)))\n\tsort.Sort(sort.Reverse(sort.StringSlice(stringList)))\n\n\tfmt.Printf(\"%v\\n%v\\n%v\\n\", intList, float8List, stringList)\n}\n```\n\n\n```\n[9 8 7 6 5 4 3 2 1 0]\n[99.9 50.4 31.4 27.81828 12.3 10 5.9 4.2 3.14]\n[z y x w i f d c b a]\n```\n\n#### 结构体类型的排序\n结构体类型的排序是通过使用 sort.Sort(slice) 实现的， 只要 slice 实现了 sort.Interface 的三个方法就可以。 虽然这么说，但是排序的方法却有那么好几种。首先一种就是模拟排序 [] int 构造对应的 IntSlice 类型，然后对 IntSlice 类型实现 Interface 的三个方法。\n##### 1、模拟 IntSlice 排序\n```\npackage main\n \nimport (\n    \"fmt\"\n    \"sort\"\n)\n \ntype Person struct {\n    Name string\n    Age  int\n}\n \n// 按照 Person.Age 从大到小排序\ntype PersonSlice [] Person\n \nfunc (a PersonSlice) Len() int {    \t // 重写 Len() 方法\n    return len(a)\n}\nfunc (a PersonSlice) Swap(i, j int){     // 重写 Swap() 方法\n    a[i], a[j] = a[j], a[i]\n}\nfunc (a PersonSlice) Less(i, j int) bool {    // 重写 Less() 方法， 从大到小排序\n    return a[j].Age < a[i].Age\n}\n \nfunc main() {\n    people := [] Person{\n        {\"zhang san\", 12},\n        {\"li si\", 30},\n        {\"wang wu\", 52},\n        {\"zhao liu\", 26},\n    }\n \n    fmt.Println(people)\n \n    sort.Sort(PersonSlice(people))    // 按照 Age 的逆序排序\n    fmt.Println(people)\n \n    sort.Sort(sort.Reverse(PersonSlice(people)))    // 按照 Age 的升序排序\n    fmt.Println(people)\n \n}\n```\n\n这完全是一种模拟的方式，所以如果懂了 IntSlice 自然就理解这里了，反过来，理解了这里那么 IntSlice 那里也就懂了。\n这种方法的缺点是：根据 Age 排序需要重新定义 PersonSlice 方法，绑定 Len 、 Less 和 Swap 方法， 如果需要根据 Name 排序， 又需要重新写三个函数； 如果结构体有 4 个字段，有四种类型的排序，那么就要写 3 × 4 = 12 个方法， 即使有一些完全是多余的， O__O”… 仔细思量一下，根据不同的标准 Age 或是 Name， 真正不同的体现在 Less 方法上，所以可以将 Less 抽象出来， 每种排序的 Less 让其变成动态的，比如下面一种方法。\n\n##### 2、封装成 Wrapper\n\n```\npackage main\n \nimport (\n    \"fmt\"\n    \"sort\"\n)\n \ntype Person struct {\n    Name string\n    Age  int\n}\n \ntype PersonWrapper struct {\t\t\t\t\t//注意此处\n    people [] Person\n    by func(p, q * Person) bool\n}\n \nfunc (pw PersonWrapper) Len() int {    \t\t// 重写 Len() 方法\n    return len(pw.people)\n}\nfunc (pw PersonWrapper) Swap(i, j int){     // 重写 Swap() 方法\n    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]\n}\nfunc (pw PersonWrapper) Less(i, j int) bool {    // 重写 Less() 方法\n    return pw.by(&pw.people[i], &pw.people[j])\n}\n \nfunc main() {\n    people := [] Person{\n        {\"zhang san\", 12},\n        {\"li si\", 30},\n        {\"wang wu\", 52},\n        {\"zhao liu\", 26},\n    }\n \n    fmt.Println(people)\n \n    sort.Sort(PersonWrapper{people, func (p, q *Person) bool {\n        return q.Age < p.Age    // Age 递减排序\n    }})\n \n    fmt.Println(people)\n    sort.Sort(PersonWrapper{people, func (p, q *Person) bool {\n        return p.Name < q.Name    // Name 递增排序\n    }})\n \n    fmt.Println(people)\n \n}\n```\n\n这种方法将 [] Person 和比较的准则 cmp 封装在了一起，形成了 PersonWrapper 函数，然后在其上绑定 Len 、 Less 和 Swap 方法。 实际上 sort.Sort(pw) 排序的是 pw 中的 people， 这就是前面说的， go 的排序未必就是针对的一个数组或是 slice， 而可以是一个对象中的数组或是 slice 。\n\n##### 3、进一步封装\n\n感觉方法 2 已经很不错了， 唯一一个缺点是，在 main 中使用的时候暴露了 sort.Sort 的使用，还有就是 PersonWrapper 的构造。 为了让 main 中使用起来更为方便， me 们可以再简单的封装一下， 构造一个 SortPerson 方法， 如下：\n```\npackage main\n \nimport (\n    \"fmt\"\n    \"sort\"\n)\n \ntype Person struct {\n    Name string\n    Age  int\n}\n \ntype PersonWrapper struct {\n    people [] Person\n    by func(p, q * Person) bool\n}\n \ntype SortBy func(p, q *Person) bool\n \nfunc (pw PersonWrapper) Len() int {    \t\t// 重写 Len() 方法\n    return len(pw.people)\n}\nfunc (pw PersonWrapper) Swap(i, j int){         // 重写 Swap() 方法\n    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]\n}\nfunc (pw PersonWrapper) Less(i, j int) bool {    // 重写 Less() 方法\n    return pw.by(&pw.people[i], &pw.people[j])\n}\n \n// 封装成 SortPerson 方法\nfunc SortPerson(people [] Person, by SortBy){\n    sort.Sort(PersonWrapper{people, by})\n}\n \nfunc main() {\n    people := [] Person{\n        {\"zhang san\", 12},\n        {\"li si\", 30},\n        {\"wang wu\", 52},\n        {\"zhao liu\", 26},\n    }\n \n    fmt.Println(people)\n \n    sort.Sort(PersonWrapper{people, func (p, q *Person) bool {\n        return q.Age < p.Age    // Age 递减排序\n    }})\n \n    fmt.Println(people)\n \n    SortPerson(people, func (p, q *Person) bool {\n        return p.Name < q.Name    // Name 递增排序\n    })\n \n    fmt.Println(people)\n \n}\n```\n在方法 2 的基础上构造了 SortPerson 函数，使用的时候传过去一个 [] Person 和一个 cmp 函数。\n\n##### 4、另一种思路\n\n```\npackage main\n \nimport (\n    \"fmt\"\n    \"sort\"\n)\n \ntype Person struct {\n    Name        string\n    Weight      int\n}\n \ntype PersonSlice []Person\n \nfunc (s PersonSlice) Len() int  { return len(s) }\nfunc (s PersonSlice) Swap(i, j int)     { s[i], s[j] = s[j], s[i] }\n \ntype ByName struct{ PersonSlice }    // 将 PersonSlice 包装起来到 ByName 中\n \nfunc (s ByName) Less(i, j int) bool     { return s.PersonSlice[i].Name < s.PersonSlice[j].Name }    // 将 Less 绑定到 ByName 上\n \n \ntype ByWeight struct{ PersonSlice }    // 将 PersonSlice 包装起来到 ByWeight 中\nfunc (s ByWeight) Less(i, j int) bool   { return s.PersonSlice[i].Weight < s.PersonSlice[j].Weight }    // 将 Less 绑定到 ByWeight 上\n \nfunc main() {\n    s := []Person{\n        {\"apple\", 12},\n        {\"pear\", 20},\n        {\"banana\", 50},\n        {\"orange\", 87},\n        {\"hello\", 34},\n        {\"world\", 43},\n    }\n \n    sort.Sort(ByWeight{s})\n    fmt.Println(\"People by weight:\")\n    printPeople(s)\n \n    sort.Sort(ByName{s})\n    fmt.Println(\"\\nPeople by name:\")\n    printPeople(s)\n \n}\n \nfunc printPeople(s []Person) {\n    for _, o := range s {\n        fmt.Printf(\"%-8s (%v)\\n\", o.Name, o.Weight)\n    }\n}\n```\n对结构体的排序， 暂时就到这里。 第一种排序对只根据一个字段的比较合适， 另外三个是针对可能根据多个字段排序的。方法 4 我认为每次都要多构造一个 ByXXX ， 颇为不便， 这样多麻烦，不如方法 2 和方法 3 来的方便，直接传进去一个 cmp。 方法2、 3 没有太大的差别， 3 只是简单封装了一下而已， 对于使用者来说， 可能会更方便一些，而且也会更少的出错。\n\n\n### 取最值\n\n这个取最大值和最小值也是需要自己实现, 引入包`math`\n```\nfunc sliceMinMax() {\n\tintList := []int{2, 4, 3, 5, 7, 6, 9, 8, 1, 0}\n\n\tfmt.Println(intList)\n\t//取最大值\n\tfmt.Println(\"maxValue = \", getMaxValue(intList))\n\n\t//取最小值\n\tfmt.Println(\"minValue = \", getMinValue(intList))\n\n}\n\nfunc getMaxValue(slice []int) int {\n\tvar maxValue float64 = float64(slice[0])\n\tfor _, v := range slice {\n\t\tmaxValue = math.Max(float64(maxValue), float64(v))\n\t}\n\treturn int(maxValue)\n}\n\nfunc getMinValue(slice []int) int {\n\tvar maxValue float64 = float64(slice[0])\n\tfor _, v := range slice {\n\t\tmaxValue = math.Min(float64(maxValue), float64(v))\n\t}\n\treturn int(maxValue)\n}\n```\n\n```\n[2 4 3 5 7 6 9 8 1 0]\nmaxValue =  9\nminValue =  0\n```\n\n\n\n\n\n","source":"_posts/slice.md","raw":"---\ntitle: slice\ncategories:\n  - go\ntags:\n  - go\n  - slice\n  - 排序\ndate: 2018-05-04 11:45:23\n---\n\n\n切片的几种常用操作，reslice, append, copy, delete, insert, 排序, 取最值等，这几种基本上可以解决日常开发的绝大部分的问题了。\n\n### slice声明和创建\n\nslice 本身不是数组，它指向数组的底层\n作为变长数组饿替代方案，可以关联底层数组的全部或者局部\n可以直接创建，一般用make(), 也可以从底层数组获取生成\n如果多个slice 指向相同的底层数组，一个值的改变会影响全部\n\n<!--more-->\n\n```\nfunc sliceCreate() {\n\n\t//声明 slice 如果只是声明，只有指针初始地址，容量为0\n\tvar slice1 []int\n\n\tfmt.Printf(\"slice1  %p\\n\", slice1)\n\n\t//添加元素后，容量超出上限，内存地址重新分配\n\tslice1 = []int{1, 2, 3}\n\n\tfmt.Printf(\"slice1  %p\\n\", slice1)\n\n\t//声明并赋值\n\n\tvar s2 = []string{\"a\", \"b\", \"c\"}\n\tfmt.Println(s2)\n\n\tvar arr = [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tfmt.Print(\"s2  \\n\", arr)\n\n\t// 取第二个元素\n\tslice2 := arr[1]\n\tfmt.Println(slice2)\n\n\t//取第5到10个元素\n\tslice3 := arr[5:10] // slice范围取值的时候，前面闭区间，后面开区间\n\tfmt.Println(slice3)\n\n\t//从第5个元素取到最后  的两种写法\n\tslice4 := arr[5:len(arr)]\n\tslice5 := arr[5:]\n\tfmt.Println(slice4, slice5)\n\n\t//取前5个元素\n\tslice6 := arr[:5]\n\tfmt.Print(\"\\n\", slice6)\n\n\t//使用make 创建slice\n\t//存放的元素是int类型，初始容量是3, 容量超过10再次开辟内存空间，并且容量翻倍\n\t// 如果不给初始容量，默认的初始容量就是当前元素个数\n\ts1 := make([]int, 3, 10)\n\tfmt.Print(\"\\n\", len(s1), cap(s1))\n}\n```\n\n输出\n\n```\nslice1  0x0\nslice1  0xc4200182c0\n[a b c]\ns2  \n[0 1 2 3 4 5 6 7 8 9]1\n[5 6 7 8 9]\n[5 6 7 8 9] [5 6 7 8 9]\n\n[0 1 2 3 4]\n3 10\n```\n\n### ReSlice\n\n```\nfunc ResliceTest() {\n\t\n\t// reslice索引 以 被slice 为准\n\t// 索引不可以超过cap值\n\n\tvar a = []byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}\n\n\t// 切片区间取值 包含起始值， 不包含终止值 相当与 闭开区间\n\t//取出 cde\n\tvar s1 = a[2:5]\n\tfmt.Println(string(s1))\n\tfmt.Println(len(s1), cap(s1))\n\n\t//从 s1中取出de\n\tvar s2 = s1[1:3]\n\tfmt.Print(\"\\n\", string(s2))\n\n\t// 虽然s1 指向 a中的 c 到 e, 由于a的内存是连续， 可以从s1中取到数组的末尾\n\n\tvar s3 = s1[0:cap(s1)]\n\tfmt.Print(\"\\n s3 = \", string(s3))\n\n}\n```\n\n```\ncde\n3 6\n\nde\n s3 = cdefgh\n```\n\n### Append\n\n可以在slice尾部追加元素\n可以将一个slice追加到另一个slice\nslice2 追加到slice1 后，如果容量超过slice1，则slice1容量将重新分配，内存地址也改变\n```\nfunc appendTest() {\n\n\ts1 := make([]int, 3, 6)\n\tfmt.Printf(\"%p\\n\", s1)\n\n\ts1 = append(s1, 1, 2, 3) //s1 还没有超出容量，内存地址不变\n\tfmt.Printf(\"%v---%p\\n\", s1, s1)\n\n\ts1 = append(s1, 9) //超出容量，内存地址改变\n\tfmt.Printf(\"%v %p\\n\", s1, s1)\n\n\tvar arr = []int{1, 2, 3, 4, 5}\n\tvar slice2 = arr[2:5] //3, 4, 5\n\tvar slice3 = arr[1:3] //2, 3\n\n\tfmt.Println(slice2, slice3) //重叠部分是3\n\n\tslice2[0] = 9 //改变重叠部分的值， 其他所有对应的值都会改变\n\tfmt.Println(arr, slice2, slice3)\n\n\tslice3 = append(slice3, 1, 2, 2, 2, 2, 2) //超出slice3原本的容量，内存地址重新分配，其他对象重叠部分的元素就不会改变\n\tfmt.Println(slice3)\n}\n```\n\n```\n0xc42001c0c0\n[0 0 0 1 2 3]---0xc42001c0c0\n[0 0 0 1 2 3 9] 0xc420078060\n[3 4 5] [2 3]\n[1 2 9 4 5] [9 4 5] [2 9]\n[2 9 1 2 2 2 2 2]\n```\n\n### Copy\n\n```\nfunc copyTest() {\n\n\t//copy 会把重叠部分的元素给覆盖\n\tvar s1 = []int{1, 2, 3, 4, 5, 6, 7}\n\tvar s2 = []int{7, 8, 9}\n\t// 短的copy到长的情况\n\tcopy(s1, s2) //把s2 copy 到s1 中\n\tfmt.Println(\"s1---\", s1)\n\n\t// 长的copy到短的情况\n\tvar s3 = []int{1, 2, 3, 4, 5, 6, 7}\n\tvar s4 = []int{7, 8, 9}\n\tcopy(s4, s3)\n\tfmt.Println(\"s4---\", s4)\n\n\tvar s5 = []int{1, 2, 3, 4, 5, 6, 7}\n\tvar s6 = []int{7, 8, 9}\n\t//将制定元素copy到指定位置\n\tcopy(s5[2:4], s6[1:3])\n\tfmt.Println(\"s5---\", s5)\n\n}\n```\n\n```\ns1--- [7 8 9 4 5 6 7]\ns4--- [1 2 3]\ns5--- [1 2 8 9 5 6 7]\n```\n\n### delete\n\ngo官方没有提供删除的方法，只能自己实现，实现的方法有多种，这里给出一种简洁的实现方式\n\n```\nfunc sliceDelete() {\n\n\tvar slice = []string{\"a\", \"b\", \"c\", \"d\"}\n\n\tfmt.Println(removeString(slice, 2)\n}\n\n//删除函数\nfunc removeString(s []string, i int) []string {\n\n\treturn append(s[:i], s[i+1:]...)\n\n}\n```\n\n输出\n\n```\n[a b d]\n```\n\n### insert\n\n官方还是没有提供插入的方法，需要自己实现，如果用`append`实现，`append`每次操作都会复制创建一个新的底层数组，会比较耗性能，这里采用反射实现\n这里需要引入`reflect`\n\n```\nfunc silceInsert() {\n\n\ta := []int{1, 2, 3, 4, 5}\n\tfmt.Println(a)\n\tfmt.Println(\"插入元素后\", Insert(a, 3, 0))\n\n\tb := []string{\"a\", \"b\", \"c\", \"d\", \"e\"}\n\tfmt.Println(b)\n\tfmt.Println(\"插入元素后\", Insert(b, 3, \"x\"))\n\n\tc := []interface{}{1, \"a\", true, 3.2, 'a'}\n\tfmt.Println(c)\n\tfmt.Println(\"插入元素后\", Insert(c, 3, false))\n\n}\n\nfunc Insert(slice interface{}, pos int, value interface{}) interface{} {\n\tv := reflect.ValueOf(slice)\n\tv = reflect.Append(v, reflect.ValueOf(value))\n\treflect.Copy(v.Slice(pos+1, v.Len()), v.Slice(pos, v.Len()))\n\tv.Index(pos).Set(reflect.ValueOf(value))\n\treturn v.Interface()\n}\n```\n\n```\n[1 2 3 4 5]\n插入元素后 [1 2 3 0 4 5]\n[a b c d e]\n插入元素后 [a b c x d e]\n[1 a true 3.2 97]\n插入元素后 [1 a true false 3.2 97]\n```\n\n\n### 排序\n\n几种常见的排序方法：冒泡算法，选择排序，插入排序，快速排序，不过对于排序，官方倒是给出了方法，可以直接使用，需要引入`sort`\n\n#### 升序排序\n\n对于 int 、 float64 和 string 数组或是分片的排序， go 分别提供了 sort.Ints() 、 sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序。\n\n```\nfunc sliceSort() {\n\n\tintList := []int{2, 4, 3, 5, 7, 6, 9, 8, 1, 0}\n\tfloat8List := []float64{4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14}\n\tstringList := []string{\"a\", \"c\", \"b\", \"d\", \"f\", \"i\", \"z\", \"x\", \"w\", \"y\"}\n\n\tsort.Ints(intList)\n\tsort.Float64s(float8List)\n\tsort.Strings(stringList)\n\n\tfmt.Printf(\"%v\\n%v\\n%v\\n\", intList, float8List, stringList)\n}\n```\n\n```\n[0 1 2 3 4 5 6 7 8 9]\n[3.14 4.2 5.9 10 12.3 27.81828 31.4 50.4 99.9]\n[a b c d f i w x y z]\n```\n\n#### 降序排序\n\nint 、 float64 和 string 都有默认的升序排序函数， 现在问题是如果降序如何 ？ 有其他语言编程经验的人都知道，只需要交换 cmp 的比较法则就可以了， go 的实现是类似的，然而又有所不同。 go 中对某个 Type 的对象 obj 排序， 可以使用 sort.Sort(obj) 即可，就是需要对 Type 类型绑定三个方法 ： Len() 求长度、Less(i,j) 比较第 i 和 第 j 个元素大小的函数、 Swap(i,j) 交换第 i 和第 j 个元素的函数。sort 包下的三个类型 IntSlice 、 Float64Slice 、 StringSlice 分别实现了这三个方法， 对应排序的是 [] int 、 [] float64 和 [] string 。如果期望逆序排序， 只需要将对应的 Less 函数简单修改一下即可。\n\ngo 的 sort 包可以使用 sort.Reverse(slice) 来调换 slice.Interface.Less ，也就是比较函数，所以， int 、 float64 和 string 的逆序排序函数可以这么写：\n\n```\nfunc sliceSort2() {\n\tintList := []int{2, 4, 3, 5, 7, 6, 9, 8, 1, 0}\n\tfloat8List := []float64{4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14}\n\tstringList := []string{\"a\", \"c\", \"b\", \"d\", \"f\", \"i\", \"z\", \"x\", \"w\", \"y\"}\n\n\tsort.Sort(sort.Reverse(sort.IntSlice(intList)))\n\tsort.Sort(sort.Reverse(sort.Float64Slice(float8List)))\n\tsort.Sort(sort.Reverse(sort.StringSlice(stringList)))\n\n\tfmt.Printf(\"%v\\n%v\\n%v\\n\", intList, float8List, stringList)\n}\n```\n\n\n```\n[9 8 7 6 5 4 3 2 1 0]\n[99.9 50.4 31.4 27.81828 12.3 10 5.9 4.2 3.14]\n[z y x w i f d c b a]\n```\n\n#### 结构体类型的排序\n结构体类型的排序是通过使用 sort.Sort(slice) 实现的， 只要 slice 实现了 sort.Interface 的三个方法就可以。 虽然这么说，但是排序的方法却有那么好几种。首先一种就是模拟排序 [] int 构造对应的 IntSlice 类型，然后对 IntSlice 类型实现 Interface 的三个方法。\n##### 1、模拟 IntSlice 排序\n```\npackage main\n \nimport (\n    \"fmt\"\n    \"sort\"\n)\n \ntype Person struct {\n    Name string\n    Age  int\n}\n \n// 按照 Person.Age 从大到小排序\ntype PersonSlice [] Person\n \nfunc (a PersonSlice) Len() int {    \t // 重写 Len() 方法\n    return len(a)\n}\nfunc (a PersonSlice) Swap(i, j int){     // 重写 Swap() 方法\n    a[i], a[j] = a[j], a[i]\n}\nfunc (a PersonSlice) Less(i, j int) bool {    // 重写 Less() 方法， 从大到小排序\n    return a[j].Age < a[i].Age\n}\n \nfunc main() {\n    people := [] Person{\n        {\"zhang san\", 12},\n        {\"li si\", 30},\n        {\"wang wu\", 52},\n        {\"zhao liu\", 26},\n    }\n \n    fmt.Println(people)\n \n    sort.Sort(PersonSlice(people))    // 按照 Age 的逆序排序\n    fmt.Println(people)\n \n    sort.Sort(sort.Reverse(PersonSlice(people)))    // 按照 Age 的升序排序\n    fmt.Println(people)\n \n}\n```\n\n这完全是一种模拟的方式，所以如果懂了 IntSlice 自然就理解这里了，反过来，理解了这里那么 IntSlice 那里也就懂了。\n这种方法的缺点是：根据 Age 排序需要重新定义 PersonSlice 方法，绑定 Len 、 Less 和 Swap 方法， 如果需要根据 Name 排序， 又需要重新写三个函数； 如果结构体有 4 个字段，有四种类型的排序，那么就要写 3 × 4 = 12 个方法， 即使有一些完全是多余的， O__O”… 仔细思量一下，根据不同的标准 Age 或是 Name， 真正不同的体现在 Less 方法上，所以可以将 Less 抽象出来， 每种排序的 Less 让其变成动态的，比如下面一种方法。\n\n##### 2、封装成 Wrapper\n\n```\npackage main\n \nimport (\n    \"fmt\"\n    \"sort\"\n)\n \ntype Person struct {\n    Name string\n    Age  int\n}\n \ntype PersonWrapper struct {\t\t\t\t\t//注意此处\n    people [] Person\n    by func(p, q * Person) bool\n}\n \nfunc (pw PersonWrapper) Len() int {    \t\t// 重写 Len() 方法\n    return len(pw.people)\n}\nfunc (pw PersonWrapper) Swap(i, j int){     // 重写 Swap() 方法\n    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]\n}\nfunc (pw PersonWrapper) Less(i, j int) bool {    // 重写 Less() 方法\n    return pw.by(&pw.people[i], &pw.people[j])\n}\n \nfunc main() {\n    people := [] Person{\n        {\"zhang san\", 12},\n        {\"li si\", 30},\n        {\"wang wu\", 52},\n        {\"zhao liu\", 26},\n    }\n \n    fmt.Println(people)\n \n    sort.Sort(PersonWrapper{people, func (p, q *Person) bool {\n        return q.Age < p.Age    // Age 递减排序\n    }})\n \n    fmt.Println(people)\n    sort.Sort(PersonWrapper{people, func (p, q *Person) bool {\n        return p.Name < q.Name    // Name 递增排序\n    }})\n \n    fmt.Println(people)\n \n}\n```\n\n这种方法将 [] Person 和比较的准则 cmp 封装在了一起，形成了 PersonWrapper 函数，然后在其上绑定 Len 、 Less 和 Swap 方法。 实际上 sort.Sort(pw) 排序的是 pw 中的 people， 这就是前面说的， go 的排序未必就是针对的一个数组或是 slice， 而可以是一个对象中的数组或是 slice 。\n\n##### 3、进一步封装\n\n感觉方法 2 已经很不错了， 唯一一个缺点是，在 main 中使用的时候暴露了 sort.Sort 的使用，还有就是 PersonWrapper 的构造。 为了让 main 中使用起来更为方便， me 们可以再简单的封装一下， 构造一个 SortPerson 方法， 如下：\n```\npackage main\n \nimport (\n    \"fmt\"\n    \"sort\"\n)\n \ntype Person struct {\n    Name string\n    Age  int\n}\n \ntype PersonWrapper struct {\n    people [] Person\n    by func(p, q * Person) bool\n}\n \ntype SortBy func(p, q *Person) bool\n \nfunc (pw PersonWrapper) Len() int {    \t\t// 重写 Len() 方法\n    return len(pw.people)\n}\nfunc (pw PersonWrapper) Swap(i, j int){         // 重写 Swap() 方法\n    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]\n}\nfunc (pw PersonWrapper) Less(i, j int) bool {    // 重写 Less() 方法\n    return pw.by(&pw.people[i], &pw.people[j])\n}\n \n// 封装成 SortPerson 方法\nfunc SortPerson(people [] Person, by SortBy){\n    sort.Sort(PersonWrapper{people, by})\n}\n \nfunc main() {\n    people := [] Person{\n        {\"zhang san\", 12},\n        {\"li si\", 30},\n        {\"wang wu\", 52},\n        {\"zhao liu\", 26},\n    }\n \n    fmt.Println(people)\n \n    sort.Sort(PersonWrapper{people, func (p, q *Person) bool {\n        return q.Age < p.Age    // Age 递减排序\n    }})\n \n    fmt.Println(people)\n \n    SortPerson(people, func (p, q *Person) bool {\n        return p.Name < q.Name    // Name 递增排序\n    })\n \n    fmt.Println(people)\n \n}\n```\n在方法 2 的基础上构造了 SortPerson 函数，使用的时候传过去一个 [] Person 和一个 cmp 函数。\n\n##### 4、另一种思路\n\n```\npackage main\n \nimport (\n    \"fmt\"\n    \"sort\"\n)\n \ntype Person struct {\n    Name        string\n    Weight      int\n}\n \ntype PersonSlice []Person\n \nfunc (s PersonSlice) Len() int  { return len(s) }\nfunc (s PersonSlice) Swap(i, j int)     { s[i], s[j] = s[j], s[i] }\n \ntype ByName struct{ PersonSlice }    // 将 PersonSlice 包装起来到 ByName 中\n \nfunc (s ByName) Less(i, j int) bool     { return s.PersonSlice[i].Name < s.PersonSlice[j].Name }    // 将 Less 绑定到 ByName 上\n \n \ntype ByWeight struct{ PersonSlice }    // 将 PersonSlice 包装起来到 ByWeight 中\nfunc (s ByWeight) Less(i, j int) bool   { return s.PersonSlice[i].Weight < s.PersonSlice[j].Weight }    // 将 Less 绑定到 ByWeight 上\n \nfunc main() {\n    s := []Person{\n        {\"apple\", 12},\n        {\"pear\", 20},\n        {\"banana\", 50},\n        {\"orange\", 87},\n        {\"hello\", 34},\n        {\"world\", 43},\n    }\n \n    sort.Sort(ByWeight{s})\n    fmt.Println(\"People by weight:\")\n    printPeople(s)\n \n    sort.Sort(ByName{s})\n    fmt.Println(\"\\nPeople by name:\")\n    printPeople(s)\n \n}\n \nfunc printPeople(s []Person) {\n    for _, o := range s {\n        fmt.Printf(\"%-8s (%v)\\n\", o.Name, o.Weight)\n    }\n}\n```\n对结构体的排序， 暂时就到这里。 第一种排序对只根据一个字段的比较合适， 另外三个是针对可能根据多个字段排序的。方法 4 我认为每次都要多构造一个 ByXXX ， 颇为不便， 这样多麻烦，不如方法 2 和方法 3 来的方便，直接传进去一个 cmp。 方法2、 3 没有太大的差别， 3 只是简单封装了一下而已， 对于使用者来说， 可能会更方便一些，而且也会更少的出错。\n\n\n### 取最值\n\n这个取最大值和最小值也是需要自己实现, 引入包`math`\n```\nfunc sliceMinMax() {\n\tintList := []int{2, 4, 3, 5, 7, 6, 9, 8, 1, 0}\n\n\tfmt.Println(intList)\n\t//取最大值\n\tfmt.Println(\"maxValue = \", getMaxValue(intList))\n\n\t//取最小值\n\tfmt.Println(\"minValue = \", getMinValue(intList))\n\n}\n\nfunc getMaxValue(slice []int) int {\n\tvar maxValue float64 = float64(slice[0])\n\tfor _, v := range slice {\n\t\tmaxValue = math.Max(float64(maxValue), float64(v))\n\t}\n\treturn int(maxValue)\n}\n\nfunc getMinValue(slice []int) int {\n\tvar maxValue float64 = float64(slice[0])\n\tfor _, v := range slice {\n\t\tmaxValue = math.Min(float64(maxValue), float64(v))\n\t}\n\treturn int(maxValue)\n}\n```\n\n```\n[2 4 3 5 7 6 9 8 1 0]\nmaxValue =  9\nminValue =  0\n```\n\n\n\n\n\n","slug":"slice","published":1,"updated":"2018-05-04T03:47:16.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tf1002elx60bb94cnkg","content":"<p>切片的几种常用操作，reslice, append, copy, delete, insert, 排序, 取最值等，这几种基本上可以解决日常开发的绝大部分的问题了。</p>\n<h3 id=\"slice声明和创建\"><a href=\"#slice声明和创建\" class=\"headerlink\" title=\"slice声明和创建\"></a>slice声明和创建</h3><p>slice 本身不是数组，它指向数组的底层<br>作为变长数组饿替代方案，可以关联底层数组的全部或者局部<br>可以直接创建，一般用make(), 也可以从底层数组获取生成<br>如果多个slice 指向相同的底层数组，一个值的改变会影响全部</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliceCreate() &#123;</div><div class=\"line\"></div><div class=\"line\">\t//声明 slice 如果只是声明，只有指针初始地址，容量为0</div><div class=\"line\">\tvar slice1 []int</div><div class=\"line\"></div><div class=\"line\">\tfmt.Printf(&quot;slice1  %p\\n&quot;, slice1)</div><div class=\"line\"></div><div class=\"line\">\t//添加元素后，容量超出上限，内存地址重新分配</div><div class=\"line\">\tslice1 = []int&#123;1, 2, 3&#125;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Printf(&quot;slice1  %p\\n&quot;, slice1)</div><div class=\"line\"></div><div class=\"line\">\t//声明并赋值</div><div class=\"line\"></div><div class=\"line\">\tvar s2 = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</div><div class=\"line\">\tfmt.Println(s2)</div><div class=\"line\"></div><div class=\"line\">\tvar arr = [10]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</div><div class=\"line\">\tfmt.Print(&quot;s2  \\n&quot;, arr)</div><div class=\"line\"></div><div class=\"line\">\t// 取第二个元素</div><div class=\"line\">\tslice2 := arr[1]</div><div class=\"line\">\tfmt.Println(slice2)</div><div class=\"line\"></div><div class=\"line\">\t//取第5到10个元素</div><div class=\"line\">\tslice3 := arr[5:10] // slice范围取值的时候，前面闭区间，后面开区间</div><div class=\"line\">\tfmt.Println(slice3)</div><div class=\"line\"></div><div class=\"line\">\t//从第5个元素取到最后  的两种写法</div><div class=\"line\">\tslice4 := arr[5:len(arr)]</div><div class=\"line\">\tslice5 := arr[5:]</div><div class=\"line\">\tfmt.Println(slice4, slice5)</div><div class=\"line\"></div><div class=\"line\">\t//取前5个元素</div><div class=\"line\">\tslice6 := arr[:5]</div><div class=\"line\">\tfmt.Print(&quot;\\n&quot;, slice6)</div><div class=\"line\"></div><div class=\"line\">\t//使用make 创建slice</div><div class=\"line\">\t//存放的元素是int类型，初始容量是3, 容量超过10再次开辟内存空间，并且容量翻倍</div><div class=\"line\">\t// 如果不给初始容量，默认的初始容量就是当前元素个数</div><div class=\"line\">\ts1 := make([]int, 3, 10)</div><div class=\"line\">\tfmt.Print(&quot;\\n&quot;, len(s1), cap(s1))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">slice1  0x0</div><div class=\"line\">slice1  0xc4200182c0</div><div class=\"line\">[a b c]</div><div class=\"line\">s2  </div><div class=\"line\">[0 1 2 3 4 5 6 7 8 9]1</div><div class=\"line\">[5 6 7 8 9]</div><div class=\"line\">[5 6 7 8 9] [5 6 7 8 9]</div><div class=\"line\"></div><div class=\"line\">[0 1 2 3 4]</div><div class=\"line\">3 10</div></pre></td></tr></table></figure>\n<h3 id=\"ReSlice\"><a href=\"#ReSlice\" class=\"headerlink\" title=\"ReSlice\"></a>ReSlice</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func ResliceTest() &#123;</div><div class=\"line\">\t</div><div class=\"line\">\t// reslice索引 以 被slice 为准</div><div class=\"line\">\t// 索引不可以超过cap值</div><div class=\"line\"></div><div class=\"line\">\tvar a = []byte&#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;&#125;</div><div class=\"line\"></div><div class=\"line\">\t// 切片区间取值 包含起始值， 不包含终止值 相当与 闭开区间</div><div class=\"line\">\t//取出 cde</div><div class=\"line\">\tvar s1 = a[2:5]</div><div class=\"line\">\tfmt.Println(string(s1))</div><div class=\"line\">\tfmt.Println(len(s1), cap(s1))</div><div class=\"line\"></div><div class=\"line\">\t//从 s1中取出de</div><div class=\"line\">\tvar s2 = s1[1:3]</div><div class=\"line\">\tfmt.Print(&quot;\\n&quot;, string(s2))</div><div class=\"line\"></div><div class=\"line\">\t// 虽然s1 指向 a中的 c 到 e, 由于a的内存是连续， 可以从s1中取到数组的末尾</div><div class=\"line\"></div><div class=\"line\">\tvar s3 = s1[0:cap(s1)]</div><div class=\"line\">\tfmt.Print(&quot;\\n s3 = &quot;, string(s3))</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">cde</div><div class=\"line\">3 6</div><div class=\"line\"></div><div class=\"line\">de</div><div class=\"line\"> s3 = cdefgh</div></pre></td></tr></table></figure>\n<h3 id=\"Append\"><a href=\"#Append\" class=\"headerlink\" title=\"Append\"></a>Append</h3><p>可以在slice尾部追加元素<br>可以将一个slice追加到另一个slice<br>slice2 追加到slice1 后，如果容量超过slice1，则slice1容量将重新分配，内存地址也改变<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func appendTest() &#123;</div><div class=\"line\"></div><div class=\"line\">\ts1 := make([]int, 3, 6)</div><div class=\"line\">\tfmt.Printf(&quot;%p\\n&quot;, s1)</div><div class=\"line\"></div><div class=\"line\">\ts1 = append(s1, 1, 2, 3) //s1 还没有超出容量，内存地址不变</div><div class=\"line\">\tfmt.Printf(&quot;%v---%p\\n&quot;, s1, s1)</div><div class=\"line\"></div><div class=\"line\">\ts1 = append(s1, 9) //超出容量，内存地址改变</div><div class=\"line\">\tfmt.Printf(&quot;%v %p\\n&quot;, s1, s1)</div><div class=\"line\"></div><div class=\"line\">\tvar arr = []int&#123;1, 2, 3, 4, 5&#125;</div><div class=\"line\">\tvar slice2 = arr[2:5] //3, 4, 5</div><div class=\"line\">\tvar slice3 = arr[1:3] //2, 3</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(slice2, slice3) //重叠部分是3</div><div class=\"line\"></div><div class=\"line\">\tslice2[0] = 9 //改变重叠部分的值， 其他所有对应的值都会改变</div><div class=\"line\">\tfmt.Println(arr, slice2, slice3)</div><div class=\"line\"></div><div class=\"line\">\tslice3 = append(slice3, 1, 2, 2, 2, 2, 2) //超出slice3原本的容量，内存地址重新分配，其他对象重叠部分的元素就不会改变</div><div class=\"line\">\tfmt.Println(slice3)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">0xc42001c0c0</div><div class=\"line\">[0 0 0 1 2 3]---0xc42001c0c0</div><div class=\"line\">[0 0 0 1 2 3 9] 0xc420078060</div><div class=\"line\">[3 4 5] [2 3]</div><div class=\"line\">[1 2 9 4 5] [9 4 5] [2 9]</div><div class=\"line\">[2 9 1 2 2 2 2 2]</div></pre></td></tr></table></figure>\n<h3 id=\"Copy\"><a href=\"#Copy\" class=\"headerlink\" title=\"Copy\"></a>Copy</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">func copyTest() &#123;</div><div class=\"line\"></div><div class=\"line\">\t//copy 会把重叠部分的元素给覆盖</div><div class=\"line\">\tvar s1 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class=\"line\">\tvar s2 = []int&#123;7, 8, 9&#125;</div><div class=\"line\">\t// 短的copy到长的情况</div><div class=\"line\">\tcopy(s1, s2) //把s2 copy 到s1 中</div><div class=\"line\">\tfmt.Println(&quot;s1---&quot;, s1)</div><div class=\"line\"></div><div class=\"line\">\t// 长的copy到短的情况</div><div class=\"line\">\tvar s3 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class=\"line\">\tvar s4 = []int&#123;7, 8, 9&#125;</div><div class=\"line\">\tcopy(s4, s3)</div><div class=\"line\">\tfmt.Println(&quot;s4---&quot;, s4)</div><div class=\"line\"></div><div class=\"line\">\tvar s5 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class=\"line\">\tvar s6 = []int&#123;7, 8, 9&#125;</div><div class=\"line\">\t//将制定元素copy到指定位置</div><div class=\"line\">\tcopy(s5[2:4], s6[1:3])</div><div class=\"line\">\tfmt.Println(&quot;s5---&quot;, s5)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">s1--- [7 8 9 4 5 6 7]</div><div class=\"line\">s4--- [1 2 3]</div><div class=\"line\">s5--- [1 2 8 9 5 6 7]</div></pre></td></tr></table></figure>\n<h3 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h3><p>go官方没有提供删除的方法，只能自己实现，实现的方法有多种，这里给出一种简洁的实现方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliceDelete() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar slice = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(removeString(slice, 2)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//删除函数</div><div class=\"line\">func removeString(s []string, i int) []string &#123;</div><div class=\"line\"></div><div class=\"line\">\treturn append(s[:i], s[i+1:]...)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[a b d]</div></pre></td></tr></table></figure>\n<h3 id=\"insert\"><a href=\"#insert\" class=\"headerlink\" title=\"insert\"></a>insert</h3><p>官方还是没有提供插入的方法，需要自己实现，如果用<code>append</code>实现，<code>append</code>每次操作都会复制创建一个新的底层数组，会比较耗性能，这里采用反射实现<br>这里需要引入<code>reflect</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func silceInsert() &#123;</div><div class=\"line\"></div><div class=\"line\">\ta := []int&#123;1, 2, 3, 4, 5&#125;</div><div class=\"line\">\tfmt.Println(a)</div><div class=\"line\">\tfmt.Println(&quot;插入元素后&quot;, Insert(a, 3, 0))</div><div class=\"line\"></div><div class=\"line\">\tb := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;</div><div class=\"line\">\tfmt.Println(b)</div><div class=\"line\">\tfmt.Println(&quot;插入元素后&quot;, Insert(b, 3, &quot;x&quot;))</div><div class=\"line\"></div><div class=\"line\">\tc := []interface&#123;&#125;&#123;1, &quot;a&quot;, true, 3.2, &apos;a&apos;&#125;</div><div class=\"line\">\tfmt.Println(c)</div><div class=\"line\">\tfmt.Println(&quot;插入元素后&quot;, Insert(c, 3, false))</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func Insert(slice interface&#123;&#125;, pos int, value interface&#123;&#125;) interface&#123;&#125; &#123;</div><div class=\"line\">\tv := reflect.ValueOf(slice)</div><div class=\"line\">\tv = reflect.Append(v, reflect.ValueOf(value))</div><div class=\"line\">\treflect.Copy(v.Slice(pos+1, v.Len()), v.Slice(pos, v.Len()))</div><div class=\"line\">\tv.Index(pos).Set(reflect.ValueOf(value))</div><div class=\"line\">\treturn v.Interface()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[1 2 3 4 5]</div><div class=\"line\">插入元素后 [1 2 3 0 4 5]</div><div class=\"line\">[a b c d e]</div><div class=\"line\">插入元素后 [a b c x d e]</div><div class=\"line\">[1 a true 3.2 97]</div><div class=\"line\">插入元素后 [1 a true false 3.2 97]</div></pre></td></tr></table></figure>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>几种常见的排序方法：冒泡算法，选择排序，插入排序，快速排序，不过对于排序，官方倒是给出了方法，可以直接使用，需要引入<code>sort</code></p>\n<h4 id=\"升序排序\"><a href=\"#升序排序\" class=\"headerlink\" title=\"升序排序\"></a>升序排序</h4><p>对于 int 、 float64 和 string 数组或是分片的排序， go 分别提供了 sort.Ints() 、 sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliceSort() &#123;</div><div class=\"line\"></div><div class=\"line\">\tintList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class=\"line\">\tfloat8List := []float64&#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125;</div><div class=\"line\">\tstringList := []string&#123;&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;i&quot;, &quot;z&quot;, &quot;x&quot;, &quot;w&quot;, &quot;y&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">\tsort.Ints(intList)</div><div class=\"line\">\tsort.Float64s(float8List)</div><div class=\"line\">\tsort.Strings(stringList)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Printf(&quot;%v\\n%v\\n%v\\n&quot;, intList, float8List, stringList)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0 1 2 3 4 5 6 7 8 9]</div><div class=\"line\">[3.14 4.2 5.9 10 12.3 27.81828 31.4 50.4 99.9]</div><div class=\"line\">[a b c d f i w x y z]</div></pre></td></tr></table></figure>\n<h4 id=\"降序排序\"><a href=\"#降序排序\" class=\"headerlink\" title=\"降序排序\"></a>降序排序</h4><p>int 、 float64 和 string 都有默认的升序排序函数， 现在问题是如果降序如何 ？ 有其他语言编程经验的人都知道，只需要交换 cmp 的比较法则就可以了， go 的实现是类似的，然而又有所不同。 go 中对某个 Type 的对象 obj 排序， 可以使用 sort.Sort(obj) 即可，就是需要对 Type 类型绑定三个方法 ： Len() 求长度、Less(i,j) 比较第 i 和 第 j 个元素大小的函数、 Swap(i,j) 交换第 i 和第 j 个元素的函数。sort 包下的三个类型 IntSlice 、 Float64Slice 、 StringSlice 分别实现了这三个方法， 对应排序的是 [] int 、 [] float64 和 [] string 。如果期望逆序排序， 只需要将对应的 Less 函数简单修改一下即可。</p>\n<p>go 的 sort 包可以使用 sort.Reverse(slice) 来调换 slice.Interface.Less ，也就是比较函数，所以， int 、 float64 和 string 的逆序排序函数可以这么写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliceSort2() &#123;</div><div class=\"line\">\tintList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class=\"line\">\tfloat8List := []float64&#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125;</div><div class=\"line\">\tstringList := []string&#123;&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;i&quot;, &quot;z&quot;, &quot;x&quot;, &quot;w&quot;, &quot;y&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">\tsort.Sort(sort.Reverse(sort.IntSlice(intList)))</div><div class=\"line\">\tsort.Sort(sort.Reverse(sort.Float64Slice(float8List)))</div><div class=\"line\">\tsort.Sort(sort.Reverse(sort.StringSlice(stringList)))</div><div class=\"line\"></div><div class=\"line\">\tfmt.Printf(&quot;%v\\n%v\\n%v\\n&quot;, intList, float8List, stringList)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[9 8 7 6 5 4 3 2 1 0]</div><div class=\"line\">[99.9 50.4 31.4 27.81828 12.3 10 5.9 4.2 3.14]</div><div class=\"line\">[z y x w i f d c b a]</div></pre></td></tr></table></figure>\n<h4 id=\"结构体类型的排序\"><a href=\"#结构体类型的排序\" class=\"headerlink\" title=\"结构体类型的排序\"></a>结构体类型的排序</h4><p>结构体类型的排序是通过使用 sort.Sort(slice) 实现的， 只要 slice 实现了 sort.Interface 的三个方法就可以。 虽然这么说，但是排序的方法却有那么好几种。首先一种就是模拟排序 [] int 构造对应的 IntSlice 类型，然后对 IntSlice 类型实现 Interface 的三个方法。</p>\n<h5 id=\"1、模拟-IntSlice-排序\"><a href=\"#1、模拟-IntSlice-排序\" class=\"headerlink\" title=\"1、模拟 IntSlice 排序\"></a>1、模拟 IntSlice 排序</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"> </div><div class=\"line\">import (</div><div class=\"line\">    &quot;fmt&quot;</div><div class=\"line\">    &quot;sort&quot;</div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\">type Person struct &#123;</div><div class=\"line\">    Name string</div><div class=\"line\">    Age  int</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">// 按照 Person.Age 从大到小排序</div><div class=\"line\">type PersonSlice [] Person</div><div class=\"line\"> </div><div class=\"line\">func (a PersonSlice) Len() int &#123;    \t // 重写 Len() 方法</div><div class=\"line\">    return len(a)</div><div class=\"line\">&#125;</div><div class=\"line\">func (a PersonSlice) Swap(i, j int)&#123;     // 重写 Swap() 方法</div><div class=\"line\">    a[i], a[j] = a[j], a[i]</div><div class=\"line\">&#125;</div><div class=\"line\">func (a PersonSlice) Less(i, j int) bool &#123;    // 重写 Less() 方法， 从大到小排序</div><div class=\"line\">    return a[j].Age &lt; a[i].Age</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">func main() &#123;</div><div class=\"line\">    people := [] Person&#123;</div><div class=\"line\">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class=\"line\">        &#123;&quot;li si&quot;, 30&#125;,</div><div class=\"line\">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class=\"line\">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(PersonSlice(people))    // 按照 Age 的逆序排序</div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(sort.Reverse(PersonSlice(people)))    // 按照 Age 的升序排序</div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这完全是一种模拟的方式，所以如果懂了 IntSlice 自然就理解这里了，反过来，理解了这里那么 IntSlice 那里也就懂了。<br>这种方法的缺点是：根据 Age 排序需要重新定义 PersonSlice 方法，绑定 Len 、 Less 和 Swap 方法， 如果需要根据 Name 排序， 又需要重新写三个函数； 如果结构体有 4 个字段，有四种类型的排序，那么就要写 3 × 4 = 12 个方法， 即使有一些完全是多余的， O__O”… 仔细思量一下，根据不同的标准 Age 或是 Name， 真正不同的体现在 Less 方法上，所以可以将 Less 抽象出来， 每种排序的 Less 让其变成动态的，比如下面一种方法。</p>\n<h5 id=\"2、封装成-Wrapper\"><a href=\"#2、封装成-Wrapper\" class=\"headerlink\" title=\"2、封装成 Wrapper\"></a>2、封装成 Wrapper</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"> </div><div class=\"line\">import (</div><div class=\"line\">    &quot;fmt&quot;</div><div class=\"line\">    &quot;sort&quot;</div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\">type Person struct &#123;</div><div class=\"line\">    Name string</div><div class=\"line\">    Age  int</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">type PersonWrapper struct &#123;\t\t\t\t\t//注意此处</div><div class=\"line\">    people [] Person</div><div class=\"line\">    by func(p, q * Person) bool</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">func (pw PersonWrapper) Len() int &#123;    \t\t// 重写 Len() 方法</div><div class=\"line\">    return len(pw.people)</div><div class=\"line\">&#125;</div><div class=\"line\">func (pw PersonWrapper) Swap(i, j int)&#123;     // 重写 Swap() 方法</div><div class=\"line\">    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]</div><div class=\"line\">&#125;</div><div class=\"line\">func (pw PersonWrapper) Less(i, j int) bool &#123;    // 重写 Less() 方法</div><div class=\"line\">    return pw.by(&amp;pw.people[i], &amp;pw.people[j])</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">func main() &#123;</div><div class=\"line\">    people := [] Person&#123;</div><div class=\"line\">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class=\"line\">        &#123;&quot;li si&quot;, 30&#125;,</div><div class=\"line\">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class=\"line\">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class=\"line\">        return q.Age &lt; p.Age    // Age 递减排序</div><div class=\"line\">    &#125;&#125;)</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class=\"line\">        return p.Name &lt; q.Name    // Name 递增排序</div><div class=\"line\">    &#125;&#125;)</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方法将 [] Person 和比较的准则 cmp 封装在了一起，形成了 PersonWrapper 函数，然后在其上绑定 Len 、 Less 和 Swap 方法。 实际上 sort.Sort(pw) 排序的是 pw 中的 people， 这就是前面说的， go 的排序未必就是针对的一个数组或是 slice， 而可以是一个对象中的数组或是 slice 。</p>\n<h5 id=\"3、进一步封装\"><a href=\"#3、进一步封装\" class=\"headerlink\" title=\"3、进一步封装\"></a>3、进一步封装</h5><p>感觉方法 2 已经很不错了， 唯一一个缺点是，在 main 中使用的时候暴露了 sort.Sort 的使用，还有就是 PersonWrapper 的构造。 为了让 main 中使用起来更为方便， me 们可以再简单的封装一下， 构造一个 SortPerson 方法， 如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"> </div><div class=\"line\">import (</div><div class=\"line\">    &quot;fmt&quot;</div><div class=\"line\">    &quot;sort&quot;</div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\">type Person struct &#123;</div><div class=\"line\">    Name string</div><div class=\"line\">    Age  int</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">type PersonWrapper struct &#123;</div><div class=\"line\">    people [] Person</div><div class=\"line\">    by func(p, q * Person) bool</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">type SortBy func(p, q *Person) bool</div><div class=\"line\"> </div><div class=\"line\">func (pw PersonWrapper) Len() int &#123;    \t\t// 重写 Len() 方法</div><div class=\"line\">    return len(pw.people)</div><div class=\"line\">&#125;</div><div class=\"line\">func (pw PersonWrapper) Swap(i, j int)&#123;         // 重写 Swap() 方法</div><div class=\"line\">    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]</div><div class=\"line\">&#125;</div><div class=\"line\">func (pw PersonWrapper) Less(i, j int) bool &#123;    // 重写 Less() 方法</div><div class=\"line\">    return pw.by(&amp;pw.people[i], &amp;pw.people[j])</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">// 封装成 SortPerson 方法</div><div class=\"line\">func SortPerson(people [] Person, by SortBy)&#123;</div><div class=\"line\">    sort.Sort(PersonWrapper&#123;people, by&#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">func main() &#123;</div><div class=\"line\">    people := [] Person&#123;</div><div class=\"line\">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class=\"line\">        &#123;&quot;li si&quot;, 30&#125;,</div><div class=\"line\">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class=\"line\">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class=\"line\">        return q.Age &lt; p.Age    // Age 递减排序</div><div class=\"line\">    &#125;&#125;)</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">    SortPerson(people, func (p, q *Person) bool &#123;</div><div class=\"line\">        return p.Name &lt; q.Name    // Name 递增排序</div><div class=\"line\">    &#125;)</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在方法 2 的基础上构造了 SortPerson 函数，使用的时候传过去一个 [] Person 和一个 cmp 函数。</p>\n<h5 id=\"4、另一种思路\"><a href=\"#4、另一种思路\" class=\"headerlink\" title=\"4、另一种思路\"></a>4、另一种思路</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"> </div><div class=\"line\">import (</div><div class=\"line\">    &quot;fmt&quot;</div><div class=\"line\">    &quot;sort&quot;</div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\">type Person struct &#123;</div><div class=\"line\">    Name        string</div><div class=\"line\">    Weight      int</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">type PersonSlice []Person</div><div class=\"line\"> </div><div class=\"line\">func (s PersonSlice) Len() int  &#123; return len(s) &#125;</div><div class=\"line\">func (s PersonSlice) Swap(i, j int)     &#123; s[i], s[j] = s[j], s[i] &#125;</div><div class=\"line\"> </div><div class=\"line\">type ByName struct&#123; PersonSlice &#125;    // 将 PersonSlice 包装起来到 ByName 中</div><div class=\"line\"> </div><div class=\"line\">func (s ByName) Less(i, j int) bool     &#123; return s.PersonSlice[i].Name &lt; s.PersonSlice[j].Name &#125;    // 将 Less 绑定到 ByName 上</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\">type ByWeight struct&#123; PersonSlice &#125;    // 将 PersonSlice 包装起来到 ByWeight 中</div><div class=\"line\">func (s ByWeight) Less(i, j int) bool   &#123; return s.PersonSlice[i].Weight &lt; s.PersonSlice[j].Weight &#125;    // 将 Less 绑定到 ByWeight 上</div><div class=\"line\"> </div><div class=\"line\">func main() &#123;</div><div class=\"line\">    s := []Person&#123;</div><div class=\"line\">        &#123;&quot;apple&quot;, 12&#125;,</div><div class=\"line\">        &#123;&quot;pear&quot;, 20&#125;,</div><div class=\"line\">        &#123;&quot;banana&quot;, 50&#125;,</div><div class=\"line\">        &#123;&quot;orange&quot;, 87&#125;,</div><div class=\"line\">        &#123;&quot;hello&quot;, 34&#125;,</div><div class=\"line\">        &#123;&quot;world&quot;, 43&#125;,</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(ByWeight&#123;s&#125;)</div><div class=\"line\">    fmt.Println(&quot;People by weight:&quot;)</div><div class=\"line\">    printPeople(s)</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(ByName&#123;s&#125;)</div><div class=\"line\">    fmt.Println(&quot;\\nPeople by name:&quot;)</div><div class=\"line\">    printPeople(s)</div><div class=\"line\"> </div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">func printPeople(s []Person) &#123;</div><div class=\"line\">    for _, o := range s &#123;</div><div class=\"line\">        fmt.Printf(&quot;%-8s (%v)\\n&quot;, o.Name, o.Weight)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对结构体的排序， 暂时就到这里。 第一种排序对只根据一个字段的比较合适， 另外三个是针对可能根据多个字段排序的。方法 4 我认为每次都要多构造一个 ByXXX ， 颇为不便， 这样多麻烦，不如方法 2 和方法 3 来的方便，直接传进去一个 cmp。 方法2、 3 没有太大的差别， 3 只是简单封装了一下而已， 对于使用者来说， 可能会更方便一些，而且也会更少的出错。</p>\n<h3 id=\"取最值\"><a href=\"#取最值\" class=\"headerlink\" title=\"取最值\"></a>取最值</h3><p>这个取最大值和最小值也是需要自己实现, 引入包<code>math</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliceMinMax() &#123;</div><div class=\"line\">\tintList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(intList)</div><div class=\"line\">\t//取最大值</div><div class=\"line\">\tfmt.Println(&quot;maxValue = &quot;, getMaxValue(intList))</div><div class=\"line\"></div><div class=\"line\">\t//取最小值</div><div class=\"line\">\tfmt.Println(&quot;minValue = &quot;, getMinValue(intList))</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func getMaxValue(slice []int) int &#123;</div><div class=\"line\">\tvar maxValue float64 = float64(slice[0])</div><div class=\"line\">\tfor _, v := range slice &#123;</div><div class=\"line\">\t\tmaxValue = math.Max(float64(maxValue), float64(v))</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn int(maxValue)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func getMinValue(slice []int) int &#123;</div><div class=\"line\">\tvar maxValue float64 = float64(slice[0])</div><div class=\"line\">\tfor _, v := range slice &#123;</div><div class=\"line\">\t\tmaxValue = math.Min(float64(maxValue), float64(v))</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn int(maxValue)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[2 4 3 5 7 6 9 8 1 0]</div><div class=\"line\">maxValue =  9</div><div class=\"line\">minValue =  0</div></pre></td></tr></table></figure>\n","excerpt":"<p>切片的几种常用操作，reslice, append, copy, delete, insert, 排序, 取最值等，这几种基本上可以解决日常开发的绝大部分的问题了。</p>\n<h3 id=\"slice声明和创建\"><a href=\"#slice声明和创建\" class=\"headerlink\" title=\"slice声明和创建\"></a>slice声明和创建</h3><p>slice 本身不是数组，它指向数组的底层<br>作为变长数组饿替代方案，可以关联底层数组的全部或者局部<br>可以直接创建，一般用make(), 也可以从底层数组获取生成<br>如果多个slice 指向相同的底层数组，一个值的改变会影响全部</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliceCreate() &#123;</div><div class=\"line\"></div><div class=\"line\">\t//声明 slice 如果只是声明，只有指针初始地址，容量为0</div><div class=\"line\">\tvar slice1 []int</div><div class=\"line\"></div><div class=\"line\">\tfmt.Printf(&quot;slice1  %p\\n&quot;, slice1)</div><div class=\"line\"></div><div class=\"line\">\t//添加元素后，容量超出上限，内存地址重新分配</div><div class=\"line\">\tslice1 = []int&#123;1, 2, 3&#125;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Printf(&quot;slice1  %p\\n&quot;, slice1)</div><div class=\"line\"></div><div class=\"line\">\t//声明并赋值</div><div class=\"line\"></div><div class=\"line\">\tvar s2 = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</div><div class=\"line\">\tfmt.Println(s2)</div><div class=\"line\"></div><div class=\"line\">\tvar arr = [10]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</div><div class=\"line\">\tfmt.Print(&quot;s2  \\n&quot;, arr)</div><div class=\"line\"></div><div class=\"line\">\t// 取第二个元素</div><div class=\"line\">\tslice2 := arr[1]</div><div class=\"line\">\tfmt.Println(slice2)</div><div class=\"line\"></div><div class=\"line\">\t//取第5到10个元素</div><div class=\"line\">\tslice3 := arr[5:10] // slice范围取值的时候，前面闭区间，后面开区间</div><div class=\"line\">\tfmt.Println(slice3)</div><div class=\"line\"></div><div class=\"line\">\t//从第5个元素取到最后  的两种写法</div><div class=\"line\">\tslice4 := arr[5:len(arr)]</div><div class=\"line\">\tslice5 := arr[5:]</div><div class=\"line\">\tfmt.Println(slice4, slice5)</div><div class=\"line\"></div><div class=\"line\">\t//取前5个元素</div><div class=\"line\">\tslice6 := arr[:5]</div><div class=\"line\">\tfmt.Print(&quot;\\n&quot;, slice6)</div><div class=\"line\"></div><div class=\"line\">\t//使用make 创建slice</div><div class=\"line\">\t//存放的元素是int类型，初始容量是3, 容量超过10再次开辟内存空间，并且容量翻倍</div><div class=\"line\">\t// 如果不给初始容量，默认的初始容量就是当前元素个数</div><div class=\"line\">\ts1 := make([]int, 3, 10)</div><div class=\"line\">\tfmt.Print(&quot;\\n&quot;, len(s1), cap(s1))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">slice1  0x0</div><div class=\"line\">slice1  0xc4200182c0</div><div class=\"line\">[a b c]</div><div class=\"line\">s2  </div><div class=\"line\">[0 1 2 3 4 5 6 7 8 9]1</div><div class=\"line\">[5 6 7 8 9]</div><div class=\"line\">[5 6 7 8 9] [5 6 7 8 9]</div><div class=\"line\"></div><div class=\"line\">[0 1 2 3 4]</div><div class=\"line\">3 10</div></pre></td></tr></table></figure>\n<h3 id=\"ReSlice\"><a href=\"#ReSlice\" class=\"headerlink\" title=\"ReSlice\"></a>ReSlice</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func ResliceTest() &#123;</div><div class=\"line\">\t</div><div class=\"line\">\t// reslice索引 以 被slice 为准</div><div class=\"line\">\t// 索引不可以超过cap值</div><div class=\"line\"></div><div class=\"line\">\tvar a = []byte&#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;&#125;</div><div class=\"line\"></div><div class=\"line\">\t// 切片区间取值 包含起始值， 不包含终止值 相当与 闭开区间</div><div class=\"line\">\t//取出 cde</div><div class=\"line\">\tvar s1 = a[2:5]</div><div class=\"line\">\tfmt.Println(string(s1))</div><div class=\"line\">\tfmt.Println(len(s1), cap(s1))</div><div class=\"line\"></div><div class=\"line\">\t//从 s1中取出de</div><div class=\"line\">\tvar s2 = s1[1:3]</div><div class=\"line\">\tfmt.Print(&quot;\\n&quot;, string(s2))</div><div class=\"line\"></div><div class=\"line\">\t// 虽然s1 指向 a中的 c 到 e, 由于a的内存是连续， 可以从s1中取到数组的末尾</div><div class=\"line\"></div><div class=\"line\">\tvar s3 = s1[0:cap(s1)]</div><div class=\"line\">\tfmt.Print(&quot;\\n s3 = &quot;, string(s3))</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">cde</div><div class=\"line\">3 6</div><div class=\"line\"></div><div class=\"line\">de</div><div class=\"line\"> s3 = cdefgh</div></pre></td></tr></table></figure>\n<h3 id=\"Append\"><a href=\"#Append\" class=\"headerlink\" title=\"Append\"></a>Append</h3><p>可以在slice尾部追加元素<br>可以将一个slice追加到另一个slice<br>slice2 追加到slice1 后，如果容量超过slice1，则slice1容量将重新分配，内存地址也改变<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func appendTest() &#123;</div><div class=\"line\"></div><div class=\"line\">\ts1 := make([]int, 3, 6)</div><div class=\"line\">\tfmt.Printf(&quot;%p\\n&quot;, s1)</div><div class=\"line\"></div><div class=\"line\">\ts1 = append(s1, 1, 2, 3) //s1 还没有超出容量，内存地址不变</div><div class=\"line\">\tfmt.Printf(&quot;%v---%p\\n&quot;, s1, s1)</div><div class=\"line\"></div><div class=\"line\">\ts1 = append(s1, 9) //超出容量，内存地址改变</div><div class=\"line\">\tfmt.Printf(&quot;%v %p\\n&quot;, s1, s1)</div><div class=\"line\"></div><div class=\"line\">\tvar arr = []int&#123;1, 2, 3, 4, 5&#125;</div><div class=\"line\">\tvar slice2 = arr[2:5] //3, 4, 5</div><div class=\"line\">\tvar slice3 = arr[1:3] //2, 3</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(slice2, slice3) //重叠部分是3</div><div class=\"line\"></div><div class=\"line\">\tslice2[0] = 9 //改变重叠部分的值， 其他所有对应的值都会改变</div><div class=\"line\">\tfmt.Println(arr, slice2, slice3)</div><div class=\"line\"></div><div class=\"line\">\tslice3 = append(slice3, 1, 2, 2, 2, 2, 2) //超出slice3原本的容量，内存地址重新分配，其他对象重叠部分的元素就不会改变</div><div class=\"line\">\tfmt.Println(slice3)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">0xc42001c0c0</div><div class=\"line\">[0 0 0 1 2 3]---0xc42001c0c0</div><div class=\"line\">[0 0 0 1 2 3 9] 0xc420078060</div><div class=\"line\">[3 4 5] [2 3]</div><div class=\"line\">[1 2 9 4 5] [9 4 5] [2 9]</div><div class=\"line\">[2 9 1 2 2 2 2 2]</div></pre></td></tr></table></figure>\n<h3 id=\"Copy\"><a href=\"#Copy\" class=\"headerlink\" title=\"Copy\"></a>Copy</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">func copyTest() &#123;</div><div class=\"line\"></div><div class=\"line\">\t//copy 会把重叠部分的元素给覆盖</div><div class=\"line\">\tvar s1 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class=\"line\">\tvar s2 = []int&#123;7, 8, 9&#125;</div><div class=\"line\">\t// 短的copy到长的情况</div><div class=\"line\">\tcopy(s1, s2) //把s2 copy 到s1 中</div><div class=\"line\">\tfmt.Println(&quot;s1---&quot;, s1)</div><div class=\"line\"></div><div class=\"line\">\t// 长的copy到短的情况</div><div class=\"line\">\tvar s3 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class=\"line\">\tvar s4 = []int&#123;7, 8, 9&#125;</div><div class=\"line\">\tcopy(s4, s3)</div><div class=\"line\">\tfmt.Println(&quot;s4---&quot;, s4)</div><div class=\"line\"></div><div class=\"line\">\tvar s5 = []int&#123;1, 2, 3, 4, 5, 6, 7&#125;</div><div class=\"line\">\tvar s6 = []int&#123;7, 8, 9&#125;</div><div class=\"line\">\t//将制定元素copy到指定位置</div><div class=\"line\">\tcopy(s5[2:4], s6[1:3])</div><div class=\"line\">\tfmt.Println(&quot;s5---&quot;, s5)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">s1--- [7 8 9 4 5 6 7]</div><div class=\"line\">s4--- [1 2 3]</div><div class=\"line\">s5--- [1 2 8 9 5 6 7]</div></pre></td></tr></table></figure>\n<h3 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h3><p>go官方没有提供删除的方法，只能自己实现，实现的方法有多种，这里给出一种简洁的实现方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliceDelete() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar slice = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(removeString(slice, 2)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//删除函数</div><div class=\"line\">func removeString(s []string, i int) []string &#123;</div><div class=\"line\"></div><div class=\"line\">\treturn append(s[:i], s[i+1:]...)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[a b d]</div></pre></td></tr></table></figure>\n<h3 id=\"insert\"><a href=\"#insert\" class=\"headerlink\" title=\"insert\"></a>insert</h3><p>官方还是没有提供插入的方法，需要自己实现，如果用<code>append</code>实现，<code>append</code>每次操作都会复制创建一个新的底层数组，会比较耗性能，这里采用反射实现<br>这里需要引入<code>reflect</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func silceInsert() &#123;</div><div class=\"line\"></div><div class=\"line\">\ta := []int&#123;1, 2, 3, 4, 5&#125;</div><div class=\"line\">\tfmt.Println(a)</div><div class=\"line\">\tfmt.Println(&quot;插入元素后&quot;, Insert(a, 3, 0))</div><div class=\"line\"></div><div class=\"line\">\tb := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;&#125;</div><div class=\"line\">\tfmt.Println(b)</div><div class=\"line\">\tfmt.Println(&quot;插入元素后&quot;, Insert(b, 3, &quot;x&quot;))</div><div class=\"line\"></div><div class=\"line\">\tc := []interface&#123;&#125;&#123;1, &quot;a&quot;, true, 3.2, &apos;a&apos;&#125;</div><div class=\"line\">\tfmt.Println(c)</div><div class=\"line\">\tfmt.Println(&quot;插入元素后&quot;, Insert(c, 3, false))</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func Insert(slice interface&#123;&#125;, pos int, value interface&#123;&#125;) interface&#123;&#125; &#123;</div><div class=\"line\">\tv := reflect.ValueOf(slice)</div><div class=\"line\">\tv = reflect.Append(v, reflect.ValueOf(value))</div><div class=\"line\">\treflect.Copy(v.Slice(pos+1, v.Len()), v.Slice(pos, v.Len()))</div><div class=\"line\">\tv.Index(pos).Set(reflect.ValueOf(value))</div><div class=\"line\">\treturn v.Interface()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[1 2 3 4 5]</div><div class=\"line\">插入元素后 [1 2 3 0 4 5]</div><div class=\"line\">[a b c d e]</div><div class=\"line\">插入元素后 [a b c x d e]</div><div class=\"line\">[1 a true 3.2 97]</div><div class=\"line\">插入元素后 [1 a true false 3.2 97]</div></pre></td></tr></table></figure>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>几种常见的排序方法：冒泡算法，选择排序，插入排序，快速排序，不过对于排序，官方倒是给出了方法，可以直接使用，需要引入<code>sort</code></p>\n<h4 id=\"升序排序\"><a href=\"#升序排序\" class=\"headerlink\" title=\"升序排序\"></a>升序排序</h4><p>对于 int 、 float64 和 string 数组或是分片的排序， go 分别提供了 sort.Ints() 、 sort.Float64s() 和 sort.Strings() 函数， 默认都是从小到大排序。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliceSort() &#123;</div><div class=\"line\"></div><div class=\"line\">\tintList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class=\"line\">\tfloat8List := []float64&#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125;</div><div class=\"line\">\tstringList := []string&#123;&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;i&quot;, &quot;z&quot;, &quot;x&quot;, &quot;w&quot;, &quot;y&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">\tsort.Ints(intList)</div><div class=\"line\">\tsort.Float64s(float8List)</div><div class=\"line\">\tsort.Strings(stringList)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Printf(&quot;%v\\n%v\\n%v\\n&quot;, intList, float8List, stringList)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[0 1 2 3 4 5 6 7 8 9]</div><div class=\"line\">[3.14 4.2 5.9 10 12.3 27.81828 31.4 50.4 99.9]</div><div class=\"line\">[a b c d f i w x y z]</div></pre></td></tr></table></figure>\n<h4 id=\"降序排序\"><a href=\"#降序排序\" class=\"headerlink\" title=\"降序排序\"></a>降序排序</h4><p>int 、 float64 和 string 都有默认的升序排序函数， 现在问题是如果降序如何 ？ 有其他语言编程经验的人都知道，只需要交换 cmp 的比较法则就可以了， go 的实现是类似的，然而又有所不同。 go 中对某个 Type 的对象 obj 排序， 可以使用 sort.Sort(obj) 即可，就是需要对 Type 类型绑定三个方法 ： Len() 求长度、Less(i,j) 比较第 i 和 第 j 个元素大小的函数、 Swap(i,j) 交换第 i 和第 j 个元素的函数。sort 包下的三个类型 IntSlice 、 Float64Slice 、 StringSlice 分别实现了这三个方法， 对应排序的是 [] int 、 [] float64 和 [] string 。如果期望逆序排序， 只需要将对应的 Less 函数简单修改一下即可。</p>\n<p>go 的 sort 包可以使用 sort.Reverse(slice) 来调换 slice.Interface.Less ，也就是比较函数，所以， int 、 float64 和 string 的逆序排序函数可以这么写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliceSort2() &#123;</div><div class=\"line\">\tintList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class=\"line\">\tfloat8List := []float64&#123;4.2, 5.9, 12.3, 10.0, 50.4, 99.9, 31.4, 27.81828, 3.14&#125;</div><div class=\"line\">\tstringList := []string&#123;&quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;i&quot;, &quot;z&quot;, &quot;x&quot;, &quot;w&quot;, &quot;y&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">\tsort.Sort(sort.Reverse(sort.IntSlice(intList)))</div><div class=\"line\">\tsort.Sort(sort.Reverse(sort.Float64Slice(float8List)))</div><div class=\"line\">\tsort.Sort(sort.Reverse(sort.StringSlice(stringList)))</div><div class=\"line\"></div><div class=\"line\">\tfmt.Printf(&quot;%v\\n%v\\n%v\\n&quot;, intList, float8List, stringList)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[9 8 7 6 5 4 3 2 1 0]</div><div class=\"line\">[99.9 50.4 31.4 27.81828 12.3 10 5.9 4.2 3.14]</div><div class=\"line\">[z y x w i f d c b a]</div></pre></td></tr></table></figure>\n<h4 id=\"结构体类型的排序\"><a href=\"#结构体类型的排序\" class=\"headerlink\" title=\"结构体类型的排序\"></a>结构体类型的排序</h4><p>结构体类型的排序是通过使用 sort.Sort(slice) 实现的， 只要 slice 实现了 sort.Interface 的三个方法就可以。 虽然这么说，但是排序的方法却有那么好几种。首先一种就是模拟排序 [] int 构造对应的 IntSlice 类型，然后对 IntSlice 类型实现 Interface 的三个方法。</p>\n<h5 id=\"1、模拟-IntSlice-排序\"><a href=\"#1、模拟-IntSlice-排序\" class=\"headerlink\" title=\"1、模拟 IntSlice 排序\"></a>1、模拟 IntSlice 排序</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"> </div><div class=\"line\">import (</div><div class=\"line\">    &quot;fmt&quot;</div><div class=\"line\">    &quot;sort&quot;</div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\">type Person struct &#123;</div><div class=\"line\">    Name string</div><div class=\"line\">    Age  int</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">// 按照 Person.Age 从大到小排序</div><div class=\"line\">type PersonSlice [] Person</div><div class=\"line\"> </div><div class=\"line\">func (a PersonSlice) Len() int &#123;    \t // 重写 Len() 方法</div><div class=\"line\">    return len(a)</div><div class=\"line\">&#125;</div><div class=\"line\">func (a PersonSlice) Swap(i, j int)&#123;     // 重写 Swap() 方法</div><div class=\"line\">    a[i], a[j] = a[j], a[i]</div><div class=\"line\">&#125;</div><div class=\"line\">func (a PersonSlice) Less(i, j int) bool &#123;    // 重写 Less() 方法， 从大到小排序</div><div class=\"line\">    return a[j].Age &lt; a[i].Age</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">func main() &#123;</div><div class=\"line\">    people := [] Person&#123;</div><div class=\"line\">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class=\"line\">        &#123;&quot;li si&quot;, 30&#125;,</div><div class=\"line\">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class=\"line\">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(PersonSlice(people))    // 按照 Age 的逆序排序</div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(sort.Reverse(PersonSlice(people)))    // 按照 Age 的升序排序</div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这完全是一种模拟的方式，所以如果懂了 IntSlice 自然就理解这里了，反过来，理解了这里那么 IntSlice 那里也就懂了。<br>这种方法的缺点是：根据 Age 排序需要重新定义 PersonSlice 方法，绑定 Len 、 Less 和 Swap 方法， 如果需要根据 Name 排序， 又需要重新写三个函数； 如果结构体有 4 个字段，有四种类型的排序，那么就要写 3 × 4 = 12 个方法， 即使有一些完全是多余的， O__O”… 仔细思量一下，根据不同的标准 Age 或是 Name， 真正不同的体现在 Less 方法上，所以可以将 Less 抽象出来， 每种排序的 Less 让其变成动态的，比如下面一种方法。</p>\n<h5 id=\"2、封装成-Wrapper\"><a href=\"#2、封装成-Wrapper\" class=\"headerlink\" title=\"2、封装成 Wrapper\"></a>2、封装成 Wrapper</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"> </div><div class=\"line\">import (</div><div class=\"line\">    &quot;fmt&quot;</div><div class=\"line\">    &quot;sort&quot;</div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\">type Person struct &#123;</div><div class=\"line\">    Name string</div><div class=\"line\">    Age  int</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">type PersonWrapper struct &#123;\t\t\t\t\t//注意此处</div><div class=\"line\">    people [] Person</div><div class=\"line\">    by func(p, q * Person) bool</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">func (pw PersonWrapper) Len() int &#123;    \t\t// 重写 Len() 方法</div><div class=\"line\">    return len(pw.people)</div><div class=\"line\">&#125;</div><div class=\"line\">func (pw PersonWrapper) Swap(i, j int)&#123;     // 重写 Swap() 方法</div><div class=\"line\">    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]</div><div class=\"line\">&#125;</div><div class=\"line\">func (pw PersonWrapper) Less(i, j int) bool &#123;    // 重写 Less() 方法</div><div class=\"line\">    return pw.by(&amp;pw.people[i], &amp;pw.people[j])</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">func main() &#123;</div><div class=\"line\">    people := [] Person&#123;</div><div class=\"line\">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class=\"line\">        &#123;&quot;li si&quot;, 30&#125;,</div><div class=\"line\">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class=\"line\">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class=\"line\">        return q.Age &lt; p.Age    // Age 递减排序</div><div class=\"line\">    &#125;&#125;)</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class=\"line\">        return p.Name &lt; q.Name    // Name 递增排序</div><div class=\"line\">    &#125;&#125;)</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方法将 [] Person 和比较的准则 cmp 封装在了一起，形成了 PersonWrapper 函数，然后在其上绑定 Len 、 Less 和 Swap 方法。 实际上 sort.Sort(pw) 排序的是 pw 中的 people， 这就是前面说的， go 的排序未必就是针对的一个数组或是 slice， 而可以是一个对象中的数组或是 slice 。</p>\n<h5 id=\"3、进一步封装\"><a href=\"#3、进一步封装\" class=\"headerlink\" title=\"3、进一步封装\"></a>3、进一步封装</h5><p>感觉方法 2 已经很不错了， 唯一一个缺点是，在 main 中使用的时候暴露了 sort.Sort 的使用，还有就是 PersonWrapper 的构造。 为了让 main 中使用起来更为方便， me 们可以再简单的封装一下， 构造一个 SortPerson 方法， 如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"> </div><div class=\"line\">import (</div><div class=\"line\">    &quot;fmt&quot;</div><div class=\"line\">    &quot;sort&quot;</div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\">type Person struct &#123;</div><div class=\"line\">    Name string</div><div class=\"line\">    Age  int</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">type PersonWrapper struct &#123;</div><div class=\"line\">    people [] Person</div><div class=\"line\">    by func(p, q * Person) bool</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">type SortBy func(p, q *Person) bool</div><div class=\"line\"> </div><div class=\"line\">func (pw PersonWrapper) Len() int &#123;    \t\t// 重写 Len() 方法</div><div class=\"line\">    return len(pw.people)</div><div class=\"line\">&#125;</div><div class=\"line\">func (pw PersonWrapper) Swap(i, j int)&#123;         // 重写 Swap() 方法</div><div class=\"line\">    pw.people[i], pw.people[j] = pw.people[j], pw.people[i]</div><div class=\"line\">&#125;</div><div class=\"line\">func (pw PersonWrapper) Less(i, j int) bool &#123;    // 重写 Less() 方法</div><div class=\"line\">    return pw.by(&amp;pw.people[i], &amp;pw.people[j])</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">// 封装成 SortPerson 方法</div><div class=\"line\">func SortPerson(people [] Person, by SortBy)&#123;</div><div class=\"line\">    sort.Sort(PersonWrapper&#123;people, by&#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">func main() &#123;</div><div class=\"line\">    people := [] Person&#123;</div><div class=\"line\">        &#123;&quot;zhang san&quot;, 12&#125;,</div><div class=\"line\">        &#123;&quot;li si&quot;, 30&#125;,</div><div class=\"line\">        &#123;&quot;wang wu&quot;, 52&#125;,</div><div class=\"line\">        &#123;&quot;zhao liu&quot;, 26&#125;,</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(PersonWrapper&#123;people, func (p, q *Person) bool &#123;</div><div class=\"line\">        return q.Age &lt; p.Age    // Age 递减排序</div><div class=\"line\">    &#125;&#125;)</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">    SortPerson(people, func (p, q *Person) bool &#123;</div><div class=\"line\">        return p.Name &lt; q.Name    // Name 递增排序</div><div class=\"line\">    &#125;)</div><div class=\"line\"> </div><div class=\"line\">    fmt.Println(people)</div><div class=\"line\"> </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在方法 2 的基础上构造了 SortPerson 函数，使用的时候传过去一个 [] Person 和一个 cmp 函数。</p>\n<h5 id=\"4、另一种思路\"><a href=\"#4、另一种思路\" class=\"headerlink\" title=\"4、另一种思路\"></a>4、另一种思路</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"> </div><div class=\"line\">import (</div><div class=\"line\">    &quot;fmt&quot;</div><div class=\"line\">    &quot;sort&quot;</div><div class=\"line\">)</div><div class=\"line\"> </div><div class=\"line\">type Person struct &#123;</div><div class=\"line\">    Name        string</div><div class=\"line\">    Weight      int</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">type PersonSlice []Person</div><div class=\"line\"> </div><div class=\"line\">func (s PersonSlice) Len() int  &#123; return len(s) &#125;</div><div class=\"line\">func (s PersonSlice) Swap(i, j int)     &#123; s[i], s[j] = s[j], s[i] &#125;</div><div class=\"line\"> </div><div class=\"line\">type ByName struct&#123; PersonSlice &#125;    // 将 PersonSlice 包装起来到 ByName 中</div><div class=\"line\"> </div><div class=\"line\">func (s ByName) Less(i, j int) bool     &#123; return s.PersonSlice[i].Name &lt; s.PersonSlice[j].Name &#125;    // 将 Less 绑定到 ByName 上</div><div class=\"line\"> </div><div class=\"line\"> </div><div class=\"line\">type ByWeight struct&#123; PersonSlice &#125;    // 将 PersonSlice 包装起来到 ByWeight 中</div><div class=\"line\">func (s ByWeight) Less(i, j int) bool   &#123; return s.PersonSlice[i].Weight &lt; s.PersonSlice[j].Weight &#125;    // 将 Less 绑定到 ByWeight 上</div><div class=\"line\"> </div><div class=\"line\">func main() &#123;</div><div class=\"line\">    s := []Person&#123;</div><div class=\"line\">        &#123;&quot;apple&quot;, 12&#125;,</div><div class=\"line\">        &#123;&quot;pear&quot;, 20&#125;,</div><div class=\"line\">        &#123;&quot;banana&quot;, 50&#125;,</div><div class=\"line\">        &#123;&quot;orange&quot;, 87&#125;,</div><div class=\"line\">        &#123;&quot;hello&quot;, 34&#125;,</div><div class=\"line\">        &#123;&quot;world&quot;, 43&#125;,</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(ByWeight&#123;s&#125;)</div><div class=\"line\">    fmt.Println(&quot;People by weight:&quot;)</div><div class=\"line\">    printPeople(s)</div><div class=\"line\"> </div><div class=\"line\">    sort.Sort(ByName&#123;s&#125;)</div><div class=\"line\">    fmt.Println(&quot;\\nPeople by name:&quot;)</div><div class=\"line\">    printPeople(s)</div><div class=\"line\"> </div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">func printPeople(s []Person) &#123;</div><div class=\"line\">    for _, o := range s &#123;</div><div class=\"line\">        fmt.Printf(&quot;%-8s (%v)\\n&quot;, o.Name, o.Weight)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对结构体的排序， 暂时就到这里。 第一种排序对只根据一个字段的比较合适， 另外三个是针对可能根据多个字段排序的。方法 4 我认为每次都要多构造一个 ByXXX ， 颇为不便， 这样多麻烦，不如方法 2 和方法 3 来的方便，直接传进去一个 cmp。 方法2、 3 没有太大的差别， 3 只是简单封装了一下而已， 对于使用者来说， 可能会更方便一些，而且也会更少的出错。</p>\n<h3 id=\"取最值\"><a href=\"#取最值\" class=\"headerlink\" title=\"取最值\"></a>取最值</h3><p>这个取最大值和最小值也是需要自己实现, 引入包<code>math</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">func sliceMinMax() &#123;</div><div class=\"line\">\tintList := []int&#123;2, 4, 3, 5, 7, 6, 9, 8, 1, 0&#125;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(intList)</div><div class=\"line\">\t//取最大值</div><div class=\"line\">\tfmt.Println(&quot;maxValue = &quot;, getMaxValue(intList))</div><div class=\"line\"></div><div class=\"line\">\t//取最小值</div><div class=\"line\">\tfmt.Println(&quot;minValue = &quot;, getMinValue(intList))</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func getMaxValue(slice []int) int &#123;</div><div class=\"line\">\tvar maxValue float64 = float64(slice[0])</div><div class=\"line\">\tfor _, v := range slice &#123;</div><div class=\"line\">\t\tmaxValue = math.Max(float64(maxValue), float64(v))</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn int(maxValue)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func getMinValue(slice []int) int &#123;</div><div class=\"line\">\tvar maxValue float64 = float64(slice[0])</div><div class=\"line\">\tfor _, v := range slice &#123;</div><div class=\"line\">\t\tmaxValue = math.Min(float64(maxValue), float64(v))</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn int(maxValue)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[2 4 3 5 7 6 9 8 1 0]</div><div class=\"line\">maxValue =  9</div><div class=\"line\">minValue =  0</div></pre></td></tr></table></figure>"},{"title":"一分钟学会环形进度条","date":"2016-02-27T10:36:20.000Z","_content":"\n有几篇博客写到了怎么实现环形进度条，大多是使用Core Graph来实现，实现比较麻烦且效率略低，只是一个小小的进度条而已，我们当然是用最简单而且效率高的方式来实现。\n先看一下这篇博客，博客地址：[http://www.brighttj.com/ios/ios-implement-loop-progress.html](http://www.brighttj.com/ios/ios-implement-loop-progress.html)\n这篇博客写的不错，不过看上去还是略微复杂了，我自己根据自己的思路整理了一下，当然目的是为了更加简洁易懂。\n\n### 一：先制作一个不带颜色渐变的进度条\n\n自定义一个cycleView，在.m 中实现drawRect方法\n\n```\n- (void)drawRect:(CGRect)rect {\n    \n    CGContextRef ctx = UIGraphicsGetCurrentContext();//获取上下文\n    \n    CGPoint center = CGPointMake(100, 100);  //设置圆心位置\n    CGFloat radius = 90;  //设置半径\n    CGFloat startA = - M_PI_2;  //圆起点位置\n    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //圆终点位置\n    \n    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];\n    \n    CGContextSetLineWidth(ctx, 10); //设置线条宽度\n    [[UIColor blueColor] setStroke]; //设置描边颜色\n    \n    CGContextAddPath(ctx, path.CGPath); //把路径添加到上下文\n    \n    CGContextStrokePath(ctx);  //渲染\n\n}\n\n```\n<!-- more -->\n\n因为drawRect方法只是在视图刚刚出现的时候执行一次，所以我们需要使用 \n\n`[self setNeedsDisplay];`\n\n这个方法来进行重新绘制，\n在控制器里面加一个slider，滑动slider来控制进度变化\n\n```\n- (void)drawProgress:(CGFloat )progress\n{\n    _progress = progress;\n    [self setNeedsDisplay];\n}\n```\n\n看一下效果\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/0.png)\n\n如果进度条不需要加渐变色，那么这儿几行代码就完成了。\n\n下面来实现一下带有渐变色的进度条，原理很简单，刚刚画的是一条默认是黑色的线条，我们把黑色替换成一条渐变色的线条就可以了。\n环形渐变色线条的制作：\n\n\n### 第一步\n\n使用CAShapeLayer绘制出渐变层，应为它只能指定两个点之间进行渐变，所以这里需要两个CAShapeLayer，左边一个和右边一个，看一下效果图\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/3.jpg)\n\n代码实现\n\n```\n//生成渐变色\n    CALayer *gradientLayer = [CALayer layer];\n    \n    //左侧渐变色\n    CAGradientLayer *leftLayer = [CAGradientLayer layer];\n    leftLayer.frame = CGRectMake(0, 0, self.bounds.size.width / 2, self.bounds.size.height);    // 分段设置渐变色\n    leftLayer.locations = @[@0.3, @0.9, @1];\n    leftLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor greenColor].CGColor];\n    [gradientLayer addSublayer:leftLayer];\n    \n    //右侧渐变色\n    CAGradientLayer *rightLayer = [CAGradientLayer layer];\n    rightLayer.frame = CGRectMake(self.bounds.size.width / 2, 0, self.bounds.size.width / 2, self.bounds.size.height);\n    rightLayer.locations = @[@0.3, @0.9, @1];\n    rightLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor redColor].CGColor];\n    [gradientLayer addSublayer:rightLayer];\n    \n```\n\n这个渐变层只是一个中间变量，是不能显示出来的，我这里只是演示一下，现在我们已经拿到了渐变层gradientLayer。\n\n### 第二步\n\n我们需要制作一个环形路径\n先看一下效果：\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/2.jpg)\n\n代码实现：\n\n```\nCGPoint center = CGPointMake(100, 100);\n    CGFloat radius = 90;\n    CGFloat startA = - M_PI_2;  //设置进度条起点位置\n    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //设置进度条终点位置\n    \n    //获取环形路径（画一个圆形，填充色透明，设置线框宽度为10，这样就获得了一个环形）\n    _progressLayer = [CAShapeLayer layer];//创建一个track shape layer\n    _progressLayer.frame = self.bounds;\n    _progressLayer.fillColor = [[UIColor clearColor] CGColor];  //填充色为无色\n    _progressLayer.strokeColor = [[UIColor redColor] CGColor]; //指定path的渲染颜色,这里可以设置任意不透明颜色\n    _progressLayer.opacity = 1; //背景颜色的透明度\n    _progressLayer.lineCap = kCALineCapRound;//指定线的边缘是圆的\n    _progressLayer.lineWidth = 10;//线的宽度\n    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];//上面说明过了用来构建圆形\n    _progressLayer.path =[path CGPath]; //把path传递給layer，然后layer会处理相应的渲染，整个逻辑和CoreGraph是一致的。\n    [self.layer addSublayer:_progressLayer];\n\n```\n\n### 第三步，也是最后一步了\n\n用我们在第二步生成的环形路径去截取第一步生成的渐变层\n\n```\n[gradientLayer setMask:_progressLayer]; //用progressLayer来截取渐变层\nself.layer addSublayer:gradientLayer];\n```\n\n截取的layer层就是我们最后需要的，看一看我们最后截取后得到的\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/4.jpg)\n\n到这里，我们已经完成了99%了，最后一步，根据自己的需要让它显示多少的比例就完成了。比例的控制在第二部的progress属性，比例在0-1之间，看一看最后的效果。\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/1.jpg)\n\n\n[demo下载地址](https://github.com/suifengqjn/TBCycleProgress)\n\n更多原创文章可以看 [我的博客](https://gcblog/github.io/)\n\n\n\n\n\n","source":"_posts/一分钟学会环形进度条.md","raw":"---\ntitle: 一分钟学会环形进度条\ndate: 2016-02-27 18:36:20\ntags: [iOS, UI]\ncategories: \n- iOS技术\n---\n\n有几篇博客写到了怎么实现环形进度条，大多是使用Core Graph来实现，实现比较麻烦且效率略低，只是一个小小的进度条而已，我们当然是用最简单而且效率高的方式来实现。\n先看一下这篇博客，博客地址：[http://www.brighttj.com/ios/ios-implement-loop-progress.html](http://www.brighttj.com/ios/ios-implement-loop-progress.html)\n这篇博客写的不错，不过看上去还是略微复杂了，我自己根据自己的思路整理了一下，当然目的是为了更加简洁易懂。\n\n### 一：先制作一个不带颜色渐变的进度条\n\n自定义一个cycleView，在.m 中实现drawRect方法\n\n```\n- (void)drawRect:(CGRect)rect {\n    \n    CGContextRef ctx = UIGraphicsGetCurrentContext();//获取上下文\n    \n    CGPoint center = CGPointMake(100, 100);  //设置圆心位置\n    CGFloat radius = 90;  //设置半径\n    CGFloat startA = - M_PI_2;  //圆起点位置\n    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //圆终点位置\n    \n    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];\n    \n    CGContextSetLineWidth(ctx, 10); //设置线条宽度\n    [[UIColor blueColor] setStroke]; //设置描边颜色\n    \n    CGContextAddPath(ctx, path.CGPath); //把路径添加到上下文\n    \n    CGContextStrokePath(ctx);  //渲染\n\n}\n\n```\n<!-- more -->\n\n因为drawRect方法只是在视图刚刚出现的时候执行一次，所以我们需要使用 \n\n`[self setNeedsDisplay];`\n\n这个方法来进行重新绘制，\n在控制器里面加一个slider，滑动slider来控制进度变化\n\n```\n- (void)drawProgress:(CGFloat )progress\n{\n    _progress = progress;\n    [self setNeedsDisplay];\n}\n```\n\n看一下效果\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/0.png)\n\n如果进度条不需要加渐变色，那么这儿几行代码就完成了。\n\n下面来实现一下带有渐变色的进度条，原理很简单，刚刚画的是一条默认是黑色的线条，我们把黑色替换成一条渐变色的线条就可以了。\n环形渐变色线条的制作：\n\n\n### 第一步\n\n使用CAShapeLayer绘制出渐变层，应为它只能指定两个点之间进行渐变，所以这里需要两个CAShapeLayer，左边一个和右边一个，看一下效果图\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/3.jpg)\n\n代码实现\n\n```\n//生成渐变色\n    CALayer *gradientLayer = [CALayer layer];\n    \n    //左侧渐变色\n    CAGradientLayer *leftLayer = [CAGradientLayer layer];\n    leftLayer.frame = CGRectMake(0, 0, self.bounds.size.width / 2, self.bounds.size.height);    // 分段设置渐变色\n    leftLayer.locations = @[@0.3, @0.9, @1];\n    leftLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor greenColor].CGColor];\n    [gradientLayer addSublayer:leftLayer];\n    \n    //右侧渐变色\n    CAGradientLayer *rightLayer = [CAGradientLayer layer];\n    rightLayer.frame = CGRectMake(self.bounds.size.width / 2, 0, self.bounds.size.width / 2, self.bounds.size.height);\n    rightLayer.locations = @[@0.3, @0.9, @1];\n    rightLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor redColor].CGColor];\n    [gradientLayer addSublayer:rightLayer];\n    \n```\n\n这个渐变层只是一个中间变量，是不能显示出来的，我这里只是演示一下，现在我们已经拿到了渐变层gradientLayer。\n\n### 第二步\n\n我们需要制作一个环形路径\n先看一下效果：\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/2.jpg)\n\n代码实现：\n\n```\nCGPoint center = CGPointMake(100, 100);\n    CGFloat radius = 90;\n    CGFloat startA = - M_PI_2;  //设置进度条起点位置\n    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //设置进度条终点位置\n    \n    //获取环形路径（画一个圆形，填充色透明，设置线框宽度为10，这样就获得了一个环形）\n    _progressLayer = [CAShapeLayer layer];//创建一个track shape layer\n    _progressLayer.frame = self.bounds;\n    _progressLayer.fillColor = [[UIColor clearColor] CGColor];  //填充色为无色\n    _progressLayer.strokeColor = [[UIColor redColor] CGColor]; //指定path的渲染颜色,这里可以设置任意不透明颜色\n    _progressLayer.opacity = 1; //背景颜色的透明度\n    _progressLayer.lineCap = kCALineCapRound;//指定线的边缘是圆的\n    _progressLayer.lineWidth = 10;//线的宽度\n    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];//上面说明过了用来构建圆形\n    _progressLayer.path =[path CGPath]; //把path传递給layer，然后layer会处理相应的渲染，整个逻辑和CoreGraph是一致的。\n    [self.layer addSublayer:_progressLayer];\n\n```\n\n### 第三步，也是最后一步了\n\n用我们在第二步生成的环形路径去截取第一步生成的渐变层\n\n```\n[gradientLayer setMask:_progressLayer]; //用progressLayer来截取渐变层\nself.layer addSublayer:gradientLayer];\n```\n\n截取的layer层就是我们最后需要的，看一看我们最后截取后得到的\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/4.jpg)\n\n到这里，我们已经完成了99%了，最后一步，根据自己的需要让它显示多少的比例就完成了。比例的控制在第二部的progress属性，比例在0-1之间，看一看最后的效果。\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/1.jpg)\n\n\n[demo下载地址](https://github.com/suifengqjn/TBCycleProgress)\n\n更多原创文章可以看 [我的博客](https://gcblog/github.io/)\n\n\n\n\n\n","slug":"一分钟学会环形进度条","published":1,"updated":"2016-11-17T14:59:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tf3002ilx60s3i6nfjv","content":"<p>有几篇博客写到了怎么实现环形进度条，大多是使用Core Graph来实现，实现比较麻烦且效率略低，只是一个小小的进度条而已，我们当然是用最简单而且效率高的方式来实现。<br>先看一下这篇博客，博客地址：<a href=\"http://www.brighttj.com/ios/ios-implement-loop-progress.html\" target=\"_blank\" rel=\"external\">http://www.brighttj.com/ios/ios-implement-loop-progress.html</a><br>这篇博客写的不错，不过看上去还是略微复杂了，我自己根据自己的思路整理了一下，当然目的是为了更加简洁易懂。</p>\n<h3 id=\"一：先制作一个不带颜色渐变的进度条\"><a href=\"#一：先制作一个不带颜色渐变的进度条\" class=\"headerlink\" title=\"一：先制作一个不带颜色渐变的进度条\"></a>一：先制作一个不带颜色渐变的进度条</h3><p>自定义一个cycleView，在.m 中实现drawRect方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawRect:(CGRect)rect &#123;</div><div class=\"line\">    </div><div class=\"line\">    CGContextRef ctx = UIGraphicsGetCurrentContext();//获取上下文</div><div class=\"line\">    </div><div class=\"line\">    CGPoint center = CGPointMake(100, 100);  //设置圆心位置</div><div class=\"line\">    CGFloat radius = 90;  //设置半径</div><div class=\"line\">    CGFloat startA = - M_PI_2;  //圆起点位置</div><div class=\"line\">    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //圆终点位置</div><div class=\"line\">    </div><div class=\"line\">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];</div><div class=\"line\">    </div><div class=\"line\">    CGContextSetLineWidth(ctx, 10); //设置线条宽度</div><div class=\"line\">    [[UIColor blueColor] setStroke]; //设置描边颜色</div><div class=\"line\">    </div><div class=\"line\">    CGContextAddPath(ctx, path.CGPath); //把路径添加到上下文</div><div class=\"line\">    </div><div class=\"line\">    CGContextStrokePath(ctx);  //渲染</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>因为drawRect方法只是在视图刚刚出现的时候执行一次，所以我们需要使用 </p>\n<p><code>[self setNeedsDisplay];</code></p>\n<p>这个方法来进行重新绘制，<br>在控制器里面加一个slider，滑动slider来控制进度变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawProgress:(CGFloat )progress</div><div class=\"line\">&#123;</div><div class=\"line\">    _progress = progress;</div><div class=\"line\">    [self setNeedsDisplay];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一下效果</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/0.png\" alt=\"image\"></p>\n<p>如果进度条不需要加渐变色，那么这儿几行代码就完成了。</p>\n<p>下面来实现一下带有渐变色的进度条，原理很简单，刚刚画的是一条默认是黑色的线条，我们把黑色替换成一条渐变色的线条就可以了。<br>环形渐变色线条的制作：</p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>使用CAShapeLayer绘制出渐变层，应为它只能指定两个点之间进行渐变，所以这里需要两个CAShapeLayer，左边一个和右边一个，看一下效果图</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/3.jpg\" alt=\"image\"></p>\n<p>代码实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//生成渐变色</div><div class=\"line\">    CALayer *gradientLayer = [CALayer layer];</div><div class=\"line\">    </div><div class=\"line\">    //左侧渐变色</div><div class=\"line\">    CAGradientLayer *leftLayer = [CAGradientLayer layer];</div><div class=\"line\">    leftLayer.frame = CGRectMake(0, 0, self.bounds.size.width / 2, self.bounds.size.height);    // 分段设置渐变色</div><div class=\"line\">    leftLayer.locations = @[@0.3, @0.9, @1];</div><div class=\"line\">    leftLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor greenColor].CGColor];</div><div class=\"line\">    [gradientLayer addSublayer:leftLayer];</div><div class=\"line\">    </div><div class=\"line\">    //右侧渐变色</div><div class=\"line\">    CAGradientLayer *rightLayer = [CAGradientLayer layer];</div><div class=\"line\">    rightLayer.frame = CGRectMake(self.bounds.size.width / 2, 0, self.bounds.size.width / 2, self.bounds.size.height);</div><div class=\"line\">    rightLayer.locations = @[@0.3, @0.9, @1];</div><div class=\"line\">    rightLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor redColor].CGColor];</div><div class=\"line\">    [gradientLayer addSublayer:rightLayer];</div></pre></td></tr></table></figure>\n<p>这个渐变层只是一个中间变量，是不能显示出来的，我这里只是演示一下，现在我们已经拿到了渐变层gradientLayer。</p>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>我们需要制作一个环形路径<br>先看一下效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/2.jpg\" alt=\"image\"></p>\n<p>代码实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGPoint center = CGPointMake(100, 100);</div><div class=\"line\">    CGFloat radius = 90;</div><div class=\"line\">    CGFloat startA = - M_PI_2;  //设置进度条起点位置</div><div class=\"line\">    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //设置进度条终点位置</div><div class=\"line\">    </div><div class=\"line\">    //获取环形路径（画一个圆形，填充色透明，设置线框宽度为10，这样就获得了一个环形）</div><div class=\"line\">    _progressLayer = [CAShapeLayer layer];//创建一个track shape layer</div><div class=\"line\">    _progressLayer.frame = self.bounds;</div><div class=\"line\">    _progressLayer.fillColor = [[UIColor clearColor] CGColor];  //填充色为无色</div><div class=\"line\">    _progressLayer.strokeColor = [[UIColor redColor] CGColor]; //指定path的渲染颜色,这里可以设置任意不透明颜色</div><div class=\"line\">    _progressLayer.opacity = 1; //背景颜色的透明度</div><div class=\"line\">    _progressLayer.lineCap = kCALineCapRound;//指定线的边缘是圆的</div><div class=\"line\">    _progressLayer.lineWidth = 10;//线的宽度</div><div class=\"line\">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];//上面说明过了用来构建圆形</div><div class=\"line\">    _progressLayer.path =[path CGPath]; //把path传递給layer，然后layer会处理相应的渲染，整个逻辑和CoreGraph是一致的。</div><div class=\"line\">    [self.layer addSublayer:_progressLayer];</div></pre></td></tr></table></figure>\n<h3 id=\"第三步，也是最后一步了\"><a href=\"#第三步，也是最后一步了\" class=\"headerlink\" title=\"第三步，也是最后一步了\"></a>第三步，也是最后一步了</h3><p>用我们在第二步生成的环形路径去截取第一步生成的渐变层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[gradientLayer setMask:_progressLayer]; //用progressLayer来截取渐变层</div><div class=\"line\">self.layer addSublayer:gradientLayer];</div></pre></td></tr></table></figure>\n<p>截取的layer层就是我们最后需要的，看一看我们最后截取后得到的<br><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/4.jpg\" alt=\"image\"></p>\n<p>到这里，我们已经完成了99%了，最后一步，根据自己的需要让它显示多少的比例就完成了。比例的控制在第二部的progress属性，比例在0-1之间，看一看最后的效果。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/1.jpg\" alt=\"image\"></p>\n<p><a href=\"https://github.com/suifengqjn/TBCycleProgress\" target=\"_blank\" rel=\"external\">demo下载地址</a></p>\n<p>更多原创文章可以看 <a href=\"https://gcblog/github.io/\">我的博客</a></p>\n","excerpt":"<p>有几篇博客写到了怎么实现环形进度条，大多是使用Core Graph来实现，实现比较麻烦且效率略低，只是一个小小的进度条而已，我们当然是用最简单而且效率高的方式来实现。<br>先看一下这篇博客，博客地址：<a href=\"http://www.brighttj.com/ios/ios-implement-loop-progress.html\">http://www.brighttj.com/ios/ios-implement-loop-progress.html</a><br>这篇博客写的不错，不过看上去还是略微复杂了，我自己根据自己的思路整理了一下，当然目的是为了更加简洁易懂。</p>\n<h3 id=\"一：先制作一个不带颜色渐变的进度条\"><a href=\"#一：先制作一个不带颜色渐变的进度条\" class=\"headerlink\" title=\"一：先制作一个不带颜色渐变的进度条\"></a>一：先制作一个不带颜色渐变的进度条</h3><p>自定义一个cycleView，在.m 中实现drawRect方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawRect:(CGRect)rect &#123;</div><div class=\"line\">    </div><div class=\"line\">    CGContextRef ctx = UIGraphicsGetCurrentContext();//获取上下文</div><div class=\"line\">    </div><div class=\"line\">    CGPoint center = CGPointMake(100, 100);  //设置圆心位置</div><div class=\"line\">    CGFloat radius = 90;  //设置半径</div><div class=\"line\">    CGFloat startA = - M_PI_2;  //圆起点位置</div><div class=\"line\">    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //圆终点位置</div><div class=\"line\">    </div><div class=\"line\">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];</div><div class=\"line\">    </div><div class=\"line\">    CGContextSetLineWidth(ctx, 10); //设置线条宽度</div><div class=\"line\">    [[UIColor blueColor] setStroke]; //设置描边颜色</div><div class=\"line\">    </div><div class=\"line\">    CGContextAddPath(ctx, path.CGPath); //把路径添加到上下文</div><div class=\"line\">    </div><div class=\"line\">    CGContextStrokePath(ctx);  //渲染</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>因为drawRect方法只是在视图刚刚出现的时候执行一次，所以我们需要使用 </p>\n<p><code>[self setNeedsDisplay];</code></p>\n<p>这个方法来进行重新绘制，<br>在控制器里面加一个slider，滑动slider来控制进度变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawProgress:(CGFloat )progress</div><div class=\"line\">&#123;</div><div class=\"line\">    _progress = progress;</div><div class=\"line\">    [self setNeedsDisplay];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一下效果</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/0.png\" alt=\"image\"></p>\n<p>如果进度条不需要加渐变色，那么这儿几行代码就完成了。</p>\n<p>下面来实现一下带有渐变色的进度条，原理很简单，刚刚画的是一条默认是黑色的线条，我们把黑色替换成一条渐变色的线条就可以了。<br>环形渐变色线条的制作：</p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>使用CAShapeLayer绘制出渐变层，应为它只能指定两个点之间进行渐变，所以这里需要两个CAShapeLayer，左边一个和右边一个，看一下效果图</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/3.jpg\" alt=\"image\"></p>\n<p>代码实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//生成渐变色</div><div class=\"line\">    CALayer *gradientLayer = [CALayer layer];</div><div class=\"line\">    </div><div class=\"line\">    //左侧渐变色</div><div class=\"line\">    CAGradientLayer *leftLayer = [CAGradientLayer layer];</div><div class=\"line\">    leftLayer.frame = CGRectMake(0, 0, self.bounds.size.width / 2, self.bounds.size.height);    // 分段设置渐变色</div><div class=\"line\">    leftLayer.locations = @[@0.3, @0.9, @1];</div><div class=\"line\">    leftLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor greenColor].CGColor];</div><div class=\"line\">    [gradientLayer addSublayer:leftLayer];</div><div class=\"line\">    </div><div class=\"line\">    //右侧渐变色</div><div class=\"line\">    CAGradientLayer *rightLayer = [CAGradientLayer layer];</div><div class=\"line\">    rightLayer.frame = CGRectMake(self.bounds.size.width / 2, 0, self.bounds.size.width / 2, self.bounds.size.height);</div><div class=\"line\">    rightLayer.locations = @[@0.3, @0.9, @1];</div><div class=\"line\">    rightLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor redColor].CGColor];</div><div class=\"line\">    [gradientLayer addSublayer:rightLayer];</div></pre></td></tr></table></figure>\n<p>这个渐变层只是一个中间变量，是不能显示出来的，我这里只是演示一下，现在我们已经拿到了渐变层gradientLayer。</p>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>我们需要制作一个环形路径<br>先看一下效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/2.jpg\" alt=\"image\"></p>\n<p>代码实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGPoint center = CGPointMake(100, 100);</div><div class=\"line\">    CGFloat radius = 90;</div><div class=\"line\">    CGFloat startA = - M_PI_2;  //设置进度条起点位置</div><div class=\"line\">    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //设置进度条终点位置</div><div class=\"line\">    </div><div class=\"line\">    //获取环形路径（画一个圆形，填充色透明，设置线框宽度为10，这样就获得了一个环形）</div><div class=\"line\">    _progressLayer = [CAShapeLayer layer];//创建一个track shape layer</div><div class=\"line\">    _progressLayer.frame = self.bounds;</div><div class=\"line\">    _progressLayer.fillColor = [[UIColor clearColor] CGColor];  //填充色为无色</div><div class=\"line\">    _progressLayer.strokeColor = [[UIColor redColor] CGColor]; //指定path的渲染颜色,这里可以设置任意不透明颜色</div><div class=\"line\">    _progressLayer.opacity = 1; //背景颜色的透明度</div><div class=\"line\">    _progressLayer.lineCap = kCALineCapRound;//指定线的边缘是圆的</div><div class=\"line\">    _progressLayer.lineWidth = 10;//线的宽度</div><div class=\"line\">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];//上面说明过了用来构建圆形</div><div class=\"line\">    _progressLayer.path =[path CGPath]; //把path传递給layer，然后layer会处理相应的渲染，整个逻辑和CoreGraph是一致的。</div><div class=\"line\">    [self.layer addSublayer:_progressLayer];</div></pre></td></tr></table></figure>\n<h3 id=\"第三步，也是最后一步了\"><a href=\"#第三步，也是最后一步了\" class=\"headerlink\" title=\"第三步，也是最后一步了\"></a>第三步，也是最后一步了</h3><p>用我们在第二步生成的环形路径去截取第一步生成的渐变层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[gradientLayer setMask:_progressLayer]; //用progressLayer来截取渐变层</div><div class=\"line\">self.layer addSublayer:gradientLayer];</div></pre></td></tr></table></figure>\n<p>截取的layer层就是我们最后需要的，看一看我们最后截取后得到的<br><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/4.jpg\" alt=\"image\"></p>\n<p>到这里，我们已经完成了99%了，最后一步，根据自己的需要让它显示多少的比例就完成了。比例的控制在第二部的progress属性，比例在0-1之间，看一看最后的效果。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/1.jpg\" alt=\"image\"></p>\n<p><a href=\"https://github.com/suifengqjn/TBCycleProgress\">demo下载地址</a></p>\n<p>更多原创文章可以看 <a href=\"https://gcblog/github.io/\">我的博客</a></p>"},{"title":"共识算法POS原理及实现","date":"2018-06-29T11:31:41.000Z","_content":"\n## POS简介\n\nPOS：Proof of Stake，股权证明\n类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 \n简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。以太坊就是采用POS共识算法。\n\n## 算法具体实现原理\n\n每个旷工都有出块(即挖矿)的权力，只要出块成功，就有系统给出的奖励，这里不需要通过复杂的计算来挖矿，问题只在于谁来出块，股权越大，出块的概率就越大，反之，则相反。POS有很多变种，股权可以是持有币的数量，或者支付的数量等等。\n\n<!--more-->\n\n## 代码简单实现其原理\n\n```\npackage main\n\nimport (\n\t\"time\"\n\t\"strconv\"\n\t\"crypto/sha256\"\n\t\"math/rand\"\n\t\"fmt\"\n\t\"encoding/hex\"\n)\n\n//实现pos挖矿的原理\n\ntype Block struct {\n\tIndex int\n\tData string //\n\tPreHash string\n\tHash string\n\tTimestamp string\n\t//记录挖矿节点\n\tValidator *Node\n\n}\n\nfunc genesisBlock() Block  {\n\n\tvar genesBlock  = Block{0, \"Genesis block\",\"\",\"\",time.Now().String(),&Node{0, 0, \"dd\"}}\n\tgenesBlock.Hash = hex.EncodeToString(BlockHash(&genesBlock))\n\treturn genesBlock\n}\n\nfunc BlockHash(block *Block) []byte  {\n\trecord := strconv.Itoa(block.Index) + block.Data + block.PreHash + block.Timestamp + block.Validator.Address\n\th := sha256.New()\n\th.Write([]byte(record))\n\thashed := h.Sum(nil)\n\n\treturn hashed\n}\n\n//创建全节点类型\ntype Node struct {\n\tTokens int //持币数量\n\tDays int //持币时间\n\tAddress string //地址\n}\n\n\n//创建5个节点\n//算法的实现要满足 持币越多的节点越容易出块\nvar nodes = make([]Node, 5)\n//存放节点的地址\nvar addr = make([]*Node, 15)\n\n\nfunc InitNodes()  {\n\n\tnodes[0] = Node{1, 1, \"0x12341\"}\n\tnodes[1] = Node{2, 1, \"0x12342\"}\n\tnodes[2] = Node{3, 1, \"0x12343\"}\n\tnodes[3] = Node{4, 1, \"0x12344\"}\n\tnodes[4] = Node{5, 1, \"0x12345\"}\n\n\tcnt :=0\n\tfor i:=0;i<5;i++ {\n\t\tfor j:=0;j<nodes[i].Tokens * nodes[i].Days;j++{\n\t\t\taddr[cnt] = &nodes[i]\n\t\t\tcnt++\n\t\t}\n\t}\n\n}\n\n//采用Pos共识算法进行挖矿\nfunc CreateNewBlock(lastBlock *Block, data string) Block{\n\n\tvar newBlock Block\n\tnewBlock.Index = lastBlock.Index + 1\n\tnewBlock.Timestamp = time.Now().String()\n\tnewBlock.PreHash = lastBlock.Hash\n\tnewBlock.Data = data\n\n\n\t//通过pos计算由那个村民挖矿\n\t//设置随机种子\n\trand.Seed(time.Now().Unix())\n\t//[0,15)产生0-15的随机值\n\tvar rd =rand.Intn(15)\n\n\t//选出挖矿的旷工\n\tnode := addr[rd]\n\t//设置当前区块挖矿地址为旷工\n\tnewBlock.Validator = node\n\t//简单模拟 挖矿所得奖励\n\tnode.Tokens += 1\n\tnewBlock.Hash = hex.EncodeToString(BlockHash(&newBlock))\n\treturn newBlock\n}\n\nfunc main()  {\n\n\tInitNodes()\n\n\t//创建创世区块\n\tvar genesisBlock = genesisBlock()\n\n\t//创建新区快\n\tvar newBlock = CreateNewBlock(&genesisBlock, \"new block\")\n\n\t//打印新区快信息\n\tfmt.Println(newBlock)\n\tfmt.Println(newBlock.Validator.Address)\n\tfmt.Println(newBlock.Validator.Tokens)\n\n}\n\n```\n\n输出\n```\n{1 new block 72e8838ad3bb761c7d3ba42c4e6bad86409dd3f4ce958c890409c4b9ddf44171 e4f9575cfb14ee146810862c9e5cc78ebff185f5888f428dbb945bd9060b31f7 2018-06-29 19:29:04.827332898 +0800 CST m=+0.000837770 0xc42007e0a0}\n0x12341\n2\n```\n\n\n\n\n","source":"_posts/共识算法POS原理及实现.md","raw":"---\ntitle: 共识算法POS原理及实现\ncategories:\n  - 共识算法\ntags:\n  - POS\n  - 共识算法\ndate: 2018-06-29 19:31:41\n---\n\n## POS简介\n\nPOS：Proof of Stake，股权证明\n类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。 \n简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。以太坊就是采用POS共识算法。\n\n## 算法具体实现原理\n\n每个旷工都有出块(即挖矿)的权力，只要出块成功，就有系统给出的奖励，这里不需要通过复杂的计算来挖矿，问题只在于谁来出块，股权越大，出块的概率就越大，反之，则相反。POS有很多变种，股权可以是持有币的数量，或者支付的数量等等。\n\n<!--more-->\n\n## 代码简单实现其原理\n\n```\npackage main\n\nimport (\n\t\"time\"\n\t\"strconv\"\n\t\"crypto/sha256\"\n\t\"math/rand\"\n\t\"fmt\"\n\t\"encoding/hex\"\n)\n\n//实现pos挖矿的原理\n\ntype Block struct {\n\tIndex int\n\tData string //\n\tPreHash string\n\tHash string\n\tTimestamp string\n\t//记录挖矿节点\n\tValidator *Node\n\n}\n\nfunc genesisBlock() Block  {\n\n\tvar genesBlock  = Block{0, \"Genesis block\",\"\",\"\",time.Now().String(),&Node{0, 0, \"dd\"}}\n\tgenesBlock.Hash = hex.EncodeToString(BlockHash(&genesBlock))\n\treturn genesBlock\n}\n\nfunc BlockHash(block *Block) []byte  {\n\trecord := strconv.Itoa(block.Index) + block.Data + block.PreHash + block.Timestamp + block.Validator.Address\n\th := sha256.New()\n\th.Write([]byte(record))\n\thashed := h.Sum(nil)\n\n\treturn hashed\n}\n\n//创建全节点类型\ntype Node struct {\n\tTokens int //持币数量\n\tDays int //持币时间\n\tAddress string //地址\n}\n\n\n//创建5个节点\n//算法的实现要满足 持币越多的节点越容易出块\nvar nodes = make([]Node, 5)\n//存放节点的地址\nvar addr = make([]*Node, 15)\n\n\nfunc InitNodes()  {\n\n\tnodes[0] = Node{1, 1, \"0x12341\"}\n\tnodes[1] = Node{2, 1, \"0x12342\"}\n\tnodes[2] = Node{3, 1, \"0x12343\"}\n\tnodes[3] = Node{4, 1, \"0x12344\"}\n\tnodes[4] = Node{5, 1, \"0x12345\"}\n\n\tcnt :=0\n\tfor i:=0;i<5;i++ {\n\t\tfor j:=0;j<nodes[i].Tokens * nodes[i].Days;j++{\n\t\t\taddr[cnt] = &nodes[i]\n\t\t\tcnt++\n\t\t}\n\t}\n\n}\n\n//采用Pos共识算法进行挖矿\nfunc CreateNewBlock(lastBlock *Block, data string) Block{\n\n\tvar newBlock Block\n\tnewBlock.Index = lastBlock.Index + 1\n\tnewBlock.Timestamp = time.Now().String()\n\tnewBlock.PreHash = lastBlock.Hash\n\tnewBlock.Data = data\n\n\n\t//通过pos计算由那个村民挖矿\n\t//设置随机种子\n\trand.Seed(time.Now().Unix())\n\t//[0,15)产生0-15的随机值\n\tvar rd =rand.Intn(15)\n\n\t//选出挖矿的旷工\n\tnode := addr[rd]\n\t//设置当前区块挖矿地址为旷工\n\tnewBlock.Validator = node\n\t//简单模拟 挖矿所得奖励\n\tnode.Tokens += 1\n\tnewBlock.Hash = hex.EncodeToString(BlockHash(&newBlock))\n\treturn newBlock\n}\n\nfunc main()  {\n\n\tInitNodes()\n\n\t//创建创世区块\n\tvar genesisBlock = genesisBlock()\n\n\t//创建新区快\n\tvar newBlock = CreateNewBlock(&genesisBlock, \"new block\")\n\n\t//打印新区快信息\n\tfmt.Println(newBlock)\n\tfmt.Println(newBlock.Validator.Address)\n\tfmt.Println(newBlock.Validator.Tokens)\n\n}\n\n```\n\n输出\n```\n{1 new block 72e8838ad3bb761c7d3ba42c4e6bad86409dd3f4ce958c890409c4b9ddf44171 e4f9575cfb14ee146810862c9e5cc78ebff185f5888f428dbb945bd9060b31f7 2018-06-29 19:29:04.827332898 +0800 CST m=+0.000837770 0xc42007e0a0}\n0x12341\n2\n```\n\n\n\n\n","slug":"共识算法POS原理及实现","published":1,"updated":"2018-06-29T11:33:55.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tf4002klx60zobu9101","content":"<h2 id=\"POS简介\"><a href=\"#POS简介\" class=\"headerlink\" title=\"POS简介\"></a>POS简介</h2><p>POS：Proof of Stake，股权证明<br>类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。<br>简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。以太坊就是采用POS共识算法。</p>\n<h2 id=\"算法具体实现原理\"><a href=\"#算法具体实现原理\" class=\"headerlink\" title=\"算法具体实现原理\"></a>算法具体实现原理</h2><p>每个旷工都有出块(即挖矿)的权力，只要出块成功，就有系统给出的奖励，这里不需要通过复杂的计算来挖矿，问题只在于谁来出块，股权越大，出块的概率就越大，反之，则相反。POS有很多变种，股权可以是持有币的数量，或者支付的数量等等。</p>\n<a id=\"more\"></a>\n<h2 id=\"代码简单实现其原理\"><a href=\"#代码简单实现其原理\" class=\"headerlink\" title=\"代码简单实现其原理\"></a>代码简单实现其原理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;time&quot;</div><div class=\"line\">\t&quot;strconv&quot;</div><div class=\"line\">\t&quot;crypto/sha256&quot;</div><div class=\"line\">\t&quot;math/rand&quot;</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;encoding/hex&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">//实现pos挖矿的原理</div><div class=\"line\"></div><div class=\"line\">type Block struct &#123;</div><div class=\"line\">\tIndex int</div><div class=\"line\">\tData string //</div><div class=\"line\">\tPreHash string</div><div class=\"line\">\tHash string</div><div class=\"line\">\tTimestamp string</div><div class=\"line\">\t//记录挖矿节点</div><div class=\"line\">\tValidator *Node</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func genesisBlock() Block  &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar genesBlock  = Block&#123;0, &quot;Genesis block&quot;,&quot;&quot;,&quot;&quot;,time.Now().String(),&amp;Node&#123;0, 0, &quot;dd&quot;&#125;&#125;</div><div class=\"line\">\tgenesBlock.Hash = hex.EncodeToString(BlockHash(&amp;genesBlock))</div><div class=\"line\">\treturn genesBlock</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func BlockHash(block *Block) []byte  &#123;</div><div class=\"line\">\trecord := strconv.Itoa(block.Index) + block.Data + block.PreHash + block.Timestamp + block.Validator.Address</div><div class=\"line\">\th := sha256.New()</div><div class=\"line\">\th.Write([]byte(record))</div><div class=\"line\">\thashed := h.Sum(nil)</div><div class=\"line\"></div><div class=\"line\">\treturn hashed</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建全节点类型</div><div class=\"line\">type Node struct &#123;</div><div class=\"line\">\tTokens int //持币数量</div><div class=\"line\">\tDays int //持币时间</div><div class=\"line\">\tAddress string //地址</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//创建5个节点</div><div class=\"line\">//算法的实现要满足 持币越多的节点越容易出块</div><div class=\"line\">var nodes = make([]Node, 5)</div><div class=\"line\">//存放节点的地址</div><div class=\"line\">var addr = make([]*Node, 15)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func InitNodes()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tnodes[0] = Node&#123;1, 1, &quot;0x12341&quot;&#125;</div><div class=\"line\">\tnodes[1] = Node&#123;2, 1, &quot;0x12342&quot;&#125;</div><div class=\"line\">\tnodes[2] = Node&#123;3, 1, &quot;0x12343&quot;&#125;</div><div class=\"line\">\tnodes[3] = Node&#123;4, 1, &quot;0x12344&quot;&#125;</div><div class=\"line\">\tnodes[4] = Node&#123;5, 1, &quot;0x12345&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">\tcnt :=0</div><div class=\"line\">\tfor i:=0;i&lt;5;i++ &#123;</div><div class=\"line\">\t\tfor j:=0;j&lt;nodes[i].Tokens * nodes[i].Days;j++&#123;</div><div class=\"line\">\t\t\taddr[cnt] = &amp;nodes[i]</div><div class=\"line\">\t\t\tcnt++</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//采用Pos共识算法进行挖矿</div><div class=\"line\">func CreateNewBlock(lastBlock *Block, data string) Block&#123;</div><div class=\"line\"></div><div class=\"line\">\tvar newBlock Block</div><div class=\"line\">\tnewBlock.Index = lastBlock.Index + 1</div><div class=\"line\">\tnewBlock.Timestamp = time.Now().String()</div><div class=\"line\">\tnewBlock.PreHash = lastBlock.Hash</div><div class=\"line\">\tnewBlock.Data = data</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//通过pos计算由那个村民挖矿</div><div class=\"line\">\t//设置随机种子</div><div class=\"line\">\trand.Seed(time.Now().Unix())</div><div class=\"line\">\t//[0,15)产生0-15的随机值</div><div class=\"line\">\tvar rd =rand.Intn(15)</div><div class=\"line\"></div><div class=\"line\">\t//选出挖矿的旷工</div><div class=\"line\">\tnode := addr[rd]</div><div class=\"line\">\t//设置当前区块挖矿地址为旷工</div><div class=\"line\">\tnewBlock.Validator = node</div><div class=\"line\">\t//简单模拟 挖矿所得奖励</div><div class=\"line\">\tnode.Tokens += 1</div><div class=\"line\">\tnewBlock.Hash = hex.EncodeToString(BlockHash(&amp;newBlock))</div><div class=\"line\">\treturn newBlock</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tInitNodes()</div><div class=\"line\"></div><div class=\"line\">\t//创建创世区块</div><div class=\"line\">\tvar genesisBlock = genesisBlock()</div><div class=\"line\"></div><div class=\"line\">\t//创建新区快</div><div class=\"line\">\tvar newBlock = CreateNewBlock(&amp;genesisBlock, &quot;new block&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//打印新区快信息</div><div class=\"line\">\tfmt.Println(newBlock)</div><div class=\"line\">\tfmt.Println(newBlock.Validator.Address)</div><div class=\"line\">\tfmt.Println(newBlock.Validator.Tokens)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;1 new block 72e8838ad3bb761c7d3ba42c4e6bad86409dd3f4ce958c890409c4b9ddf44171 e4f9575cfb14ee146810862c9e5cc78ebff185f5888f428dbb945bd9060b31f7 2018-06-29 19:29:04.827332898 +0800 CST m=+0.000837770 0xc42007e0a0&#125;</div><div class=\"line\">0x12341</div><div class=\"line\">2</div></pre></td></tr></table></figure></p>\n","excerpt":"<h2 id=\"POS简介\"><a href=\"#POS简介\" class=\"headerlink\" title=\"POS简介\"></a>POS简介</h2><p>POS：Proof of Stake，股权证明<br>类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。<br>简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个POS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币，这下就很有意思了，持币有利息。以太坊就是采用POS共识算法。</p>\n<h2 id=\"算法具体实现原理\"><a href=\"#算法具体实现原理\" class=\"headerlink\" title=\"算法具体实现原理\"></a>算法具体实现原理</h2><p>每个旷工都有出块(即挖矿)的权力，只要出块成功，就有系统给出的奖励，这里不需要通过复杂的计算来挖矿，问题只在于谁来出块，股权越大，出块的概率就越大，反之，则相反。POS有很多变种，股权可以是持有币的数量，或者支付的数量等等。</p>","more":"<h2 id=\"代码简单实现其原理\"><a href=\"#代码简单实现其原理\" class=\"headerlink\" title=\"代码简单实现其原理\"></a>代码简单实现其原理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;time&quot;</div><div class=\"line\">\t&quot;strconv&quot;</div><div class=\"line\">\t&quot;crypto/sha256&quot;</div><div class=\"line\">\t&quot;math/rand&quot;</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;encoding/hex&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">//实现pos挖矿的原理</div><div class=\"line\"></div><div class=\"line\">type Block struct &#123;</div><div class=\"line\">\tIndex int</div><div class=\"line\">\tData string //</div><div class=\"line\">\tPreHash string</div><div class=\"line\">\tHash string</div><div class=\"line\">\tTimestamp string</div><div class=\"line\">\t//记录挖矿节点</div><div class=\"line\">\tValidator *Node</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func genesisBlock() Block  &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar genesBlock  = Block&#123;0, &quot;Genesis block&quot;,&quot;&quot;,&quot;&quot;,time.Now().String(),&amp;Node&#123;0, 0, &quot;dd&quot;&#125;&#125;</div><div class=\"line\">\tgenesBlock.Hash = hex.EncodeToString(BlockHash(&amp;genesBlock))</div><div class=\"line\">\treturn genesBlock</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func BlockHash(block *Block) []byte  &#123;</div><div class=\"line\">\trecord := strconv.Itoa(block.Index) + block.Data + block.PreHash + block.Timestamp + block.Validator.Address</div><div class=\"line\">\th := sha256.New()</div><div class=\"line\">\th.Write([]byte(record))</div><div class=\"line\">\thashed := h.Sum(nil)</div><div class=\"line\"></div><div class=\"line\">\treturn hashed</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建全节点类型</div><div class=\"line\">type Node struct &#123;</div><div class=\"line\">\tTokens int //持币数量</div><div class=\"line\">\tDays int //持币时间</div><div class=\"line\">\tAddress string //地址</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//创建5个节点</div><div class=\"line\">//算法的实现要满足 持币越多的节点越容易出块</div><div class=\"line\">var nodes = make([]Node, 5)</div><div class=\"line\">//存放节点的地址</div><div class=\"line\">var addr = make([]*Node, 15)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func InitNodes()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tnodes[0] = Node&#123;1, 1, &quot;0x12341&quot;&#125;</div><div class=\"line\">\tnodes[1] = Node&#123;2, 1, &quot;0x12342&quot;&#125;</div><div class=\"line\">\tnodes[2] = Node&#123;3, 1, &quot;0x12343&quot;&#125;</div><div class=\"line\">\tnodes[3] = Node&#123;4, 1, &quot;0x12344&quot;&#125;</div><div class=\"line\">\tnodes[4] = Node&#123;5, 1, &quot;0x12345&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">\tcnt :=0</div><div class=\"line\">\tfor i:=0;i&lt;5;i++ &#123;</div><div class=\"line\">\t\tfor j:=0;j&lt;nodes[i].Tokens * nodes[i].Days;j++&#123;</div><div class=\"line\">\t\t\taddr[cnt] = &amp;nodes[i]</div><div class=\"line\">\t\t\tcnt++</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//采用Pos共识算法进行挖矿</div><div class=\"line\">func CreateNewBlock(lastBlock *Block, data string) Block&#123;</div><div class=\"line\"></div><div class=\"line\">\tvar newBlock Block</div><div class=\"line\">\tnewBlock.Index = lastBlock.Index + 1</div><div class=\"line\">\tnewBlock.Timestamp = time.Now().String()</div><div class=\"line\">\tnewBlock.PreHash = lastBlock.Hash</div><div class=\"line\">\tnewBlock.Data = data</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//通过pos计算由那个村民挖矿</div><div class=\"line\">\t//设置随机种子</div><div class=\"line\">\trand.Seed(time.Now().Unix())</div><div class=\"line\">\t//[0,15)产生0-15的随机值</div><div class=\"line\">\tvar rd =rand.Intn(15)</div><div class=\"line\"></div><div class=\"line\">\t//选出挖矿的旷工</div><div class=\"line\">\tnode := addr[rd]</div><div class=\"line\">\t//设置当前区块挖矿地址为旷工</div><div class=\"line\">\tnewBlock.Validator = node</div><div class=\"line\">\t//简单模拟 挖矿所得奖励</div><div class=\"line\">\tnode.Tokens += 1</div><div class=\"line\">\tnewBlock.Hash = hex.EncodeToString(BlockHash(&amp;newBlock))</div><div class=\"line\">\treturn newBlock</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tInitNodes()</div><div class=\"line\"></div><div class=\"line\">\t//创建创世区块</div><div class=\"line\">\tvar genesisBlock = genesisBlock()</div><div class=\"line\"></div><div class=\"line\">\t//创建新区快</div><div class=\"line\">\tvar newBlock = CreateNewBlock(&amp;genesisBlock, &quot;new block&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//打印新区快信息</div><div class=\"line\">\tfmt.Println(newBlock)</div><div class=\"line\">\tfmt.Println(newBlock.Validator.Address)</div><div class=\"line\">\tfmt.Println(newBlock.Validator.Tokens)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;1 new block 72e8838ad3bb761c7d3ba42c4e6bad86409dd3f4ce958c890409c4b9ddf44171 e4f9575cfb14ee146810862c9e5cc78ebff185f5888f428dbb945bd9060b31f7 2018-06-29 19:29:04.827332898 +0800 CST m=+0.000837770 0xc42007e0a0&#125;</div><div class=\"line\">0x12341</div><div class=\"line\">2</div></pre></td></tr></table></figure></p>"},{"title":"共识算法DPOS原理及实现","date":"2018-06-29T11:31:58.000Z","_content":"\n## 原理简介\n\nDPOS：Delegated Proof of Stake，委任权益证明\n它的原理是让每一个持有币的人进行投票，由此产生n位代表 , 我们可以将其理解为n个超级节点或者矿池，而这n个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。EOS就是采用DPOS共识算法。\n\n## 算法具体实现原理\n\n假设n为21，竞选的节点有几百个，持币人对这些节点进行投票，选出票数最多的21位，由这21位轮流来出块。\n\n<!--more-->\n\n## 代码简单实现其原理\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n\t\"strconv\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n)\n\ntype Block struct {\n\tIndex int\n\tTimestamp string\n\tPrehash string\n\tHash string\n\tData []byte\n\n\tdelegate *Node// 代理 区块由哪个节点挖出\n}\n\n\nfunc GenesisBlock()  Block {\n\tgene := Block{0, time.Now().String(),\"\", \"\", []byte(\"genesis block\"), nil}\n\n\tgene.Hash = string(blockHash(gene))\n\n\treturn Block{}\n}\n\nfunc blockHash(block Block) []byte  {\n\n\trecord := strconv.Itoa(block.Index) + block.Timestamp + block.Prehash + hex.EncodeToString(block.Data)\n\n\th := sha256.New()\n\th.Write([]byte(record))\n\thashed := h.Sum(nil)\n\treturn hashed\n}\n\n\n//节点类型\ntype Node struct {\n\tName  string //节点名称\n\tVotes int    // 被选举的票数\n}\n\nfunc (node *Node)GenerateNewBlock(lastBlock Block, data []byte) Block  {\n\n\tvar newBlock = Block{lastBlock.Index+1, time.Now().String(), lastBlock.Hash, \"\", data, nil}\n\n\tnewBlock.Hash = hex.EncodeToString(blockHash(newBlock))\n\tnewBlock.delegate = node\n\treturn newBlock\n\n}\n\n//创建节点\nvar NodeArr = make([]Node,10)\nfunc CreateNode() {\n\n\tfor i := 0; i < 10; i++ {\n\t\tname := fmt.Sprintf(\"NODE %d num\", i+1)\n\t\tNodeArr[i] = Node{name, 0}\n\t}\n\n}\n\n//简单模拟投票\nfunc Vote()  {\n\tfor i := 0; i < 10; i++ {\n\t\trand.Seed(time.Now().UnixNano())\n\t\tvote := rand.Intn(10) + 1\n\t\tNodeArr[i].Votes = vote\n\t}\n}\n\n\n//选出票数最多的前3位\nfunc SortNodes() []Node  {\n\tn:= NodeArr\n\tfor i := 0; i<len(n) ;i++  {\n\t\tfor j := 0; j < len(n)-1 ;j++  {\n\t\t\tif n[j].Votes < n[j+1].Votes {\n\t\t\t\tn[j],n[j+1] = n[j+1],n[j]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n[:3]\n}\n\n\nfunc main() {\n\n\tCreateNode()\n\tfmt.Println(NodeArr)\n\tVote()\n\tnodes := SortNodes()\n\n\tfmt.Println(nodes)\n\n\n\t//创建创世区块\n\tgene := GenesisBlock()\n\n\tlastBlock := gene\n\tfor i:= 0; i< len(nodes) ;i++  {\n\t\tlastBlock =  nodes[i].GenerateNewBlock(lastBlock,[]byte(fmt.Sprintf(\"new block %d\",i)))\n\n\t}\n\n\n}\n\n```\n\n输出\n```\n竞选的节点 [{第 1 个节点 0} {第 2 个节点 0} {第 3 个节点 0} {第 4 个节点 0} {第 5 个节点 0} {第 6 个节点 0} {第 7 个节点 0} {第 8 个节点 0} {第 9 个节点 0} {第 10 个节点 0}]\n选出的节点 [{第 10 个节点 8} {第 4 个节点 7} {第 3 个节点 6}]\n第 10 个节点 出块 {1 2018-06-29 19:28:28.41834078 +0800 CST m=+0.000940357  0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 [110 101 119 32 98 108 111 99 107 32 48] 0xc420090000}\n第 4 个节点 出块 {2 2018-06-29 19:28:28.418365811 +0800 CST m=+0.000965387 0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 [110 101 119 32 98 108 111 99 107 32 49] 0xc420090018}\n第 3 个节点 出块 {3 2018-06-29 19:28:28.418395274 +0800 CST m=+0.000994849 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 86d8790c046523635a02f1316a4b85c27c7df3a762b8d7bc550bf5317adf8455 [110 101 119 32 98 108 111 99 107 32 50] 0xc420090030}\n\n```\n\n\n\n\n\n","source":"_posts/共识算法DPOS原理及实现.md","raw":"---\ntitle: 共识算法DPOS原理及实现\ncategories:\n  - 共识算法\ntags:\n  - DPOS\n  - 共识算法\ndate: 2018-06-29 19:31:58\n---\n\n## 原理简介\n\nDPOS：Delegated Proof of Stake，委任权益证明\n它的原理是让每一个持有币的人进行投票，由此产生n位代表 , 我们可以将其理解为n个超级节点或者矿池，而这n个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。EOS就是采用DPOS共识算法。\n\n## 算法具体实现原理\n\n假设n为21，竞选的节点有几百个，持币人对这些节点进行投票，选出票数最多的21位，由这21位轮流来出块。\n\n<!--more-->\n\n## 代码简单实现其原理\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n\t\"strconv\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n)\n\ntype Block struct {\n\tIndex int\n\tTimestamp string\n\tPrehash string\n\tHash string\n\tData []byte\n\n\tdelegate *Node// 代理 区块由哪个节点挖出\n}\n\n\nfunc GenesisBlock()  Block {\n\tgene := Block{0, time.Now().String(),\"\", \"\", []byte(\"genesis block\"), nil}\n\n\tgene.Hash = string(blockHash(gene))\n\n\treturn Block{}\n}\n\nfunc blockHash(block Block) []byte  {\n\n\trecord := strconv.Itoa(block.Index) + block.Timestamp + block.Prehash + hex.EncodeToString(block.Data)\n\n\th := sha256.New()\n\th.Write([]byte(record))\n\thashed := h.Sum(nil)\n\treturn hashed\n}\n\n\n//节点类型\ntype Node struct {\n\tName  string //节点名称\n\tVotes int    // 被选举的票数\n}\n\nfunc (node *Node)GenerateNewBlock(lastBlock Block, data []byte) Block  {\n\n\tvar newBlock = Block{lastBlock.Index+1, time.Now().String(), lastBlock.Hash, \"\", data, nil}\n\n\tnewBlock.Hash = hex.EncodeToString(blockHash(newBlock))\n\tnewBlock.delegate = node\n\treturn newBlock\n\n}\n\n//创建节点\nvar NodeArr = make([]Node,10)\nfunc CreateNode() {\n\n\tfor i := 0; i < 10; i++ {\n\t\tname := fmt.Sprintf(\"NODE %d num\", i+1)\n\t\tNodeArr[i] = Node{name, 0}\n\t}\n\n}\n\n//简单模拟投票\nfunc Vote()  {\n\tfor i := 0; i < 10; i++ {\n\t\trand.Seed(time.Now().UnixNano())\n\t\tvote := rand.Intn(10) + 1\n\t\tNodeArr[i].Votes = vote\n\t}\n}\n\n\n//选出票数最多的前3位\nfunc SortNodes() []Node  {\n\tn:= NodeArr\n\tfor i := 0; i<len(n) ;i++  {\n\t\tfor j := 0; j < len(n)-1 ;j++  {\n\t\t\tif n[j].Votes < n[j+1].Votes {\n\t\t\t\tn[j],n[j+1] = n[j+1],n[j]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n[:3]\n}\n\n\nfunc main() {\n\n\tCreateNode()\n\tfmt.Println(NodeArr)\n\tVote()\n\tnodes := SortNodes()\n\n\tfmt.Println(nodes)\n\n\n\t//创建创世区块\n\tgene := GenesisBlock()\n\n\tlastBlock := gene\n\tfor i:= 0; i< len(nodes) ;i++  {\n\t\tlastBlock =  nodes[i].GenerateNewBlock(lastBlock,[]byte(fmt.Sprintf(\"new block %d\",i)))\n\n\t}\n\n\n}\n\n```\n\n输出\n```\n竞选的节点 [{第 1 个节点 0} {第 2 个节点 0} {第 3 个节点 0} {第 4 个节点 0} {第 5 个节点 0} {第 6 个节点 0} {第 7 个节点 0} {第 8 个节点 0} {第 9 个节点 0} {第 10 个节点 0}]\n选出的节点 [{第 10 个节点 8} {第 4 个节点 7} {第 3 个节点 6}]\n第 10 个节点 出块 {1 2018-06-29 19:28:28.41834078 +0800 CST m=+0.000940357  0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 [110 101 119 32 98 108 111 99 107 32 48] 0xc420090000}\n第 4 个节点 出块 {2 2018-06-29 19:28:28.418365811 +0800 CST m=+0.000965387 0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 [110 101 119 32 98 108 111 99 107 32 49] 0xc420090018}\n第 3 个节点 出块 {3 2018-06-29 19:28:28.418395274 +0800 CST m=+0.000994849 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 86d8790c046523635a02f1316a4b85c27c7df3a762b8d7bc550bf5317adf8455 [110 101 119 32 98 108 111 99 107 32 50] 0xc420090030}\n\n```\n\n\n\n\n\n","slug":"共识算法DPOS原理及实现","published":1,"updated":"2018-06-29T11:34:46.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tf5002mlx606vyqnatm","content":"<h2 id=\"原理简介\"><a href=\"#原理简介\" class=\"headerlink\" title=\"原理简介\"></a>原理简介</h2><p>DPOS：Delegated Proof of Stake，委任权益证明<br>它的原理是让每一个持有币的人进行投票，由此产生n位代表 , 我们可以将其理解为n个超级节点或者矿池，而这n个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。EOS就是采用DPOS共识算法。</p>\n<h2 id=\"算法具体实现原理\"><a href=\"#算法具体实现原理\" class=\"headerlink\" title=\"算法具体实现原理\"></a>算法具体实现原理</h2><p>假设n为21，竞选的节点有几百个，持币人对这些节点进行投票，选出票数最多的21位，由这21位轮流来出块。</p>\n<a id=\"more\"></a>\n<h2 id=\"代码简单实现其原理\"><a href=\"#代码简单实现其原理\" class=\"headerlink\" title=\"代码简单实现其原理\"></a>代码简单实现其原理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;math/rand&quot;</div><div class=\"line\">\t&quot;time&quot;</div><div class=\"line\">\t&quot;strconv&quot;</div><div class=\"line\">\t&quot;crypto/sha256&quot;</div><div class=\"line\">\t&quot;encoding/hex&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">type Block struct &#123;</div><div class=\"line\">\tIndex int</div><div class=\"line\">\tTimestamp string</div><div class=\"line\">\tPrehash string</div><div class=\"line\">\tHash string</div><div class=\"line\">\tData []byte</div><div class=\"line\"></div><div class=\"line\">\tdelegate *Node// 代理 区块由哪个节点挖出</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func GenesisBlock()  Block &#123;</div><div class=\"line\">\tgene := Block&#123;0, time.Now().String(),&quot;&quot;, &quot;&quot;, []byte(&quot;genesis block&quot;), nil&#125;</div><div class=\"line\"></div><div class=\"line\">\tgene.Hash = string(blockHash(gene))</div><div class=\"line\"></div><div class=\"line\">\treturn Block&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func blockHash(block Block) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\trecord := strconv.Itoa(block.Index) + block.Timestamp + block.Prehash + hex.EncodeToString(block.Data)</div><div class=\"line\"></div><div class=\"line\">\th := sha256.New()</div><div class=\"line\">\th.Write([]byte(record))</div><div class=\"line\">\thashed := h.Sum(nil)</div><div class=\"line\">\treturn hashed</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//节点类型</div><div class=\"line\">type Node struct &#123;</div><div class=\"line\">\tName  string //节点名称</div><div class=\"line\">\tVotes int    // 被选举的票数</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (node *Node)GenerateNewBlock(lastBlock Block, data []byte) Block  &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar newBlock = Block&#123;lastBlock.Index+1, time.Now().String(), lastBlock.Hash, &quot;&quot;, data, nil&#125;</div><div class=\"line\"></div><div class=\"line\">\tnewBlock.Hash = hex.EncodeToString(blockHash(newBlock))</div><div class=\"line\">\tnewBlock.delegate = node</div><div class=\"line\">\treturn newBlock</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建节点</div><div class=\"line\">var NodeArr = make([]Node,10)</div><div class=\"line\">func CreateNode() &#123;</div><div class=\"line\"></div><div class=\"line\">\tfor i := 0; i &lt; 10; i++ &#123;</div><div class=\"line\">\t\tname := fmt.Sprintf(&quot;NODE %d num&quot;, i+1)</div><div class=\"line\">\t\tNodeArr[i] = Node&#123;name, 0&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//简单模拟投票</div><div class=\"line\">func Vote()  &#123;</div><div class=\"line\">\tfor i := 0; i &lt; 10; i++ &#123;</div><div class=\"line\">\t\trand.Seed(time.Now().UnixNano())</div><div class=\"line\">\t\tvote := rand.Intn(10) + 1</div><div class=\"line\">\t\tNodeArr[i].Votes = vote</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//选出票数最多的前3位</div><div class=\"line\">func SortNodes() []Node  &#123;</div><div class=\"line\">\tn:= NodeArr</div><div class=\"line\">\tfor i := 0; i&lt;len(n) ;i++  &#123;</div><div class=\"line\">\t\tfor j := 0; j &lt; len(n)-1 ;j++  &#123;</div><div class=\"line\">\t\t\tif n[j].Votes &lt; n[j+1].Votes &#123;</div><div class=\"line\">\t\t\t\tn[j],n[j+1] = n[j+1],n[j]</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\treturn n[:3]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func main() &#123;</div><div class=\"line\"></div><div class=\"line\">\tCreateNode()</div><div class=\"line\">\tfmt.Println(NodeArr)</div><div class=\"line\">\tVote()</div><div class=\"line\">\tnodes := SortNodes()</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(nodes)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//创建创世区块</div><div class=\"line\">\tgene := GenesisBlock()</div><div class=\"line\"></div><div class=\"line\">\tlastBlock := gene</div><div class=\"line\">\tfor i:= 0; i&lt; len(nodes) ;i++  &#123;</div><div class=\"line\">\t\tlastBlock =  nodes[i].GenerateNewBlock(lastBlock,[]byte(fmt.Sprintf(&quot;new block %d&quot;,i)))</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">竞选的节点 [&#123;第 1 个节点 0&#125; &#123;第 2 个节点 0&#125; &#123;第 3 个节点 0&#125; &#123;第 4 个节点 0&#125; &#123;第 5 个节点 0&#125; &#123;第 6 个节点 0&#125; &#123;第 7 个节点 0&#125; &#123;第 8 个节点 0&#125; &#123;第 9 个节点 0&#125; &#123;第 10 个节点 0&#125;]</div><div class=\"line\">选出的节点 [&#123;第 10 个节点 8&#125; &#123;第 4 个节点 7&#125; &#123;第 3 个节点 6&#125;]</div><div class=\"line\">第 10 个节点 出块 &#123;1 2018-06-29 19:28:28.41834078 +0800 CST m=+0.000940357  0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 [110 101 119 32 98 108 111 99 107 32 48] 0xc420090000&#125;</div><div class=\"line\">第 4 个节点 出块 &#123;2 2018-06-29 19:28:28.418365811 +0800 CST m=+0.000965387 0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 [110 101 119 32 98 108 111 99 107 32 49] 0xc420090018&#125;</div><div class=\"line\">第 3 个节点 出块 &#123;3 2018-06-29 19:28:28.418395274 +0800 CST m=+0.000994849 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 86d8790c046523635a02f1316a4b85c27c7df3a762b8d7bc550bf5317adf8455 [110 101 119 32 98 108 111 99 107 32 50] 0xc420090030&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"<h2 id=\"原理简介\"><a href=\"#原理简介\" class=\"headerlink\" title=\"原理简介\"></a>原理简介</h2><p>DPOS：Delegated Proof of Stake，委任权益证明<br>它的原理是让每一个持有币的人进行投票，由此产生n位代表 , 我们可以将其理解为n个超级节点或者矿池，而这n个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像是议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们时，没能生成区块），他们会被除名，网络会选出新的超级节点来取代他们。EOS就是采用DPOS共识算法。</p>\n<h2 id=\"算法具体实现原理\"><a href=\"#算法具体实现原理\" class=\"headerlink\" title=\"算法具体实现原理\"></a>算法具体实现原理</h2><p>假设n为21，竞选的节点有几百个，持币人对这些节点进行投票，选出票数最多的21位，由这21位轮流来出块。</p>","more":"<h2 id=\"代码简单实现其原理\"><a href=\"#代码简单实现其原理\" class=\"headerlink\" title=\"代码简单实现其原理\"></a>代码简单实现其原理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;math/rand&quot;</div><div class=\"line\">\t&quot;time&quot;</div><div class=\"line\">\t&quot;strconv&quot;</div><div class=\"line\">\t&quot;crypto/sha256&quot;</div><div class=\"line\">\t&quot;encoding/hex&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">type Block struct &#123;</div><div class=\"line\">\tIndex int</div><div class=\"line\">\tTimestamp string</div><div class=\"line\">\tPrehash string</div><div class=\"line\">\tHash string</div><div class=\"line\">\tData []byte</div><div class=\"line\"></div><div class=\"line\">\tdelegate *Node// 代理 区块由哪个节点挖出</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func GenesisBlock()  Block &#123;</div><div class=\"line\">\tgene := Block&#123;0, time.Now().String(),&quot;&quot;, &quot;&quot;, []byte(&quot;genesis block&quot;), nil&#125;</div><div class=\"line\"></div><div class=\"line\">\tgene.Hash = string(blockHash(gene))</div><div class=\"line\"></div><div class=\"line\">\treturn Block&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func blockHash(block Block) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\trecord := strconv.Itoa(block.Index) + block.Timestamp + block.Prehash + hex.EncodeToString(block.Data)</div><div class=\"line\"></div><div class=\"line\">\th := sha256.New()</div><div class=\"line\">\th.Write([]byte(record))</div><div class=\"line\">\thashed := h.Sum(nil)</div><div class=\"line\">\treturn hashed</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//节点类型</div><div class=\"line\">type Node struct &#123;</div><div class=\"line\">\tName  string //节点名称</div><div class=\"line\">\tVotes int    // 被选举的票数</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (node *Node)GenerateNewBlock(lastBlock Block, data []byte) Block  &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar newBlock = Block&#123;lastBlock.Index+1, time.Now().String(), lastBlock.Hash, &quot;&quot;, data, nil&#125;</div><div class=\"line\"></div><div class=\"line\">\tnewBlock.Hash = hex.EncodeToString(blockHash(newBlock))</div><div class=\"line\">\tnewBlock.delegate = node</div><div class=\"line\">\treturn newBlock</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建节点</div><div class=\"line\">var NodeArr = make([]Node,10)</div><div class=\"line\">func CreateNode() &#123;</div><div class=\"line\"></div><div class=\"line\">\tfor i := 0; i &lt; 10; i++ &#123;</div><div class=\"line\">\t\tname := fmt.Sprintf(&quot;NODE %d num&quot;, i+1)</div><div class=\"line\">\t\tNodeArr[i] = Node&#123;name, 0&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//简单模拟投票</div><div class=\"line\">func Vote()  &#123;</div><div class=\"line\">\tfor i := 0; i &lt; 10; i++ &#123;</div><div class=\"line\">\t\trand.Seed(time.Now().UnixNano())</div><div class=\"line\">\t\tvote := rand.Intn(10) + 1</div><div class=\"line\">\t\tNodeArr[i].Votes = vote</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//选出票数最多的前3位</div><div class=\"line\">func SortNodes() []Node  &#123;</div><div class=\"line\">\tn:= NodeArr</div><div class=\"line\">\tfor i := 0; i&lt;len(n) ;i++  &#123;</div><div class=\"line\">\t\tfor j := 0; j &lt; len(n)-1 ;j++  &#123;</div><div class=\"line\">\t\t\tif n[j].Votes &lt; n[j+1].Votes &#123;</div><div class=\"line\">\t\t\t\tn[j],n[j+1] = n[j+1],n[j]</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\treturn n[:3]</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func main() &#123;</div><div class=\"line\"></div><div class=\"line\">\tCreateNode()</div><div class=\"line\">\tfmt.Println(NodeArr)</div><div class=\"line\">\tVote()</div><div class=\"line\">\tnodes := SortNodes()</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(nodes)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//创建创世区块</div><div class=\"line\">\tgene := GenesisBlock()</div><div class=\"line\"></div><div class=\"line\">\tlastBlock := gene</div><div class=\"line\">\tfor i:= 0; i&lt; len(nodes) ;i++  &#123;</div><div class=\"line\">\t\tlastBlock =  nodes[i].GenerateNewBlock(lastBlock,[]byte(fmt.Sprintf(&quot;new block %d&quot;,i)))</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">竞选的节点 [&#123;第 1 个节点 0&#125; &#123;第 2 个节点 0&#125; &#123;第 3 个节点 0&#125; &#123;第 4 个节点 0&#125; &#123;第 5 个节点 0&#125; &#123;第 6 个节点 0&#125; &#123;第 7 个节点 0&#125; &#123;第 8 个节点 0&#125; &#123;第 9 个节点 0&#125; &#123;第 10 个节点 0&#125;]</div><div class=\"line\">选出的节点 [&#123;第 10 个节点 8&#125; &#123;第 4 个节点 7&#125; &#123;第 3 个节点 6&#125;]</div><div class=\"line\">第 10 个节点 出块 &#123;1 2018-06-29 19:28:28.41834078 +0800 CST m=+0.000940357  0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 [110 101 119 32 98 108 111 99 107 32 48] 0xc420090000&#125;</div><div class=\"line\">第 4 个节点 出块 &#123;2 2018-06-29 19:28:28.418365811 +0800 CST m=+0.000965387 0c142d83bf773e248c3438dd99423f6b289d171696b5e24573e06e2c4c445161 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 [110 101 119 32 98 108 111 99 107 32 49] 0xc420090018&#125;</div><div class=\"line\">第 3 个节点 出块 &#123;3 2018-06-29 19:28:28.418395274 +0800 CST m=+0.000994849 439cbbac2d6a8b476b7dbffd788c0f8019b55d65c6c075eb32ce4060e3a2cd63 86d8790c046523635a02f1316a4b85c27c7df3a762b8d7bc550bf5317adf8455 [110 101 119 32 98 108 111 99 107 32 50] 0xc420090030&#125;</div></pre></td></tr></table></figure></p>"},{"title":"共识算法POW原理及实现","date":"2018-06-29T11:31:22.000Z","_content":"\n## POW简介\n\nProof of Work，工作证明。\nPOW共识算法主要是通过计算难度值来决定谁来出块。POW的工作量是指方程式求解，谁先解出来，谁就有权利出块。方程式是通过前一个区块的哈希值和随机值nonce来计算下一个区块的哈希值，谁先找到nonce，谁就能最先计算出下一个区块的哈希值，这种方式之所以被称为计算难度值是因为方程式没有固定解法，只能不断的尝试，这种解方程式的方式称为哈希碰撞，是概率事件，碰撞的次数越多，方程式求解的难度就会越大。比特币就是采用POW共识算法\n\n## 算法具体实现原理\n\n这里涉及到两个重要的概念，一个是难度系数，一个是nonce，nonce可以理解为一个随机数，就是挖矿中要找到一个符合条件的nonce值。\n这里假设难度系数是4(比特币初始难度系数就是4)，将一个区块中的数据加上nonce值打包，nonce值从0开始一直递增，将这打包的数据计算hash值，hash满足最前面有4个0，就是挖矿成功。难度系数为多少，hash最前面就需要满足多少个0。\n\n<!--more-->\n\n## 代码简单实现其原理\n\n```\npackage main\n\nimport (\n\t\"strconv\"\n\t\"time\"\n\t\"crypto/sha256\"\n\t\"strings\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\n//pow 挖矿算法\n\n//定义难度系数\nconst difiiculty = 4\n\ntype Block struct {\n\tIndex      int // 区块高度\n\tTimeStamp  int64\n\tData       string //交易记录\n\tHash       string\n\tPrehash    string\n\tNonce      int\n\tDifficulty int //难度系数\n}\n\n//创建区块链\nvar BlockChain []Block\n\n//创世区块\nfunc GenesisBlock() *Block {\n\n\tvar geneBlock = Block{0, time.Now().Unix(), \"\", \"\", \"\", 0, difiiculty}\n\tgeneBlock.Hash = hex.EncodeToString(BlockHash(geneBlock))\n\n\treturn &geneBlock\n\n}\n\n\n\nfunc BlockHash(block Block) []byte {\n\tre := strconv.Itoa(block.Index) + strconv.Itoa(int(block.TimeStamp)) + block.Data + block.Prehash +\n\t\tstrconv.Itoa(block.Nonce) + strconv.Itoa(block.Difficulty)\n\n\th := sha256.New()\n\th.Write([]byte(re))\n\thashed := h.Sum(nil)\n\n\treturn hashed\n\n\n}\n\nfunc isBlockValid(block Block) bool  {\n\tprefix := strings.Repeat(\"0\", block.Difficulty)\n\treturn strings.HasPrefix(block.Hash, prefix)\n}\n\n//创建新区块 pow挖矿\nfunc CreateNewBlock(lastBlock *Block, data string) *Block {\n\tvar newBlock Block\n\tnewBlock.Index = lastBlock.Index + 1\n\tnewBlock.TimeStamp = time.Now().Unix()\n\tnewBlock.Data = data\n\tnewBlock.Prehash = lastBlock.Hash\n\tnewBlock.Difficulty = difiiculty\n\tnewBlock.Nonce = 0\n\t//开挖-当前区块的hash值的前面的0的个数与难度系数值相同\n\tfor {\n\t\t//计算hash\n\t\tcuhash := hex.EncodeToString(BlockHash(newBlock))\n\t\tfmt.Println(\"挖矿中\",cuhash)\n\t\tnewBlock.Hash = cuhash\n\t\tif isBlockValid(newBlock) {\n\n\t\t\t//校验区块\n\t\t\tif VerflyBlock(newBlock, *lastBlock) {\n\t\t\t\tfmt.Println(\"挖矿成功\")\n\t\t\t\treturn  &newBlock\n\t\t\t}\n\t\t}\n\t\t\n\t\tnewBlock.Nonce ++\n\n\t}\n}\n\n\n//校验新的区块是否合法\nfunc VerflyBlock(newblock Block, lastBlock Block) bool  {\n\tif lastBlock.Index +1 !=newblock.Index {\n\t\treturn false\n\t}\n\tif newblock.Prehash !=lastBlock.Hash {\n\t\treturn false\n\t}\n\treturn true\n\n}\n\nfunc main()  {\n\n\tvar genBlock = GenesisBlock()\n\t\n\tnewBlock := CreateNewBlock(genBlock,\"新区块\")\n\tfmt.Println(newBlock)\n\n}\n```\n\n输出\n\n```\n挖矿中 ac6665903c0cd2f000e17483fbcf6e3e8fa365de2b55663e7c94167f816d1489\n挖矿中 a46e18c7938ccb2d0554232f94c6e8db933fae509adafd4091f5f0b51951e6ae\n挖矿中 3738b5eb5f8f956974fc767058a6d7c94da0fc406e86df2d508b9b87fc109171\n挖矿中 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811\n挖矿成功\n&{1 1530267247 新区块 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811 a8df431924b17633bdf0303763661aa7a41c2608cd99f6527542e1326c718152 12167 4}\n```\n\n\n\n\n","source":"_posts/共识算法POW原理及实现.md","raw":"---\ntitle: 共识算法POW原理及实现\ncategories:\n  - 共识算法\ntags:\n  - POW\n  - 共识算法\ndate: 2018-06-29 19:31:22\n---\n\n## POW简介\n\nProof of Work，工作证明。\nPOW共识算法主要是通过计算难度值来决定谁来出块。POW的工作量是指方程式求解，谁先解出来，谁就有权利出块。方程式是通过前一个区块的哈希值和随机值nonce来计算下一个区块的哈希值，谁先找到nonce，谁就能最先计算出下一个区块的哈希值，这种方式之所以被称为计算难度值是因为方程式没有固定解法，只能不断的尝试，这种解方程式的方式称为哈希碰撞，是概率事件，碰撞的次数越多，方程式求解的难度就会越大。比特币就是采用POW共识算法\n\n## 算法具体实现原理\n\n这里涉及到两个重要的概念，一个是难度系数，一个是nonce，nonce可以理解为一个随机数，就是挖矿中要找到一个符合条件的nonce值。\n这里假设难度系数是4(比特币初始难度系数就是4)，将一个区块中的数据加上nonce值打包，nonce值从0开始一直递增，将这打包的数据计算hash值，hash满足最前面有4个0，就是挖矿成功。难度系数为多少，hash最前面就需要满足多少个0。\n\n<!--more-->\n\n## 代码简单实现其原理\n\n```\npackage main\n\nimport (\n\t\"strconv\"\n\t\"time\"\n\t\"crypto/sha256\"\n\t\"strings\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\n//pow 挖矿算法\n\n//定义难度系数\nconst difiiculty = 4\n\ntype Block struct {\n\tIndex      int // 区块高度\n\tTimeStamp  int64\n\tData       string //交易记录\n\tHash       string\n\tPrehash    string\n\tNonce      int\n\tDifficulty int //难度系数\n}\n\n//创建区块链\nvar BlockChain []Block\n\n//创世区块\nfunc GenesisBlock() *Block {\n\n\tvar geneBlock = Block{0, time.Now().Unix(), \"\", \"\", \"\", 0, difiiculty}\n\tgeneBlock.Hash = hex.EncodeToString(BlockHash(geneBlock))\n\n\treturn &geneBlock\n\n}\n\n\n\nfunc BlockHash(block Block) []byte {\n\tre := strconv.Itoa(block.Index) + strconv.Itoa(int(block.TimeStamp)) + block.Data + block.Prehash +\n\t\tstrconv.Itoa(block.Nonce) + strconv.Itoa(block.Difficulty)\n\n\th := sha256.New()\n\th.Write([]byte(re))\n\thashed := h.Sum(nil)\n\n\treturn hashed\n\n\n}\n\nfunc isBlockValid(block Block) bool  {\n\tprefix := strings.Repeat(\"0\", block.Difficulty)\n\treturn strings.HasPrefix(block.Hash, prefix)\n}\n\n//创建新区块 pow挖矿\nfunc CreateNewBlock(lastBlock *Block, data string) *Block {\n\tvar newBlock Block\n\tnewBlock.Index = lastBlock.Index + 1\n\tnewBlock.TimeStamp = time.Now().Unix()\n\tnewBlock.Data = data\n\tnewBlock.Prehash = lastBlock.Hash\n\tnewBlock.Difficulty = difiiculty\n\tnewBlock.Nonce = 0\n\t//开挖-当前区块的hash值的前面的0的个数与难度系数值相同\n\tfor {\n\t\t//计算hash\n\t\tcuhash := hex.EncodeToString(BlockHash(newBlock))\n\t\tfmt.Println(\"挖矿中\",cuhash)\n\t\tnewBlock.Hash = cuhash\n\t\tif isBlockValid(newBlock) {\n\n\t\t\t//校验区块\n\t\t\tif VerflyBlock(newBlock, *lastBlock) {\n\t\t\t\tfmt.Println(\"挖矿成功\")\n\t\t\t\treturn  &newBlock\n\t\t\t}\n\t\t}\n\t\t\n\t\tnewBlock.Nonce ++\n\n\t}\n}\n\n\n//校验新的区块是否合法\nfunc VerflyBlock(newblock Block, lastBlock Block) bool  {\n\tif lastBlock.Index +1 !=newblock.Index {\n\t\treturn false\n\t}\n\tif newblock.Prehash !=lastBlock.Hash {\n\t\treturn false\n\t}\n\treturn true\n\n}\n\nfunc main()  {\n\n\tvar genBlock = GenesisBlock()\n\t\n\tnewBlock := CreateNewBlock(genBlock,\"新区块\")\n\tfmt.Println(newBlock)\n\n}\n```\n\n输出\n\n```\n挖矿中 ac6665903c0cd2f000e17483fbcf6e3e8fa365de2b55663e7c94167f816d1489\n挖矿中 a46e18c7938ccb2d0554232f94c6e8db933fae509adafd4091f5f0b51951e6ae\n挖矿中 3738b5eb5f8f956974fc767058a6d7c94da0fc406e86df2d508b9b87fc109171\n挖矿中 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811\n挖矿成功\n&{1 1530267247 新区块 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811 a8df431924b17633bdf0303763661aa7a41c2608cd99f6527542e1326c718152 12167 4}\n```\n\n\n\n\n","slug":"共识算法POW原理及实现","published":1,"updated":"2018-06-29T11:33:06.997Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tf8002rlx60z85g2khg","content":"<h2 id=\"POW简介\"><a href=\"#POW简介\" class=\"headerlink\" title=\"POW简介\"></a>POW简介</h2><p>Proof of Work，工作证明。<br>POW共识算法主要是通过计算难度值来决定谁来出块。POW的工作量是指方程式求解，谁先解出来，谁就有权利出块。方程式是通过前一个区块的哈希值和随机值nonce来计算下一个区块的哈希值，谁先找到nonce，谁就能最先计算出下一个区块的哈希值，这种方式之所以被称为计算难度值是因为方程式没有固定解法，只能不断的尝试，这种解方程式的方式称为哈希碰撞，是概率事件，碰撞的次数越多，方程式求解的难度就会越大。比特币就是采用POW共识算法</p>\n<h2 id=\"算法具体实现原理\"><a href=\"#算法具体实现原理\" class=\"headerlink\" title=\"算法具体实现原理\"></a>算法具体实现原理</h2><p>这里涉及到两个重要的概念，一个是难度系数，一个是nonce，nonce可以理解为一个随机数，就是挖矿中要找到一个符合条件的nonce值。<br>这里假设难度系数是4(比特币初始难度系数就是4)，将一个区块中的数据加上nonce值打包，nonce值从0开始一直递增，将这打包的数据计算hash值，hash满足最前面有4个0，就是挖矿成功。难度系数为多少，hash最前面就需要满足多少个0。</p>\n<a id=\"more\"></a>\n<h2 id=\"代码简单实现其原理\"><a href=\"#代码简单实现其原理\" class=\"headerlink\" title=\"代码简单实现其原理\"></a>代码简单实现其原理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;strconv&quot;</div><div class=\"line\">\t&quot;time&quot;</div><div class=\"line\">\t&quot;crypto/sha256&quot;</div><div class=\"line\">\t&quot;strings&quot;</div><div class=\"line\">\t&quot;encoding/hex&quot;</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">//pow 挖矿算法</div><div class=\"line\"></div><div class=\"line\">//定义难度系数</div><div class=\"line\">const difiiculty = 4</div><div class=\"line\"></div><div class=\"line\">type Block struct &#123;</div><div class=\"line\">\tIndex      int // 区块高度</div><div class=\"line\">\tTimeStamp  int64</div><div class=\"line\">\tData       string //交易记录</div><div class=\"line\">\tHash       string</div><div class=\"line\">\tPrehash    string</div><div class=\"line\">\tNonce      int</div><div class=\"line\">\tDifficulty int //难度系数</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建区块链</div><div class=\"line\">var BlockChain []Block</div><div class=\"line\"></div><div class=\"line\">//创世区块</div><div class=\"line\">func GenesisBlock() *Block &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar geneBlock = Block&#123;0, time.Now().Unix(), &quot;&quot;, &quot;&quot;, &quot;&quot;, 0, difiiculty&#125;</div><div class=\"line\">\tgeneBlock.Hash = hex.EncodeToString(BlockHash(geneBlock))</div><div class=\"line\"></div><div class=\"line\">\treturn &amp;geneBlock</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func BlockHash(block Block) []byte &#123;</div><div class=\"line\">\tre := strconv.Itoa(block.Index) + strconv.Itoa(int(block.TimeStamp)) + block.Data + block.Prehash +</div><div class=\"line\">\t\tstrconv.Itoa(block.Nonce) + strconv.Itoa(block.Difficulty)</div><div class=\"line\"></div><div class=\"line\">\th := sha256.New()</div><div class=\"line\">\th.Write([]byte(re))</div><div class=\"line\">\thashed := h.Sum(nil)</div><div class=\"line\"></div><div class=\"line\">\treturn hashed</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func isBlockValid(block Block) bool  &#123;</div><div class=\"line\">\tprefix := strings.Repeat(&quot;0&quot;, block.Difficulty)</div><div class=\"line\">\treturn strings.HasPrefix(block.Hash, prefix)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建新区块 pow挖矿</div><div class=\"line\">func CreateNewBlock(lastBlock *Block, data string) *Block &#123;</div><div class=\"line\">\tvar newBlock Block</div><div class=\"line\">\tnewBlock.Index = lastBlock.Index + 1</div><div class=\"line\">\tnewBlock.TimeStamp = time.Now().Unix()</div><div class=\"line\">\tnewBlock.Data = data</div><div class=\"line\">\tnewBlock.Prehash = lastBlock.Hash</div><div class=\"line\">\tnewBlock.Difficulty = difiiculty</div><div class=\"line\">\tnewBlock.Nonce = 0</div><div class=\"line\">\t//开挖-当前区块的hash值的前面的0的个数与难度系数值相同</div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\t//计算hash</div><div class=\"line\">\t\tcuhash := hex.EncodeToString(BlockHash(newBlock))</div><div class=\"line\">\t\tfmt.Println(&quot;挖矿中&quot;,cuhash)</div><div class=\"line\">\t\tnewBlock.Hash = cuhash</div><div class=\"line\">\t\tif isBlockValid(newBlock) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t//校验区块</div><div class=\"line\">\t\t\tif VerflyBlock(newBlock, *lastBlock) &#123;</div><div class=\"line\">\t\t\t\tfmt.Println(&quot;挖矿成功&quot;)</div><div class=\"line\">\t\t\t\treturn  &amp;newBlock</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tnewBlock.Nonce ++</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//校验新的区块是否合法</div><div class=\"line\">func VerflyBlock(newblock Block, lastBlock Block) bool  &#123;</div><div class=\"line\">\tif lastBlock.Index +1 !=newblock.Index &#123;</div><div class=\"line\">\t\treturn false</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif newblock.Prehash !=lastBlock.Hash &#123;</div><div class=\"line\">\t\treturn false</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn true</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar genBlock = GenesisBlock()</div><div class=\"line\">\t</div><div class=\"line\">\tnewBlock := CreateNewBlock(genBlock,&quot;新区块&quot;)</div><div class=\"line\">\tfmt.Println(newBlock)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">挖矿中 ac6665903c0cd2f000e17483fbcf6e3e8fa365de2b55663e7c94167f816d1489</div><div class=\"line\">挖矿中 a46e18c7938ccb2d0554232f94c6e8db933fae509adafd4091f5f0b51951e6ae</div><div class=\"line\">挖矿中 3738b5eb5f8f956974fc767058a6d7c94da0fc406e86df2d508b9b87fc109171</div><div class=\"line\">挖矿中 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811</div><div class=\"line\">挖矿成功</div><div class=\"line\">&amp;&#123;1 1530267247 新区块 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811 a8df431924b17633bdf0303763661aa7a41c2608cd99f6527542e1326c718152 12167 4&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<h2 id=\"POW简介\"><a href=\"#POW简介\" class=\"headerlink\" title=\"POW简介\"></a>POW简介</h2><p>Proof of Work，工作证明。<br>POW共识算法主要是通过计算难度值来决定谁来出块。POW的工作量是指方程式求解，谁先解出来，谁就有权利出块。方程式是通过前一个区块的哈希值和随机值nonce来计算下一个区块的哈希值，谁先找到nonce，谁就能最先计算出下一个区块的哈希值，这种方式之所以被称为计算难度值是因为方程式没有固定解法，只能不断的尝试，这种解方程式的方式称为哈希碰撞，是概率事件，碰撞的次数越多，方程式求解的难度就会越大。比特币就是采用POW共识算法</p>\n<h2 id=\"算法具体实现原理\"><a href=\"#算法具体实现原理\" class=\"headerlink\" title=\"算法具体实现原理\"></a>算法具体实现原理</h2><p>这里涉及到两个重要的概念，一个是难度系数，一个是nonce，nonce可以理解为一个随机数，就是挖矿中要找到一个符合条件的nonce值。<br>这里假设难度系数是4(比特币初始难度系数就是4)，将一个区块中的数据加上nonce值打包，nonce值从0开始一直递增，将这打包的数据计算hash值，hash满足最前面有4个0，就是挖矿成功。难度系数为多少，hash最前面就需要满足多少个0。</p>","more":"<h2 id=\"代码简单实现其原理\"><a href=\"#代码简单实现其原理\" class=\"headerlink\" title=\"代码简单实现其原理\"></a>代码简单实现其原理</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;strconv&quot;</div><div class=\"line\">\t&quot;time&quot;</div><div class=\"line\">\t&quot;crypto/sha256&quot;</div><div class=\"line\">\t&quot;strings&quot;</div><div class=\"line\">\t&quot;encoding/hex&quot;</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">//pow 挖矿算法</div><div class=\"line\"></div><div class=\"line\">//定义难度系数</div><div class=\"line\">const difiiculty = 4</div><div class=\"line\"></div><div class=\"line\">type Block struct &#123;</div><div class=\"line\">\tIndex      int // 区块高度</div><div class=\"line\">\tTimeStamp  int64</div><div class=\"line\">\tData       string //交易记录</div><div class=\"line\">\tHash       string</div><div class=\"line\">\tPrehash    string</div><div class=\"line\">\tNonce      int</div><div class=\"line\">\tDifficulty int //难度系数</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建区块链</div><div class=\"line\">var BlockChain []Block</div><div class=\"line\"></div><div class=\"line\">//创世区块</div><div class=\"line\">func GenesisBlock() *Block &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar geneBlock = Block&#123;0, time.Now().Unix(), &quot;&quot;, &quot;&quot;, &quot;&quot;, 0, difiiculty&#125;</div><div class=\"line\">\tgeneBlock.Hash = hex.EncodeToString(BlockHash(geneBlock))</div><div class=\"line\"></div><div class=\"line\">\treturn &amp;geneBlock</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func BlockHash(block Block) []byte &#123;</div><div class=\"line\">\tre := strconv.Itoa(block.Index) + strconv.Itoa(int(block.TimeStamp)) + block.Data + block.Prehash +</div><div class=\"line\">\t\tstrconv.Itoa(block.Nonce) + strconv.Itoa(block.Difficulty)</div><div class=\"line\"></div><div class=\"line\">\th := sha256.New()</div><div class=\"line\">\th.Write([]byte(re))</div><div class=\"line\">\thashed := h.Sum(nil)</div><div class=\"line\"></div><div class=\"line\">\treturn hashed</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func isBlockValid(block Block) bool  &#123;</div><div class=\"line\">\tprefix := strings.Repeat(&quot;0&quot;, block.Difficulty)</div><div class=\"line\">\treturn strings.HasPrefix(block.Hash, prefix)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//创建新区块 pow挖矿</div><div class=\"line\">func CreateNewBlock(lastBlock *Block, data string) *Block &#123;</div><div class=\"line\">\tvar newBlock Block</div><div class=\"line\">\tnewBlock.Index = lastBlock.Index + 1</div><div class=\"line\">\tnewBlock.TimeStamp = time.Now().Unix()</div><div class=\"line\">\tnewBlock.Data = data</div><div class=\"line\">\tnewBlock.Prehash = lastBlock.Hash</div><div class=\"line\">\tnewBlock.Difficulty = difiiculty</div><div class=\"line\">\tnewBlock.Nonce = 0</div><div class=\"line\">\t//开挖-当前区块的hash值的前面的0的个数与难度系数值相同</div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\t//计算hash</div><div class=\"line\">\t\tcuhash := hex.EncodeToString(BlockHash(newBlock))</div><div class=\"line\">\t\tfmt.Println(&quot;挖矿中&quot;,cuhash)</div><div class=\"line\">\t\tnewBlock.Hash = cuhash</div><div class=\"line\">\t\tif isBlockValid(newBlock) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t//校验区块</div><div class=\"line\">\t\t\tif VerflyBlock(newBlock, *lastBlock) &#123;</div><div class=\"line\">\t\t\t\tfmt.Println(&quot;挖矿成功&quot;)</div><div class=\"line\">\t\t\t\treturn  &amp;newBlock</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tnewBlock.Nonce ++</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//校验新的区块是否合法</div><div class=\"line\">func VerflyBlock(newblock Block, lastBlock Block) bool  &#123;</div><div class=\"line\">\tif lastBlock.Index +1 !=newblock.Index &#123;</div><div class=\"line\">\t\treturn false</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif newblock.Prehash !=lastBlock.Hash &#123;</div><div class=\"line\">\t\treturn false</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn true</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar genBlock = GenesisBlock()</div><div class=\"line\">\t</div><div class=\"line\">\tnewBlock := CreateNewBlock(genBlock,&quot;新区块&quot;)</div><div class=\"line\">\tfmt.Println(newBlock)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">挖矿中 ac6665903c0cd2f000e17483fbcf6e3e8fa365de2b55663e7c94167f816d1489</div><div class=\"line\">挖矿中 a46e18c7938ccb2d0554232f94c6e8db933fae509adafd4091f5f0b51951e6ae</div><div class=\"line\">挖矿中 3738b5eb5f8f956974fc767058a6d7c94da0fc406e86df2d508b9b87fc109171</div><div class=\"line\">挖矿中 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811</div><div class=\"line\">挖矿成功</div><div class=\"line\">&amp;&#123;1 1530267247 新区块 0000694b1acaec754175f0a49a1aa190e122b58e9f58125bd18ceec898f8d811 a8df431924b17633bdf0303763661aa7a41c2608cd99f6527542e1326c718152 12167 4&#125;</div></pre></td></tr></table></figure>"},{"title":"分布式Raft算法原理及实现","date":"2018-07-04T11:37:18.000Z","_content":"\n\n## Raft 状态\n\n一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效，每个节点处于以下三种状态之一：\n\n* `follower（跟随者）` ：所有结点都以 `follower` 的状态开始。如果没收到 `leader`消息则会变成 `candidate`状态。\n* `candidate（候选人）`：会向其他结点“拉选票”，如果得到大部分的票则成为`leader`。这个过程就叫做Leader选举(Leader Election)。\n* `leader（领导者）`：所有对系统的修改都会先经过`leader`。\n\n<!--more-->\n\n## Raft 一致性算法\n\nRaft通过选出一个leader来简化日志副本的管理，例如，日志项(log entry)只允许从leader流向follower。\n\n基于leader的方法，Raft算法可以分解成三个子问题：\n\n`Leader election` (领导选举)：原来的leader挂掉后，必须选出一个新的leader\n\n`Log replication` (日志复制)：leader从客户端接收日志，并复制到整个集群中\n\n`Safety` (安全性)：如果有任意的server将日志项回放到状态机中了，那么其他的server只会回放相同的日志项\n\n## Leader election (领导选举)\n\nRaft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是 `follower`(跟随者) 身份。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，然后他就会认为系统中没有可用的领导者然后开始进行选举以选出新的领导者。要开始一次选举过程，`follower` 会给当前term加1并且转换成`candidate`状态。\n\n然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人的状态维持直到发生以下任何一个条件发生的时候，\n\n* 他自己赢得了这次的选举\n    * 如果这个节点赢得了半数以上的vote就会成为leader，每个节点会按照first-come-first-served的原则进行投票，并且一个term中只能投给一个节点， 这样就保证了一个term最多有一个节点赢得半数以上的vote。\n    * 当一个节点赢得选举， 他会成为leader， 并且给所有节点发送这个信息， 这样所有节点都会回退成follower。\n    \n* 其他的服务器成为领导者\n   \n    如果在等待选举期间，candidate接收到其他server要成为leader的RPC，分两种情况处理：\n\n    * 如果leader的term大于或等于自身的term，那么改`candidate` 会转成`follower` 状态\n    * 如果leader的term小于自身的term，那么会拒绝该 `leader`，并继续保持`candidate` 状态\n* 一段时间之后没有任何一个获胜的人\n    \n    * 有可能，很多follower同时变成candidate，导致没有candidate能获得大多数的选举，从而导致无法选出主。当这个情况发生时，每个candidate会超时，然后重新发增加term，发起新一轮选举RPC。需要注意的是，如果没有特别处理，可能出导致无限地重复选主的情况。\n\n    * Raft采用随机定时器的方法来避免上述情况，每个candidate选择一个时间间隔内的随机值，例如150-300ms，采用这种机制，一般只有一个server会进入candidate状态，然后获得大多数server的选举，最后成为主。每个candidate在收到leader的心跳信息后会重启定时器，从而避免在leader正常工作时，会发生选举的情况。\n\n## Log replication (日志复制)\n\n当选出 `leader` 后，它会开始接受客户端请求，每个请求会带有一个指令，可以被回放到状态机中。`leader` 把指令追加成一个`log entry`，然后通过AppendEntries RPC并行的发送给其他的server，当改entry被多数派server复制后，`leader` 会把该entry回放到状态机中，然后把结果返回给客户端。\n\n当 `follower` 宕机或者运行较慢时，`leader` 会无限地重发AppendEntries给这些follower，直到所有的follower都复制了该log entry。\n\nraft的log replication保证以下性质(Log Matching Property)：\n\n* 如果两个log entry有相同的index和term，那么它们存储相同的指令\n\n* 如果两个log entry在两份不同的日志中，并且有相同的index和term，那么它们之前的log entry是完全相同的\n\n其中特性一通过以下保证：\n\n* leader在一个特定的term和index下，只会创建一个log entry\n* log entry不会改变它们在日志中的位置\n\n特性二通过以下保证：\n\n* AppendEntries会做log entry的一致性检查，当发送一个AppendEntriesRPC时，leader会带上需要复制的log entry前一个log entry的(index, iterm)\n\n如果follower没有发现与它一样的log entry，那么它会拒绝接受新的log entry 这样就能保证特性二得以满足。\n\n## 安全性\n\n### 选举限制\n\n在一些一致性算法中，即使一台server没有包含所有之前已提交的log entry，也能被选为主，这些算法需要把leader上缺失的日志从其他的server拷贝到leader上，这种方法会导致额外的复杂度。相对而言，raft使用一种更简单的方法，即它保证所有已提交的log entry都会在当前选举的leader上，因此，在raft算法中，日志只会从leader流向follower。\n\n为了实现上述目标，raft在选举中会保证，一个candidate只有得到大多数的server的选票之后，才能被选为主。得到大多数的选票表明，选举它的server中至少有一个server是拥有所有已经提交的log entry的，而leader的日志至少和follower的一样新，这样就保证了leader肯定有所有已提交的log entry。\n\n### 提交之前任期内的日志条目\n\n领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。下图展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。\n\n![](http://olgjbx93m.bkt.clouddn.com/20180123-10289.png)\n\n如上图的例子，图（c）就发生了一个log entry虽然已经复制到大多数的服务器，但是仍然有可能被覆盖掉的可能，如图（d），整个发生的时序如下：\n\n* 图a中，S1被选为主，然后复制到log index为2的log entry到S2上\n\n* 图b中，S1挂掉，然后S5获得了S3，S4和自身的选举，成为leader，然后，其从客户端收到了一个新的log entry(3)\n\n* 图c中，S5挂掉，S1重新正常工作，又被选为主，继续复制log entry(2)，在log entry(2)被提交前，S1又挂掉\n\n* 图d中，S5又重新被选为领导者，然后，会把term 3的log entry覆盖到其他log index为2的log entry\n\n为了上图描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。例如，图e中，如果S1在挂掉前把log entry(4)复制到了大多数的server后，就能保证之前的log entry（2）被提交了，之后S5也就不可能被选为领导者了。\n\n### 安全性论证\n\n以反证法来证明，假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。\n\n![](http://olgjbx93m.bkt.clouddn.com/20180123-23202.png)\n\n> 如果 S1 （任期 T 的领导者）提交了一条新的日志在它的任期里，然后 S5 在之后的任期 U 里被选举为领导人，然后至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。\n\n1. 在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。\n\n2. 领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人U 投票了，这个投票者是产生这个矛盾的关键。\n\n3. 这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。\n\n4. 投票者在给领导人 U 投票时依然保有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有和领导人冲突的时候才会删除条目。\n\n5. 投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。\n    * 首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。\n    \n    * 除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交当然日志，这里产生矛盾。\n\n6. 因此，假设不成立，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目\n\n### 跟随者和候选人崩溃\n\n跟随者或者候选人崩溃，会按如下处理：\n\n* 领导者会不断给它发送选举和追加日志的RPC，直到成功\n* 跟随者会忽略它已经处理过的追加日志的RPC\n\n###  时间和可用性\n\n领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：\n\n```\n广播时间（broadcastTime） << 选举超时时间（electionTimeout） << 平均故障间隔时间（MTBF）\n```\n\n* **广播时间**指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；\n\n* **选举超时时间**就是选举的超时时间限制\n\n* **平均故障间隔时间**就是对于一台服务器而言，两次故障之间的平均时间。\n\n选举超时时间要大于广播时间的原因是，防止跟随者因为还没收到领导者的心跳，而重新选主。\n\n选举超时时间要小于MTBF的原因是，防止选举时，能正常工作的server没有达到大多数。\n\n对于广播时间，一般在[0.5ms,20ms]之间，而平均故障间隔时间一般非常大，至少是按照月为单位。因此，一般选举超时时间一般选择范围为[10ms,500ms]。因此，当领导者挂掉后，能在较短时间内重新选主。\n\n## 动画演示 Raft\n\nhttp://thesecretlivesofdata.com/raft/\n\n## 代码实现\n\n实现效果：\n4个子节点投票，选出leader，投票停止，leader状态变为leader，子节点状态重置。leader向子节点发送心跳数据，表名自己活着。leader使用浏览器自定义给子节点发送数据。\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"flag\"\n\t\"net\"\n\t\"strconv\"\n\t\"time\"\n\t\"strings\"\n\t\"net/http\"\n\t\"math/rand\"\n)\n\nconst (\n\tLEADER = iota\n\tCANDIDATE\n\tFOLLOWER\n)\n\n//声明地址信息\ntype Addr struct {\n\tHost string  //ip\n\tPort int\n\tAddr string\n}\n\ntype RaftServer struct {\n\n\tVotes int //选票\n\tRole int // 角色 follower candidate leader\n\tNodes []Addr\n\tisElecting bool //判断当前节点是否处于选举中\n\tTimeout int //选举间隔时间（也叫超时时间）\n\tElecChan chan bool //通道信号\n\tHeartBeatChan chan bool  //leader 的心跳信号\n\tPort int //端口号\n\n\t//网页接收到的参数 由主节点向子节点传参\n\tCusMsg chan string\n\n\n}\n\nfunc (rs *RaftServer)changeRole(role int)  {\n\tswitch role {\n\tcase LEADER:\n\t\tfmt.Println(\"leader\")\n\tcase CANDIDATE:\n\t\tfmt.Println(\"candidate\")\n\tcase FOLLOWER:\n\t\tfmt.Println(\"follower\")\n\n\t}\n\trs.Role = role\n}\n\nfunc (rs *RaftServer)resetTimeout()  {\n\t//Raft系统一般为1500-3000毫秒选一次\n\trs.Timeout =  2000\n}\n\n//运行服务器\nfunc (rs *RaftServer)Run()  {\n\t//rs监听 是否有人 给我投票\n\tlisten , _ := net.Listen(\"tcp\", \":\"+strconv.Itoa(rs.Port))\n\n\tdefer listen.Close()\n\n\tgo rs.elect()\n\n\t//控制投票时间\n\tgo rs.electTimeDuration()\n\n\t//go rs.printRole()\n\n\t// 主节点发送心跳\n\tgo rs.sendHeartBeat()\n\t//\n\tgo rs.sendDataToOtherNodes()\n\n\t//监听http协议\n\tgo rs.setHttpServer()\n\n\tfor {\n\t\tconn,_ := listen.Accept()\n\t\tgo func(){\n\n\t\t\tfor {\n\t\t\t\tby := make([]byte, 1024)\n\t\t\t\tn,_:= conn.Read(by)\n\t\t\t\tfmt.Println(\"收到消息\", string(by[:n]))\n\n\t\t\t\tvalue := string(by[:n])\n\t\t\t\tv,_ := strconv.Atoi(value)\n\t\t\t\tif v == rs.Port {\n\t\t\t\t\trs.Votes++\n\t\t\t\t\tfmt.Println(\"当前票数：\", rs.Votes)\n\t\t\t\t\t// leader 选举成功\n\t\t\t\t\tif VoteSuccess(rs.Votes, 5) == true {\n\t\t\t\t\t\tfmt.Printf(\"我是 %v, 我被选举成leader\", rs.Port)\n\n\t\t\t\t\t\t//通知其他节点。停止选举\n\t\t\t\t\t\t//重置其他节点状态和票数\n\t\t\t\t\t\trs.VoteToOther(\"stopVote\")\n\t\t\t\t\t\trs.isElecting = false\n\t\t\t\t\t\t//改变当前节点状态\n\n\t\t\t\t\t\trs.changeRole(LEADER)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\t\t\t\t//收到leader发来的消息\n\t\t\t\tif strings.HasPrefix(string(by[:n]), \"stopVote\") {\n\t\t\t\t\t//停止给别人投票\n\t\t\t\t\trs.isElecting = false\n\t\t\t\t\t//回退自己的状态\n\t\t\t\t\trs.changeRole(FOLLOWER)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}()\n\t}\n\n}\n\nfunc VoteSuccess(vote int, target int) bool  {\n\tif vote >= target {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n//发送数据)\nfunc (rs *RaftServer)VoteToOther(data string)  {\n\tfor _,k := range rs.Nodes {\n\t\tif k.Port != rs.Port {\n\t\t\tif data == \"1234\" {\n\t\t\t\tfmt.Println(\"-------------\", k.Port)\n\t\t\t}\n\n\t\t\tlabel :conn,err := net.Dial(\"tcp\", \":\"+strconv.Itoa(k.Port))\n\t\t\tfor  {\n\t\t\t\tif err != nil {\n\t\t\t\t\ttime.Sleep(1*time.Second)\n\t\t\t\t\tgoto  label\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tconn.Write([]byte(data))\n\n\t\t}\n\t}\n}\n\n//给别人投票\nfunc (rs *RaftServer)elect()  {\n\n\tfor {\n\t\t//通过通道确定现在可以给别人投票\n\n\t\t<- rs.ElecChan\n\n\t\t//给其他节点投票，不能投给自己\n\t\tvote := getVoteNum()\n\n\t\trs.VoteToOther(strconv.Itoa(vote))\n\t\t// 设置选举状态\n\t\tif rs.Role != LEADER {\n\t\t\trs.changeRole(CANDIDATE)\n\t\t} else {\n\t\t\t//是leader的情况\n\t\t\treturn\n\t\t}\n\n\t}\n}\n\nfunc getVoteNum() int  {\n\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(4) + 5000\n}\n\n\nfunc (rs *RaftServer)electTimeDuration()  {\n\t//\n\tfmt.Println(\"+++\", rs.isElecting)\n\tfor {\n\t\tif rs.isElecting {\n\n\t\t\trs.ElecChan <- true\n\t\t\ttime.Sleep(time.Duration(rs.Timeout) * time.Millisecond)\n\n\t\t}\n\n\n\t}\n}\n\n//打印当前对象的角色\nfunc (rs *RaftServer)printRole()  {\n\tfor  {\n\t\ttime.Sleep(1 * time.Second)\n\t\tfmt.Println(rs.Port, \"状态为\", rs.Role, rs.isElecting)\n\t}\n}\n\n\nfunc main()  {\n\n\t//获取参数\n\t//运行  go run main.go -p 5000  (p 后面就是要启动的端口)\n\tport := flag.Int(\"p\",1234,\"port\")\n\tflag.Parse()\n\tfmt.Println(*port)\n\n\trs := RaftServer{}\n\trs.isElecting = true\n\trs.Votes = 0\n\trs.Role = FOLLOWER\n\t//控制是否开始投票\n\trs.ElecChan = make(chan bool)\n\trs.HeartBeatChan = make(chan bool)\n\trs.CusMsg = make(chan string)\n\trs.resetTimeout()\n\trs.Nodes = []Addr{\n\t\t{\"127.0.0.1\",5000,\"5000\"},\n\t\t{\"127.0.0.1\",5001,\"5001\"},\n\t\t{\"127.0.0.1\",5002,\"5002\"},\n\t\t{\"127.0.0.1\",5003,\"5003\"},\n\t}\n\trs.Port = *port\n\n\trs.Run()\n\n}\n//主节点发送心跳信号给其他节点\nfunc (rs *RaftServer)sendHeartBeat()  {\n\t// 每隔1s 发送一次心跳\n\tfor {\n\t\ttime.Sleep(1 * time.Second)\n\t\tif rs.Role == LEADER {\n\t\t\t//发送消息\n\t\t\trs.VoteToOther(\"heat beating\")\n\t\t}\n\t}\n}\n\n//通过leader 给其他所有子节点发送数据\nfunc (rs *RaftServer)sendDataToOtherNodes()  {\n\tfor {\n\t\tmsg :=<-rs.CusMsg\n\t\tif rs.Role == LEADER {\n\t\t\t//发送消息\n\t\t\trs.VoteToOther(msg)\n\n\t\t}\n\t}\n}\n\n//开启http服务器\nfunc (rs *RaftServer)setHttpServer()  {\n\n\thttp.HandleFunc(\"/req\", rs.request)\n\thttpPort := rs.Port + 10\n\tif err:=http.ListenAndServe(\":\"+strconv.Itoa(httpPort), nil); err == nil {\n\t\tfmt.Println(err)\n\t}\n\n}\n//leader向其他子节点发送数据\nfunc (rs *RaftServer)request(writer http.ResponseWriter, request *http.Request){\n\n\trequest.ParseForm()\n\tif len(request.Form[\"data\"][0]) > 0 {\n\t\twriter.Write([]byte(\"ok\"))\n\t\tfmt.Println(request.Form[\"data\"][0])\n\t\trs.CusMsg <- request.Form[\"data\"][0]\n\t}\n\n}\n\n```\n\n运行：\n开启4个终端 分别执行 \n\n* go run main.go -p 5000\n* go run main.go -p 5001\n* go run main.go -p 5002\n* go run main.go -p 5003\n\n如果5001成为了leader，在浏览器输入`http://127.0.0.1:5011/req?data=XXX`\nxxx就是leader向子节点发送的数据，浏览器的端口是终端的端口加上10，如果5000是leader，浏览器就是5010.\n\n\n\n","source":"_posts/分布式Raft算法原理及实现.md","raw":"---\ntitle: 分布式Raft算法原理及实现\ncategories:\n  - 区块链\ntags:\n  - 分布式\n  - Raft\ndate: 2018-07-04 19:37:18\n---\n\n\n## Raft 状态\n\n一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效，每个节点处于以下三种状态之一：\n\n* `follower（跟随者）` ：所有结点都以 `follower` 的状态开始。如果没收到 `leader`消息则会变成 `candidate`状态。\n* `candidate（候选人）`：会向其他结点“拉选票”，如果得到大部分的票则成为`leader`。这个过程就叫做Leader选举(Leader Election)。\n* `leader（领导者）`：所有对系统的修改都会先经过`leader`。\n\n<!--more-->\n\n## Raft 一致性算法\n\nRaft通过选出一个leader来简化日志副本的管理，例如，日志项(log entry)只允许从leader流向follower。\n\n基于leader的方法，Raft算法可以分解成三个子问题：\n\n`Leader election` (领导选举)：原来的leader挂掉后，必须选出一个新的leader\n\n`Log replication` (日志复制)：leader从客户端接收日志，并复制到整个集群中\n\n`Safety` (安全性)：如果有任意的server将日志项回放到状态机中了，那么其他的server只会回放相同的日志项\n\n## Leader election (领导选举)\n\nRaft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是 `follower`(跟随者) 身份。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，然后他就会认为系统中没有可用的领导者然后开始进行选举以选出新的领导者。要开始一次选举过程，`follower` 会给当前term加1并且转换成`candidate`状态。\n\n然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人的状态维持直到发生以下任何一个条件发生的时候，\n\n* 他自己赢得了这次的选举\n    * 如果这个节点赢得了半数以上的vote就会成为leader，每个节点会按照first-come-first-served的原则进行投票，并且一个term中只能投给一个节点， 这样就保证了一个term最多有一个节点赢得半数以上的vote。\n    * 当一个节点赢得选举， 他会成为leader， 并且给所有节点发送这个信息， 这样所有节点都会回退成follower。\n    \n* 其他的服务器成为领导者\n   \n    如果在等待选举期间，candidate接收到其他server要成为leader的RPC，分两种情况处理：\n\n    * 如果leader的term大于或等于自身的term，那么改`candidate` 会转成`follower` 状态\n    * 如果leader的term小于自身的term，那么会拒绝该 `leader`，并继续保持`candidate` 状态\n* 一段时间之后没有任何一个获胜的人\n    \n    * 有可能，很多follower同时变成candidate，导致没有candidate能获得大多数的选举，从而导致无法选出主。当这个情况发生时，每个candidate会超时，然后重新发增加term，发起新一轮选举RPC。需要注意的是，如果没有特别处理，可能出导致无限地重复选主的情况。\n\n    * Raft采用随机定时器的方法来避免上述情况，每个candidate选择一个时间间隔内的随机值，例如150-300ms，采用这种机制，一般只有一个server会进入candidate状态，然后获得大多数server的选举，最后成为主。每个candidate在收到leader的心跳信息后会重启定时器，从而避免在leader正常工作时，会发生选举的情况。\n\n## Log replication (日志复制)\n\n当选出 `leader` 后，它会开始接受客户端请求，每个请求会带有一个指令，可以被回放到状态机中。`leader` 把指令追加成一个`log entry`，然后通过AppendEntries RPC并行的发送给其他的server，当改entry被多数派server复制后，`leader` 会把该entry回放到状态机中，然后把结果返回给客户端。\n\n当 `follower` 宕机或者运行较慢时，`leader` 会无限地重发AppendEntries给这些follower，直到所有的follower都复制了该log entry。\n\nraft的log replication保证以下性质(Log Matching Property)：\n\n* 如果两个log entry有相同的index和term，那么它们存储相同的指令\n\n* 如果两个log entry在两份不同的日志中，并且有相同的index和term，那么它们之前的log entry是完全相同的\n\n其中特性一通过以下保证：\n\n* leader在一个特定的term和index下，只会创建一个log entry\n* log entry不会改变它们在日志中的位置\n\n特性二通过以下保证：\n\n* AppendEntries会做log entry的一致性检查，当发送一个AppendEntriesRPC时，leader会带上需要复制的log entry前一个log entry的(index, iterm)\n\n如果follower没有发现与它一样的log entry，那么它会拒绝接受新的log entry 这样就能保证特性二得以满足。\n\n## 安全性\n\n### 选举限制\n\n在一些一致性算法中，即使一台server没有包含所有之前已提交的log entry，也能被选为主，这些算法需要把leader上缺失的日志从其他的server拷贝到leader上，这种方法会导致额外的复杂度。相对而言，raft使用一种更简单的方法，即它保证所有已提交的log entry都会在当前选举的leader上，因此，在raft算法中，日志只会从leader流向follower。\n\n为了实现上述目标，raft在选举中会保证，一个candidate只有得到大多数的server的选票之后，才能被选为主。得到大多数的选票表明，选举它的server中至少有一个server是拥有所有已经提交的log entry的，而leader的日志至少和follower的一样新，这样就保证了leader肯定有所有已提交的log entry。\n\n### 提交之前任期内的日志条目\n\n领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。下图展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。\n\n![](http://olgjbx93m.bkt.clouddn.com/20180123-10289.png)\n\n如上图的例子，图（c）就发生了一个log entry虽然已经复制到大多数的服务器，但是仍然有可能被覆盖掉的可能，如图（d），整个发生的时序如下：\n\n* 图a中，S1被选为主，然后复制到log index为2的log entry到S2上\n\n* 图b中，S1挂掉，然后S5获得了S3，S4和自身的选举，成为leader，然后，其从客户端收到了一个新的log entry(3)\n\n* 图c中，S5挂掉，S1重新正常工作，又被选为主，继续复制log entry(2)，在log entry(2)被提交前，S1又挂掉\n\n* 图d中，S5又重新被选为领导者，然后，会把term 3的log entry覆盖到其他log index为2的log entry\n\n为了上图描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。例如，图e中，如果S1在挂掉前把log entry(4)复制到了大多数的server后，就能保证之前的log entry（2）被提交了，之后S5也就不可能被选为领导者了。\n\n### 安全性论证\n\n以反证法来证明，假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。\n\n![](http://olgjbx93m.bkt.clouddn.com/20180123-23202.png)\n\n> 如果 S1 （任期 T 的领导者）提交了一条新的日志在它的任期里，然后 S5 在之后的任期 U 里被选举为领导人，然后至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。\n\n1. 在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。\n\n2. 领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人U 投票了，这个投票者是产生这个矛盾的关键。\n\n3. 这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。\n\n4. 投票者在给领导人 U 投票时依然保有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有和领导人冲突的时候才会删除条目。\n\n5. 投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。\n    * 首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。\n    \n    * 除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交当然日志，这里产生矛盾。\n\n6. 因此，假设不成立，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目\n\n### 跟随者和候选人崩溃\n\n跟随者或者候选人崩溃，会按如下处理：\n\n* 领导者会不断给它发送选举和追加日志的RPC，直到成功\n* 跟随者会忽略它已经处理过的追加日志的RPC\n\n###  时间和可用性\n\n领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：\n\n```\n广播时间（broadcastTime） << 选举超时时间（electionTimeout） << 平均故障间隔时间（MTBF）\n```\n\n* **广播时间**指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；\n\n* **选举超时时间**就是选举的超时时间限制\n\n* **平均故障间隔时间**就是对于一台服务器而言，两次故障之间的平均时间。\n\n选举超时时间要大于广播时间的原因是，防止跟随者因为还没收到领导者的心跳，而重新选主。\n\n选举超时时间要小于MTBF的原因是，防止选举时，能正常工作的server没有达到大多数。\n\n对于广播时间，一般在[0.5ms,20ms]之间，而平均故障间隔时间一般非常大，至少是按照月为单位。因此，一般选举超时时间一般选择范围为[10ms,500ms]。因此，当领导者挂掉后，能在较短时间内重新选主。\n\n## 动画演示 Raft\n\nhttp://thesecretlivesofdata.com/raft/\n\n## 代码实现\n\n实现效果：\n4个子节点投票，选出leader，投票停止，leader状态变为leader，子节点状态重置。leader向子节点发送心跳数据，表名自己活着。leader使用浏览器自定义给子节点发送数据。\n\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"flag\"\n\t\"net\"\n\t\"strconv\"\n\t\"time\"\n\t\"strings\"\n\t\"net/http\"\n\t\"math/rand\"\n)\n\nconst (\n\tLEADER = iota\n\tCANDIDATE\n\tFOLLOWER\n)\n\n//声明地址信息\ntype Addr struct {\n\tHost string  //ip\n\tPort int\n\tAddr string\n}\n\ntype RaftServer struct {\n\n\tVotes int //选票\n\tRole int // 角色 follower candidate leader\n\tNodes []Addr\n\tisElecting bool //判断当前节点是否处于选举中\n\tTimeout int //选举间隔时间（也叫超时时间）\n\tElecChan chan bool //通道信号\n\tHeartBeatChan chan bool  //leader 的心跳信号\n\tPort int //端口号\n\n\t//网页接收到的参数 由主节点向子节点传参\n\tCusMsg chan string\n\n\n}\n\nfunc (rs *RaftServer)changeRole(role int)  {\n\tswitch role {\n\tcase LEADER:\n\t\tfmt.Println(\"leader\")\n\tcase CANDIDATE:\n\t\tfmt.Println(\"candidate\")\n\tcase FOLLOWER:\n\t\tfmt.Println(\"follower\")\n\n\t}\n\trs.Role = role\n}\n\nfunc (rs *RaftServer)resetTimeout()  {\n\t//Raft系统一般为1500-3000毫秒选一次\n\trs.Timeout =  2000\n}\n\n//运行服务器\nfunc (rs *RaftServer)Run()  {\n\t//rs监听 是否有人 给我投票\n\tlisten , _ := net.Listen(\"tcp\", \":\"+strconv.Itoa(rs.Port))\n\n\tdefer listen.Close()\n\n\tgo rs.elect()\n\n\t//控制投票时间\n\tgo rs.electTimeDuration()\n\n\t//go rs.printRole()\n\n\t// 主节点发送心跳\n\tgo rs.sendHeartBeat()\n\t//\n\tgo rs.sendDataToOtherNodes()\n\n\t//监听http协议\n\tgo rs.setHttpServer()\n\n\tfor {\n\t\tconn,_ := listen.Accept()\n\t\tgo func(){\n\n\t\t\tfor {\n\t\t\t\tby := make([]byte, 1024)\n\t\t\t\tn,_:= conn.Read(by)\n\t\t\t\tfmt.Println(\"收到消息\", string(by[:n]))\n\n\t\t\t\tvalue := string(by[:n])\n\t\t\t\tv,_ := strconv.Atoi(value)\n\t\t\t\tif v == rs.Port {\n\t\t\t\t\trs.Votes++\n\t\t\t\t\tfmt.Println(\"当前票数：\", rs.Votes)\n\t\t\t\t\t// leader 选举成功\n\t\t\t\t\tif VoteSuccess(rs.Votes, 5) == true {\n\t\t\t\t\t\tfmt.Printf(\"我是 %v, 我被选举成leader\", rs.Port)\n\n\t\t\t\t\t\t//通知其他节点。停止选举\n\t\t\t\t\t\t//重置其他节点状态和票数\n\t\t\t\t\t\trs.VoteToOther(\"stopVote\")\n\t\t\t\t\t\trs.isElecting = false\n\t\t\t\t\t\t//改变当前节点状态\n\n\t\t\t\t\t\trs.changeRole(LEADER)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\t\t\t\t//收到leader发来的消息\n\t\t\t\tif strings.HasPrefix(string(by[:n]), \"stopVote\") {\n\t\t\t\t\t//停止给别人投票\n\t\t\t\t\trs.isElecting = false\n\t\t\t\t\t//回退自己的状态\n\t\t\t\t\trs.changeRole(FOLLOWER)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}()\n\t}\n\n}\n\nfunc VoteSuccess(vote int, target int) bool  {\n\tif vote >= target {\n\t\treturn true\n\t}\n\treturn false\n}\n\n\n//发送数据)\nfunc (rs *RaftServer)VoteToOther(data string)  {\n\tfor _,k := range rs.Nodes {\n\t\tif k.Port != rs.Port {\n\t\t\tif data == \"1234\" {\n\t\t\t\tfmt.Println(\"-------------\", k.Port)\n\t\t\t}\n\n\t\t\tlabel :conn,err := net.Dial(\"tcp\", \":\"+strconv.Itoa(k.Port))\n\t\t\tfor  {\n\t\t\t\tif err != nil {\n\t\t\t\t\ttime.Sleep(1*time.Second)\n\t\t\t\t\tgoto  label\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tconn.Write([]byte(data))\n\n\t\t}\n\t}\n}\n\n//给别人投票\nfunc (rs *RaftServer)elect()  {\n\n\tfor {\n\t\t//通过通道确定现在可以给别人投票\n\n\t\t<- rs.ElecChan\n\n\t\t//给其他节点投票，不能投给自己\n\t\tvote := getVoteNum()\n\n\t\trs.VoteToOther(strconv.Itoa(vote))\n\t\t// 设置选举状态\n\t\tif rs.Role != LEADER {\n\t\t\trs.changeRole(CANDIDATE)\n\t\t} else {\n\t\t\t//是leader的情况\n\t\t\treturn\n\t\t}\n\n\t}\n}\n\nfunc getVoteNum() int  {\n\n\trand.Seed(time.Now().UnixNano())\n\treturn rand.Intn(4) + 5000\n}\n\n\nfunc (rs *RaftServer)electTimeDuration()  {\n\t//\n\tfmt.Println(\"+++\", rs.isElecting)\n\tfor {\n\t\tif rs.isElecting {\n\n\t\t\trs.ElecChan <- true\n\t\t\ttime.Sleep(time.Duration(rs.Timeout) * time.Millisecond)\n\n\t\t}\n\n\n\t}\n}\n\n//打印当前对象的角色\nfunc (rs *RaftServer)printRole()  {\n\tfor  {\n\t\ttime.Sleep(1 * time.Second)\n\t\tfmt.Println(rs.Port, \"状态为\", rs.Role, rs.isElecting)\n\t}\n}\n\n\nfunc main()  {\n\n\t//获取参数\n\t//运行  go run main.go -p 5000  (p 后面就是要启动的端口)\n\tport := flag.Int(\"p\",1234,\"port\")\n\tflag.Parse()\n\tfmt.Println(*port)\n\n\trs := RaftServer{}\n\trs.isElecting = true\n\trs.Votes = 0\n\trs.Role = FOLLOWER\n\t//控制是否开始投票\n\trs.ElecChan = make(chan bool)\n\trs.HeartBeatChan = make(chan bool)\n\trs.CusMsg = make(chan string)\n\trs.resetTimeout()\n\trs.Nodes = []Addr{\n\t\t{\"127.0.0.1\",5000,\"5000\"},\n\t\t{\"127.0.0.1\",5001,\"5001\"},\n\t\t{\"127.0.0.1\",5002,\"5002\"},\n\t\t{\"127.0.0.1\",5003,\"5003\"},\n\t}\n\trs.Port = *port\n\n\trs.Run()\n\n}\n//主节点发送心跳信号给其他节点\nfunc (rs *RaftServer)sendHeartBeat()  {\n\t// 每隔1s 发送一次心跳\n\tfor {\n\t\ttime.Sleep(1 * time.Second)\n\t\tif rs.Role == LEADER {\n\t\t\t//发送消息\n\t\t\trs.VoteToOther(\"heat beating\")\n\t\t}\n\t}\n}\n\n//通过leader 给其他所有子节点发送数据\nfunc (rs *RaftServer)sendDataToOtherNodes()  {\n\tfor {\n\t\tmsg :=<-rs.CusMsg\n\t\tif rs.Role == LEADER {\n\t\t\t//发送消息\n\t\t\trs.VoteToOther(msg)\n\n\t\t}\n\t}\n}\n\n//开启http服务器\nfunc (rs *RaftServer)setHttpServer()  {\n\n\thttp.HandleFunc(\"/req\", rs.request)\n\thttpPort := rs.Port + 10\n\tif err:=http.ListenAndServe(\":\"+strconv.Itoa(httpPort), nil); err == nil {\n\t\tfmt.Println(err)\n\t}\n\n}\n//leader向其他子节点发送数据\nfunc (rs *RaftServer)request(writer http.ResponseWriter, request *http.Request){\n\n\trequest.ParseForm()\n\tif len(request.Form[\"data\"][0]) > 0 {\n\t\twriter.Write([]byte(\"ok\"))\n\t\tfmt.Println(request.Form[\"data\"][0])\n\t\trs.CusMsg <- request.Form[\"data\"][0]\n\t}\n\n}\n\n```\n\n运行：\n开启4个终端 分别执行 \n\n* go run main.go -p 5000\n* go run main.go -p 5001\n* go run main.go -p 5002\n* go run main.go -p 5003\n\n如果5001成为了leader，在浏览器输入`http://127.0.0.1:5011/req?data=XXX`\nxxx就是leader向子节点发送的数据，浏览器的端口是终端的端口加上10，如果5000是leader，浏览器就是5010.\n\n\n\n","slug":"分布式Raft算法原理及实现","published":1,"updated":"2018-07-04T11:38:04.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tf9002ulx60zgmxamyw","content":"<h2 id=\"Raft-状态\"><a href=\"#Raft-状态\" class=\"headerlink\" title=\"Raft 状态\"></a>Raft 状态</h2><p>一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效，每个节点处于以下三种状态之一：</p>\n<ul>\n<li><code>follower（跟随者）</code> ：所有结点都以 <code>follower</code> 的状态开始。如果没收到 <code>leader</code>消息则会变成 <code>candidate</code>状态。</li>\n<li><code>candidate（候选人）</code>：会向其他结点“拉选票”，如果得到大部分的票则成为<code>leader</code>。这个过程就叫做Leader选举(Leader Election)。</li>\n<li><code>leader（领导者）</code>：所有对系统的修改都会先经过<code>leader</code>。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"Raft-一致性算法\"><a href=\"#Raft-一致性算法\" class=\"headerlink\" title=\"Raft 一致性算法\"></a>Raft 一致性算法</h2><p>Raft通过选出一个leader来简化日志副本的管理，例如，日志项(log entry)只允许从leader流向follower。</p>\n<p>基于leader的方法，Raft算法可以分解成三个子问题：</p>\n<p><code>Leader election</code> (领导选举)：原来的leader挂掉后，必须选出一个新的leader</p>\n<p><code>Log replication</code> (日志复制)：leader从客户端接收日志，并复制到整个集群中</p>\n<p><code>Safety</code> (安全性)：如果有任意的server将日志项回放到状态机中了，那么其他的server只会回放相同的日志项</p>\n<h2 id=\"Leader-election-领导选举\"><a href=\"#Leader-election-领导选举\" class=\"headerlink\" title=\"Leader election (领导选举)\"></a>Leader election (领导选举)</h2><p>Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是 <code>follower</code>(跟随者) 身份。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，然后他就会认为系统中没有可用的领导者然后开始进行选举以选出新的领导者。要开始一次选举过程，<code>follower</code> 会给当前term加1并且转换成<code>candidate</code>状态。</p>\n<p>然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人的状态维持直到发生以下任何一个条件发生的时候，</p>\n<ul>\n<li><p>他自己赢得了这次的选举</p>\n<ul>\n<li>如果这个节点赢得了半数以上的vote就会成为leader，每个节点会按照first-come-first-served的原则进行投票，并且一个term中只能投给一个节点， 这样就保证了一个term最多有一个节点赢得半数以上的vote。</li>\n<li>当一个节点赢得选举， 他会成为leader， 并且给所有节点发送这个信息， 这样所有节点都会回退成follower。</li>\n</ul>\n</li>\n<li><p>其他的服务器成为领导者</p>\n<p>  如果在等待选举期间，candidate接收到其他server要成为leader的RPC，分两种情况处理：</p>\n<ul>\n<li>如果leader的term大于或等于自身的term，那么改<code>candidate</code> 会转成<code>follower</code> 状态</li>\n<li>如果leader的term小于自身的term，那么会拒绝该 <code>leader</code>，并继续保持<code>candidate</code> 状态</li>\n</ul>\n</li>\n<li><p>一段时间之后没有任何一个获胜的人</p>\n<ul>\n<li><p>有可能，很多follower同时变成candidate，导致没有candidate能获得大多数的选举，从而导致无法选出主。当这个情况发生时，每个candidate会超时，然后重新发增加term，发起新一轮选举RPC。需要注意的是，如果没有特别处理，可能出导致无限地重复选主的情况。</p>\n</li>\n<li><p>Raft采用随机定时器的方法来避免上述情况，每个candidate选择一个时间间隔内的随机值，例如150-300ms，采用这种机制，一般只有一个server会进入candidate状态，然后获得大多数server的选举，最后成为主。每个candidate在收到leader的心跳信息后会重启定时器，从而避免在leader正常工作时，会发生选举的情况。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Log-replication-日志复制\"><a href=\"#Log-replication-日志复制\" class=\"headerlink\" title=\"Log replication (日志复制)\"></a>Log replication (日志复制)</h2><p>当选出 <code>leader</code> 后，它会开始接受客户端请求，每个请求会带有一个指令，可以被回放到状态机中。<code>leader</code> 把指令追加成一个<code>log entry</code>，然后通过AppendEntries RPC并行的发送给其他的server，当改entry被多数派server复制后，<code>leader</code> 会把该entry回放到状态机中，然后把结果返回给客户端。</p>\n<p>当 <code>follower</code> 宕机或者运行较慢时，<code>leader</code> 会无限地重发AppendEntries给这些follower，直到所有的follower都复制了该log entry。</p>\n<p>raft的log replication保证以下性质(Log Matching Property)：</p>\n<ul>\n<li><p>如果两个log entry有相同的index和term，那么它们存储相同的指令</p>\n</li>\n<li><p>如果两个log entry在两份不同的日志中，并且有相同的index和term，那么它们之前的log entry是完全相同的</p>\n</li>\n</ul>\n<p>其中特性一通过以下保证：</p>\n<ul>\n<li>leader在一个特定的term和index下，只会创建一个log entry</li>\n<li>log entry不会改变它们在日志中的位置</li>\n</ul>\n<p>特性二通过以下保证：</p>\n<ul>\n<li>AppendEntries会做log entry的一致性检查，当发送一个AppendEntriesRPC时，leader会带上需要复制的log entry前一个log entry的(index, iterm)</li>\n</ul>\n<p>如果follower没有发现与它一样的log entry，那么它会拒绝接受新的log entry 这样就能保证特性二得以满足。</p>\n<h2 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h2><h3 id=\"选举限制\"><a href=\"#选举限制\" class=\"headerlink\" title=\"选举限制\"></a>选举限制</h3><p>在一些一致性算法中，即使一台server没有包含所有之前已提交的log entry，也能被选为主，这些算法需要把leader上缺失的日志从其他的server拷贝到leader上，这种方法会导致额外的复杂度。相对而言，raft使用一种更简单的方法，即它保证所有已提交的log entry都会在当前选举的leader上，因此，在raft算法中，日志只会从leader流向follower。</p>\n<p>为了实现上述目标，raft在选举中会保证，一个candidate只有得到大多数的server的选票之后，才能被选为主。得到大多数的选票表明，选举它的server中至少有一个server是拥有所有已经提交的log entry的，而leader的日志至少和follower的一样新，这样就保证了leader肯定有所有已提交的log entry。</p>\n<h3 id=\"提交之前任期内的日志条目\"><a href=\"#提交之前任期内的日志条目\" class=\"headerlink\" title=\"提交之前任期内的日志条目\"></a>提交之前任期内的日志条目</h3><p>领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。下图展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。</p>\n<p><img src=\"http://olgjbx93m.bkt.clouddn.com/20180123-10289.png\" alt=\"\"></p>\n<p>如上图的例子，图（c）就发生了一个log entry虽然已经复制到大多数的服务器，但是仍然有可能被覆盖掉的可能，如图（d），整个发生的时序如下：</p>\n<ul>\n<li><p>图a中，S1被选为主，然后复制到log index为2的log entry到S2上</p>\n</li>\n<li><p>图b中，S1挂掉，然后S5获得了S3，S4和自身的选举，成为leader，然后，其从客户端收到了一个新的log entry(3)</p>\n</li>\n<li><p>图c中，S5挂掉，S1重新正常工作，又被选为主，继续复制log entry(2)，在log entry(2)被提交前，S1又挂掉</p>\n</li>\n<li><p>图d中，S5又重新被选为领导者，然后，会把term 3的log entry覆盖到其他log index为2的log entry</p>\n</li>\n</ul>\n<p>为了上图描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。例如，图e中，如果S1在挂掉前把log entry(4)复制到了大多数的server后，就能保证之前的log entry（2）被提交了，之后S5也就不可能被选为领导者了。</p>\n<h3 id=\"安全性论证\"><a href=\"#安全性论证\" class=\"headerlink\" title=\"安全性论证\"></a>安全性论证</h3><p>以反证法来证明，假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。</p>\n<p><img src=\"http://olgjbx93m.bkt.clouddn.com/20180123-23202.png\" alt=\"\"></p>\n<blockquote>\n<p>如果 S1 （任期 T 的领导者）提交了一条新的日志在它的任期里，然后 S5 在之后的任期 U 里被选举为领导人，然后至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。</p>\n</blockquote>\n<ol>\n<li><p>在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。</p>\n</li>\n<li><p>领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人U 投票了，这个投票者是产生这个矛盾的关键。</p>\n</li>\n<li><p>这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。</p>\n</li>\n<li><p>投票者在给领导人 U 投票时依然保有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有和领导人冲突的时候才会删除条目。</p>\n</li>\n<li><p>投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。</p>\n<ul>\n<li><p>首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。</p>\n</li>\n<li><p>除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交当然日志，这里产生矛盾。</p>\n</li>\n</ul>\n</li>\n<li><p>因此，假设不成立，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目</p>\n</li>\n</ol>\n<h3 id=\"跟随者和候选人崩溃\"><a href=\"#跟随者和候选人崩溃\" class=\"headerlink\" title=\"跟随者和候选人崩溃\"></a>跟随者和候选人崩溃</h3><p>跟随者或者候选人崩溃，会按如下处理：</p>\n<ul>\n<li>领导者会不断给它发送选举和追加日志的RPC，直到成功</li>\n<li>跟随者会忽略它已经处理过的追加日志的RPC</li>\n</ul>\n<h3 id=\"时间和可用性\"><a href=\"#时间和可用性\" class=\"headerlink\" title=\"时间和可用性\"></a>时间和可用性</h3><p>领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</div></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>广播时间</strong>指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；</p>\n</li>\n<li><p><strong>选举超时时间</strong>就是选举的超时时间限制</p>\n</li>\n<li><p><strong>平均故障间隔时间</strong>就是对于一台服务器而言，两次故障之间的平均时间。</p>\n</li>\n</ul>\n<p>选举超时时间要大于广播时间的原因是，防止跟随者因为还没收到领导者的心跳，而重新选主。</p>\n<p>选举超时时间要小于MTBF的原因是，防止选举时，能正常工作的server没有达到大多数。</p>\n<p>对于广播时间，一般在[0.5ms,20ms]之间，而平均故障间隔时间一般非常大，至少是按照月为单位。因此，一般选举超时时间一般选择范围为[10ms,500ms]。因此，当领导者挂掉后，能在较短时间内重新选主。</p>\n<h2 id=\"动画演示-Raft\"><a href=\"#动画演示-Raft\" class=\"headerlink\" title=\"动画演示 Raft\"></a>动画演示 Raft</h2><p><a href=\"http://thesecretlivesofdata.com/raft/\" target=\"_blank\" rel=\"external\">http://thesecretlivesofdata.com/raft/</a></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>实现效果：<br>4个子节点投票，选出leader，投票停止，leader状态变为leader，子节点状态重置。leader向子节点发送心跳数据，表名自己活着。leader使用浏览器自定义给子节点发送数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;flag&quot;</div><div class=\"line\">\t&quot;net&quot;</div><div class=\"line\">\t&quot;strconv&quot;</div><div class=\"line\">\t&quot;time&quot;</div><div class=\"line\">\t&quot;strings&quot;</div><div class=\"line\">\t&quot;net/http&quot;</div><div class=\"line\">\t&quot;math/rand&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">const (</div><div class=\"line\">\tLEADER = iota</div><div class=\"line\">\tCANDIDATE</div><div class=\"line\">\tFOLLOWER</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">//声明地址信息</div><div class=\"line\">type Addr struct &#123;</div><div class=\"line\">\tHost string  //ip</div><div class=\"line\">\tPort int</div><div class=\"line\">\tAddr string</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">type RaftServer struct &#123;</div><div class=\"line\"></div><div class=\"line\">\tVotes int //选票</div><div class=\"line\">\tRole int // 角色 follower candidate leader</div><div class=\"line\">\tNodes []Addr</div><div class=\"line\">\tisElecting bool //判断当前节点是否处于选举中</div><div class=\"line\">\tTimeout int //选举间隔时间（也叫超时时间）</div><div class=\"line\">\tElecChan chan bool //通道信号</div><div class=\"line\">\tHeartBeatChan chan bool  //leader 的心跳信号</div><div class=\"line\">\tPort int //端口号</div><div class=\"line\"></div><div class=\"line\">\t//网页接收到的参数 由主节点向子节点传参</div><div class=\"line\">\tCusMsg chan string</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (rs *RaftServer)changeRole(role int)  &#123;</div><div class=\"line\">\tswitch role &#123;</div><div class=\"line\">\tcase LEADER:</div><div class=\"line\">\t\tfmt.Println(&quot;leader&quot;)</div><div class=\"line\">\tcase CANDIDATE:</div><div class=\"line\">\t\tfmt.Println(&quot;candidate&quot;)</div><div class=\"line\">\tcase FOLLOWER:</div><div class=\"line\">\t\tfmt.Println(&quot;follower&quot;)</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\trs.Role = role</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (rs *RaftServer)resetTimeout()  &#123;</div><div class=\"line\">\t//Raft系统一般为1500-3000毫秒选一次</div><div class=\"line\">\trs.Timeout =  2000</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//运行服务器</div><div class=\"line\">func (rs *RaftServer)Run()  &#123;</div><div class=\"line\">\t//rs监听 是否有人 给我投票</div><div class=\"line\">\tlisten , _ := net.Listen(&quot;tcp&quot;, &quot;:&quot;+strconv.Itoa(rs.Port))</div><div class=\"line\"></div><div class=\"line\">\tdefer listen.Close()</div><div class=\"line\"></div><div class=\"line\">\tgo rs.elect()</div><div class=\"line\"></div><div class=\"line\">\t//控制投票时间</div><div class=\"line\">\tgo rs.electTimeDuration()</div><div class=\"line\"></div><div class=\"line\">\t//go rs.printRole()</div><div class=\"line\"></div><div class=\"line\">\t// 主节点发送心跳</div><div class=\"line\">\tgo rs.sendHeartBeat()</div><div class=\"line\">\t//</div><div class=\"line\">\tgo rs.sendDataToOtherNodes()</div><div class=\"line\"></div><div class=\"line\">\t//监听http协议</div><div class=\"line\">\tgo rs.setHttpServer()</div><div class=\"line\"></div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\tconn,_ := listen.Accept()</div><div class=\"line\">\t\tgo func()&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tfor &#123;</div><div class=\"line\">\t\t\t\tby := make([]byte, 1024)</div><div class=\"line\">\t\t\t\tn,_:= conn.Read(by)</div><div class=\"line\">\t\t\t\tfmt.Println(&quot;收到消息&quot;, string(by[:n]))</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tvalue := string(by[:n])</div><div class=\"line\">\t\t\t\tv,_ := strconv.Atoi(value)</div><div class=\"line\">\t\t\t\tif v == rs.Port &#123;</div><div class=\"line\">\t\t\t\t\trs.Votes++</div><div class=\"line\">\t\t\t\t\tfmt.Println(&quot;当前票数：&quot;, rs.Votes)</div><div class=\"line\">\t\t\t\t\t// leader 选举成功</div><div class=\"line\">\t\t\t\t\tif VoteSuccess(rs.Votes, 5) == true &#123;</div><div class=\"line\">\t\t\t\t\t\tfmt.Printf(&quot;我是 %v, 我被选举成leader&quot;, rs.Port)</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\t//通知其他节点。停止选举</div><div class=\"line\">\t\t\t\t\t\t//重置其他节点状态和票数</div><div class=\"line\">\t\t\t\t\t\trs.VoteToOther(&quot;stopVote&quot;)</div><div class=\"line\">\t\t\t\t\t\trs.isElecting = false</div><div class=\"line\">\t\t\t\t\t\t//改变当前节点状态</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\trs.changeRole(LEADER)</div><div class=\"line\">\t\t\t\t\t\tbreak</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t\t\t\t//收到leader发来的消息</div><div class=\"line\">\t\t\t\tif strings.HasPrefix(string(by[:n]), &quot;stopVote&quot;) &#123;</div><div class=\"line\">\t\t\t\t\t//停止给别人投票</div><div class=\"line\">\t\t\t\t\trs.isElecting = false</div><div class=\"line\">\t\t\t\t\t//回退自己的状态</div><div class=\"line\">\t\t\t\t\trs.changeRole(FOLLOWER)</div><div class=\"line\">\t\t\t\t\tbreak</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;()</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func VoteSuccess(vote int, target int) bool  &#123;</div><div class=\"line\">\tif vote &gt;= target &#123;</div><div class=\"line\">\t\treturn true</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn false</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//发送数据)</div><div class=\"line\">func (rs *RaftServer)VoteToOther(data string)  &#123;</div><div class=\"line\">\tfor _,k := range rs.Nodes &#123;</div><div class=\"line\">\t\tif k.Port != rs.Port &#123;</div><div class=\"line\">\t\t\tif data == &quot;1234&quot; &#123;</div><div class=\"line\">\t\t\t\tfmt.Println(&quot;-------------&quot;, k.Port)</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tlabel :conn,err := net.Dial(&quot;tcp&quot;, &quot;:&quot;+strconv.Itoa(k.Port))</div><div class=\"line\">\t\t\tfor  &#123;</div><div class=\"line\">\t\t\t\tif err != nil &#123;</div><div class=\"line\">\t\t\t\t\ttime.Sleep(1*time.Second)</div><div class=\"line\">\t\t\t\t\tgoto  label</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tbreak</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tconn.Write([]byte(data))</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//给别人投票</div><div class=\"line\">func (rs *RaftServer)elect()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\t//通过通道确定现在可以给别人投票</div><div class=\"line\"></div><div class=\"line\">\t\t&lt;- rs.ElecChan</div><div class=\"line\"></div><div class=\"line\">\t\t//给其他节点投票，不能投给自己</div><div class=\"line\">\t\tvote := getVoteNum()</div><div class=\"line\"></div><div class=\"line\">\t\trs.VoteToOther(strconv.Itoa(vote))</div><div class=\"line\">\t\t// 设置选举状态</div><div class=\"line\">\t\tif rs.Role != LEADER &#123;</div><div class=\"line\">\t\t\trs.changeRole(CANDIDATE)</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t//是leader的情况</div><div class=\"line\">\t\t\treturn</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func getVoteNum() int  &#123;</div><div class=\"line\"></div><div class=\"line\">\trand.Seed(time.Now().UnixNano())</div><div class=\"line\">\treturn rand.Intn(4) + 5000</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func (rs *RaftServer)electTimeDuration()  &#123;</div><div class=\"line\">\t//</div><div class=\"line\">\tfmt.Println(&quot;+++&quot;, rs.isElecting)</div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\tif rs.isElecting &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\trs.ElecChan &lt;- true</div><div class=\"line\">\t\t\ttime.Sleep(time.Duration(rs.Timeout) * time.Millisecond)</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//打印当前对象的角色</div><div class=\"line\">func (rs *RaftServer)printRole()  &#123;</div><div class=\"line\">\tfor  &#123;</div><div class=\"line\">\t\ttime.Sleep(1 * time.Second)</div><div class=\"line\">\t\tfmt.Println(rs.Port, &quot;状态为&quot;, rs.Role, rs.isElecting)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//获取参数</div><div class=\"line\">\t//运行  go run main.go -p 5000  (p 后面就是要启动的端口)</div><div class=\"line\">\tport := flag.Int(&quot;p&quot;,1234,&quot;port&quot;)</div><div class=\"line\">\tflag.Parse()</div><div class=\"line\">\tfmt.Println(*port)</div><div class=\"line\"></div><div class=\"line\">\trs := RaftServer&#123;&#125;</div><div class=\"line\">\trs.isElecting = true</div><div class=\"line\">\trs.Votes = 0</div><div class=\"line\">\trs.Role = FOLLOWER</div><div class=\"line\">\t//控制是否开始投票</div><div class=\"line\">\trs.ElecChan = make(chan bool)</div><div class=\"line\">\trs.HeartBeatChan = make(chan bool)</div><div class=\"line\">\trs.CusMsg = make(chan string)</div><div class=\"line\">\trs.resetTimeout()</div><div class=\"line\">\trs.Nodes = []Addr&#123;</div><div class=\"line\">\t\t&#123;&quot;127.0.0.1&quot;,5000,&quot;5000&quot;&#125;,</div><div class=\"line\">\t\t&#123;&quot;127.0.0.1&quot;,5001,&quot;5001&quot;&#125;,</div><div class=\"line\">\t\t&#123;&quot;127.0.0.1&quot;,5002,&quot;5002&quot;&#125;,</div><div class=\"line\">\t\t&#123;&quot;127.0.0.1&quot;,5003,&quot;5003&quot;&#125;,</div><div class=\"line\">\t&#125;</div><div class=\"line\">\trs.Port = *port</div><div class=\"line\"></div><div class=\"line\">\trs.Run()</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">//主节点发送心跳信号给其他节点</div><div class=\"line\">func (rs *RaftServer)sendHeartBeat()  &#123;</div><div class=\"line\">\t// 每隔1s 发送一次心跳</div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\ttime.Sleep(1 * time.Second)</div><div class=\"line\">\t\tif rs.Role == LEADER &#123;</div><div class=\"line\">\t\t\t//发送消息</div><div class=\"line\">\t\t\trs.VoteToOther(&quot;heat beating&quot;)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//通过leader 给其他所有子节点发送数据</div><div class=\"line\">func (rs *RaftServer)sendDataToOtherNodes()  &#123;</div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\tmsg :=&lt;-rs.CusMsg</div><div class=\"line\">\t\tif rs.Role == LEADER &#123;</div><div class=\"line\">\t\t\t//发送消息</div><div class=\"line\">\t\t\trs.VoteToOther(msg)</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//开启http服务器</div><div class=\"line\">func (rs *RaftServer)setHttpServer()  &#123;</div><div class=\"line\"></div><div class=\"line\">\thttp.HandleFunc(&quot;/req&quot;, rs.request)</div><div class=\"line\">\thttpPort := rs.Port + 10</div><div class=\"line\">\tif err:=http.ListenAndServe(&quot;:&quot;+strconv.Itoa(httpPort), nil); err == nil &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">//leader向其他子节点发送数据</div><div class=\"line\">func (rs *RaftServer)request(writer http.ResponseWriter, request *http.Request)&#123;</div><div class=\"line\"></div><div class=\"line\">\trequest.ParseForm()</div><div class=\"line\">\tif len(request.Form[&quot;data&quot;][0]) &gt; 0 &#123;</div><div class=\"line\">\t\twriter.Write([]byte(&quot;ok&quot;))</div><div class=\"line\">\t\tfmt.Println(request.Form[&quot;data&quot;][0])</div><div class=\"line\">\t\trs.CusMsg &lt;- request.Form[&quot;data&quot;][0]</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行：<br>开启4个终端 分别执行 </p>\n<ul>\n<li>go run main.go -p 5000</li>\n<li>go run main.go -p 5001</li>\n<li>go run main.go -p 5002</li>\n<li>go run main.go -p 5003</li>\n</ul>\n<p>如果5001成为了leader，在浏览器输入<code>http://127.0.0.1:5011/req?data=XXX</code><br>xxx就是leader向子节点发送的数据，浏览器的端口是终端的端口加上10，如果5000是leader，浏览器就是5010.</p>\n","excerpt":"<h2 id=\"Raft-状态\"><a href=\"#Raft-状态\" class=\"headerlink\" title=\"Raft 状态\"></a>Raft 状态</h2><p>一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效，每个节点处于以下三种状态之一：</p>\n<ul>\n<li><code>follower（跟随者）</code> ：所有结点都以 <code>follower</code> 的状态开始。如果没收到 <code>leader</code>消息则会变成 <code>candidate</code>状态。</li>\n<li><code>candidate（候选人）</code>：会向其他结点“拉选票”，如果得到大部分的票则成为<code>leader</code>。这个过程就叫做Leader选举(Leader Election)。</li>\n<li><code>leader（领导者）</code>：所有对系统的修改都会先经过<code>leader</code>。</li>\n</ul>","more":"<h2 id=\"Raft-一致性算法\"><a href=\"#Raft-一致性算法\" class=\"headerlink\" title=\"Raft 一致性算法\"></a>Raft 一致性算法</h2><p>Raft通过选出一个leader来简化日志副本的管理，例如，日志项(log entry)只允许从leader流向follower。</p>\n<p>基于leader的方法，Raft算法可以分解成三个子问题：</p>\n<p><code>Leader election</code> (领导选举)：原来的leader挂掉后，必须选出一个新的leader</p>\n<p><code>Log replication</code> (日志复制)：leader从客户端接收日志，并复制到整个集群中</p>\n<p><code>Safety</code> (安全性)：如果有任意的server将日志项回放到状态机中了，那么其他的server只会回放相同的日志项</p>\n<h2 id=\"Leader-election-领导选举\"><a href=\"#Leader-election-领导选举\" class=\"headerlink\" title=\"Leader election (领导选举)\"></a>Leader election (领导选举)</h2><p>Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是 <code>follower</code>(跟随者) 身份。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，然后他就会认为系统中没有可用的领导者然后开始进行选举以选出新的领导者。要开始一次选举过程，<code>follower</code> 会给当前term加1并且转换成<code>candidate</code>状态。</p>\n<p>然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人的状态维持直到发生以下任何一个条件发生的时候，</p>\n<ul>\n<li><p>他自己赢得了这次的选举</p>\n<ul>\n<li>如果这个节点赢得了半数以上的vote就会成为leader，每个节点会按照first-come-first-served的原则进行投票，并且一个term中只能投给一个节点， 这样就保证了一个term最多有一个节点赢得半数以上的vote。</li>\n<li>当一个节点赢得选举， 他会成为leader， 并且给所有节点发送这个信息， 这样所有节点都会回退成follower。</li>\n</ul>\n</li>\n<li><p>其他的服务器成为领导者</p>\n<p>  如果在等待选举期间，candidate接收到其他server要成为leader的RPC，分两种情况处理：</p>\n<ul>\n<li>如果leader的term大于或等于自身的term，那么改<code>candidate</code> 会转成<code>follower</code> 状态</li>\n<li>如果leader的term小于自身的term，那么会拒绝该 <code>leader</code>，并继续保持<code>candidate</code> 状态</li>\n</ul>\n</li>\n<li><p>一段时间之后没有任何一个获胜的人</p>\n<ul>\n<li><p>有可能，很多follower同时变成candidate，导致没有candidate能获得大多数的选举，从而导致无法选出主。当这个情况发生时，每个candidate会超时，然后重新发增加term，发起新一轮选举RPC。需要注意的是，如果没有特别处理，可能出导致无限地重复选主的情况。</p>\n</li>\n<li><p>Raft采用随机定时器的方法来避免上述情况，每个candidate选择一个时间间隔内的随机值，例如150-300ms，采用这种机制，一般只有一个server会进入candidate状态，然后获得大多数server的选举，最后成为主。每个candidate在收到leader的心跳信息后会重启定时器，从而避免在leader正常工作时，会发生选举的情况。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Log-replication-日志复制\"><a href=\"#Log-replication-日志复制\" class=\"headerlink\" title=\"Log replication (日志复制)\"></a>Log replication (日志复制)</h2><p>当选出 <code>leader</code> 后，它会开始接受客户端请求，每个请求会带有一个指令，可以被回放到状态机中。<code>leader</code> 把指令追加成一个<code>log entry</code>，然后通过AppendEntries RPC并行的发送给其他的server，当改entry被多数派server复制后，<code>leader</code> 会把该entry回放到状态机中，然后把结果返回给客户端。</p>\n<p>当 <code>follower</code> 宕机或者运行较慢时，<code>leader</code> 会无限地重发AppendEntries给这些follower，直到所有的follower都复制了该log entry。</p>\n<p>raft的log replication保证以下性质(Log Matching Property)：</p>\n<ul>\n<li><p>如果两个log entry有相同的index和term，那么它们存储相同的指令</p>\n</li>\n<li><p>如果两个log entry在两份不同的日志中，并且有相同的index和term，那么它们之前的log entry是完全相同的</p>\n</li>\n</ul>\n<p>其中特性一通过以下保证：</p>\n<ul>\n<li>leader在一个特定的term和index下，只会创建一个log entry</li>\n<li>log entry不会改变它们在日志中的位置</li>\n</ul>\n<p>特性二通过以下保证：</p>\n<ul>\n<li>AppendEntries会做log entry的一致性检查，当发送一个AppendEntriesRPC时，leader会带上需要复制的log entry前一个log entry的(index, iterm)</li>\n</ul>\n<p>如果follower没有发现与它一样的log entry，那么它会拒绝接受新的log entry 这样就能保证特性二得以满足。</p>\n<h2 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h2><h3 id=\"选举限制\"><a href=\"#选举限制\" class=\"headerlink\" title=\"选举限制\"></a>选举限制</h3><p>在一些一致性算法中，即使一台server没有包含所有之前已提交的log entry，也能被选为主，这些算法需要把leader上缺失的日志从其他的server拷贝到leader上，这种方法会导致额外的复杂度。相对而言，raft使用一种更简单的方法，即它保证所有已提交的log entry都会在当前选举的leader上，因此，在raft算法中，日志只会从leader流向follower。</p>\n<p>为了实现上述目标，raft在选举中会保证，一个candidate只有得到大多数的server的选票之后，才能被选为主。得到大多数的选票表明，选举它的server中至少有一个server是拥有所有已经提交的log entry的，而leader的日志至少和follower的一样新，这样就保证了leader肯定有所有已提交的log entry。</p>\n<h3 id=\"提交之前任期内的日志条目\"><a href=\"#提交之前任期内的日志条目\" class=\"headerlink\" title=\"提交之前任期内的日志条目\"></a>提交之前任期内的日志条目</h3><p>领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。下图展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。</p>\n<p><img src=\"http://olgjbx93m.bkt.clouddn.com/20180123-10289.png\" alt=\"\"></p>\n<p>如上图的例子，图（c）就发生了一个log entry虽然已经复制到大多数的服务器，但是仍然有可能被覆盖掉的可能，如图（d），整个发生的时序如下：</p>\n<ul>\n<li><p>图a中，S1被选为主，然后复制到log index为2的log entry到S2上</p>\n</li>\n<li><p>图b中，S1挂掉，然后S5获得了S3，S4和自身的选举，成为leader，然后，其从客户端收到了一个新的log entry(3)</p>\n</li>\n<li><p>图c中，S5挂掉，S1重新正常工作，又被选为主，继续复制log entry(2)，在log entry(2)被提交前，S1又挂掉</p>\n</li>\n<li><p>图d中，S5又重新被选为领导者，然后，会把term 3的log entry覆盖到其他log index为2的log entry</p>\n</li>\n</ul>\n<p>为了上图描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。例如，图e中，如果S1在挂掉前把log entry(4)复制到了大多数的server后，就能保证之前的log entry（2）被提交了，之后S5也就不可能被选为领导者了。</p>\n<h3 id=\"安全性论证\"><a href=\"#安全性论证\" class=\"headerlink\" title=\"安全性论证\"></a>安全性论证</h3><p>以反证法来证明，假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。</p>\n<p><img src=\"http://olgjbx93m.bkt.clouddn.com/20180123-23202.png\" alt=\"\"></p>\n<blockquote>\n<p>如果 S1 （任期 T 的领导者）提交了一条新的日志在它的任期里，然后 S5 在之后的任期 U 里被选举为领导人，然后至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。</p>\n</blockquote>\n<ol>\n<li><p>在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。</p>\n</li>\n<li><p>领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人U 投票了，这个投票者是产生这个矛盾的关键。</p>\n</li>\n<li><p>这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。</p>\n</li>\n<li><p>投票者在给领导人 U 投票时依然保有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有和领导人冲突的时候才会删除条目。</p>\n</li>\n<li><p>投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。</p>\n<ul>\n<li><p>首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。</p>\n</li>\n<li><p>除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交当然日志，这里产生矛盾。</p>\n</li>\n</ul>\n</li>\n<li><p>因此，假设不成立，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目</p>\n</li>\n</ol>\n<h3 id=\"跟随者和候选人崩溃\"><a href=\"#跟随者和候选人崩溃\" class=\"headerlink\" title=\"跟随者和候选人崩溃\"></a>跟随者和候选人崩溃</h3><p>跟随者或者候选人崩溃，会按如下处理：</p>\n<ul>\n<li>领导者会不断给它发送选举和追加日志的RPC，直到成功</li>\n<li>跟随者会忽略它已经处理过的追加日志的RPC</li>\n</ul>\n<h3 id=\"时间和可用性\"><a href=\"#时间和可用性\" class=\"headerlink\" title=\"时间和可用性\"></a>时间和可用性</h3><p>领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</div></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>广播时间</strong>指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；</p>\n</li>\n<li><p><strong>选举超时时间</strong>就是选举的超时时间限制</p>\n</li>\n<li><p><strong>平均故障间隔时间</strong>就是对于一台服务器而言，两次故障之间的平均时间。</p>\n</li>\n</ul>\n<p>选举超时时间要大于广播时间的原因是，防止跟随者因为还没收到领导者的心跳，而重新选主。</p>\n<p>选举超时时间要小于MTBF的原因是，防止选举时，能正常工作的server没有达到大多数。</p>\n<p>对于广播时间，一般在[0.5ms,20ms]之间，而平均故障间隔时间一般非常大，至少是按照月为单位。因此，一般选举超时时间一般选择范围为[10ms,500ms]。因此，当领导者挂掉后，能在较短时间内重新选主。</p>\n<h2 id=\"动画演示-Raft\"><a href=\"#动画演示-Raft\" class=\"headerlink\" title=\"动画演示 Raft\"></a>动画演示 Raft</h2><p><a href=\"http://thesecretlivesofdata.com/raft/\">http://thesecretlivesofdata.com/raft/</a></p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>实现效果：<br>4个子节点投票，选出leader，投票停止，leader状态变为leader，子节点状态重置。leader向子节点发送心跳数据，表名自己活着。leader使用浏览器自定义给子节点发送数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div><div class=\"line\">246</div><div class=\"line\">247</div><div class=\"line\">248</div><div class=\"line\">249</div><div class=\"line\">250</div><div class=\"line\">251</div><div class=\"line\">252</div><div class=\"line\">253</div><div class=\"line\">254</div><div class=\"line\">255</div><div class=\"line\">256</div><div class=\"line\">257</div><div class=\"line\">258</div><div class=\"line\">259</div><div class=\"line\">260</div><div class=\"line\">261</div><div class=\"line\">262</div><div class=\"line\">263</div><div class=\"line\">264</div><div class=\"line\">265</div><div class=\"line\">266</div><div class=\"line\">267</div><div class=\"line\">268</div><div class=\"line\">269</div><div class=\"line\">270</div><div class=\"line\">271</div><div class=\"line\">272</div><div class=\"line\">273</div><div class=\"line\">274</div><div class=\"line\">275</div><div class=\"line\">276</div><div class=\"line\">277</div><div class=\"line\">278</div><div class=\"line\">279</div><div class=\"line\">280</div><div class=\"line\">281</div><div class=\"line\">282</div><div class=\"line\">283</div><div class=\"line\">284</div><div class=\"line\">285</div><div class=\"line\">286</div><div class=\"line\">287</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;flag&quot;</div><div class=\"line\">\t&quot;net&quot;</div><div class=\"line\">\t&quot;strconv&quot;</div><div class=\"line\">\t&quot;time&quot;</div><div class=\"line\">\t&quot;strings&quot;</div><div class=\"line\">\t&quot;net/http&quot;</div><div class=\"line\">\t&quot;math/rand&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">const (</div><div class=\"line\">\tLEADER = iota</div><div class=\"line\">\tCANDIDATE</div><div class=\"line\">\tFOLLOWER</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">//声明地址信息</div><div class=\"line\">type Addr struct &#123;</div><div class=\"line\">\tHost string  //ip</div><div class=\"line\">\tPort int</div><div class=\"line\">\tAddr string</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">type RaftServer struct &#123;</div><div class=\"line\"></div><div class=\"line\">\tVotes int //选票</div><div class=\"line\">\tRole int // 角色 follower candidate leader</div><div class=\"line\">\tNodes []Addr</div><div class=\"line\">\tisElecting bool //判断当前节点是否处于选举中</div><div class=\"line\">\tTimeout int //选举间隔时间（也叫超时时间）</div><div class=\"line\">\tElecChan chan bool //通道信号</div><div class=\"line\">\tHeartBeatChan chan bool  //leader 的心跳信号</div><div class=\"line\">\tPort int //端口号</div><div class=\"line\"></div><div class=\"line\">\t//网页接收到的参数 由主节点向子节点传参</div><div class=\"line\">\tCusMsg chan string</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (rs *RaftServer)changeRole(role int)  &#123;</div><div class=\"line\">\tswitch role &#123;</div><div class=\"line\">\tcase LEADER:</div><div class=\"line\">\t\tfmt.Println(&quot;leader&quot;)</div><div class=\"line\">\tcase CANDIDATE:</div><div class=\"line\">\t\tfmt.Println(&quot;candidate&quot;)</div><div class=\"line\">\tcase FOLLOWER:</div><div class=\"line\">\t\tfmt.Println(&quot;follower&quot;)</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\trs.Role = role</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (rs *RaftServer)resetTimeout()  &#123;</div><div class=\"line\">\t//Raft系统一般为1500-3000毫秒选一次</div><div class=\"line\">\trs.Timeout =  2000</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//运行服务器</div><div class=\"line\">func (rs *RaftServer)Run()  &#123;</div><div class=\"line\">\t//rs监听 是否有人 给我投票</div><div class=\"line\">\tlisten , _ := net.Listen(&quot;tcp&quot;, &quot;:&quot;+strconv.Itoa(rs.Port))</div><div class=\"line\"></div><div class=\"line\">\tdefer listen.Close()</div><div class=\"line\"></div><div class=\"line\">\tgo rs.elect()</div><div class=\"line\"></div><div class=\"line\">\t//控制投票时间</div><div class=\"line\">\tgo rs.electTimeDuration()</div><div class=\"line\"></div><div class=\"line\">\t//go rs.printRole()</div><div class=\"line\"></div><div class=\"line\">\t// 主节点发送心跳</div><div class=\"line\">\tgo rs.sendHeartBeat()</div><div class=\"line\">\t//</div><div class=\"line\">\tgo rs.sendDataToOtherNodes()</div><div class=\"line\"></div><div class=\"line\">\t//监听http协议</div><div class=\"line\">\tgo rs.setHttpServer()</div><div class=\"line\"></div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\tconn,_ := listen.Accept()</div><div class=\"line\">\t\tgo func()&#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tfor &#123;</div><div class=\"line\">\t\t\t\tby := make([]byte, 1024)</div><div class=\"line\">\t\t\t\tn,_:= conn.Read(by)</div><div class=\"line\">\t\t\t\tfmt.Println(&quot;收到消息&quot;, string(by[:n]))</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tvalue := string(by[:n])</div><div class=\"line\">\t\t\t\tv,_ := strconv.Atoi(value)</div><div class=\"line\">\t\t\t\tif v == rs.Port &#123;</div><div class=\"line\">\t\t\t\t\trs.Votes++</div><div class=\"line\">\t\t\t\t\tfmt.Println(&quot;当前票数：&quot;, rs.Votes)</div><div class=\"line\">\t\t\t\t\t// leader 选举成功</div><div class=\"line\">\t\t\t\t\tif VoteSuccess(rs.Votes, 5) == true &#123;</div><div class=\"line\">\t\t\t\t\t\tfmt.Printf(&quot;我是 %v, 我被选举成leader&quot;, rs.Port)</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\t//通知其他节点。停止选举</div><div class=\"line\">\t\t\t\t\t\t//重置其他节点状态和票数</div><div class=\"line\">\t\t\t\t\t\trs.VoteToOther(&quot;stopVote&quot;)</div><div class=\"line\">\t\t\t\t\t\trs.isElecting = false</div><div class=\"line\">\t\t\t\t\t\t//改变当前节点状态</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t\trs.changeRole(LEADER)</div><div class=\"line\">\t\t\t\t\t\tbreak</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t\t\t\t//收到leader发来的消息</div><div class=\"line\">\t\t\t\tif strings.HasPrefix(string(by[:n]), &quot;stopVote&quot;) &#123;</div><div class=\"line\">\t\t\t\t\t//停止给别人投票</div><div class=\"line\">\t\t\t\t\trs.isElecting = false</div><div class=\"line\">\t\t\t\t\t//回退自己的状态</div><div class=\"line\">\t\t\t\t\trs.changeRole(FOLLOWER)</div><div class=\"line\">\t\t\t\t\tbreak</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;()</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func VoteSuccess(vote int, target int) bool  &#123;</div><div class=\"line\">\tif vote &gt;= target &#123;</div><div class=\"line\">\t\treturn true</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn false</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//发送数据)</div><div class=\"line\">func (rs *RaftServer)VoteToOther(data string)  &#123;</div><div class=\"line\">\tfor _,k := range rs.Nodes &#123;</div><div class=\"line\">\t\tif k.Port != rs.Port &#123;</div><div class=\"line\">\t\t\tif data == &quot;1234&quot; &#123;</div><div class=\"line\">\t\t\t\tfmt.Println(&quot;-------------&quot;, k.Port)</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tlabel :conn,err := net.Dial(&quot;tcp&quot;, &quot;:&quot;+strconv.Itoa(k.Port))</div><div class=\"line\">\t\t\tfor  &#123;</div><div class=\"line\">\t\t\t\tif err != nil &#123;</div><div class=\"line\">\t\t\t\t\ttime.Sleep(1*time.Second)</div><div class=\"line\">\t\t\t\t\tgoto  label</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tbreak</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tconn.Write([]byte(data))</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//给别人投票</div><div class=\"line\">func (rs *RaftServer)elect()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\t//通过通道确定现在可以给别人投票</div><div class=\"line\"></div><div class=\"line\">\t\t&lt;- rs.ElecChan</div><div class=\"line\"></div><div class=\"line\">\t\t//给其他节点投票，不能投给自己</div><div class=\"line\">\t\tvote := getVoteNum()</div><div class=\"line\"></div><div class=\"line\">\t\trs.VoteToOther(strconv.Itoa(vote))</div><div class=\"line\">\t\t// 设置选举状态</div><div class=\"line\">\t\tif rs.Role != LEADER &#123;</div><div class=\"line\">\t\t\trs.changeRole(CANDIDATE)</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t//是leader的情况</div><div class=\"line\">\t\t\treturn</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func getVoteNum() int  &#123;</div><div class=\"line\"></div><div class=\"line\">\trand.Seed(time.Now().UnixNano())</div><div class=\"line\">\treturn rand.Intn(4) + 5000</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func (rs *RaftServer)electTimeDuration()  &#123;</div><div class=\"line\">\t//</div><div class=\"line\">\tfmt.Println(&quot;+++&quot;, rs.isElecting)</div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\tif rs.isElecting &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\trs.ElecChan &lt;- true</div><div class=\"line\">\t\t\ttime.Sleep(time.Duration(rs.Timeout) * time.Millisecond)</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//打印当前对象的角色</div><div class=\"line\">func (rs *RaftServer)printRole()  &#123;</div><div class=\"line\">\tfor  &#123;</div><div class=\"line\">\t\ttime.Sleep(1 * time.Second)</div><div class=\"line\">\t\tfmt.Println(rs.Port, &quot;状态为&quot;, rs.Role, rs.isElecting)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//获取参数</div><div class=\"line\">\t//运行  go run main.go -p 5000  (p 后面就是要启动的端口)</div><div class=\"line\">\tport := flag.Int(&quot;p&quot;,1234,&quot;port&quot;)</div><div class=\"line\">\tflag.Parse()</div><div class=\"line\">\tfmt.Println(*port)</div><div class=\"line\"></div><div class=\"line\">\trs := RaftServer&#123;&#125;</div><div class=\"line\">\trs.isElecting = true</div><div class=\"line\">\trs.Votes = 0</div><div class=\"line\">\trs.Role = FOLLOWER</div><div class=\"line\">\t//控制是否开始投票</div><div class=\"line\">\trs.ElecChan = make(chan bool)</div><div class=\"line\">\trs.HeartBeatChan = make(chan bool)</div><div class=\"line\">\trs.CusMsg = make(chan string)</div><div class=\"line\">\trs.resetTimeout()</div><div class=\"line\">\trs.Nodes = []Addr&#123;</div><div class=\"line\">\t\t&#123;&quot;127.0.0.1&quot;,5000,&quot;5000&quot;&#125;,</div><div class=\"line\">\t\t&#123;&quot;127.0.0.1&quot;,5001,&quot;5001&quot;&#125;,</div><div class=\"line\">\t\t&#123;&quot;127.0.0.1&quot;,5002,&quot;5002&quot;&#125;,</div><div class=\"line\">\t\t&#123;&quot;127.0.0.1&quot;,5003,&quot;5003&quot;&#125;,</div><div class=\"line\">\t&#125;</div><div class=\"line\">\trs.Port = *port</div><div class=\"line\"></div><div class=\"line\">\trs.Run()</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">//主节点发送心跳信号给其他节点</div><div class=\"line\">func (rs *RaftServer)sendHeartBeat()  &#123;</div><div class=\"line\">\t// 每隔1s 发送一次心跳</div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\ttime.Sleep(1 * time.Second)</div><div class=\"line\">\t\tif rs.Role == LEADER &#123;</div><div class=\"line\">\t\t\t//发送消息</div><div class=\"line\">\t\t\trs.VoteToOther(&quot;heat beating&quot;)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//通过leader 给其他所有子节点发送数据</div><div class=\"line\">func (rs *RaftServer)sendDataToOtherNodes()  &#123;</div><div class=\"line\">\tfor &#123;</div><div class=\"line\">\t\tmsg :=&lt;-rs.CusMsg</div><div class=\"line\">\t\tif rs.Role == LEADER &#123;</div><div class=\"line\">\t\t\t//发送消息</div><div class=\"line\">\t\t\trs.VoteToOther(msg)</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//开启http服务器</div><div class=\"line\">func (rs *RaftServer)setHttpServer()  &#123;</div><div class=\"line\"></div><div class=\"line\">\thttp.HandleFunc(&quot;/req&quot;, rs.request)</div><div class=\"line\">\thttpPort := rs.Port + 10</div><div class=\"line\">\tif err:=http.ListenAndServe(&quot;:&quot;+strconv.Itoa(httpPort), nil); err == nil &#123;</div><div class=\"line\">\t\tfmt.Println(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">//leader向其他子节点发送数据</div><div class=\"line\">func (rs *RaftServer)request(writer http.ResponseWriter, request *http.Request)&#123;</div><div class=\"line\"></div><div class=\"line\">\trequest.ParseForm()</div><div class=\"line\">\tif len(request.Form[&quot;data&quot;][0]) &gt; 0 &#123;</div><div class=\"line\">\t\twriter.Write([]byte(&quot;ok&quot;))</div><div class=\"line\">\t\tfmt.Println(request.Form[&quot;data&quot;][0])</div><div class=\"line\">\t\trs.CusMsg &lt;- request.Form[&quot;data&quot;][0]</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行：<br>开启4个终端 分别执行 </p>\n<ul>\n<li>go run main.go -p 5000</li>\n<li>go run main.go -p 5001</li>\n<li>go run main.go -p 5002</li>\n<li>go run main.go -p 5003</li>\n</ul>\n<p>如果5001成为了leader，在浏览器输入<code>http://127.0.0.1:5011/req?data=XXX</code><br>xxx就是leader向子节点发送的数据，浏览器的端口是终端的端口加上10，如果5000是leader，浏览器就是5010.</p>"},{"title":"字符串操作","date":"2018-04-26T03:30:20.000Z","_content":"\n### 目录\n\n本文列举关于字符串最常用的几个操作，都会举例说明\n\n* [字符串长度](#0)\n* [查找](#1)\n* [替换](#2)\n* [分割](#3)\n* [合并](#4)\n* [前缀或后缀](#5)\n* [截取](#6)\n* [删除](#7)\n* [插入](#8)\n* [编码转换](#9)\n* [转换数值类型](#10)\n* [大小写转换](#11)\n* [Trim操作](#12)\n* [ASCII 转换](#13)\n* [字符串重复几次](#14)\n* [字符或子串在字符串中首次出现的位置或最后一次出现的位置](#15)\n\n字符串相关操作需要导入包`strings`\n\n<!--more-->\n\n<h3 id=\"0\">字符串长度</h3>\t\n\n* `len()`\n\n```\nfunc strLength() {\n\tvar str = \"abc\"\n\tvar length = len(str)\n\tfmt.Println(length)\n}\n```\n\n<h3 id=\"1\">查找</h3>\t\n\n* `func Contains(s, substr string) bool` 子串substr在s中，返回true\n* `func ContainsAny(s, chars string) bool`  chars中任何一个字符在s中，返回true\n* `func ContainsRune(s string, r rune) bool`  Unicode代码点r在s中，返回true\n* `func Count(s, sep string) int` sep 在s中重复出现的次数(不计算重叠)\n* `func Index(s, sep string)` int 在字符串s中查找sep所在的位置, 找不到返回-1\n\n>在Go中，查找子串出现次数即字符串模式匹配，实现的是Rabin-Karp算法。\n>另外，Count 是计算子串在字符串中出现的无重叠的次数\n\n```\nfunc existSubStringOrChar() {\n\n\tvar super = \"abcdef!\"\n\tvar suba = \"abc\"\n\tvar subb = \"ef!\"\n\n\tvar hasa = existSubString(super, suba)\n\tvar hasb = existSubChar(super, subb)\n\n\tfmt.Println(hasa, hasb)\n\n\tvar s = \"fivevev\"\n\tvar sep1 = \"vev\"\n\tvar sep2 = \"adfd\"\n\n\tvar c1 = repeatCount(s, sep1)\n\tvar c2 = repeatCount(s, sep2)\n\tfmt.Println(c1, c2)\n\n}\n\n// 是否存在某个字符或子串\nfunc existSubString(superString string, substring string) bool {\n\treturn strings.Contains(superString, substring)\n\n}\n\n//substring 是否含有superString 的任意一个字符\nfunc existSubChar(superString string, substring string) bool {\n\treturn strings.ContainsAny(superString, substring)\n}\n\n//substring 的重复出现次数\nfunc repeatCount(superString string, substring string) int {\n\treturn strings.Count(superString, substring)\n}\n```\n\n结果\n\n```\ntrue true\n1 0\n```\n\n<h3 id=\"2\">替换</h3>\t\n\n* `strings.Replace(s, old, new, n)`\n\n`s`需要替换的字符串   `old`需要被替换掉的某个子串    `new`替换的值 \n`n`  `n<0`全部替换  `n==0`不替换 `n>0`全部替换 如果`n`的下标匹配上old值，则只替换当前下标的字符，如果不是，则全部替换\n\n```\nfunc strReplace() {\n\n\tvar str = \"cabcdefgabc\"\n\tvar value = strings.Replace(str, \"a\", \"v\", -1)\n\tvar value1 = strings.Replace(str, \"a\", \"v\", 0)\n\tvar value2 = strings.Replace(str, \"a\", \"v\", 1)\n\tvar value3 = strings.Replace(str, \"a\", \"v\", 3)\n\n\tfmt.Println(value, value1, value2, value3)\n\tstrings.Replace(s, old, new, n)\n}\n```\n\n结果\n```\ncvbcdefgvbc cabcdefgabc cvbcdefgabc cvbcdefgvbc\n```\n\n<h3 id=\"3\">分割</h3>\n\t\n#### Fields 和 FieldsFunc\n\n* Fields 按空格切割\n* FieldsFunc 按照自己指定的方式切割\n\n实际上，Fields 函数就是调用 FieldsFunc 实现的：\n```\nfunc Fields(s string) []string {\n    return FieldsFunc(s, unicode.IsSpace)\n}\n```\n\n```\nfunc strCut() {\n\n\tvar str = \"abc bde efg\"\n\n\tvar cut1 = strings.Fields(str)\n\n\tvar cut2 = strings.FieldsFunc(str, unicode.IsSpace)\n\n\tfmt.Println(cut1, cut2)\n\n\ts := \"ab*cd*ef\"\n\tresult := strings.FieldsFunc(s, func(c rune) bool {\n\t\tif c == 'h' {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\tfmt.Println(result)\n\n}\n```\n\n结果\n```\n[abc bde efg] [abc bde efg]\n[ab*cd*ef]\n```\n\n#### Split 和 SplitAfter、 SplitN 和 SplitAfterN\n\n```\nfunc Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }\nfunc SplitAfter(s, sep string) []string { return genSplit(s, sep, len(sep), -1) }\nfunc SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }\nfunc SplitAfterN(s, sep string, n int) []string { return genSplit(s, sep,len(sep), n)}\n```\n\n它们都调用了 genSplit 函数。\n这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split(\"abc\",\"\")，得到的是[a b c]。\n\n##### 功能区分：after 会保留分隔符\n```\nfmt.Printf(\"%q\\n\", strings.Split(\"foo,bar,baz\", \",\"))\nfmt.Printf(\"%q\\n\", strings.SplitAfter(\"foo,bar,baz\", \",\"))\n```\n输出：\n```\n[\"foo\" \"bar\" \"baz\"]\n[\"foo,\" \"bar,\" \"baz\"]\n```\n##### N的区别\n`N` 用来控制分割的个数\n当 n < 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n > 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割\n\n`fmt.Printf(\"%q\\n\", strings.SplitN(\"foo,bar,baz\", \",\", 2))`\n输出：\n`[\"foo\" \"bar,baz\"]`\n\n另外看一下官方文档提供的例子，注意一下输出结果：\n```\nfmt.Printf(\"%q\\n\", strings.Split(\"a,b,c\", \",\"))\nfmt.Printf(\"%q\\n\", strings.Split(\"a man a plan a canal panama\", \"a \"))\nfmt.Printf(\"%q\\n\", strings.Split(\" xyz \", \"\"))\nfmt.Printf(\"%q\\n\", strings.Split(\"\", \"Bernardo O'Higgins\"))\n```\n输出：\n```\n[\"a\" \"b\" \"c\"]\n[\"\" \"man \" \"plan \" \"canal panama\"]\n[\" \" \"x\" \"y\" \"z\" \" \"]\n[\"\"]\n```\n##### split总结\n关于字符串的分割，最常用的就是`Split`，其他几乎用不到\n\n<h3 id=\"4\">合并</h3>\n\n将字符串数组（或slice）连接起来可以通过 Join 实现\n\n* `func Join(a []string, sep string) string`\n\n```\nfunc strJoin() {\n\tvar arr = []string{\"a\", \"b\", \"c\"}\n\tfmt.Println(arr)\n\t// 用 ‘-’ 拼接\n\tfmt.Println(strings.Join(arr, \"-\"))\n\t// 直接拼接\n\tfmt.Println(strings.Join(arr, \"\"))\n}\n```\n输出：\n```\n[a b c]\na-b-c\nabc\n```\n\n\n<h3 id=\"5\">前缀或后缀</h3>\t\n\n```\nfunc presuf() {\n\n\tvar str = \"abcdefg\"\n\t//判断开始\n\tvar preA = strings.HasPrefix(str, \"a\")\n\n\t//判断结尾\n\tvar preG = strings.HasSuffix(str, \"g\")\n\n\tfmt.Println(preA, preG)\n\n}\n```\n输出：\n`true true`\n\n<h3 id=\"6\">截取</h3>\n\n```\nfunc subString() {\n\t//strings 没有 截取字符串的方法\n\tvar str = \"abc中国defgh\"\n\t// 将str转为切片处理 这里最好不用byte，byte不支持中文，unicode等\n\tvar strArr = string([]rune(str)[:4])\n\n\tfmt.Println(strArr)\n}\n```\n输出：\n```\nabc中\n```\n\n<h3 id=\"7\">删除</h3>\n\t\nstrings 包中没有提供删除的方法，只能自己实现\n\t\n```\nfunc deleteStrWithRange(s string, start int, end int) string {\nif len(s) == 0 || end > len(s) {\n\treturn \"\"\n}\nvar str1 = string([]rune(s)[:start])\nvar str2 = string([]rune(s)[end:])\nreturn str1 + str2\n}\n```\n\t\n```\nvar sss = deleteStrWithRange(\"012345678\", 1, 3)\nfmt.Println(sss)\n```\n\t\n输出：\n`0345678`\n\t\n<h3 id=\"8\">插入</h3>\n\ngo strings 包没有插入方法，只能将字符串转化为切片，然后插入元素，再转为string\n\n<h3 id=\"9\">编码转换</h3>\n\n字符串转换需要用到 `strconv`\n\n*\tAppend 函数表示将给定的类型(如bool, int等)转换为字符串后, 添加在现有的字节数组中[]byte\n*\tFormat 函数将给定的类型变量转换为string返回\n*\tParse 函数将字符串转换为其他类型\n\n#### unicode  与 中文 互转\n\n```\nfunc chinaeseToUnicode() {\n\tsText := \"中文\"\n\ttextQuoted := strconv.QuoteToASCII(sText)\n\tfmt.Println(textQuoted)\n\n\ttextUnquoted := textQuoted[1 : len(textQuoted)-1]\n\tfmt.Println(textUnquoted)\n\n\tsUnicodev := strings.Split(textUnquoted, \"\\\\u\")\n\tvar context string\n\tfor _, v := range sUnicodev {\n\t\tif len(v) < 1 {\n\t\t\tcontinue\n\t\t}\n\t\ttemp, err := strconv.ParseInt(v, 16, 32)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tcontext += fmt.Sprintf(\"%c\", temp)\n\t}\n\tfmt.Println(context)\n}\n```\n输出\n```\n\"\\u4e2d\\u6587\"\n\\u4e2d\\u6587\n中文\n```\n\n#### 转码与解码\n\n需要导入包 `net/url`\n\n```\nfunc encodeAndDecode() {\n\tvar str = \"https://www.baidu.com/生活\"\n\n\t//转码\n\tvar encode = url.QueryEscape(str)\n\n\tfmt.Println(encode)\n\n\t//解码\n\tdecodeurl, err := url.QueryUnescape(encode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(decodeurl)\n}\n```\n输出\n```\nhttps%3A%2F%2Fwww.baidu.com%2F%E7%94%9F%E6%B4%BB\nhttps://www.baidu.com/生活\n```\n\n<h3 id=\"10\">转换数值类型</h3>\n\n```\nfunc strToValue() {\n\n\t// int 转 string\n\tvar intA int = 123\n\tvar stringA string = strconv.Itoa(intA)\n\tfmt.Println(stringA, reflect.TypeOf(stringA))\n\n\t// string 转 int\n\n\tvar stringB = \"45678\"\n\tintB, err := strconv.Atoi(stringB)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(intB, reflect.TypeOf(intB))\n\n\t// string to float\n\tvar stringc = \"123.45678\"\n\tfloatC, err := strconv.ParseFloat(stringc, 32) //bitSize：指定浮点类型（32:float32、64:float64,\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(floatC, reflect.TypeOf(floatC))\n\n}\n```\n输出\n```\n123 string\n45678 int\n123.45678 float64\n```\n\n<h3 id=\"11\">大小写转换</h3>\n\n```\n// 给定字符串转换为英文标题的首字母大写的格式(不能正确处理unicode标点)\nfunc Title(s string) string\n\n// 所有字母转换为小写\nfunc ToLower(s string) string\n\n// 所有字母转换为大写\nfunc ToUpper(s string) string\n\n```\n\n```\nfmt.Println(strings.Title(\"her royal highness\"))  // Her Royal Highness\n\nfmt.Println(strings.ToLower(\"Gopher123\"))  // gopher123\n\nfmt.Println(strings.ToUpper(\"Gopher\"))  // GOPHER\n```\n\n<h3 id=\"12\">Trim操作</h3>\n\nbytes提供了有Compare、Count、Equal、Index、Join、Split、Replace等直接针对[]byte类型的函数。还有一个重要的Buffer类，将[]byte类型当作一个缓冲区，提供了对这个缓冲区便捷的操作：读、写、和string/rune之间的转换、迭代等函数。\n\n在bytes库中，有Trim系列的函数，它的功能是对[]byte类型做裁剪，去除不需要的部分。\n\n* `func Trim(s string, cutset string) string` 去除两边自定义字符\n* `func TrimFunc(s string, f func(rune) bool) string` 自定义清除\n* `func TrimLeft(s string, cutset string) string` 清除左边\n* `func TrimPrefix(s, prefix string) string` 删除前缀\n\n```\nfunc strtrim() {\n\tvar str = \"  ads!/  ;'  jha   asdfhj   \"\n\n\t// 去除首尾空格，一般这个最常用\n\tvar value1 = strings.Trim(str, \" \")\n\tfmt.Println(value1)\n\n\t//自定义trim\n\tfmt.Println(strings.TrimFunc(\"&&&&nihao&&&&\", func(r rune) bool {\n\t\tif r == '&' {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}))\n\n\t//trim 左侧 & 右侧\n\tfmt.Println(strings.TrimLeft(\"&&&&nihao&&&&\", \"&\"))\n\tfmt.Println(strings.TrimRight(\"&&&&nihao&&&&\", \"&\"))\n\n\t//去除前缀，后缀也一样\n\tvar str2 = \"xxx_abcd\"\n\tif strings.HasPrefix(str2, \"xxx_\") {\n\t\tfmt.Println(strings.TrimPrefix(str2, \"xxx_\"))\n\t}\n}\n\n```\n输出：\n\n```\nads!/  ;'  jha   asdfhj\nnihao\nnihao&&&&\n&&&&nihao\nabcd\n```\n\n\n\n<h3 id=\"13\">ASCII 转换</h3>\n\n```\nfunc strASCII() {\n\n\t//字符转ASCII\n\tvar c rune = 'a'\n\tvar i1 = int(c)\n\tfmt.Println(\"'a' convert to ASCII\", i1)\n\n\t//ASCII 转字符\n\tvar i int = 98\n\tvar c1 = rune(i)\n\tfmt.Println(\"98 convert to string\", string(c1))\n}\n```\n输出\n\n```\n'a' convert to ASCII 97\n98 convert to string b\n```\n\n<h3 id=\"14\">字符串重复几次</h3>\n\n* `func Repeat(s string, count int) string`\n\n```\nfunc strRepeatCount() {\n\tfmt.Println(strings.Repeat(\"a\", 2))\n}\n```\n输出\n\n`aa`\n\n<h3 id=\"15\">字符或子串在字符串中首次出现的位置或最后一次出现的位置</h3>\n\n#### 4个查找第一次出现的位置\n\n// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引\n`func Index(s, sep string) int`\n// chars中任何一个Unicode代码点在s中首次出现的位置\n`func IndexAny(s, chars string) int`\n// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true\n`func IndexFunc(s string, f func(rune) bool) int`\n// Unicode 代码点 r 在 s 中第一次出现的位置\n`func IndexRune(s string, r rune) int`\n\n一般用`indexAny`\n\n#### 3个查找最后一次出现的位置\n\n`func LastIndex(s, sep string) int`\n`func LastIndexAny(s, chars string) int`\n`func LastIndexFunc(s string, f func(rune) bool) int`\n\n一般用`LastIndexAny`就行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/字符串操作.md","raw":"---\ntitle: 字符串操作\ndate: 2018-04-26 11:30:20\ncategories:\n  - go\ntags:\n\t- go\n\t- strings\n\t- 字符串操作\n---\n\n### 目录\n\n本文列举关于字符串最常用的几个操作，都会举例说明\n\n* [字符串长度](#0)\n* [查找](#1)\n* [替换](#2)\n* [分割](#3)\n* [合并](#4)\n* [前缀或后缀](#5)\n* [截取](#6)\n* [删除](#7)\n* [插入](#8)\n* [编码转换](#9)\n* [转换数值类型](#10)\n* [大小写转换](#11)\n* [Trim操作](#12)\n* [ASCII 转换](#13)\n* [字符串重复几次](#14)\n* [字符或子串在字符串中首次出现的位置或最后一次出现的位置](#15)\n\n字符串相关操作需要导入包`strings`\n\n<!--more-->\n\n<h3 id=\"0\">字符串长度</h3>\t\n\n* `len()`\n\n```\nfunc strLength() {\n\tvar str = \"abc\"\n\tvar length = len(str)\n\tfmt.Println(length)\n}\n```\n\n<h3 id=\"1\">查找</h3>\t\n\n* `func Contains(s, substr string) bool` 子串substr在s中，返回true\n* `func ContainsAny(s, chars string) bool`  chars中任何一个字符在s中，返回true\n* `func ContainsRune(s string, r rune) bool`  Unicode代码点r在s中，返回true\n* `func Count(s, sep string) int` sep 在s中重复出现的次数(不计算重叠)\n* `func Index(s, sep string)` int 在字符串s中查找sep所在的位置, 找不到返回-1\n\n>在Go中，查找子串出现次数即字符串模式匹配，实现的是Rabin-Karp算法。\n>另外，Count 是计算子串在字符串中出现的无重叠的次数\n\n```\nfunc existSubStringOrChar() {\n\n\tvar super = \"abcdef!\"\n\tvar suba = \"abc\"\n\tvar subb = \"ef!\"\n\n\tvar hasa = existSubString(super, suba)\n\tvar hasb = existSubChar(super, subb)\n\n\tfmt.Println(hasa, hasb)\n\n\tvar s = \"fivevev\"\n\tvar sep1 = \"vev\"\n\tvar sep2 = \"adfd\"\n\n\tvar c1 = repeatCount(s, sep1)\n\tvar c2 = repeatCount(s, sep2)\n\tfmt.Println(c1, c2)\n\n}\n\n// 是否存在某个字符或子串\nfunc existSubString(superString string, substring string) bool {\n\treturn strings.Contains(superString, substring)\n\n}\n\n//substring 是否含有superString 的任意一个字符\nfunc existSubChar(superString string, substring string) bool {\n\treturn strings.ContainsAny(superString, substring)\n}\n\n//substring 的重复出现次数\nfunc repeatCount(superString string, substring string) int {\n\treturn strings.Count(superString, substring)\n}\n```\n\n结果\n\n```\ntrue true\n1 0\n```\n\n<h3 id=\"2\">替换</h3>\t\n\n* `strings.Replace(s, old, new, n)`\n\n`s`需要替换的字符串   `old`需要被替换掉的某个子串    `new`替换的值 \n`n`  `n<0`全部替换  `n==0`不替换 `n>0`全部替换 如果`n`的下标匹配上old值，则只替换当前下标的字符，如果不是，则全部替换\n\n```\nfunc strReplace() {\n\n\tvar str = \"cabcdefgabc\"\n\tvar value = strings.Replace(str, \"a\", \"v\", -1)\n\tvar value1 = strings.Replace(str, \"a\", \"v\", 0)\n\tvar value2 = strings.Replace(str, \"a\", \"v\", 1)\n\tvar value3 = strings.Replace(str, \"a\", \"v\", 3)\n\n\tfmt.Println(value, value1, value2, value3)\n\tstrings.Replace(s, old, new, n)\n}\n```\n\n结果\n```\ncvbcdefgvbc cabcdefgabc cvbcdefgabc cvbcdefgvbc\n```\n\n<h3 id=\"3\">分割</h3>\n\t\n#### Fields 和 FieldsFunc\n\n* Fields 按空格切割\n* FieldsFunc 按照自己指定的方式切割\n\n实际上，Fields 函数就是调用 FieldsFunc 实现的：\n```\nfunc Fields(s string) []string {\n    return FieldsFunc(s, unicode.IsSpace)\n}\n```\n\n```\nfunc strCut() {\n\n\tvar str = \"abc bde efg\"\n\n\tvar cut1 = strings.Fields(str)\n\n\tvar cut2 = strings.FieldsFunc(str, unicode.IsSpace)\n\n\tfmt.Println(cut1, cut2)\n\n\ts := \"ab*cd*ef\"\n\tresult := strings.FieldsFunc(s, func(c rune) bool {\n\t\tif c == 'h' {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\tfmt.Println(result)\n\n}\n```\n\n结果\n```\n[abc bde efg] [abc bde efg]\n[ab*cd*ef]\n```\n\n#### Split 和 SplitAfter、 SplitN 和 SplitAfterN\n\n```\nfunc Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }\nfunc SplitAfter(s, sep string) []string { return genSplit(s, sep, len(sep), -1) }\nfunc SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }\nfunc SplitAfterN(s, sep string, n int) []string { return genSplit(s, sep,len(sep), n)}\n```\n\n它们都调用了 genSplit 函数。\n这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split(\"abc\",\"\")，得到的是[a b c]。\n\n##### 功能区分：after 会保留分隔符\n```\nfmt.Printf(\"%q\\n\", strings.Split(\"foo,bar,baz\", \",\"))\nfmt.Printf(\"%q\\n\", strings.SplitAfter(\"foo,bar,baz\", \",\"))\n```\n输出：\n```\n[\"foo\" \"bar\" \"baz\"]\n[\"foo,\" \"bar,\" \"baz\"]\n```\n##### N的区别\n`N` 用来控制分割的个数\n当 n < 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n > 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割\n\n`fmt.Printf(\"%q\\n\", strings.SplitN(\"foo,bar,baz\", \",\", 2))`\n输出：\n`[\"foo\" \"bar,baz\"]`\n\n另外看一下官方文档提供的例子，注意一下输出结果：\n```\nfmt.Printf(\"%q\\n\", strings.Split(\"a,b,c\", \",\"))\nfmt.Printf(\"%q\\n\", strings.Split(\"a man a plan a canal panama\", \"a \"))\nfmt.Printf(\"%q\\n\", strings.Split(\" xyz \", \"\"))\nfmt.Printf(\"%q\\n\", strings.Split(\"\", \"Bernardo O'Higgins\"))\n```\n输出：\n```\n[\"a\" \"b\" \"c\"]\n[\"\" \"man \" \"plan \" \"canal panama\"]\n[\" \" \"x\" \"y\" \"z\" \" \"]\n[\"\"]\n```\n##### split总结\n关于字符串的分割，最常用的就是`Split`，其他几乎用不到\n\n<h3 id=\"4\">合并</h3>\n\n将字符串数组（或slice）连接起来可以通过 Join 实现\n\n* `func Join(a []string, sep string) string`\n\n```\nfunc strJoin() {\n\tvar arr = []string{\"a\", \"b\", \"c\"}\n\tfmt.Println(arr)\n\t// 用 ‘-’ 拼接\n\tfmt.Println(strings.Join(arr, \"-\"))\n\t// 直接拼接\n\tfmt.Println(strings.Join(arr, \"\"))\n}\n```\n输出：\n```\n[a b c]\na-b-c\nabc\n```\n\n\n<h3 id=\"5\">前缀或后缀</h3>\t\n\n```\nfunc presuf() {\n\n\tvar str = \"abcdefg\"\n\t//判断开始\n\tvar preA = strings.HasPrefix(str, \"a\")\n\n\t//判断结尾\n\tvar preG = strings.HasSuffix(str, \"g\")\n\n\tfmt.Println(preA, preG)\n\n}\n```\n输出：\n`true true`\n\n<h3 id=\"6\">截取</h3>\n\n```\nfunc subString() {\n\t//strings 没有 截取字符串的方法\n\tvar str = \"abc中国defgh\"\n\t// 将str转为切片处理 这里最好不用byte，byte不支持中文，unicode等\n\tvar strArr = string([]rune(str)[:4])\n\n\tfmt.Println(strArr)\n}\n```\n输出：\n```\nabc中\n```\n\n<h3 id=\"7\">删除</h3>\n\t\nstrings 包中没有提供删除的方法，只能自己实现\n\t\n```\nfunc deleteStrWithRange(s string, start int, end int) string {\nif len(s) == 0 || end > len(s) {\n\treturn \"\"\n}\nvar str1 = string([]rune(s)[:start])\nvar str2 = string([]rune(s)[end:])\nreturn str1 + str2\n}\n```\n\t\n```\nvar sss = deleteStrWithRange(\"012345678\", 1, 3)\nfmt.Println(sss)\n```\n\t\n输出：\n`0345678`\n\t\n<h3 id=\"8\">插入</h3>\n\ngo strings 包没有插入方法，只能将字符串转化为切片，然后插入元素，再转为string\n\n<h3 id=\"9\">编码转换</h3>\n\n字符串转换需要用到 `strconv`\n\n*\tAppend 函数表示将给定的类型(如bool, int等)转换为字符串后, 添加在现有的字节数组中[]byte\n*\tFormat 函数将给定的类型变量转换为string返回\n*\tParse 函数将字符串转换为其他类型\n\n#### unicode  与 中文 互转\n\n```\nfunc chinaeseToUnicode() {\n\tsText := \"中文\"\n\ttextQuoted := strconv.QuoteToASCII(sText)\n\tfmt.Println(textQuoted)\n\n\ttextUnquoted := textQuoted[1 : len(textQuoted)-1]\n\tfmt.Println(textUnquoted)\n\n\tsUnicodev := strings.Split(textUnquoted, \"\\\\u\")\n\tvar context string\n\tfor _, v := range sUnicodev {\n\t\tif len(v) < 1 {\n\t\t\tcontinue\n\t\t}\n\t\ttemp, err := strconv.ParseInt(v, 16, 32)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tcontext += fmt.Sprintf(\"%c\", temp)\n\t}\n\tfmt.Println(context)\n}\n```\n输出\n```\n\"\\u4e2d\\u6587\"\n\\u4e2d\\u6587\n中文\n```\n\n#### 转码与解码\n\n需要导入包 `net/url`\n\n```\nfunc encodeAndDecode() {\n\tvar str = \"https://www.baidu.com/生活\"\n\n\t//转码\n\tvar encode = url.QueryEscape(str)\n\n\tfmt.Println(encode)\n\n\t//解码\n\tdecodeurl, err := url.QueryUnescape(encode)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(decodeurl)\n}\n```\n输出\n```\nhttps%3A%2F%2Fwww.baidu.com%2F%E7%94%9F%E6%B4%BB\nhttps://www.baidu.com/生活\n```\n\n<h3 id=\"10\">转换数值类型</h3>\n\n```\nfunc strToValue() {\n\n\t// int 转 string\n\tvar intA int = 123\n\tvar stringA string = strconv.Itoa(intA)\n\tfmt.Println(stringA, reflect.TypeOf(stringA))\n\n\t// string 转 int\n\n\tvar stringB = \"45678\"\n\tintB, err := strconv.Atoi(stringB)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(intB, reflect.TypeOf(intB))\n\n\t// string to float\n\tvar stringc = \"123.45678\"\n\tfloatC, err := strconv.ParseFloat(stringc, 32) //bitSize：指定浮点类型（32:float32、64:float64,\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(floatC, reflect.TypeOf(floatC))\n\n}\n```\n输出\n```\n123 string\n45678 int\n123.45678 float64\n```\n\n<h3 id=\"11\">大小写转换</h3>\n\n```\n// 给定字符串转换为英文标题的首字母大写的格式(不能正确处理unicode标点)\nfunc Title(s string) string\n\n// 所有字母转换为小写\nfunc ToLower(s string) string\n\n// 所有字母转换为大写\nfunc ToUpper(s string) string\n\n```\n\n```\nfmt.Println(strings.Title(\"her royal highness\"))  // Her Royal Highness\n\nfmt.Println(strings.ToLower(\"Gopher123\"))  // gopher123\n\nfmt.Println(strings.ToUpper(\"Gopher\"))  // GOPHER\n```\n\n<h3 id=\"12\">Trim操作</h3>\n\nbytes提供了有Compare、Count、Equal、Index、Join、Split、Replace等直接针对[]byte类型的函数。还有一个重要的Buffer类，将[]byte类型当作一个缓冲区，提供了对这个缓冲区便捷的操作：读、写、和string/rune之间的转换、迭代等函数。\n\n在bytes库中，有Trim系列的函数，它的功能是对[]byte类型做裁剪，去除不需要的部分。\n\n* `func Trim(s string, cutset string) string` 去除两边自定义字符\n* `func TrimFunc(s string, f func(rune) bool) string` 自定义清除\n* `func TrimLeft(s string, cutset string) string` 清除左边\n* `func TrimPrefix(s, prefix string) string` 删除前缀\n\n```\nfunc strtrim() {\n\tvar str = \"  ads!/  ;'  jha   asdfhj   \"\n\n\t// 去除首尾空格，一般这个最常用\n\tvar value1 = strings.Trim(str, \" \")\n\tfmt.Println(value1)\n\n\t//自定义trim\n\tfmt.Println(strings.TrimFunc(\"&&&&nihao&&&&\", func(r rune) bool {\n\t\tif r == '&' {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}))\n\n\t//trim 左侧 & 右侧\n\tfmt.Println(strings.TrimLeft(\"&&&&nihao&&&&\", \"&\"))\n\tfmt.Println(strings.TrimRight(\"&&&&nihao&&&&\", \"&\"))\n\n\t//去除前缀，后缀也一样\n\tvar str2 = \"xxx_abcd\"\n\tif strings.HasPrefix(str2, \"xxx_\") {\n\t\tfmt.Println(strings.TrimPrefix(str2, \"xxx_\"))\n\t}\n}\n\n```\n输出：\n\n```\nads!/  ;'  jha   asdfhj\nnihao\nnihao&&&&\n&&&&nihao\nabcd\n```\n\n\n\n<h3 id=\"13\">ASCII 转换</h3>\n\n```\nfunc strASCII() {\n\n\t//字符转ASCII\n\tvar c rune = 'a'\n\tvar i1 = int(c)\n\tfmt.Println(\"'a' convert to ASCII\", i1)\n\n\t//ASCII 转字符\n\tvar i int = 98\n\tvar c1 = rune(i)\n\tfmt.Println(\"98 convert to string\", string(c1))\n}\n```\n输出\n\n```\n'a' convert to ASCII 97\n98 convert to string b\n```\n\n<h3 id=\"14\">字符串重复几次</h3>\n\n* `func Repeat(s string, count int) string`\n\n```\nfunc strRepeatCount() {\n\tfmt.Println(strings.Repeat(\"a\", 2))\n}\n```\n输出\n\n`aa`\n\n<h3 id=\"15\">字符或子串在字符串中首次出现的位置或最后一次出现的位置</h3>\n\n#### 4个查找第一次出现的位置\n\n// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引\n`func Index(s, sep string) int`\n// chars中任何一个Unicode代码点在s中首次出现的位置\n`func IndexAny(s, chars string) int`\n// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true\n`func IndexFunc(s string, f func(rune) bool) int`\n// Unicode 代码点 r 在 s 中第一次出现的位置\n`func IndexRune(s string, r rune) int`\n\n一般用`indexAny`\n\n#### 3个查找最后一次出现的位置\n\n`func LastIndex(s, sep string) int`\n`func LastIndexAny(s, chars string) int`\n`func LastIndexFunc(s string, f func(rune) bool) int`\n\n一般用`LastIndexAny`就行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"字符串操作","published":1,"updated":"2018-04-27T08:06:16.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tfa002xlx60c1tphbrc","content":"<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>本文列举关于字符串最常用的几个操作，都会举例说明</p>\n<ul>\n<li><a href=\"#0\">字符串长度</a></li>\n<li><a href=\"#1\">查找</a></li>\n<li><a href=\"#2\">替换</a></li>\n<li><a href=\"#3\">分割</a></li>\n<li><a href=\"#4\">合并</a></li>\n<li><a href=\"#5\">前缀或后缀</a></li>\n<li><a href=\"#6\">截取</a></li>\n<li><a href=\"#7\">删除</a></li>\n<li><a href=\"#8\">插入</a></li>\n<li><a href=\"#9\">编码转换</a></li>\n<li><a href=\"#10\">转换数值类型</a></li>\n<li><a href=\"#11\">大小写转换</a></li>\n<li><a href=\"#12\">Trim操作</a></li>\n<li><a href=\"#13\">ASCII 转换</a></li>\n<li><a href=\"#14\">字符串重复几次</a></li>\n<li><a href=\"#15\">字符或子串在字符串中首次出现的位置或最后一次出现的位置</a></li>\n</ul>\n<p>字符串相关操作需要导入包<code>strings</code></p>\n<a id=\"more\"></a>\n<h3 id=\"0\">字符串长度</h3>    \n\n<ul>\n<li><code>len()</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strLength() &#123;</div><div class=\"line\">\tvar str = &quot;abc&quot;</div><div class=\"line\">\tvar length = len(str)</div><div class=\"line\">\tfmt.Println(length)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"1\">查找</h3>    \n\n<ul>\n<li><code>func Contains(s, substr string) bool</code> 子串substr在s中，返回true</li>\n<li><code>func ContainsAny(s, chars string) bool</code>  chars中任何一个字符在s中，返回true</li>\n<li><code>func ContainsRune(s string, r rune) bool</code>  Unicode代码点r在s中，返回true</li>\n<li><code>func Count(s, sep string) int</code> sep 在s中重复出现的次数(不计算重叠)</li>\n<li><code>func Index(s, sep string)</code> int 在字符串s中查找sep所在的位置, 找不到返回-1</li>\n</ul>\n<blockquote>\n<p>在Go中，查找子串出现次数即字符串模式匹配，实现的是Rabin-Karp算法。<br>另外，Count 是计算子串在字符串中出现的无重叠的次数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">func existSubStringOrChar() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar super = &quot;abcdef!&quot;</div><div class=\"line\">\tvar suba = &quot;abc&quot;</div><div class=\"line\">\tvar subb = &quot;ef!&quot;</div><div class=\"line\"></div><div class=\"line\">\tvar hasa = existSubString(super, suba)</div><div class=\"line\">\tvar hasb = existSubChar(super, subb)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hasa, hasb)</div><div class=\"line\"></div><div class=\"line\">\tvar s = &quot;fivevev&quot;</div><div class=\"line\">\tvar sep1 = &quot;vev&quot;</div><div class=\"line\">\tvar sep2 = &quot;adfd&quot;</div><div class=\"line\"></div><div class=\"line\">\tvar c1 = repeatCount(s, sep1)</div><div class=\"line\">\tvar c2 = repeatCount(s, sep2)</div><div class=\"line\">\tfmt.Println(c1, c2)</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 是否存在某个字符或子串</div><div class=\"line\">func existSubString(superString string, substring string) bool &#123;</div><div class=\"line\">\treturn strings.Contains(superString, substring)</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//substring 是否含有superString 的任意一个字符</div><div class=\"line\">func existSubChar(superString string, substring string) bool &#123;</div><div class=\"line\">\treturn strings.ContainsAny(superString, substring)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//substring 的重复出现次数</div><div class=\"line\">func repeatCount(superString string, substring string) int &#123;</div><div class=\"line\">\treturn strings.Count(superString, substring)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">true true</div><div class=\"line\">1 0</div></pre></td></tr></table></figure>\n<h3 id=\"2\">替换</h3>    \n\n<ul>\n<li><code>strings.Replace(s, old, new, n)</code></li>\n</ul>\n<p><code>s</code>需要替换的字符串   <code>old</code>需要被替换掉的某个子串    <code>new</code>替换的值<br><code>n</code>  <code>n&lt;0</code>全部替换  <code>n==0</code>不替换 <code>n&gt;0</code>全部替换 如果<code>n</code>的下标匹配上old值，则只替换当前下标的字符，如果不是，则全部替换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strReplace() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar str = &quot;cabcdefgabc&quot;</div><div class=\"line\">\tvar value = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, -1)</div><div class=\"line\">\tvar value1 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 0)</div><div class=\"line\">\tvar value2 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 1)</div><div class=\"line\">\tvar value3 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 3)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(value, value1, value2, value3)</div><div class=\"line\">\tstrings.Replace(s, old, new, n)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cvbcdefgvbc cabcdefgabc cvbcdefgabc cvbcdefgvbc</div></pre></td></tr></table></figure></p>\n<h3 id=\"3\">分割</h3>\n\n<h4 id=\"Fields-和-FieldsFunc\"><a href=\"#Fields-和-FieldsFunc\" class=\"headerlink\" title=\"Fields 和 FieldsFunc\"></a>Fields 和 FieldsFunc</h4><ul>\n<li>Fields 按空格切割</li>\n<li>FieldsFunc 按照自己指定的方式切割</li>\n</ul>\n<p>实际上，Fields 函数就是调用 FieldsFunc 实现的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func Fields(s string) []string &#123;</div><div class=\"line\">    return FieldsFunc(s, unicode.IsSpace)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strCut() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar str = &quot;abc bde efg&quot;</div><div class=\"line\"></div><div class=\"line\">\tvar cut1 = strings.Fields(str)</div><div class=\"line\"></div><div class=\"line\">\tvar cut2 = strings.FieldsFunc(str, unicode.IsSpace)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(cut1, cut2)</div><div class=\"line\"></div><div class=\"line\">\ts := &quot;ab*cd*ef&quot;</div><div class=\"line\">\tresult := strings.FieldsFunc(s, func(c rune) bool &#123;</div><div class=\"line\">\t\tif c == &apos;h&apos; &#123;</div><div class=\"line\">\t\t\treturn true</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn false</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\tfmt.Println(result)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[abc bde efg] [abc bde efg]</div><div class=\"line\">[ab*cd*ef]</div></pre></td></tr></table></figure></p>\n<h4 id=\"Split-和-SplitAfter、-SplitN-和-SplitAfterN\"><a href=\"#Split-和-SplitAfter、-SplitN-和-SplitAfterN\" class=\"headerlink\" title=\"Split 和 SplitAfter、 SplitN 和 SplitAfterN\"></a>Split 和 SplitAfter、 SplitN 和 SplitAfterN</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">func Split(s, sep string) []string &#123; return genSplit(s, sep, 0, -1) &#125;</div><div class=\"line\">func SplitAfter(s, sep string) []string &#123; return genSplit(s, sep, len(sep), -1) &#125;</div><div class=\"line\">func SplitN(s, sep string, n int) []string &#123; return genSplit(s, sep, 0, n) &#125;</div><div class=\"line\">func SplitAfterN(s, sep string, n int) []string &#123; return genSplit(s, sep,len(sep), n)&#125;</div></pre></td></tr></table></figure>\n<p>它们都调用了 genSplit 函数。<br>这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split(“abc”,””)，得到的是[a b c]。</p>\n<h5 id=\"功能区分：after-会保留分隔符\"><a href=\"#功能区分：after-会保留分隔符\" class=\"headerlink\" title=\"功能区分：after 会保留分隔符\"></a>功能区分：after 会保留分隔符</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot;foo,bar,baz&quot;, &quot;,&quot;))</div><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.SplitAfter(&quot;foo,bar,baz&quot;, &quot;,&quot;))</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]</div><div class=\"line\">[&quot;foo,&quot; &quot;bar,&quot; &quot;baz&quot;]</div></pre></td></tr></table></figure></p>\n<h5 id=\"N的区别\"><a href=\"#N的区别\" class=\"headerlink\" title=\"N的区别\"></a>N的区别</h5><p><code>N</code> 用来控制分割的个数<br>当 n &lt; 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n &gt; 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割</p>\n<p><code>fmt.Printf(&quot;%q\\n&quot;, strings.SplitN(&quot;foo,bar,baz&quot;, &quot;,&quot;, 2))</code><br>输出：<br><code>[&quot;foo&quot; &quot;bar,baz&quot;]</code></p>\n<p>另外看一下官方文档提供的例子，注意一下输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot;a,b,c&quot;, &quot;,&quot;))</div><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot;a man a plan a canal panama&quot;, &quot;a &quot;))</div><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot; xyz &quot;, &quot;&quot;))</div><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot;&quot;, &quot;Bernardo O&apos;Higgins&quot;))</div></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</div><div class=\"line\">[&quot;&quot; &quot;man &quot; &quot;plan &quot; &quot;canal panama&quot;]</div><div class=\"line\">[&quot; &quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot; &quot;]</div><div class=\"line\">[&quot;&quot;]</div></pre></td></tr></table></figure></p>\n<h5 id=\"split总结\"><a href=\"#split总结\" class=\"headerlink\" title=\"split总结\"></a>split总结</h5><p>关于字符串的分割，最常用的就是<code>Split</code>，其他几乎用不到</p>\n<h3 id=\"4\">合并</h3>\n\n<p>将字符串数组（或slice）连接起来可以通过 Join 实现</p>\n<ul>\n<li><code>func Join(a []string, sep string) string</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strJoin() &#123;</div><div class=\"line\">\tvar arr = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</div><div class=\"line\">\tfmt.Println(arr)</div><div class=\"line\">\t// 用 ‘-’ 拼接</div><div class=\"line\">\tfmt.Println(strings.Join(arr, &quot;-&quot;))</div><div class=\"line\">\t// 直接拼接</div><div class=\"line\">\tfmt.Println(strings.Join(arr, &quot;&quot;))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[a b c]</div><div class=\"line\">a-b-c</div><div class=\"line\">abc</div></pre></td></tr></table></figure></p>\n<h3 id=\"5\">前缀或后缀</h3>    \n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">func presuf() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar str = &quot;abcdefg&quot;</div><div class=\"line\">\t//判断开始</div><div class=\"line\">\tvar preA = strings.HasPrefix(str, &quot;a&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//判断结尾</div><div class=\"line\">\tvar preG = strings.HasSuffix(str, &quot;g&quot;)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(preA, preG)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><code>true true</code></p>\n<h3 id=\"6\">截取</h3>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">func subString() &#123;</div><div class=\"line\">\t//strings 没有 截取字符串的方法</div><div class=\"line\">\tvar str = &quot;abc中国defgh&quot;</div><div class=\"line\">\t// 将str转为切片处理 这里最好不用byte，byte不支持中文，unicode等</div><div class=\"line\">\tvar strArr = string([]rune(str)[:4])</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(strArr)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">abc中</div></pre></td></tr></table></figure></p>\n<h3 id=\"7\">删除</h3>\n\n<p>strings 包中没有提供删除的方法，只能自己实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">func deleteStrWithRange(s string, start int, end int) string &#123;</div><div class=\"line\">if len(s) == 0 || end &gt; len(s) &#123;</div><div class=\"line\">\treturn &quot;&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">var str1 = string([]rune(s)[:start])</div><div class=\"line\">var str2 = string([]rune(s)[end:])</div><div class=\"line\">return str1 + str2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var sss = deleteStrWithRange(&quot;012345678&quot;, 1, 3)</div><div class=\"line\">fmt.Println(sss)</div></pre></td></tr></table></figure>\n<p>输出：<br><code>0345678</code></p>\n<h3 id=\"8\">插入</h3>\n\n<p>go strings 包没有插入方法，只能将字符串转化为切片，然后插入元素，再转为string</p>\n<h3 id=\"9\">编码转换</h3>\n\n<p>字符串转换需要用到 <code>strconv</code></p>\n<ul>\n<li>Append 函数表示将给定的类型(如bool, int等)转换为字符串后, 添加在现有的字节数组中[]byte</li>\n<li>Format 函数将给定的类型变量转换为string返回</li>\n<li>Parse 函数将字符串转换为其他类型</li>\n</ul>\n<h4 id=\"unicode-与-中文-互转\"><a href=\"#unicode-与-中文-互转\" class=\"headerlink\" title=\"unicode  与 中文 互转\"></a>unicode  与 中文 互转</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">func chinaeseToUnicode() &#123;</div><div class=\"line\">\tsText := &quot;中文&quot;</div><div class=\"line\">\ttextQuoted := strconv.QuoteToASCII(sText)</div><div class=\"line\">\tfmt.Println(textQuoted)</div><div class=\"line\"></div><div class=\"line\">\ttextUnquoted := textQuoted[1 : len(textQuoted)-1]</div><div class=\"line\">\tfmt.Println(textUnquoted)</div><div class=\"line\"></div><div class=\"line\">\tsUnicodev := strings.Split(textUnquoted, &quot;\\\\u&quot;)</div><div class=\"line\">\tvar context string</div><div class=\"line\">\tfor _, v := range sUnicodev &#123;</div><div class=\"line\">\t\tif len(v) &lt; 1 &#123;</div><div class=\"line\">\t\t\tcontinue</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\ttemp, err := strconv.ParseInt(v, 16, 32)</div><div class=\"line\">\t\tif err != nil &#123;</div><div class=\"line\">\t\t\tpanic(err)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tcontext += fmt.Sprintf(&quot;%c&quot;, temp)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(context)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;\\u4e2d\\u6587&quot;</div><div class=\"line\">\\u4e2d\\u6587</div><div class=\"line\">中文</div></pre></td></tr></table></figure></p>\n<h4 id=\"转码与解码\"><a href=\"#转码与解码\" class=\"headerlink\" title=\"转码与解码\"></a>转码与解码</h4><p>需要导入包 <code>net/url</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">func encodeAndDecode() &#123;</div><div class=\"line\">\tvar str = &quot;https://www.baidu.com/生活&quot;</div><div class=\"line\"></div><div class=\"line\">\t//转码</div><div class=\"line\">\tvar encode = url.QueryEscape(str)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(encode)</div><div class=\"line\"></div><div class=\"line\">\t//解码</div><div class=\"line\">\tdecodeurl, err := url.QueryUnescape(encode)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tpanic(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(decodeurl)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">https%3A%2F%2Fwww.baidu.com%2F%E7%94%9F%E6%B4%BB</div><div class=\"line\">https://www.baidu.com/生活</div></pre></td></tr></table></figure></p>\n<h3 id=\"10\">转换数值类型</h3>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strToValue() &#123;</div><div class=\"line\"></div><div class=\"line\">\t// int 转 string</div><div class=\"line\">\tvar intA int = 123</div><div class=\"line\">\tvar stringA string = strconv.Itoa(intA)</div><div class=\"line\">\tfmt.Println(stringA, reflect.TypeOf(stringA))</div><div class=\"line\"></div><div class=\"line\">\t// string 转 int</div><div class=\"line\"></div><div class=\"line\">\tvar stringB = &quot;45678&quot;</div><div class=\"line\">\tintB, err := strconv.Atoi(stringB)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tpanic(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(intB, reflect.TypeOf(intB))</div><div class=\"line\"></div><div class=\"line\">\t// string to float</div><div class=\"line\">\tvar stringc = &quot;123.45678&quot;</div><div class=\"line\">\tfloatC, err := strconv.ParseFloat(stringc, 32) //bitSize：指定浮点类型（32:float32、64:float64,</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tpanic(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(floatC, reflect.TypeOf(floatC))</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">123 string</div><div class=\"line\">45678 int</div><div class=\"line\">123.45678 float64</div></pre></td></tr></table></figure></p>\n<h3 id=\"11\">大小写转换</h3>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 给定字符串转换为英文标题的首字母大写的格式(不能正确处理unicode标点)</div><div class=\"line\">func Title(s string) string</div><div class=\"line\"></div><div class=\"line\">// 所有字母转换为小写</div><div class=\"line\">func ToLower(s string) string</div><div class=\"line\"></div><div class=\"line\">// 所有字母转换为大写</div><div class=\"line\">func ToUpper(s string) string</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">fmt.Println(strings.Title(&quot;her royal highness&quot;))  // Her Royal Highness</div><div class=\"line\"></div><div class=\"line\">fmt.Println(strings.ToLower(&quot;Gopher123&quot;))  // gopher123</div><div class=\"line\"></div><div class=\"line\">fmt.Println(strings.ToUpper(&quot;Gopher&quot;))  // GOPHER</div></pre></td></tr></table></figure>\n<h3 id=\"12\">Trim操作</h3>\n\n<p>bytes提供了有Compare、Count、Equal、Index、Join、Split、Replace等直接针对[]byte类型的函数。还有一个重要的Buffer类，将[]byte类型当作一个缓冲区，提供了对这个缓冲区便捷的操作：读、写、和string/rune之间的转换、迭代等函数。</p>\n<p>在bytes库中，有Trim系列的函数，它的功能是对[]byte类型做裁剪，去除不需要的部分。</p>\n<ul>\n<li><code>func Trim(s string, cutset string) string</code> 去除两边自定义字符</li>\n<li><code>func TrimFunc(s string, f func(rune) bool) string</code> 自定义清除</li>\n<li><code>func TrimLeft(s string, cutset string) string</code> 清除左边</li>\n<li><code>func TrimPrefix(s, prefix string) string</code> 删除前缀</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strtrim() &#123;</div><div class=\"line\">\tvar str = &quot;  ads!/  ;&apos;  jha   asdfhj   &quot;</div><div class=\"line\"></div><div class=\"line\">\t// 去除首尾空格，一般这个最常用</div><div class=\"line\">\tvar value1 = strings.Trim(str, &quot; &quot;)</div><div class=\"line\">\tfmt.Println(value1)</div><div class=\"line\"></div><div class=\"line\">\t//自定义trim</div><div class=\"line\">\tfmt.Println(strings.TrimFunc(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, func(r rune) bool &#123;</div><div class=\"line\">\t\tif r == &apos;&amp;&apos; &#123;</div><div class=\"line\">\t\t\treturn true</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn false</div><div class=\"line\">\t&#125;))</div><div class=\"line\"></div><div class=\"line\">\t//trim 左侧 &amp; 右侧</div><div class=\"line\">\tfmt.Println(strings.TrimLeft(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, &quot;&amp;&quot;))</div><div class=\"line\">\tfmt.Println(strings.TrimRight(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, &quot;&amp;&quot;))</div><div class=\"line\"></div><div class=\"line\">\t//去除前缀，后缀也一样</div><div class=\"line\">\tvar str2 = &quot;xxx_abcd&quot;</div><div class=\"line\">\tif strings.HasPrefix(str2, &quot;xxx_&quot;) &#123;</div><div class=\"line\">\t\tfmt.Println(strings.TrimPrefix(str2, &quot;xxx_&quot;))</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ads!/  ;&apos;  jha   asdfhj</div><div class=\"line\">nihao</div><div class=\"line\">nihao&amp;&amp;&amp;&amp;</div><div class=\"line\">&amp;&amp;&amp;&amp;nihao</div><div class=\"line\">abcd</div></pre></td></tr></table></figure>\n<h3 id=\"13\">ASCII 转换</h3>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strASCII() &#123;</div><div class=\"line\"></div><div class=\"line\">\t//字符转ASCII</div><div class=\"line\">\tvar c rune = &apos;a&apos;</div><div class=\"line\">\tvar i1 = int(c)</div><div class=\"line\">\tfmt.Println(&quot;&apos;a&apos; convert to ASCII&quot;, i1)</div><div class=\"line\"></div><div class=\"line\">\t//ASCII 转字符</div><div class=\"line\">\tvar i int = 98</div><div class=\"line\">\tvar c1 = rune(i)</div><div class=\"line\">\tfmt.Println(&quot;98 convert to string&quot;, string(c1))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;a&apos; convert to ASCII 97</div><div class=\"line\">98 convert to string b</div></pre></td></tr></table></figure>\n<h3 id=\"14\">字符串重复几次</h3>\n\n<ul>\n<li><code>func Repeat(s string, count int) string</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strRepeatCount() &#123;</div><div class=\"line\">\tfmt.Println(strings.Repeat(&quot;a&quot;, 2))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<p><code>aa</code></p>\n<h3 id=\"15\">字符或子串在字符串中首次出现的位置或最后一次出现的位置</h3>\n\n<h4 id=\"4个查找第一次出现的位置\"><a href=\"#4个查找第一次出现的位置\" class=\"headerlink\" title=\"4个查找第一次出现的位置\"></a>4个查找第一次出现的位置</h4><p>// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引<br><code>func Index(s, sep string) int</code><br>// chars中任何一个Unicode代码点在s中首次出现的位置<br><code>func IndexAny(s, chars string) int</code><br>// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true<br><code>func IndexFunc(s string, f func(rune) bool) int</code><br>// Unicode 代码点 r 在 s 中第一次出现的位置<br><code>func IndexRune(s string, r rune) int</code></p>\n<p>一般用<code>indexAny</code></p>\n<h4 id=\"3个查找最后一次出现的位置\"><a href=\"#3个查找最后一次出现的位置\" class=\"headerlink\" title=\"3个查找最后一次出现的位置\"></a>3个查找最后一次出现的位置</h4><p><code>func LastIndex(s, sep string) int</code><br><code>func LastIndexAny(s, chars string) int</code><br><code>func LastIndexFunc(s string, f func(rune) bool) int</code></p>\n<p>一般用<code>LastIndexAny</code>就行</p>\n","excerpt":"<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>本文列举关于字符串最常用的几个操作，都会举例说明</p>\n<ul>\n<li><a href=\"#0\">字符串长度</a></li>\n<li><a href=\"#1\">查找</a></li>\n<li><a href=\"#2\">替换</a></li>\n<li><a href=\"#3\">分割</a></li>\n<li><a href=\"#4\">合并</a></li>\n<li><a href=\"#5\">前缀或后缀</a></li>\n<li><a href=\"#6\">截取</a></li>\n<li><a href=\"#7\">删除</a></li>\n<li><a href=\"#8\">插入</a></li>\n<li><a href=\"#9\">编码转换</a></li>\n<li><a href=\"#10\">转换数值类型</a></li>\n<li><a href=\"#11\">大小写转换</a></li>\n<li><a href=\"#12\">Trim操作</a></li>\n<li><a href=\"#13\">ASCII 转换</a></li>\n<li><a href=\"#14\">字符串重复几次</a></li>\n<li><a href=\"#15\">字符或子串在字符串中首次出现的位置或最后一次出现的位置</a></li>\n</ul>\n<p>字符串相关操作需要导入包<code>strings</code></p>","more":"<h3 id=\"0\">字符串长度</h3>    \n\n<ul>\n<li><code>len()</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strLength() &#123;</div><div class=\"line\">\tvar str = &quot;abc&quot;</div><div class=\"line\">\tvar length = len(str)</div><div class=\"line\">\tfmt.Println(length)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"1\">查找</h3>    \n\n<ul>\n<li><code>func Contains(s, substr string) bool</code> 子串substr在s中，返回true</li>\n<li><code>func ContainsAny(s, chars string) bool</code>  chars中任何一个字符在s中，返回true</li>\n<li><code>func ContainsRune(s string, r rune) bool</code>  Unicode代码点r在s中，返回true</li>\n<li><code>func Count(s, sep string) int</code> sep 在s中重复出现的次数(不计算重叠)</li>\n<li><code>func Index(s, sep string)</code> int 在字符串s中查找sep所在的位置, 找不到返回-1</li>\n</ul>\n<blockquote>\n<p>在Go中，查找子串出现次数即字符串模式匹配，实现的是Rabin-Karp算法。<br>另外，Count 是计算子串在字符串中出现的无重叠的次数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">func existSubStringOrChar() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar super = &quot;abcdef!&quot;</div><div class=\"line\">\tvar suba = &quot;abc&quot;</div><div class=\"line\">\tvar subb = &quot;ef!&quot;</div><div class=\"line\"></div><div class=\"line\">\tvar hasa = existSubString(super, suba)</div><div class=\"line\">\tvar hasb = existSubChar(super, subb)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hasa, hasb)</div><div class=\"line\"></div><div class=\"line\">\tvar s = &quot;fivevev&quot;</div><div class=\"line\">\tvar sep1 = &quot;vev&quot;</div><div class=\"line\">\tvar sep2 = &quot;adfd&quot;</div><div class=\"line\"></div><div class=\"line\">\tvar c1 = repeatCount(s, sep1)</div><div class=\"line\">\tvar c2 = repeatCount(s, sep2)</div><div class=\"line\">\tfmt.Println(c1, c2)</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 是否存在某个字符或子串</div><div class=\"line\">func existSubString(superString string, substring string) bool &#123;</div><div class=\"line\">\treturn strings.Contains(superString, substring)</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//substring 是否含有superString 的任意一个字符</div><div class=\"line\">func existSubChar(superString string, substring string) bool &#123;</div><div class=\"line\">\treturn strings.ContainsAny(superString, substring)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//substring 的重复出现次数</div><div class=\"line\">func repeatCount(superString string, substring string) int &#123;</div><div class=\"line\">\treturn strings.Count(superString, substring)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">true true</div><div class=\"line\">1 0</div></pre></td></tr></table></figure>\n<h3 id=\"2\">替换</h3>    \n\n<ul>\n<li><code>strings.Replace(s, old, new, n)</code></li>\n</ul>\n<p><code>s</code>需要替换的字符串   <code>old</code>需要被替换掉的某个子串    <code>new</code>替换的值<br><code>n</code>  <code>n&lt;0</code>全部替换  <code>n==0</code>不替换 <code>n&gt;0</code>全部替换 如果<code>n</code>的下标匹配上old值，则只替换当前下标的字符，如果不是，则全部替换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strReplace() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar str = &quot;cabcdefgabc&quot;</div><div class=\"line\">\tvar value = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, -1)</div><div class=\"line\">\tvar value1 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 0)</div><div class=\"line\">\tvar value2 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 1)</div><div class=\"line\">\tvar value3 = strings.Replace(str, &quot;a&quot;, &quot;v&quot;, 3)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(value, value1, value2, value3)</div><div class=\"line\">\tstrings.Replace(s, old, new, n)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cvbcdefgvbc cabcdefgabc cvbcdefgabc cvbcdefgvbc</div></pre></td></tr></table></figure></p>\n<h3 id=\"3\">分割</h3>\n\n<h4 id=\"Fields-和-FieldsFunc\"><a href=\"#Fields-和-FieldsFunc\" class=\"headerlink\" title=\"Fields 和 FieldsFunc\"></a>Fields 和 FieldsFunc</h4><ul>\n<li>Fields 按空格切割</li>\n<li>FieldsFunc 按照自己指定的方式切割</li>\n</ul>\n<p>实际上，Fields 函数就是调用 FieldsFunc 实现的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func Fields(s string) []string &#123;</div><div class=\"line\">    return FieldsFunc(s, unicode.IsSpace)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strCut() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar str = &quot;abc bde efg&quot;</div><div class=\"line\"></div><div class=\"line\">\tvar cut1 = strings.Fields(str)</div><div class=\"line\"></div><div class=\"line\">\tvar cut2 = strings.FieldsFunc(str, unicode.IsSpace)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(cut1, cut2)</div><div class=\"line\"></div><div class=\"line\">\ts := &quot;ab*cd*ef&quot;</div><div class=\"line\">\tresult := strings.FieldsFunc(s, func(c rune) bool &#123;</div><div class=\"line\">\t\tif c == &apos;h&apos; &#123;</div><div class=\"line\">\t\t\treturn true</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn false</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\tfmt.Println(result)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[abc bde efg] [abc bde efg]</div><div class=\"line\">[ab*cd*ef]</div></pre></td></tr></table></figure></p>\n<h4 id=\"Split-和-SplitAfter、-SplitN-和-SplitAfterN\"><a href=\"#Split-和-SplitAfter、-SplitN-和-SplitAfterN\" class=\"headerlink\" title=\"Split 和 SplitAfter、 SplitN 和 SplitAfterN\"></a>Split 和 SplitAfter、 SplitN 和 SplitAfterN</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">func Split(s, sep string) []string &#123; return genSplit(s, sep, 0, -1) &#125;</div><div class=\"line\">func SplitAfter(s, sep string) []string &#123; return genSplit(s, sep, len(sep), -1) &#125;</div><div class=\"line\">func SplitN(s, sep string, n int) []string &#123; return genSplit(s, sep, 0, n) &#125;</div><div class=\"line\">func SplitAfterN(s, sep string, n int) []string &#123; return genSplit(s, sep,len(sep), n)&#125;</div></pre></td></tr></table></figure>\n<p>它们都调用了 genSplit 函数。<br>这四个函数都是通过 sep 进行分割，返回[]string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split(“abc”,””)，得到的是[a b c]。</p>\n<h5 id=\"功能区分：after-会保留分隔符\"><a href=\"#功能区分：after-会保留分隔符\" class=\"headerlink\" title=\"功能区分：after 会保留分隔符\"></a>功能区分：after 会保留分隔符</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot;foo,bar,baz&quot;, &quot;,&quot;))</div><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.SplitAfter(&quot;foo,bar,baz&quot;, &quot;,&quot;))</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]</div><div class=\"line\">[&quot;foo,&quot; &quot;bar,&quot; &quot;baz&quot;]</div></pre></td></tr></table></figure></p>\n<h5 id=\"N的区别\"><a href=\"#N的区别\" class=\"headerlink\" title=\"N的区别\"></a>N的区别</h5><p><code>N</code> 用来控制分割的个数<br>当 n &lt; 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n &gt; 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割</p>\n<p><code>fmt.Printf(&quot;%q\\n&quot;, strings.SplitN(&quot;foo,bar,baz&quot;, &quot;,&quot;, 2))</code><br>输出：<br><code>[&quot;foo&quot; &quot;bar,baz&quot;]</code></p>\n<p>另外看一下官方文档提供的例子，注意一下输出结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot;a,b,c&quot;, &quot;,&quot;))</div><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot;a man a plan a canal panama&quot;, &quot;a &quot;))</div><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot; xyz &quot;, &quot;&quot;))</div><div class=\"line\">fmt.Printf(&quot;%q\\n&quot;, strings.Split(&quot;&quot;, &quot;Bernardo O&apos;Higgins&quot;))</div></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[&quot;a&quot; &quot;b&quot; &quot;c&quot;]</div><div class=\"line\">[&quot;&quot; &quot;man &quot; &quot;plan &quot; &quot;canal panama&quot;]</div><div class=\"line\">[&quot; &quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot; &quot;]</div><div class=\"line\">[&quot;&quot;]</div></pre></td></tr></table></figure></p>\n<h5 id=\"split总结\"><a href=\"#split总结\" class=\"headerlink\" title=\"split总结\"></a>split总结</h5><p>关于字符串的分割，最常用的就是<code>Split</code>，其他几乎用不到</p>\n<h3 id=\"4\">合并</h3>\n\n<p>将字符串数组（或slice）连接起来可以通过 Join 实现</p>\n<ul>\n<li><code>func Join(a []string, sep string) string</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strJoin() &#123;</div><div class=\"line\">\tvar arr = []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</div><div class=\"line\">\tfmt.Println(arr)</div><div class=\"line\">\t// 用 ‘-’ 拼接</div><div class=\"line\">\tfmt.Println(strings.Join(arr, &quot;-&quot;))</div><div class=\"line\">\t// 直接拼接</div><div class=\"line\">\tfmt.Println(strings.Join(arr, &quot;&quot;))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[a b c]</div><div class=\"line\">a-b-c</div><div class=\"line\">abc</div></pre></td></tr></table></figure></p>\n<h3 id=\"5\">前缀或后缀</h3>    \n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">func presuf() &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar str = &quot;abcdefg&quot;</div><div class=\"line\">\t//判断开始</div><div class=\"line\">\tvar preA = strings.HasPrefix(str, &quot;a&quot;)</div><div class=\"line\"></div><div class=\"line\">\t//判断结尾</div><div class=\"line\">\tvar preG = strings.HasSuffix(str, &quot;g&quot;)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(preA, preG)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><code>true true</code></p>\n<h3 id=\"6\">截取</h3>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">func subString() &#123;</div><div class=\"line\">\t//strings 没有 截取字符串的方法</div><div class=\"line\">\tvar str = &quot;abc中国defgh&quot;</div><div class=\"line\">\t// 将str转为切片处理 这里最好不用byte，byte不支持中文，unicode等</div><div class=\"line\">\tvar strArr = string([]rune(str)[:4])</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(strArr)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">abc中</div></pre></td></tr></table></figure></p>\n<h3 id=\"7\">删除</h3>\n\n<p>strings 包中没有提供删除的方法，只能自己实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">func deleteStrWithRange(s string, start int, end int) string &#123;</div><div class=\"line\">if len(s) == 0 || end &gt; len(s) &#123;</div><div class=\"line\">\treturn &quot;&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">var str1 = string([]rune(s)[:start])</div><div class=\"line\">var str2 = string([]rune(s)[end:])</div><div class=\"line\">return str1 + str2</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var sss = deleteStrWithRange(&quot;012345678&quot;, 1, 3)</div><div class=\"line\">fmt.Println(sss)</div></pre></td></tr></table></figure>\n<p>输出：<br><code>0345678</code></p>\n<h3 id=\"8\">插入</h3>\n\n<p>go strings 包没有插入方法，只能将字符串转化为切片，然后插入元素，再转为string</p>\n<h3 id=\"9\">编码转换</h3>\n\n<p>字符串转换需要用到 <code>strconv</code></p>\n<ul>\n<li>Append 函数表示将给定的类型(如bool, int等)转换为字符串后, 添加在现有的字节数组中[]byte</li>\n<li>Format 函数将给定的类型变量转换为string返回</li>\n<li>Parse 函数将字符串转换为其他类型</li>\n</ul>\n<h4 id=\"unicode-与-中文-互转\"><a href=\"#unicode-与-中文-互转\" class=\"headerlink\" title=\"unicode  与 中文 互转\"></a>unicode  与 中文 互转</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">func chinaeseToUnicode() &#123;</div><div class=\"line\">\tsText := &quot;中文&quot;</div><div class=\"line\">\ttextQuoted := strconv.QuoteToASCII(sText)</div><div class=\"line\">\tfmt.Println(textQuoted)</div><div class=\"line\"></div><div class=\"line\">\ttextUnquoted := textQuoted[1 : len(textQuoted)-1]</div><div class=\"line\">\tfmt.Println(textUnquoted)</div><div class=\"line\"></div><div class=\"line\">\tsUnicodev := strings.Split(textUnquoted, &quot;\\\\u&quot;)</div><div class=\"line\">\tvar context string</div><div class=\"line\">\tfor _, v := range sUnicodev &#123;</div><div class=\"line\">\t\tif len(v) &lt; 1 &#123;</div><div class=\"line\">\t\t\tcontinue</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\ttemp, err := strconv.ParseInt(v, 16, 32)</div><div class=\"line\">\t\tif err != nil &#123;</div><div class=\"line\">\t\t\tpanic(err)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tcontext += fmt.Sprintf(&quot;%c&quot;, temp)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(context)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;\\u4e2d\\u6587&quot;</div><div class=\"line\">\\u4e2d\\u6587</div><div class=\"line\">中文</div></pre></td></tr></table></figure></p>\n<h4 id=\"转码与解码\"><a href=\"#转码与解码\" class=\"headerlink\" title=\"转码与解码\"></a>转码与解码</h4><p>需要导入包 <code>net/url</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">func encodeAndDecode() &#123;</div><div class=\"line\">\tvar str = &quot;https://www.baidu.com/生活&quot;</div><div class=\"line\"></div><div class=\"line\">\t//转码</div><div class=\"line\">\tvar encode = url.QueryEscape(str)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(encode)</div><div class=\"line\"></div><div class=\"line\">\t//解码</div><div class=\"line\">\tdecodeurl, err := url.QueryUnescape(encode)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tpanic(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(decodeurl)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">https%3A%2F%2Fwww.baidu.com%2F%E7%94%9F%E6%B4%BB</div><div class=\"line\">https://www.baidu.com/生活</div></pre></td></tr></table></figure></p>\n<h3 id=\"10\">转换数值类型</h3>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strToValue() &#123;</div><div class=\"line\"></div><div class=\"line\">\t// int 转 string</div><div class=\"line\">\tvar intA int = 123</div><div class=\"line\">\tvar stringA string = strconv.Itoa(intA)</div><div class=\"line\">\tfmt.Println(stringA, reflect.TypeOf(stringA))</div><div class=\"line\"></div><div class=\"line\">\t// string 转 int</div><div class=\"line\"></div><div class=\"line\">\tvar stringB = &quot;45678&quot;</div><div class=\"line\">\tintB, err := strconv.Atoi(stringB)</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tpanic(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(intB, reflect.TypeOf(intB))</div><div class=\"line\"></div><div class=\"line\">\t// string to float</div><div class=\"line\">\tvar stringc = &quot;123.45678&quot;</div><div class=\"line\">\tfloatC, err := strconv.ParseFloat(stringc, 32) //bitSize：指定浮点类型（32:float32、64:float64,</div><div class=\"line\">\tif err != nil &#123;</div><div class=\"line\">\t\tpanic(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(floatC, reflect.TypeOf(floatC))</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">123 string</div><div class=\"line\">45678 int</div><div class=\"line\">123.45678 float64</div></pre></td></tr></table></figure></p>\n<h3 id=\"11\">大小写转换</h3>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 给定字符串转换为英文标题的首字母大写的格式(不能正确处理unicode标点)</div><div class=\"line\">func Title(s string) string</div><div class=\"line\"></div><div class=\"line\">// 所有字母转换为小写</div><div class=\"line\">func ToLower(s string) string</div><div class=\"line\"></div><div class=\"line\">// 所有字母转换为大写</div><div class=\"line\">func ToUpper(s string) string</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">fmt.Println(strings.Title(&quot;her royal highness&quot;))  // Her Royal Highness</div><div class=\"line\"></div><div class=\"line\">fmt.Println(strings.ToLower(&quot;Gopher123&quot;))  // gopher123</div><div class=\"line\"></div><div class=\"line\">fmt.Println(strings.ToUpper(&quot;Gopher&quot;))  // GOPHER</div></pre></td></tr></table></figure>\n<h3 id=\"12\">Trim操作</h3>\n\n<p>bytes提供了有Compare、Count、Equal、Index、Join、Split、Replace等直接针对[]byte类型的函数。还有一个重要的Buffer类，将[]byte类型当作一个缓冲区，提供了对这个缓冲区便捷的操作：读、写、和string/rune之间的转换、迭代等函数。</p>\n<p>在bytes库中，有Trim系列的函数，它的功能是对[]byte类型做裁剪，去除不需要的部分。</p>\n<ul>\n<li><code>func Trim(s string, cutset string) string</code> 去除两边自定义字符</li>\n<li><code>func TrimFunc(s string, f func(rune) bool) string</code> 自定义清除</li>\n<li><code>func TrimLeft(s string, cutset string) string</code> 清除左边</li>\n<li><code>func TrimPrefix(s, prefix string) string</code> 删除前缀</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strtrim() &#123;</div><div class=\"line\">\tvar str = &quot;  ads!/  ;&apos;  jha   asdfhj   &quot;</div><div class=\"line\"></div><div class=\"line\">\t// 去除首尾空格，一般这个最常用</div><div class=\"line\">\tvar value1 = strings.Trim(str, &quot; &quot;)</div><div class=\"line\">\tfmt.Println(value1)</div><div class=\"line\"></div><div class=\"line\">\t//自定义trim</div><div class=\"line\">\tfmt.Println(strings.TrimFunc(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, func(r rune) bool &#123;</div><div class=\"line\">\t\tif r == &apos;&amp;&apos; &#123;</div><div class=\"line\">\t\t\treturn true</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn false</div><div class=\"line\">\t&#125;))</div><div class=\"line\"></div><div class=\"line\">\t//trim 左侧 &amp; 右侧</div><div class=\"line\">\tfmt.Println(strings.TrimLeft(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, &quot;&amp;&quot;))</div><div class=\"line\">\tfmt.Println(strings.TrimRight(&quot;&amp;&amp;&amp;&amp;nihao&amp;&amp;&amp;&amp;&quot;, &quot;&amp;&quot;))</div><div class=\"line\"></div><div class=\"line\">\t//去除前缀，后缀也一样</div><div class=\"line\">\tvar str2 = &quot;xxx_abcd&quot;</div><div class=\"line\">\tif strings.HasPrefix(str2, &quot;xxx_&quot;) &#123;</div><div class=\"line\">\t\tfmt.Println(strings.TrimPrefix(str2, &quot;xxx_&quot;))</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ads!/  ;&apos;  jha   asdfhj</div><div class=\"line\">nihao</div><div class=\"line\">nihao&amp;&amp;&amp;&amp;</div><div class=\"line\">&amp;&amp;&amp;&amp;nihao</div><div class=\"line\">abcd</div></pre></td></tr></table></figure>\n<h3 id=\"13\">ASCII 转换</h3>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strASCII() &#123;</div><div class=\"line\"></div><div class=\"line\">\t//字符转ASCII</div><div class=\"line\">\tvar c rune = &apos;a&apos;</div><div class=\"line\">\tvar i1 = int(c)</div><div class=\"line\">\tfmt.Println(&quot;&apos;a&apos; convert to ASCII&quot;, i1)</div><div class=\"line\"></div><div class=\"line\">\t//ASCII 转字符</div><div class=\"line\">\tvar i int = 98</div><div class=\"line\">\tvar c1 = rune(i)</div><div class=\"line\">\tfmt.Println(&quot;98 convert to string&quot;, string(c1))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;a&apos; convert to ASCII 97</div><div class=\"line\">98 convert to string b</div></pre></td></tr></table></figure>\n<h3 id=\"14\">字符串重复几次</h3>\n\n<ul>\n<li><code>func Repeat(s string, count int) string</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">func strRepeatCount() &#123;</div><div class=\"line\">\tfmt.Println(strings.Repeat(&quot;a&quot;, 2))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出</p>\n<p><code>aa</code></p>\n<h3 id=\"15\">字符或子串在字符串中首次出现的位置或最后一次出现的位置</h3>\n\n<h4 id=\"4个查找第一次出现的位置\"><a href=\"#4个查找第一次出现的位置\" class=\"headerlink\" title=\"4个查找第一次出现的位置\"></a>4个查找第一次出现的位置</h4><p>// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引<br><code>func Index(s, sep string) int</code><br>// chars中任何一个Unicode代码点在s中首次出现的位置<br><code>func IndexAny(s, chars string) int</code><br>// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true<br><code>func IndexFunc(s string, f func(rune) bool) int</code><br>// Unicode 代码点 r 在 s 中第一次出现的位置<br><code>func IndexRune(s string, r rune) int</code></p>\n<p>一般用<code>indexAny</code></p>\n<h4 id=\"3个查找最后一次出现的位置\"><a href=\"#3个查找最后一次出现的位置\" class=\"headerlink\" title=\"3个查找最后一次出现的位置\"></a>3个查找最后一次出现的位置</h4><p><code>func LastIndex(s, sep string) int</code><br><code>func LastIndexAny(s, chars string) int</code><br><code>func LastIndexFunc(s string, f func(rune) bool) int</code></p>\n<p>一般用<code>LastIndexAny</code>就行</p>"},{"title":"对称加密算法AES原理及实现","date":"2018-06-27T10:52:14.000Z","_content":"\n\nAES是作为DES的替代标准出现的，全称Advanced Encryption Standard，即：高级加密标准。AES加密算法，经历了公开的选拔，最终2000年，由比利时密码学家Joan Daemen和Vincent Rijmen设计的Rijndael算法被选中，成为了AES标准。\n　　AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。\n　　\n<!--more-->\n　　\n## 总体结构\n\nAES中没有使用Feistel网络，其结构称为SPN结构。\n　　\n和DES相同，AES也由多个轮组成，其中每个轮分为SubBytes、ShiftRows、MixColumns、AddRoundKey 4个步骤，即：字节代替、行移位、列混淆和轮密钥加。根据密钥长度不同，所需轮数也不同，128位、192位、256位密钥，分别需要10轮、12轮和14轮。第1轮之前有一次AddRoundKey，即轮密钥加，可以视为第0轮；之后1至N-1轮，执行SubBytes、ShiftRows、MixColumns、AddRoundKey；最后一轮仅包括：SubBytes、MixColumns、AddRoundKey。\n　　\nAES总体结构示意图：\n　　\n![结构示意图](http://olgjbx93m.bkt.clouddn.com/201801010001.png)\n\n## 分组密码\n\n密码算法可以分为分组密码和流密码两种\n\n* **分组密码（block cipher）**是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组（block）。一个分组的比特数就称为分组长度（block lenght）。\n\n    例如 DES和3DES的分组长度都是64比特。AES的分组长度为128比特。\n\n* **流密码（stream cipher）**是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特、或32比特等为单位进行加密和解密。\n\n分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；相对地，流密码是对一串数据进行连续处理，因此需要保持内部状态。\n\n## 模式\n\n分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）。\n\n* ECB模式：Electronic CodeBook mode（电子密码模式）\n* CBC模式：Cipher Block Chaining mode（密码分组链接模式）\n* CFB模式：Cipher FeedBack mode（密文反馈模式）\n* OFB模式：Output FeedBack mode（输出反馈模式）\n* CTR模式：CounTeR mode（计数器模式）\n\nECB模式存在很高的风险，下面举例后面4中模式的使用.\n加密的过程中使用了随机流，所以每次加密的密文都不一样\n\n### CBC模式\n```\nfunc main() {\n\n\n\tkey := \"1234567890asdfgh\"\n\tdata := \"hollo, world!\"\n\n\tcry := AesCBCEncrypt([]byte(data), []byte(key))\n\tfmt.Println(hex.EncodeToString(cry))\n\n\toriData := AESCBCDECriypt(cry, []byte(key))\n\tfmt.Println(string(oriData))\n\n}\n// AES也是对称加密 AES 是 DES 的替代品\n// AES 密钥长度 只能是 16、24、32 字节\n//加密\nfunc AesCBCEncrypt(org []byte, key []byte) []byte  {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\t//按照公钥长度 进行分组补码\n\torg = PKCS7Padding(org, block.BlockSize())\n\n\t//设置CBC的加密模式\n\tblockMode := cipher.NewCBCEncrypter(block, key)\n\n\t//加密处理\n\tcrypted := make([]byte, len(org))\n\tblockMode.CryptBlocks(crypted, org)\n\n\treturn crypted\n}\n\n//解密\nfunc AESCBCDECriypt(criptText []byte, key []byte) []byte  {\n\n\t//校验key的有效性\n\tblock,_:=aes.NewCipher(key)\n\t//通过CBC模式解密\n\tblockMode:=cipher.NewCBCDecrypter(block,key)\n\n\t//实现解密\n\torigData:=make([]byte,len(criptText))\n\tblockMode.CryptBlocks(origData,criptText)\n\n\t//去码\n\torigData = PKCS7UnPadding(origData)\n\treturn origData\n}\n\n\n\n\n\n//PKCS5 分组长度只能为8\n//PKCs7 分组长度 1- 255\n\nfunc PKCS7Padding(org []byte, blockSize int) []byte  {\n\n\tpad := blockSize-len(org)%blockSize\n\tpadArr := bytes.Repeat([]byte{byte(pad)}, pad)\n\treturn  append(org, padArr...)\n\n}\n\nfunc PKCS7UnPadding(cryptText []byte) []byte  {\n\t\n\tlength := len(cryptText)\n\tlastByte := cryptText[length - 1]\n\treturn cryptText[:length-int(lastByte)]\n\t\n}\n```\n\n输出\n```\nffa22c136fd3e944255d43e255c98ecc\nhollo, world!\n```\n\n### CFB模式\n```\nfunc main()  {\n\n\n\tkey := []byte(\"1234567890asdfgh\")\n\tdata := []byte(\"abc hello world!\")\n\tcry := AESCFBEncrypt(data, key)\n\n\tfmt.Println(hex.EncodeToString(cry))\n\t//fmt.Println(base64.StdEncoding.EncodeToString(cry))\n\n\tori := AESCFBDecrypt(cry, key)\n\tfmt.Println(string(ori))\n\n}\n\n//CFB分组模式加密\nfunc AESCFBEncrypt(oriData []byte, key []byte) []byte  {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\t//拆分iv和密文\n\tcipherText := make([]byte, aes.BlockSize + len(oriData))\n\n\tiv := cipherText[:aes.BlockSize]\n\n\t//向iv切片数组初始化 reader（随机内存流）\n\tio.ReadFull(rand.Reader, iv)\n\n\t//设置加密模式CFB\n\tstream := cipher.NewCFBEncrypter(block,iv)\n\n\t//加密\n\tstream.XORKeyStream(cipherText[aes.BlockSize:], oriData)\n\n\treturn  cipherText\n\n\n}\n\n//解密\nfunc AESCFBDecrypt(cryptText []byte, key []byte) []byte {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\t//拆分iv 和密文\n\tiv := cryptText[:aes.BlockSize]\n\tcipherText := cryptText[aes.BlockSize:]\n\n\n\t//设置解密模式\n\tstream := cipher.NewCFBDecrypter(block, iv)\n\n\tvar des = make([]byte, len(cipherText))\n\n\t//解密\n\tstream.XORKeyStream(des, cipherText)\n\n\treturn des\n}\n\n```\n输出\n```\n92e5c5d7bc54b337a7edbb548ee1a62c8c3c079b71f465a3f0566c0d74b8d513\nabc hello world!\n```\n\n### OFB模式\n```\nfunc main()  {\n\n\tkey := []byte(\"1234567890asdfgh\")\n\tdata := []byte(\"abcd hello world!\")\n\tcry := AESOFBEncrypt(data, key)\n\n\tfmt.Println(hex.EncodeToString(cry))\n\n\tori := AESOFBDecrypt(cry, key)\n\tfmt.Println(string(ori))\n}\n\n//AES OFB分组加密模式  CTR也是一样\nfunc AESOFBEncrypt(plaintxt []byte, key []byte) []byte  {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\tcipherText := make([]byte, aes.BlockSize + len(plaintxt))\n\n\tiv := cipherText[:aes.BlockSize]\n\n\t//向iv切片数组初始化 reader（随机内存流）\n\tio.ReadFull(rand.Reader, iv)\n\n\t//设置加密模式CFB\n\tstream := cipher.NewOFB(block,iv)\n\n\t//加密\n\tstream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)\n\n\treturn  cipherText\n\n}\n\n\n//解密\nfunc AESOFBDecrypt(cryptText []byte, key []byte) []byte {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\t//拆分iv 和 密文\n\tiv := cryptText[:aes.BlockSize]\n\tplaintxt := make([]byte, len(cryptText)-aes.BlockSize)\n\n\n\t//设置解密模式\n\tstream := cipher.NewOFB(block, iv)\n\n\t//解密\n\tstream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])\n\n\treturn plaintxt\n}\n\n```\n输出\n```\n9ee409f8513e3fcba2f1ba726da0b2a5d80251efa073544220b44c8e8fee18fce4\nabcd hello world!\n```\n\n### CTR模式\n```\nfunc main()  {\n\n\tkey := []byte(\"1234567890asdfgh\")\n\tdata := []byte(\"abcd hello world!\")\n\tcry := AESCTREncrypt(data, key)\n\n\tfmt.Println(hex.EncodeToString(cry))\n\n\tori := AESCTRDecrypt(cry, key)\n\tfmt.Println(string(ori))\n}\n\n//AES CTR分组加密模式\nfunc AESCTREncrypt(plaintxt []byte, key []byte) []byte  {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\tcipherText := make([]byte, aes.BlockSize + len(plaintxt))\n\n\tiv := cipherText[:aes.BlockSize]\n\n\t//向iv切片数组初始化 reader（随机内存流）\n\tio.ReadFull(rand.Reader, iv)\n\n\t//设置加密模式CTR\n\tstream := cipher.NewCTR(block,iv)\n\n\t//加密\n\tstream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)\n\n\treturn  cipherText\n\n}\n\n\n//解密\nfunc AESCTRDecrypt(cryptText []byte, key []byte) []byte {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\t//拆分iv 和 密文\n\tiv := cryptText[:aes.BlockSize]\n\tplaintxt := make([]byte, len(cryptText)-aes.BlockSize)\n\n\n\t//设置解密模式\n\tstream := cipher.NewCTR(block, iv)\n\n\t//解密\n\tstream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])\n\n\treturn plaintxt\n}\n\n```\n输出\n```\nc645da2d14896d2b75d41a538a5a3efe3c7721f51f2eb2e92b0c5b8ba141caf534\nabcd hello world!\n```\n\n\n\n","source":"_posts/对称加密算法AES原理及实现.md","raw":"---\ntitle: 对称加密算法AES原理及实现\ncategories:\n  - 加密算法\ntags:\n  - AES\n  - 对称加密\ndate: 2018-06-27 18:52:14\n---\n\n\nAES是作为DES的替代标准出现的，全称Advanced Encryption Standard，即：高级加密标准。AES加密算法，经历了公开的选拔，最终2000年，由比利时密码学家Joan Daemen和Vincent Rijmen设计的Rijndael算法被选中，成为了AES标准。\n　　AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。\n　　\n<!--more-->\n　　\n## 总体结构\n\nAES中没有使用Feistel网络，其结构称为SPN结构。\n　　\n和DES相同，AES也由多个轮组成，其中每个轮分为SubBytes、ShiftRows、MixColumns、AddRoundKey 4个步骤，即：字节代替、行移位、列混淆和轮密钥加。根据密钥长度不同，所需轮数也不同，128位、192位、256位密钥，分别需要10轮、12轮和14轮。第1轮之前有一次AddRoundKey，即轮密钥加，可以视为第0轮；之后1至N-1轮，执行SubBytes、ShiftRows、MixColumns、AddRoundKey；最后一轮仅包括：SubBytes、MixColumns、AddRoundKey。\n　　\nAES总体结构示意图：\n　　\n![结构示意图](http://olgjbx93m.bkt.clouddn.com/201801010001.png)\n\n## 分组密码\n\n密码算法可以分为分组密码和流密码两种\n\n* **分组密码（block cipher）**是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组（block）。一个分组的比特数就称为分组长度（block lenght）。\n\n    例如 DES和3DES的分组长度都是64比特。AES的分组长度为128比特。\n\n* **流密码（stream cipher）**是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特、或32比特等为单位进行加密和解密。\n\n分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；相对地，流密码是对一串数据进行连续处理，因此需要保持内部状态。\n\n## 模式\n\n分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）。\n\n* ECB模式：Electronic CodeBook mode（电子密码模式）\n* CBC模式：Cipher Block Chaining mode（密码分组链接模式）\n* CFB模式：Cipher FeedBack mode（密文反馈模式）\n* OFB模式：Output FeedBack mode（输出反馈模式）\n* CTR模式：CounTeR mode（计数器模式）\n\nECB模式存在很高的风险，下面举例后面4中模式的使用.\n加密的过程中使用了随机流，所以每次加密的密文都不一样\n\n### CBC模式\n```\nfunc main() {\n\n\n\tkey := \"1234567890asdfgh\"\n\tdata := \"hollo, world!\"\n\n\tcry := AesCBCEncrypt([]byte(data), []byte(key))\n\tfmt.Println(hex.EncodeToString(cry))\n\n\toriData := AESCBCDECriypt(cry, []byte(key))\n\tfmt.Println(string(oriData))\n\n}\n// AES也是对称加密 AES 是 DES 的替代品\n// AES 密钥长度 只能是 16、24、32 字节\n//加密\nfunc AesCBCEncrypt(org []byte, key []byte) []byte  {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\t//按照公钥长度 进行分组补码\n\torg = PKCS7Padding(org, block.BlockSize())\n\n\t//设置CBC的加密模式\n\tblockMode := cipher.NewCBCEncrypter(block, key)\n\n\t//加密处理\n\tcrypted := make([]byte, len(org))\n\tblockMode.CryptBlocks(crypted, org)\n\n\treturn crypted\n}\n\n//解密\nfunc AESCBCDECriypt(criptText []byte, key []byte) []byte  {\n\n\t//校验key的有效性\n\tblock,_:=aes.NewCipher(key)\n\t//通过CBC模式解密\n\tblockMode:=cipher.NewCBCDecrypter(block,key)\n\n\t//实现解密\n\torigData:=make([]byte,len(criptText))\n\tblockMode.CryptBlocks(origData,criptText)\n\n\t//去码\n\torigData = PKCS7UnPadding(origData)\n\treturn origData\n}\n\n\n\n\n\n//PKCS5 分组长度只能为8\n//PKCs7 分组长度 1- 255\n\nfunc PKCS7Padding(org []byte, blockSize int) []byte  {\n\n\tpad := blockSize-len(org)%blockSize\n\tpadArr := bytes.Repeat([]byte{byte(pad)}, pad)\n\treturn  append(org, padArr...)\n\n}\n\nfunc PKCS7UnPadding(cryptText []byte) []byte  {\n\t\n\tlength := len(cryptText)\n\tlastByte := cryptText[length - 1]\n\treturn cryptText[:length-int(lastByte)]\n\t\n}\n```\n\n输出\n```\nffa22c136fd3e944255d43e255c98ecc\nhollo, world!\n```\n\n### CFB模式\n```\nfunc main()  {\n\n\n\tkey := []byte(\"1234567890asdfgh\")\n\tdata := []byte(\"abc hello world!\")\n\tcry := AESCFBEncrypt(data, key)\n\n\tfmt.Println(hex.EncodeToString(cry))\n\t//fmt.Println(base64.StdEncoding.EncodeToString(cry))\n\n\tori := AESCFBDecrypt(cry, key)\n\tfmt.Println(string(ori))\n\n}\n\n//CFB分组模式加密\nfunc AESCFBEncrypt(oriData []byte, key []byte) []byte  {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\t//拆分iv和密文\n\tcipherText := make([]byte, aes.BlockSize + len(oriData))\n\n\tiv := cipherText[:aes.BlockSize]\n\n\t//向iv切片数组初始化 reader（随机内存流）\n\tio.ReadFull(rand.Reader, iv)\n\n\t//设置加密模式CFB\n\tstream := cipher.NewCFBEncrypter(block,iv)\n\n\t//加密\n\tstream.XORKeyStream(cipherText[aes.BlockSize:], oriData)\n\n\treturn  cipherText\n\n\n}\n\n//解密\nfunc AESCFBDecrypt(cryptText []byte, key []byte) []byte {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\t//拆分iv 和密文\n\tiv := cryptText[:aes.BlockSize]\n\tcipherText := cryptText[aes.BlockSize:]\n\n\n\t//设置解密模式\n\tstream := cipher.NewCFBDecrypter(block, iv)\n\n\tvar des = make([]byte, len(cipherText))\n\n\t//解密\n\tstream.XORKeyStream(des, cipherText)\n\n\treturn des\n}\n\n```\n输出\n```\n92e5c5d7bc54b337a7edbb548ee1a62c8c3c079b71f465a3f0566c0d74b8d513\nabc hello world!\n```\n\n### OFB模式\n```\nfunc main()  {\n\n\tkey := []byte(\"1234567890asdfgh\")\n\tdata := []byte(\"abcd hello world!\")\n\tcry := AESOFBEncrypt(data, key)\n\n\tfmt.Println(hex.EncodeToString(cry))\n\n\tori := AESOFBDecrypt(cry, key)\n\tfmt.Println(string(ori))\n}\n\n//AES OFB分组加密模式  CTR也是一样\nfunc AESOFBEncrypt(plaintxt []byte, key []byte) []byte  {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\tcipherText := make([]byte, aes.BlockSize + len(plaintxt))\n\n\tiv := cipherText[:aes.BlockSize]\n\n\t//向iv切片数组初始化 reader（随机内存流）\n\tio.ReadFull(rand.Reader, iv)\n\n\t//设置加密模式CFB\n\tstream := cipher.NewOFB(block,iv)\n\n\t//加密\n\tstream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)\n\n\treturn  cipherText\n\n}\n\n\n//解密\nfunc AESOFBDecrypt(cryptText []byte, key []byte) []byte {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\t//拆分iv 和 密文\n\tiv := cryptText[:aes.BlockSize]\n\tplaintxt := make([]byte, len(cryptText)-aes.BlockSize)\n\n\n\t//设置解密模式\n\tstream := cipher.NewOFB(block, iv)\n\n\t//解密\n\tstream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])\n\n\treturn plaintxt\n}\n\n```\n输出\n```\n9ee409f8513e3fcba2f1ba726da0b2a5d80251efa073544220b44c8e8fee18fce4\nabcd hello world!\n```\n\n### CTR模式\n```\nfunc main()  {\n\n\tkey := []byte(\"1234567890asdfgh\")\n\tdata := []byte(\"abcd hello world!\")\n\tcry := AESCTREncrypt(data, key)\n\n\tfmt.Println(hex.EncodeToString(cry))\n\n\tori := AESCTRDecrypt(cry, key)\n\tfmt.Println(string(ori))\n}\n\n//AES CTR分组加密模式\nfunc AESCTREncrypt(plaintxt []byte, key []byte) []byte  {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\tcipherText := make([]byte, aes.BlockSize + len(plaintxt))\n\n\tiv := cipherText[:aes.BlockSize]\n\n\t//向iv切片数组初始化 reader（随机内存流）\n\tio.ReadFull(rand.Reader, iv)\n\n\t//设置加密模式CTR\n\tstream := cipher.NewCTR(block,iv)\n\n\t//加密\n\tstream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)\n\n\treturn  cipherText\n\n}\n\n\n//解密\nfunc AESCTRDecrypt(cryptText []byte, key []byte) []byte {\n\n\t//校验密钥\n\tblock,_ := aes.NewCipher(key)\n\n\t//拆分iv 和 密文\n\tiv := cryptText[:aes.BlockSize]\n\tplaintxt := make([]byte, len(cryptText)-aes.BlockSize)\n\n\n\t//设置解密模式\n\tstream := cipher.NewCTR(block, iv)\n\n\t//解密\n\tstream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])\n\n\treturn plaintxt\n}\n\n```\n输出\n```\nc645da2d14896d2b75d41a538a5a3efe3c7721f51f2eb2e92b0c5b8ba141caf534\nabcd hello world!\n```\n\n\n\n","slug":"对称加密算法AES原理及实现","published":1,"updated":"2018-06-27T10:53:55.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tfc0030lx609f7vx4p7","content":"<p>AES是作为DES的替代标准出现的，全称Advanced Encryption Standard，即：高级加密标准。AES加密算法，经历了公开的选拔，最终2000年，由比利时密码学家Joan Daemen和Vincent Rijmen设计的Rijndael算法被选中，成为了AES标准。<br>　　AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。<br>　　<br><a id=\"more\"></a>\n　　</p>\n<h2 id=\"总体结构\"><a href=\"#总体结构\" class=\"headerlink\" title=\"总体结构\"></a>总体结构</h2><p>AES中没有使用Feistel网络，其结构称为SPN结构。<br>　　<br>和DES相同，AES也由多个轮组成，其中每个轮分为SubBytes、ShiftRows、MixColumns、AddRoundKey 4个步骤，即：字节代替、行移位、列混淆和轮密钥加。根据密钥长度不同，所需轮数也不同，128位、192位、256位密钥，分别需要10轮、12轮和14轮。第1轮之前有一次AddRoundKey，即轮密钥加，可以视为第0轮；之后1至N-1轮，执行SubBytes、ShiftRows、MixColumns、AddRoundKey；最后一轮仅包括：SubBytes、MixColumns、AddRoundKey。<br>　　<br>AES总体结构示意图：<br>　　<br><img src=\"http://olgjbx93m.bkt.clouddn.com/201801010001.png\" alt=\"结构示意图\"></p>\n<h2 id=\"分组密码\"><a href=\"#分组密码\" class=\"headerlink\" title=\"分组密码\"></a>分组密码</h2><p>密码算法可以分为分组密码和流密码两种</p>\n<ul>\n<li><p><strong>分组密码（block cipher）</strong>是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组（block）。一个分组的比特数就称为分组长度（block lenght）。</p>\n<p>  例如 DES和3DES的分组长度都是64比特。AES的分组长度为128比特。</p>\n</li>\n<li><p><strong>流密码（stream cipher）</strong>是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特、或32比特等为单位进行加密和解密。</p>\n</li>\n</ul>\n<p>分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；相对地，流密码是对一串数据进行连续处理，因此需要保持内部状态。</p>\n<h2 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h2><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）。</p>\n<ul>\n<li>ECB模式：Electronic CodeBook mode（电子密码模式）</li>\n<li>CBC模式：Cipher Block Chaining mode（密码分组链接模式）</li>\n<li>CFB模式：Cipher FeedBack mode（密文反馈模式）</li>\n<li>OFB模式：Output FeedBack mode（输出反馈模式）</li>\n<li>CTR模式：CounTeR mode（计数器模式）</li>\n</ul>\n<p>ECB模式存在很高的风险，下面举例后面4中模式的使用.<br>加密的过程中使用了随机流，所以每次加密的密文都不一样</p>\n<h3 id=\"CBC模式\"><a href=\"#CBC模式\" class=\"headerlink\" title=\"CBC模式\"></a>CBC模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tkey := &quot;1234567890asdfgh&quot;</div><div class=\"line\">\tdata := &quot;hollo, world!&quot;</div><div class=\"line\"></div><div class=\"line\">\tcry := AesCBCEncrypt([]byte(data), []byte(key))</div><div class=\"line\">\tfmt.Println(hex.EncodeToString(cry))</div><div class=\"line\"></div><div class=\"line\">\toriData := AESCBCDECriypt(cry, []byte(key))</div><div class=\"line\">\tfmt.Println(string(oriData))</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">// AES也是对称加密 AES 是 DES 的替代品</div><div class=\"line\">// AES 密钥长度 只能是 16、24、32 字节</div><div class=\"line\">//加密</div><div class=\"line\">func AesCBCEncrypt(org []byte, key []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\t//按照公钥长度 进行分组补码</div><div class=\"line\">\torg = PKCS7Padding(org, block.BlockSize())</div><div class=\"line\"></div><div class=\"line\">\t//设置CBC的加密模式</div><div class=\"line\">\tblockMode := cipher.NewCBCEncrypter(block, key)</div><div class=\"line\"></div><div class=\"line\">\t//加密处理</div><div class=\"line\">\tcrypted := make([]byte, len(org))</div><div class=\"line\">\tblockMode.CryptBlocks(crypted, org)</div><div class=\"line\"></div><div class=\"line\">\treturn crypted</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//解密</div><div class=\"line\">func AESCBCDECriypt(criptText []byte, key []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验key的有效性</div><div class=\"line\">\tblock,_:=aes.NewCipher(key)</div><div class=\"line\">\t//通过CBC模式解密</div><div class=\"line\">\tblockMode:=cipher.NewCBCDecrypter(block,key)</div><div class=\"line\"></div><div class=\"line\">\t//实现解密</div><div class=\"line\">\torigData:=make([]byte,len(criptText))</div><div class=\"line\">\tblockMode.CryptBlocks(origData,criptText)</div><div class=\"line\"></div><div class=\"line\">\t//去码</div><div class=\"line\">\torigData = PKCS7UnPadding(origData)</div><div class=\"line\">\treturn origData</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//PKCS5 分组长度只能为8</div><div class=\"line\">//PKCs7 分组长度 1- 255</div><div class=\"line\"></div><div class=\"line\">func PKCS7Padding(org []byte, blockSize int) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\tpad := blockSize-len(org)%blockSize</div><div class=\"line\">\tpadArr := bytes.Repeat([]byte&#123;byte(pad)&#125;, pad)</div><div class=\"line\">\treturn  append(org, padArr...)</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func PKCS7UnPadding(cryptText []byte) []byte  &#123;</div><div class=\"line\">\t</div><div class=\"line\">\tlength := len(cryptText)</div><div class=\"line\">\tlastByte := cryptText[length - 1]</div><div class=\"line\">\treturn cryptText[:length-int(lastByte)]</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ffa22c136fd3e944255d43e255c98ecc</div><div class=\"line\">hollo, world!</div></pre></td></tr></table></figure></p>\n<h3 id=\"CFB模式\"><a href=\"#CFB模式\" class=\"headerlink\" title=\"CFB模式\"></a>CFB模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tkey := []byte(&quot;1234567890asdfgh&quot;)</div><div class=\"line\">\tdata := []byte(&quot;abc hello world!&quot;)</div><div class=\"line\">\tcry := AESCFBEncrypt(data, key)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(cry))</div><div class=\"line\">\t//fmt.Println(base64.StdEncoding.EncodeToString(cry))</div><div class=\"line\"></div><div class=\"line\">\tori := AESCFBDecrypt(cry, key)</div><div class=\"line\">\tfmt.Println(string(ori))</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//CFB分组模式加密</div><div class=\"line\">func AESCFBEncrypt(oriData []byte, key []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\t//拆分iv和密文</div><div class=\"line\">\tcipherText := make([]byte, aes.BlockSize + len(oriData))</div><div class=\"line\"></div><div class=\"line\">\tiv := cipherText[:aes.BlockSize]</div><div class=\"line\"></div><div class=\"line\">\t//向iv切片数组初始化 reader（随机内存流）</div><div class=\"line\">\tio.ReadFull(rand.Reader, iv)</div><div class=\"line\"></div><div class=\"line\">\t//设置加密模式CFB</div><div class=\"line\">\tstream := cipher.NewCFBEncrypter(block,iv)</div><div class=\"line\"></div><div class=\"line\">\t//加密</div><div class=\"line\">\tstream.XORKeyStream(cipherText[aes.BlockSize:], oriData)</div><div class=\"line\"></div><div class=\"line\">\treturn  cipherText</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//解密</div><div class=\"line\">func AESCFBDecrypt(cryptText []byte, key []byte) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\t//拆分iv 和密文</div><div class=\"line\">\tiv := cryptText[:aes.BlockSize]</div><div class=\"line\">\tcipherText := cryptText[aes.BlockSize:]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//设置解密模式</div><div class=\"line\">\tstream := cipher.NewCFBDecrypter(block, iv)</div><div class=\"line\"></div><div class=\"line\">\tvar des = make([]byte, len(cipherText))</div><div class=\"line\"></div><div class=\"line\">\t//解密</div><div class=\"line\">\tstream.XORKeyStream(des, cipherText)</div><div class=\"line\"></div><div class=\"line\">\treturn des</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">92e5c5d7bc54b337a7edbb548ee1a62c8c3c079b71f465a3f0566c0d74b8d513</div><div class=\"line\">abc hello world!</div></pre></td></tr></table></figure></p>\n<h3 id=\"OFB模式\"><a href=\"#OFB模式\" class=\"headerlink\" title=\"OFB模式\"></a>OFB模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tkey := []byte(&quot;1234567890asdfgh&quot;)</div><div class=\"line\">\tdata := []byte(&quot;abcd hello world!&quot;)</div><div class=\"line\">\tcry := AESOFBEncrypt(data, key)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(cry))</div><div class=\"line\"></div><div class=\"line\">\tori := AESOFBDecrypt(cry, key)</div><div class=\"line\">\tfmt.Println(string(ori))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//AES OFB分组加密模式  CTR也是一样</div><div class=\"line\">func AESOFBEncrypt(plaintxt []byte, key []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\tcipherText := make([]byte, aes.BlockSize + len(plaintxt))</div><div class=\"line\"></div><div class=\"line\">\tiv := cipherText[:aes.BlockSize]</div><div class=\"line\"></div><div class=\"line\">\t//向iv切片数组初始化 reader（随机内存流）</div><div class=\"line\">\tio.ReadFull(rand.Reader, iv)</div><div class=\"line\"></div><div class=\"line\">\t//设置加密模式CFB</div><div class=\"line\">\tstream := cipher.NewOFB(block,iv)</div><div class=\"line\"></div><div class=\"line\">\t//加密</div><div class=\"line\">\tstream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)</div><div class=\"line\"></div><div class=\"line\">\treturn  cipherText</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//解密</div><div class=\"line\">func AESOFBDecrypt(cryptText []byte, key []byte) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\t//拆分iv 和 密文</div><div class=\"line\">\tiv := cryptText[:aes.BlockSize]</div><div class=\"line\">\tplaintxt := make([]byte, len(cryptText)-aes.BlockSize)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//设置解密模式</div><div class=\"line\">\tstream := cipher.NewOFB(block, iv)</div><div class=\"line\"></div><div class=\"line\">\t//解密</div><div class=\"line\">\tstream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])</div><div class=\"line\"></div><div class=\"line\">\treturn plaintxt</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">9ee409f8513e3fcba2f1ba726da0b2a5d80251efa073544220b44c8e8fee18fce4</div><div class=\"line\">abcd hello world!</div></pre></td></tr></table></figure></p>\n<h3 id=\"CTR模式\"><a href=\"#CTR模式\" class=\"headerlink\" title=\"CTR模式\"></a>CTR模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tkey := []byte(&quot;1234567890asdfgh&quot;)</div><div class=\"line\">\tdata := []byte(&quot;abcd hello world!&quot;)</div><div class=\"line\">\tcry := AESCTREncrypt(data, key)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(cry))</div><div class=\"line\"></div><div class=\"line\">\tori := AESCTRDecrypt(cry, key)</div><div class=\"line\">\tfmt.Println(string(ori))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//AES CTR分组加密模式</div><div class=\"line\">func AESCTREncrypt(plaintxt []byte, key []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\tcipherText := make([]byte, aes.BlockSize + len(plaintxt))</div><div class=\"line\"></div><div class=\"line\">\tiv := cipherText[:aes.BlockSize]</div><div class=\"line\"></div><div class=\"line\">\t//向iv切片数组初始化 reader（随机内存流）</div><div class=\"line\">\tio.ReadFull(rand.Reader, iv)</div><div class=\"line\"></div><div class=\"line\">\t//设置加密模式CTR</div><div class=\"line\">\tstream := cipher.NewCTR(block,iv)</div><div class=\"line\"></div><div class=\"line\">\t//加密</div><div class=\"line\">\tstream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)</div><div class=\"line\"></div><div class=\"line\">\treturn  cipherText</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//解密</div><div class=\"line\">func AESCTRDecrypt(cryptText []byte, key []byte) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\t//拆分iv 和 密文</div><div class=\"line\">\tiv := cryptText[:aes.BlockSize]</div><div class=\"line\">\tplaintxt := make([]byte, len(cryptText)-aes.BlockSize)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//设置解密模式</div><div class=\"line\">\tstream := cipher.NewCTR(block, iv)</div><div class=\"line\"></div><div class=\"line\">\t//解密</div><div class=\"line\">\tstream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])</div><div class=\"line\"></div><div class=\"line\">\treturn plaintxt</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">c645da2d14896d2b75d41a538a5a3efe3c7721f51f2eb2e92b0c5b8ba141caf534</div><div class=\"line\">abcd hello world!</div></pre></td></tr></table></figure></p>\n","excerpt":"<p>AES是作为DES的替代标准出现的，全称Advanced Encryption Standard，即：高级加密标准。AES加密算法，经历了公开的选拔，最终2000年，由比利时密码学家Joan Daemen和Vincent Rijmen设计的Rijndael算法被选中，成为了AES标准。<br>　　AES明文分组长度为128位，即16个字节，密钥长度可以为16个字节、24个字节、或32个字节，即128位密钥、192位密钥、或256位密钥。<br>　　<br>","more":"</p>\n<h2 id=\"总体结构\"><a href=\"#总体结构\" class=\"headerlink\" title=\"总体结构\"></a>总体结构</h2><p>AES中没有使用Feistel网络，其结构称为SPN结构。<br>　　<br>和DES相同，AES也由多个轮组成，其中每个轮分为SubBytes、ShiftRows、MixColumns、AddRoundKey 4个步骤，即：字节代替、行移位、列混淆和轮密钥加。根据密钥长度不同，所需轮数也不同，128位、192位、256位密钥，分别需要10轮、12轮和14轮。第1轮之前有一次AddRoundKey，即轮密钥加，可以视为第0轮；之后1至N-1轮，执行SubBytes、ShiftRows、MixColumns、AddRoundKey；最后一轮仅包括：SubBytes、MixColumns、AddRoundKey。<br>　　<br>AES总体结构示意图：<br>　　<br><img src=\"http://olgjbx93m.bkt.clouddn.com/201801010001.png\" alt=\"结构示意图\"></p>\n<h2 id=\"分组密码\"><a href=\"#分组密码\" class=\"headerlink\" title=\"分组密码\"></a>分组密码</h2><p>密码算法可以分为分组密码和流密码两种</p>\n<ul>\n<li><p><strong>分组密码（block cipher）</strong>是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”就称为分组（block）。一个分组的比特数就称为分组长度（block lenght）。</p>\n<p>  例如 DES和3DES的分组长度都是64比特。AES的分组长度为128比特。</p>\n</li>\n<li><p><strong>流密码（stream cipher）</strong>是对数据流进行连续处理的一类密码算法。流密码中一般以1比特、8比特、或32比特等为单位进行加密和解密。</p>\n</li>\n</ul>\n<p>分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度；相对地，流密码是对一串数据进行连续处理，因此需要保持内部状态。</p>\n<h2 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h2><p>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）。</p>\n<ul>\n<li>ECB模式：Electronic CodeBook mode（电子密码模式）</li>\n<li>CBC模式：Cipher Block Chaining mode（密码分组链接模式）</li>\n<li>CFB模式：Cipher FeedBack mode（密文反馈模式）</li>\n<li>OFB模式：Output FeedBack mode（输出反馈模式）</li>\n<li>CTR模式：CounTeR mode（计数器模式）</li>\n</ul>\n<p>ECB模式存在很高的风险，下面举例后面4中模式的使用.<br>加密的过程中使用了随机流，所以每次加密的密文都不一样</p>\n<h3 id=\"CBC模式\"><a href=\"#CBC模式\" class=\"headerlink\" title=\"CBC模式\"></a>CBC模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main() &#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tkey := &quot;1234567890asdfgh&quot;</div><div class=\"line\">\tdata := &quot;hollo, world!&quot;</div><div class=\"line\"></div><div class=\"line\">\tcry := AesCBCEncrypt([]byte(data), []byte(key))</div><div class=\"line\">\tfmt.Println(hex.EncodeToString(cry))</div><div class=\"line\"></div><div class=\"line\">\toriData := AESCBCDECriypt(cry, []byte(key))</div><div class=\"line\">\tfmt.Println(string(oriData))</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">// AES也是对称加密 AES 是 DES 的替代品</div><div class=\"line\">// AES 密钥长度 只能是 16、24、32 字节</div><div class=\"line\">//加密</div><div class=\"line\">func AesCBCEncrypt(org []byte, key []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\t//按照公钥长度 进行分组补码</div><div class=\"line\">\torg = PKCS7Padding(org, block.BlockSize())</div><div class=\"line\"></div><div class=\"line\">\t//设置CBC的加密模式</div><div class=\"line\">\tblockMode := cipher.NewCBCEncrypter(block, key)</div><div class=\"line\"></div><div class=\"line\">\t//加密处理</div><div class=\"line\">\tcrypted := make([]byte, len(org))</div><div class=\"line\">\tblockMode.CryptBlocks(crypted, org)</div><div class=\"line\"></div><div class=\"line\">\treturn crypted</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//解密</div><div class=\"line\">func AESCBCDECriypt(criptText []byte, key []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验key的有效性</div><div class=\"line\">\tblock,_:=aes.NewCipher(key)</div><div class=\"line\">\t//通过CBC模式解密</div><div class=\"line\">\tblockMode:=cipher.NewCBCDecrypter(block,key)</div><div class=\"line\"></div><div class=\"line\">\t//实现解密</div><div class=\"line\">\torigData:=make([]byte,len(criptText))</div><div class=\"line\">\tblockMode.CryptBlocks(origData,criptText)</div><div class=\"line\"></div><div class=\"line\">\t//去码</div><div class=\"line\">\torigData = PKCS7UnPadding(origData)</div><div class=\"line\">\treturn origData</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//PKCS5 分组长度只能为8</div><div class=\"line\">//PKCs7 分组长度 1- 255</div><div class=\"line\"></div><div class=\"line\">func PKCS7Padding(org []byte, blockSize int) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\tpad := blockSize-len(org)%blockSize</div><div class=\"line\">\tpadArr := bytes.Repeat([]byte&#123;byte(pad)&#125;, pad)</div><div class=\"line\">\treturn  append(org, padArr...)</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func PKCS7UnPadding(cryptText []byte) []byte  &#123;</div><div class=\"line\">\t</div><div class=\"line\">\tlength := len(cryptText)</div><div class=\"line\">\tlastByte := cryptText[length - 1]</div><div class=\"line\">\treturn cryptText[:length-int(lastByte)]</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ffa22c136fd3e944255d43e255c98ecc</div><div class=\"line\">hollo, world!</div></pre></td></tr></table></figure></p>\n<h3 id=\"CFB模式\"><a href=\"#CFB模式\" class=\"headerlink\" title=\"CFB模式\"></a>CFB模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tkey := []byte(&quot;1234567890asdfgh&quot;)</div><div class=\"line\">\tdata := []byte(&quot;abc hello world!&quot;)</div><div class=\"line\">\tcry := AESCFBEncrypt(data, key)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(cry))</div><div class=\"line\">\t//fmt.Println(base64.StdEncoding.EncodeToString(cry))</div><div class=\"line\"></div><div class=\"line\">\tori := AESCFBDecrypt(cry, key)</div><div class=\"line\">\tfmt.Println(string(ori))</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//CFB分组模式加密</div><div class=\"line\">func AESCFBEncrypt(oriData []byte, key []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\t//拆分iv和密文</div><div class=\"line\">\tcipherText := make([]byte, aes.BlockSize + len(oriData))</div><div class=\"line\"></div><div class=\"line\">\tiv := cipherText[:aes.BlockSize]</div><div class=\"line\"></div><div class=\"line\">\t//向iv切片数组初始化 reader（随机内存流）</div><div class=\"line\">\tio.ReadFull(rand.Reader, iv)</div><div class=\"line\"></div><div class=\"line\">\t//设置加密模式CFB</div><div class=\"line\">\tstream := cipher.NewCFBEncrypter(block,iv)</div><div class=\"line\"></div><div class=\"line\">\t//加密</div><div class=\"line\">\tstream.XORKeyStream(cipherText[aes.BlockSize:], oriData)</div><div class=\"line\"></div><div class=\"line\">\treturn  cipherText</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//解密</div><div class=\"line\">func AESCFBDecrypt(cryptText []byte, key []byte) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\t//拆分iv 和密文</div><div class=\"line\">\tiv := cryptText[:aes.BlockSize]</div><div class=\"line\">\tcipherText := cryptText[aes.BlockSize:]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//设置解密模式</div><div class=\"line\">\tstream := cipher.NewCFBDecrypter(block, iv)</div><div class=\"line\"></div><div class=\"line\">\tvar des = make([]byte, len(cipherText))</div><div class=\"line\"></div><div class=\"line\">\t//解密</div><div class=\"line\">\tstream.XORKeyStream(des, cipherText)</div><div class=\"line\"></div><div class=\"line\">\treturn des</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">92e5c5d7bc54b337a7edbb548ee1a62c8c3c079b71f465a3f0566c0d74b8d513</div><div class=\"line\">abc hello world!</div></pre></td></tr></table></figure></p>\n<h3 id=\"OFB模式\"><a href=\"#OFB模式\" class=\"headerlink\" title=\"OFB模式\"></a>OFB模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tkey := []byte(&quot;1234567890asdfgh&quot;)</div><div class=\"line\">\tdata := []byte(&quot;abcd hello world!&quot;)</div><div class=\"line\">\tcry := AESOFBEncrypt(data, key)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(cry))</div><div class=\"line\"></div><div class=\"line\">\tori := AESOFBDecrypt(cry, key)</div><div class=\"line\">\tfmt.Println(string(ori))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//AES OFB分组加密模式  CTR也是一样</div><div class=\"line\">func AESOFBEncrypt(plaintxt []byte, key []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\tcipherText := make([]byte, aes.BlockSize + len(plaintxt))</div><div class=\"line\"></div><div class=\"line\">\tiv := cipherText[:aes.BlockSize]</div><div class=\"line\"></div><div class=\"line\">\t//向iv切片数组初始化 reader（随机内存流）</div><div class=\"line\">\tio.ReadFull(rand.Reader, iv)</div><div class=\"line\"></div><div class=\"line\">\t//设置加密模式CFB</div><div class=\"line\">\tstream := cipher.NewOFB(block,iv)</div><div class=\"line\"></div><div class=\"line\">\t//加密</div><div class=\"line\">\tstream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)</div><div class=\"line\"></div><div class=\"line\">\treturn  cipherText</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//解密</div><div class=\"line\">func AESOFBDecrypt(cryptText []byte, key []byte) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\t//拆分iv 和 密文</div><div class=\"line\">\tiv := cryptText[:aes.BlockSize]</div><div class=\"line\">\tplaintxt := make([]byte, len(cryptText)-aes.BlockSize)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//设置解密模式</div><div class=\"line\">\tstream := cipher.NewOFB(block, iv)</div><div class=\"line\"></div><div class=\"line\">\t//解密</div><div class=\"line\">\tstream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])</div><div class=\"line\"></div><div class=\"line\">\treturn plaintxt</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">9ee409f8513e3fcba2f1ba726da0b2a5d80251efa073544220b44c8e8fee18fce4</div><div class=\"line\">abcd hello world!</div></pre></td></tr></table></figure></p>\n<h3 id=\"CTR模式\"><a href=\"#CTR模式\" class=\"headerlink\" title=\"CTR模式\"></a>CTR模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tkey := []byte(&quot;1234567890asdfgh&quot;)</div><div class=\"line\">\tdata := []byte(&quot;abcd hello world!&quot;)</div><div class=\"line\">\tcry := AESCTREncrypt(data, key)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(cry))</div><div class=\"line\"></div><div class=\"line\">\tori := AESCTRDecrypt(cry, key)</div><div class=\"line\">\tfmt.Println(string(ori))</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//AES CTR分组加密模式</div><div class=\"line\">func AESCTREncrypt(plaintxt []byte, key []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\tcipherText := make([]byte, aes.BlockSize + len(plaintxt))</div><div class=\"line\"></div><div class=\"line\">\tiv := cipherText[:aes.BlockSize]</div><div class=\"line\"></div><div class=\"line\">\t//向iv切片数组初始化 reader（随机内存流）</div><div class=\"line\">\tio.ReadFull(rand.Reader, iv)</div><div class=\"line\"></div><div class=\"line\">\t//设置加密模式CTR</div><div class=\"line\">\tstream := cipher.NewCTR(block,iv)</div><div class=\"line\"></div><div class=\"line\">\t//加密</div><div class=\"line\">\tstream.XORKeyStream(cipherText[aes.BlockSize:], plaintxt)</div><div class=\"line\"></div><div class=\"line\">\treturn  cipherText</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//解密</div><div class=\"line\">func AESCTRDecrypt(cryptText []byte, key []byte) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock,_ := aes.NewCipher(key)</div><div class=\"line\"></div><div class=\"line\">\t//拆分iv 和 密文</div><div class=\"line\">\tiv := cryptText[:aes.BlockSize]</div><div class=\"line\">\tplaintxt := make([]byte, len(cryptText)-aes.BlockSize)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t//设置解密模式</div><div class=\"line\">\tstream := cipher.NewCTR(block, iv)</div><div class=\"line\"></div><div class=\"line\">\t//解密</div><div class=\"line\">\tstream.XORKeyStream(plaintxt, cryptText[aes.BlockSize:])</div><div class=\"line\"></div><div class=\"line\">\treturn plaintxt</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">c645da2d14896d2b75d41a538a5a3efe3c7721f51f2eb2e92b0c5b8ba141caf534</div><div class=\"line\">abcd hello world!</div></pre></td></tr></table></figure></p>"},{"title":"对称加密算法DES原理及实现","date":"2018-06-26T11:24:12.000Z","_content":"## DES加密算法\n\nDES加密算法，为对称加密算法中的一种。70年代初由IBM研发，后1977年被美国国家标准局采纳为数据加密标准，即DES全称的由来：Data Encryption Standard。对称加密算法，是相对于非对称加密算法而言的。两者区别在于，对称加密在加密和解密时使用同一密钥，而非对称加密在加密和解密时使用不同的密钥，即公钥和私钥。常见的DES、3DES、AES均为对称加密算法，而RSA、椭圆曲线加密算法，均为非对称加密算法。\n \n　　DES是以64比特的明文为一个单位来进行加密的，超过64比特的数据，要求按固定的64比特的大小分组，分组有很多模式，后续单独总结，暂时先介绍DES加密算法。DES使用的密钥长度为64比特，但由于每隔7个比特设置一个奇偶校验位，因此其密钥长度实际为56比特。奇偶校验为最简单的错误检测码，即根据一组二进制代码中1的个数是奇数或偶数来检测错误。\n　　\n<!--more-->\n\n## Feistel网络\n\nDES的基本结构，由IBM公司的Horst Feistel设计，因此称Feistel网络。在Feistel网络中，加密的每个步骤称为轮，经过初始置换后的64位明文，进行了16轮Feistel轮的加密过程，最后经过终结置换后形成最终的64位密文。如下为Feistel网络的示意图：\n\n![](http://olgjbx93m.bkt.clouddn.com/5f65e67ee5cbf1514c5614e944684cc1af2a4096.jpg)  \n\n64位明文被分为左、右两部分处理，右侧数据和子密钥经过轮函数f生成用于加密左侧数据的比特序列，与左侧数据异或运算，运算结果输出为加密后的左侧，右侧数据则直接输出为右侧。\n　　其中子密钥为本轮加密使用的密钥，每次Feistel均使用不同的子密钥。子密钥的计算，以及轮函数的细节，稍后下文介绍。由于一次Feistel轮并不会加密右侧，因此需要将上一轮输出后的左右两侧对调后，重复Feistel轮的过程，DES算法共计进行16次Feistel轮，最后一轮输出后左右两侧无需对调。\n\nDES加密和解密的过程一致，均使用Feistel网络实现，区别仅在于解密时，密文作为输入，并逆序使用子密钥。\n\n## DES 加密算法的使用\n在使用DES加密前，需要自己实现对明文的补码和去码操作\n\n补码\n```\n//实现PKCS5Padding补码\nfunc PKCS5Padding(cipherTxt [] byte, blockSize int) []byte {\n\t//计算准备添加的数字\n\tpadding := blockSize - len(cipherTxt)%blockSize\n\n\t//得到补码\n\tpadTxt := bytes.Repeat([]byte{byte(padding)}, padding)\n\n\t//拼接原文与补码\n\tvar byteTxt = append(cipherTxt, padTxt...)\n\n\treturn byteTxt\n\n}\n```\n\n去码\n```\n//PKCS5Unpadding 去码\nfunc PKCS5UnPadding(cipherTxt []byte) []byte {\n\tvar l = len(cipherTxt)\n\tvar txt = int(cipherTxt[l-1])\n\tres := cipherTxt[:l-txt]\n\treturn res\n}\n```\n\nDES加密\n```\n// key 必须为8位\nfunc EnDESEncrypt (origData []byte, key []byte) []byte {\n\n\t//校验密钥\n\tblock, _ := des.NewCipher(key)\n\t//设置补码\n\torigData = MyDES.PKCS5Padding(origData, block.BlockSize())\n\t//设置CBC加密模式\n\tblockMode := cipher.NewCBCEncrypter(block, key)\n\n\t//加密明文\n\tcrypted := make([]byte, len(origData))\n\n\tblockMode.CryptBlocks(crypted, origData)\n\n\treturn crypted\n\n}\n```\n\n\nDES解密\n```\nfunc DeDESCriypt(cript []byte, key []byte) []byte  {\n\t//校验key的有效性\n\tblock,_:=des.NewCipher(key)\n\t//通过CBC模式解密\n\tblockMode:=cipher.NewCBCDecrypter(block,key)\n\n\t//实现解密\n\torigData:=make([]byte,len(cript))\n\tblockMode.CryptBlocks(origData,cript)\n\n\t//去码\n\torigData = MyDES.PKCS5UnPadding(origData)\n\treturn origData\n}\n```\n\n使用\n```\nfunc main()  {\n\n\tkey := []byte(\"aswedrfg\")\n\tvar data =[]byte(\"hello world\")\n\tvar cipherTxt = EnDESEncrypt(data,key)\n\tfmt.Println(\"加密的结果：\",hex.EncodeToString( cipherTxt))\n\n\tvar origData=DeDESCriypt(cipherTxt,key)\n\tfmt.Println(\"解密后的结果为:\",string(origData))\n}\n```\n\n输出结果\n```\n加密的结果： 935ae7ca3229f6c707bb9de9db9693c7\n解密后的结果为: hello world\n```\n\n## 根据DES原理自己实现加密解密过程\n\n加密\n```\nfunc EnCrypt(key string, data []byte) []byte {\n\n\tvar sum = 0\n\tfor i := 0; i < len(key); i++ {\n\t\tsum += int(key[i])\n\t}\n\t// 对明文进行补码\n\tvar pad = PKCS5Padding(data, len(key))\n\t//通过加法，实现简单加密\n\tfor i := 0;i<len(pad);i++{\n\t\tpad[i] = pad[i]+byte(sum)\n\t}\n\treturn pad\n}\n```\n\n解密\n```\nfunc Decrypt(cipherTxt []byte,key string) []byte {\n\n\tfmt.Println(\"???\",cipherTxt)\n\t//计算key的总和\n\tvar sum =0\n\tfor i:=0;i<len(key);i++ {\n\t\tsum += int(key[i])\n\t}\n\n\t//减法运算\n\tfor i:=0;i<len(cipherTxt);i++{\n\t\tcipherTxt[i]=cipherTxt[i]-byte(sum)\n\t}\n\tfmt.Println(\"???\",cipherTxt)\n\t//去码\n\tvar p = PKCS5UnPadding(cipherTxt)\n\treturn p\n}\n```\n\n## 3DES\n\n### 3DES加密\nDES是一个经典的对称加密算法，但也缺陷明显，即56位的密钥安全性不足，已被证实可以在短时间内破解。为解决此问题，出现了3DES，也称Triple DES，3DES为DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密。为了兼容普通的DES，3DES并没有直接使用 `加密->加密->加密` 的方式，而是采用了`加密->解密->加密` 的方式。\n\n![](http://oscd4dgpc.bkt.clouddn.com/00f3fb2538ec90b80eb9.jpg)\n\n当三重密钥均相同时，前两步相互抵消，相当于仅实现了一次加密，因此可实现对普通DES加密算法的兼容。\n\n![](http://oscd4dgpc.bkt.clouddn.com/7de5d8dfcd0bd221596384.jpg)\n\n### 3DES解密\n\n3DES解密过程，与加密过程相反，即逆序使用密钥。是以密钥3、密钥2、密钥1的顺序执行 `解密->加密->解密`。\n\n![](http://oscd4dgpc.bkt.clouddn.com/WX20180216-083713.png)\n\n相比DES，3DES因密钥长度变长，安全性有所提高，但其处理速度不高。因此又出现了AES加密算法，AES较于3DES速度更快、安全性更高。\n\n\n\n","source":"_posts/对称加密算法DES原理及实现.md","raw":"---\ntitle: 对称加密算法DES原理及实现\ncategories:\n  - 加密算法\ntags:\n  - 对称加密\n  - DES\n  - 3DES\ndate: 2018-06-26 19:24:12\n---\n## DES加密算法\n\nDES加密算法，为对称加密算法中的一种。70年代初由IBM研发，后1977年被美国国家标准局采纳为数据加密标准，即DES全称的由来：Data Encryption Standard。对称加密算法，是相对于非对称加密算法而言的。两者区别在于，对称加密在加密和解密时使用同一密钥，而非对称加密在加密和解密时使用不同的密钥，即公钥和私钥。常见的DES、3DES、AES均为对称加密算法，而RSA、椭圆曲线加密算法，均为非对称加密算法。\n \n　　DES是以64比特的明文为一个单位来进行加密的，超过64比特的数据，要求按固定的64比特的大小分组，分组有很多模式，后续单独总结，暂时先介绍DES加密算法。DES使用的密钥长度为64比特，但由于每隔7个比特设置一个奇偶校验位，因此其密钥长度实际为56比特。奇偶校验为最简单的错误检测码，即根据一组二进制代码中1的个数是奇数或偶数来检测错误。\n　　\n<!--more-->\n\n## Feistel网络\n\nDES的基本结构，由IBM公司的Horst Feistel设计，因此称Feistel网络。在Feistel网络中，加密的每个步骤称为轮，经过初始置换后的64位明文，进行了16轮Feistel轮的加密过程，最后经过终结置换后形成最终的64位密文。如下为Feistel网络的示意图：\n\n![](http://olgjbx93m.bkt.clouddn.com/5f65e67ee5cbf1514c5614e944684cc1af2a4096.jpg)  \n\n64位明文被分为左、右两部分处理，右侧数据和子密钥经过轮函数f生成用于加密左侧数据的比特序列，与左侧数据异或运算，运算结果输出为加密后的左侧，右侧数据则直接输出为右侧。\n　　其中子密钥为本轮加密使用的密钥，每次Feistel均使用不同的子密钥。子密钥的计算，以及轮函数的细节，稍后下文介绍。由于一次Feistel轮并不会加密右侧，因此需要将上一轮输出后的左右两侧对调后，重复Feistel轮的过程，DES算法共计进行16次Feistel轮，最后一轮输出后左右两侧无需对调。\n\nDES加密和解密的过程一致，均使用Feistel网络实现，区别仅在于解密时，密文作为输入，并逆序使用子密钥。\n\n## DES 加密算法的使用\n在使用DES加密前，需要自己实现对明文的补码和去码操作\n\n补码\n```\n//实现PKCS5Padding补码\nfunc PKCS5Padding(cipherTxt [] byte, blockSize int) []byte {\n\t//计算准备添加的数字\n\tpadding := blockSize - len(cipherTxt)%blockSize\n\n\t//得到补码\n\tpadTxt := bytes.Repeat([]byte{byte(padding)}, padding)\n\n\t//拼接原文与补码\n\tvar byteTxt = append(cipherTxt, padTxt...)\n\n\treturn byteTxt\n\n}\n```\n\n去码\n```\n//PKCS5Unpadding 去码\nfunc PKCS5UnPadding(cipherTxt []byte) []byte {\n\tvar l = len(cipherTxt)\n\tvar txt = int(cipherTxt[l-1])\n\tres := cipherTxt[:l-txt]\n\treturn res\n}\n```\n\nDES加密\n```\n// key 必须为8位\nfunc EnDESEncrypt (origData []byte, key []byte) []byte {\n\n\t//校验密钥\n\tblock, _ := des.NewCipher(key)\n\t//设置补码\n\torigData = MyDES.PKCS5Padding(origData, block.BlockSize())\n\t//设置CBC加密模式\n\tblockMode := cipher.NewCBCEncrypter(block, key)\n\n\t//加密明文\n\tcrypted := make([]byte, len(origData))\n\n\tblockMode.CryptBlocks(crypted, origData)\n\n\treturn crypted\n\n}\n```\n\n\nDES解密\n```\nfunc DeDESCriypt(cript []byte, key []byte) []byte  {\n\t//校验key的有效性\n\tblock,_:=des.NewCipher(key)\n\t//通过CBC模式解密\n\tblockMode:=cipher.NewCBCDecrypter(block,key)\n\n\t//实现解密\n\torigData:=make([]byte,len(cript))\n\tblockMode.CryptBlocks(origData,cript)\n\n\t//去码\n\torigData = MyDES.PKCS5UnPadding(origData)\n\treturn origData\n}\n```\n\n使用\n```\nfunc main()  {\n\n\tkey := []byte(\"aswedrfg\")\n\tvar data =[]byte(\"hello world\")\n\tvar cipherTxt = EnDESEncrypt(data,key)\n\tfmt.Println(\"加密的结果：\",hex.EncodeToString( cipherTxt))\n\n\tvar origData=DeDESCriypt(cipherTxt,key)\n\tfmt.Println(\"解密后的结果为:\",string(origData))\n}\n```\n\n输出结果\n```\n加密的结果： 935ae7ca3229f6c707bb9de9db9693c7\n解密后的结果为: hello world\n```\n\n## 根据DES原理自己实现加密解密过程\n\n加密\n```\nfunc EnCrypt(key string, data []byte) []byte {\n\n\tvar sum = 0\n\tfor i := 0; i < len(key); i++ {\n\t\tsum += int(key[i])\n\t}\n\t// 对明文进行补码\n\tvar pad = PKCS5Padding(data, len(key))\n\t//通过加法，实现简单加密\n\tfor i := 0;i<len(pad);i++{\n\t\tpad[i] = pad[i]+byte(sum)\n\t}\n\treturn pad\n}\n```\n\n解密\n```\nfunc Decrypt(cipherTxt []byte,key string) []byte {\n\n\tfmt.Println(\"???\",cipherTxt)\n\t//计算key的总和\n\tvar sum =0\n\tfor i:=0;i<len(key);i++ {\n\t\tsum += int(key[i])\n\t}\n\n\t//减法运算\n\tfor i:=0;i<len(cipherTxt);i++{\n\t\tcipherTxt[i]=cipherTxt[i]-byte(sum)\n\t}\n\tfmt.Println(\"???\",cipherTxt)\n\t//去码\n\tvar p = PKCS5UnPadding(cipherTxt)\n\treturn p\n}\n```\n\n## 3DES\n\n### 3DES加密\nDES是一个经典的对称加密算法，但也缺陷明显，即56位的密钥安全性不足，已被证实可以在短时间内破解。为解决此问题，出现了3DES，也称Triple DES，3DES为DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密。为了兼容普通的DES，3DES并没有直接使用 `加密->加密->加密` 的方式，而是采用了`加密->解密->加密` 的方式。\n\n![](http://oscd4dgpc.bkt.clouddn.com/00f3fb2538ec90b80eb9.jpg)\n\n当三重密钥均相同时，前两步相互抵消，相当于仅实现了一次加密，因此可实现对普通DES加密算法的兼容。\n\n![](http://oscd4dgpc.bkt.clouddn.com/7de5d8dfcd0bd221596384.jpg)\n\n### 3DES解密\n\n3DES解密过程，与加密过程相反，即逆序使用密钥。是以密钥3、密钥2、密钥1的顺序执行 `解密->加密->解密`。\n\n![](http://oscd4dgpc.bkt.clouddn.com/WX20180216-083713.png)\n\n相比DES，3DES因密钥长度变长，安全性有所提高，但其处理速度不高。因此又出现了AES加密算法，AES较于3DES速度更快、安全性更高。\n\n\n\n","slug":"对称加密算法DES原理及实现","published":1,"updated":"2018-06-27T10:50:44.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tfd0033lx60ihwb6yj9","content":"<h2 id=\"DES加密算法\"><a href=\"#DES加密算法\" class=\"headerlink\" title=\"DES加密算法\"></a>DES加密算法</h2><p>DES加密算法，为对称加密算法中的一种。70年代初由IBM研发，后1977年被美国国家标准局采纳为数据加密标准，即DES全称的由来：Data Encryption Standard。对称加密算法，是相对于非对称加密算法而言的。两者区别在于，对称加密在加密和解密时使用同一密钥，而非对称加密在加密和解密时使用不同的密钥，即公钥和私钥。常见的DES、3DES、AES均为对称加密算法，而RSA、椭圆曲线加密算法，均为非对称加密算法。<br> <br>　　DES是以64比特的明文为一个单位来进行加密的，超过64比特的数据，要求按固定的64比特的大小分组，分组有很多模式，后续单独总结，暂时先介绍DES加密算法。DES使用的密钥长度为64比特，但由于每隔7个比特设置一个奇偶校验位，因此其密钥长度实际为56比特。奇偶校验为最简单的错误检测码，即根据一组二进制代码中1的个数是奇数或偶数来检测错误。<br>　　<br><a id=\"more\"></a></p>\n<h2 id=\"Feistel网络\"><a href=\"#Feistel网络\" class=\"headerlink\" title=\"Feistel网络\"></a>Feistel网络</h2><p>DES的基本结构，由IBM公司的Horst Feistel设计，因此称Feistel网络。在Feistel网络中，加密的每个步骤称为轮，经过初始置换后的64位明文，进行了16轮Feistel轮的加密过程，最后经过终结置换后形成最终的64位密文。如下为Feistel网络的示意图：</p>\n<p><img src=\"http://olgjbx93m.bkt.clouddn.com/5f65e67ee5cbf1514c5614e944684cc1af2a4096.jpg\" alt=\"\">  </p>\n<p>64位明文被分为左、右两部分处理，右侧数据和子密钥经过轮函数f生成用于加密左侧数据的比特序列，与左侧数据异或运算，运算结果输出为加密后的左侧，右侧数据则直接输出为右侧。<br>　　其中子密钥为本轮加密使用的密钥，每次Feistel均使用不同的子密钥。子密钥的计算，以及轮函数的细节，稍后下文介绍。由于一次Feistel轮并不会加密右侧，因此需要将上一轮输出后的左右两侧对调后，重复Feistel轮的过程，DES算法共计进行16次Feistel轮，最后一轮输出后左右两侧无需对调。</p>\n<p>DES加密和解密的过程一致，均使用Feistel网络实现，区别仅在于解密时，密文作为输入，并逆序使用子密钥。</p>\n<h2 id=\"DES-加密算法的使用\"><a href=\"#DES-加密算法的使用\" class=\"headerlink\" title=\"DES 加密算法的使用\"></a>DES 加密算法的使用</h2><p>在使用DES加密前，需要自己实现对明文的补码和去码操作</p>\n<p>补码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">//实现PKCS5Padding补码</div><div class=\"line\">func PKCS5Padding(cipherTxt [] byte, blockSize int) []byte &#123;</div><div class=\"line\">\t//计算准备添加的数字</div><div class=\"line\">\tpadding := blockSize - len(cipherTxt)%blockSize</div><div class=\"line\"></div><div class=\"line\">\t//得到补码</div><div class=\"line\">\tpadTxt := bytes.Repeat([]byte&#123;byte(padding)&#125;, padding)</div><div class=\"line\"></div><div class=\"line\">\t//拼接原文与补码</div><div class=\"line\">\tvar byteTxt = append(cipherTxt, padTxt...)</div><div class=\"line\"></div><div class=\"line\">\treturn byteTxt</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>去码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//PKCS5Unpadding 去码</div><div class=\"line\">func PKCS5UnPadding(cipherTxt []byte) []byte &#123;</div><div class=\"line\">\tvar l = len(cipherTxt)</div><div class=\"line\">\tvar txt = int(cipherTxt[l-1])</div><div class=\"line\">\tres := cipherTxt[:l-txt]</div><div class=\"line\">\treturn res</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>DES加密<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// key 必须为8位</div><div class=\"line\">func EnDESEncrypt (origData []byte, key []byte) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock, _ := des.NewCipher(key)</div><div class=\"line\">\t//设置补码</div><div class=\"line\">\torigData = MyDES.PKCS5Padding(origData, block.BlockSize())</div><div class=\"line\">\t//设置CBC加密模式</div><div class=\"line\">\tblockMode := cipher.NewCBCEncrypter(block, key)</div><div class=\"line\"></div><div class=\"line\">\t//加密明文</div><div class=\"line\">\tcrypted := make([]byte, len(origData))</div><div class=\"line\"></div><div class=\"line\">\tblockMode.CryptBlocks(crypted, origData)</div><div class=\"line\"></div><div class=\"line\">\treturn crypted</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>DES解密<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">func DeDESCriypt(cript []byte, key []byte) []byte  &#123;</div><div class=\"line\">\t//校验key的有效性</div><div class=\"line\">\tblock,_:=des.NewCipher(key)</div><div class=\"line\">\t//通过CBC模式解密</div><div class=\"line\">\tblockMode:=cipher.NewCBCDecrypter(block,key)</div><div class=\"line\"></div><div class=\"line\">\t//实现解密</div><div class=\"line\">\torigData:=make([]byte,len(cript))</div><div class=\"line\">\tblockMode.CryptBlocks(origData,cript)</div><div class=\"line\"></div><div class=\"line\">\t//去码</div><div class=\"line\">\torigData = MyDES.PKCS5UnPadding(origData)</div><div class=\"line\">\treturn origData</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tkey := []byte(&quot;aswedrfg&quot;)</div><div class=\"line\">\tvar data =[]byte(&quot;hello world&quot;)</div><div class=\"line\">\tvar cipherTxt = EnDESEncrypt(data,key)</div><div class=\"line\">\tfmt.Println(&quot;加密的结果：&quot;,hex.EncodeToString( cipherTxt))</div><div class=\"line\"></div><div class=\"line\">\tvar origData=DeDESCriypt(cipherTxt,key)</div><div class=\"line\">\tfmt.Println(&quot;解密后的结果为:&quot;,string(origData))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">加密的结果： 935ae7ca3229f6c707bb9de9db9693c7</div><div class=\"line\">解密后的结果为: hello world</div></pre></td></tr></table></figure></p>\n<h2 id=\"根据DES原理自己实现加密解密过程\"><a href=\"#根据DES原理自己实现加密解密过程\" class=\"headerlink\" title=\"根据DES原理自己实现加密解密过程\"></a>根据DES原理自己实现加密解密过程</h2><p>加密<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">func EnCrypt(key string, data []byte) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar sum = 0</div><div class=\"line\">\tfor i := 0; i &lt; len(key); i++ &#123;</div><div class=\"line\">\t\tsum += int(key[i])</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t// 对明文进行补码</div><div class=\"line\">\tvar pad = PKCS5Padding(data, len(key))</div><div class=\"line\">\t//通过加法，实现简单加密</div><div class=\"line\">\tfor i := 0;i&lt;len(pad);i++&#123;</div><div class=\"line\">\t\tpad[i] = pad[i]+byte(sum)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn pad</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>解密<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">func Decrypt(cipherTxt []byte,key string) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(&quot;???&quot;,cipherTxt)</div><div class=\"line\">\t//计算key的总和</div><div class=\"line\">\tvar sum =0</div><div class=\"line\">\tfor i:=0;i&lt;len(key);i++ &#123;</div><div class=\"line\">\t\tsum += int(key[i])</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t//减法运算</div><div class=\"line\">\tfor i:=0;i&lt;len(cipherTxt);i++&#123;</div><div class=\"line\">\t\tcipherTxt[i]=cipherTxt[i]-byte(sum)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(&quot;???&quot;,cipherTxt)</div><div class=\"line\">\t//去码</div><div class=\"line\">\tvar p = PKCS5UnPadding(cipherTxt)</div><div class=\"line\">\treturn p</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"3DES\"><a href=\"#3DES\" class=\"headerlink\" title=\"3DES\"></a>3DES</h2><h3 id=\"3DES加密\"><a href=\"#3DES加密\" class=\"headerlink\" title=\"3DES加密\"></a>3DES加密</h3><p>DES是一个经典的对称加密算法，但也缺陷明显，即56位的密钥安全性不足，已被证实可以在短时间内破解。为解决此问题，出现了3DES，也称Triple DES，3DES为DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密。为了兼容普通的DES，3DES并没有直接使用 <code>加密-&gt;加密-&gt;加密</code> 的方式，而是采用了<code>加密-&gt;解密-&gt;加密</code> 的方式。</p>\n<p><img src=\"http://oscd4dgpc.bkt.clouddn.com/00f3fb2538ec90b80eb9.jpg\" alt=\"\"></p>\n<p>当三重密钥均相同时，前两步相互抵消，相当于仅实现了一次加密，因此可实现对普通DES加密算法的兼容。</p>\n<p><img src=\"http://oscd4dgpc.bkt.clouddn.com/7de5d8dfcd0bd221596384.jpg\" alt=\"\"></p>\n<h3 id=\"3DES解密\"><a href=\"#3DES解密\" class=\"headerlink\" title=\"3DES解密\"></a>3DES解密</h3><p>3DES解密过程，与加密过程相反，即逆序使用密钥。是以密钥3、密钥2、密钥1的顺序执行 <code>解密-&gt;加密-&gt;解密</code>。</p>\n<p><img src=\"http://oscd4dgpc.bkt.clouddn.com/WX20180216-083713.png\" alt=\"\"></p>\n<p>相比DES，3DES因密钥长度变长，安全性有所提高，但其处理速度不高。因此又出现了AES加密算法，AES较于3DES速度更快、安全性更高。</p>\n","excerpt":"<h2 id=\"DES加密算法\"><a href=\"#DES加密算法\" class=\"headerlink\" title=\"DES加密算法\"></a>DES加密算法</h2><p>DES加密算法，为对称加密算法中的一种。70年代初由IBM研发，后1977年被美国国家标准局采纳为数据加密标准，即DES全称的由来：Data Encryption Standard。对称加密算法，是相对于非对称加密算法而言的。两者区别在于，对称加密在加密和解密时使用同一密钥，而非对称加密在加密和解密时使用不同的密钥，即公钥和私钥。常见的DES、3DES、AES均为对称加密算法，而RSA、椭圆曲线加密算法，均为非对称加密算法。<br> <br>　　DES是以64比特的明文为一个单位来进行加密的，超过64比特的数据，要求按固定的64比特的大小分组，分组有很多模式，后续单独总结，暂时先介绍DES加密算法。DES使用的密钥长度为64比特，但由于每隔7个比特设置一个奇偶校验位，因此其密钥长度实际为56比特。奇偶校验为最简单的错误检测码，即根据一组二进制代码中1的个数是奇数或偶数来检测错误。<br>　　<br>","more":"</p>\n<h2 id=\"Feistel网络\"><a href=\"#Feistel网络\" class=\"headerlink\" title=\"Feistel网络\"></a>Feistel网络</h2><p>DES的基本结构，由IBM公司的Horst Feistel设计，因此称Feistel网络。在Feistel网络中，加密的每个步骤称为轮，经过初始置换后的64位明文，进行了16轮Feistel轮的加密过程，最后经过终结置换后形成最终的64位密文。如下为Feistel网络的示意图：</p>\n<p><img src=\"http://olgjbx93m.bkt.clouddn.com/5f65e67ee5cbf1514c5614e944684cc1af2a4096.jpg\" alt=\"\">  </p>\n<p>64位明文被分为左、右两部分处理，右侧数据和子密钥经过轮函数f生成用于加密左侧数据的比特序列，与左侧数据异或运算，运算结果输出为加密后的左侧，右侧数据则直接输出为右侧。<br>　　其中子密钥为本轮加密使用的密钥，每次Feistel均使用不同的子密钥。子密钥的计算，以及轮函数的细节，稍后下文介绍。由于一次Feistel轮并不会加密右侧，因此需要将上一轮输出后的左右两侧对调后，重复Feistel轮的过程，DES算法共计进行16次Feistel轮，最后一轮输出后左右两侧无需对调。</p>\n<p>DES加密和解密的过程一致，均使用Feistel网络实现，区别仅在于解密时，密文作为输入，并逆序使用子密钥。</p>\n<h2 id=\"DES-加密算法的使用\"><a href=\"#DES-加密算法的使用\" class=\"headerlink\" title=\"DES 加密算法的使用\"></a>DES 加密算法的使用</h2><p>在使用DES加密前，需要自己实现对明文的补码和去码操作</p>\n<p>补码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">//实现PKCS5Padding补码</div><div class=\"line\">func PKCS5Padding(cipherTxt [] byte, blockSize int) []byte &#123;</div><div class=\"line\">\t//计算准备添加的数字</div><div class=\"line\">\tpadding := blockSize - len(cipherTxt)%blockSize</div><div class=\"line\"></div><div class=\"line\">\t//得到补码</div><div class=\"line\">\tpadTxt := bytes.Repeat([]byte&#123;byte(padding)&#125;, padding)</div><div class=\"line\"></div><div class=\"line\">\t//拼接原文与补码</div><div class=\"line\">\tvar byteTxt = append(cipherTxt, padTxt...)</div><div class=\"line\"></div><div class=\"line\">\treturn byteTxt</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>去码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//PKCS5Unpadding 去码</div><div class=\"line\">func PKCS5UnPadding(cipherTxt []byte) []byte &#123;</div><div class=\"line\">\tvar l = len(cipherTxt)</div><div class=\"line\">\tvar txt = int(cipherTxt[l-1])</div><div class=\"line\">\tres := cipherTxt[:l-txt]</div><div class=\"line\">\treturn res</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>DES加密<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// key 必须为8位</div><div class=\"line\">func EnDESEncrypt (origData []byte, key []byte) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\t//校验密钥</div><div class=\"line\">\tblock, _ := des.NewCipher(key)</div><div class=\"line\">\t//设置补码</div><div class=\"line\">\torigData = MyDES.PKCS5Padding(origData, block.BlockSize())</div><div class=\"line\">\t//设置CBC加密模式</div><div class=\"line\">\tblockMode := cipher.NewCBCEncrypter(block, key)</div><div class=\"line\"></div><div class=\"line\">\t//加密明文</div><div class=\"line\">\tcrypted := make([]byte, len(origData))</div><div class=\"line\"></div><div class=\"line\">\tblockMode.CryptBlocks(crypted, origData)</div><div class=\"line\"></div><div class=\"line\">\treturn crypted</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>DES解密<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">func DeDESCriypt(cript []byte, key []byte) []byte  &#123;</div><div class=\"line\">\t//校验key的有效性</div><div class=\"line\">\tblock,_:=des.NewCipher(key)</div><div class=\"line\">\t//通过CBC模式解密</div><div class=\"line\">\tblockMode:=cipher.NewCBCDecrypter(block,key)</div><div class=\"line\"></div><div class=\"line\">\t//实现解密</div><div class=\"line\">\torigData:=make([]byte,len(cript))</div><div class=\"line\">\tblockMode.CryptBlocks(origData,cript)</div><div class=\"line\"></div><div class=\"line\">\t//去码</div><div class=\"line\">\torigData = MyDES.PKCS5UnPadding(origData)</div><div class=\"line\">\treturn origData</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tkey := []byte(&quot;aswedrfg&quot;)</div><div class=\"line\">\tvar data =[]byte(&quot;hello world&quot;)</div><div class=\"line\">\tvar cipherTxt = EnDESEncrypt(data,key)</div><div class=\"line\">\tfmt.Println(&quot;加密的结果：&quot;,hex.EncodeToString( cipherTxt))</div><div class=\"line\"></div><div class=\"line\">\tvar origData=DeDESCriypt(cipherTxt,key)</div><div class=\"line\">\tfmt.Println(&quot;解密后的结果为:&quot;,string(origData))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">加密的结果： 935ae7ca3229f6c707bb9de9db9693c7</div><div class=\"line\">解密后的结果为: hello world</div></pre></td></tr></table></figure></p>\n<h2 id=\"根据DES原理自己实现加密解密过程\"><a href=\"#根据DES原理自己实现加密解密过程\" class=\"headerlink\" title=\"根据DES原理自己实现加密解密过程\"></a>根据DES原理自己实现加密解密过程</h2><p>加密<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">func EnCrypt(key string, data []byte) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar sum = 0</div><div class=\"line\">\tfor i := 0; i &lt; len(key); i++ &#123;</div><div class=\"line\">\t\tsum += int(key[i])</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t// 对明文进行补码</div><div class=\"line\">\tvar pad = PKCS5Padding(data, len(key))</div><div class=\"line\">\t//通过加法，实现简单加密</div><div class=\"line\">\tfor i := 0;i&lt;len(pad);i++&#123;</div><div class=\"line\">\t\tpad[i] = pad[i]+byte(sum)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn pad</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>解密<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">func Decrypt(cipherTxt []byte,key string) []byte &#123;</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(&quot;???&quot;,cipherTxt)</div><div class=\"line\">\t//计算key的总和</div><div class=\"line\">\tvar sum =0</div><div class=\"line\">\tfor i:=0;i&lt;len(key);i++ &#123;</div><div class=\"line\">\t\tsum += int(key[i])</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t//减法运算</div><div class=\"line\">\tfor i:=0;i&lt;len(cipherTxt);i++&#123;</div><div class=\"line\">\t\tcipherTxt[i]=cipherTxt[i]-byte(sum)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfmt.Println(&quot;???&quot;,cipherTxt)</div><div class=\"line\">\t//去码</div><div class=\"line\">\tvar p = PKCS5UnPadding(cipherTxt)</div><div class=\"line\">\treturn p</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"3DES\"><a href=\"#3DES\" class=\"headerlink\" title=\"3DES\"></a>3DES</h2><h3 id=\"3DES加密\"><a href=\"#3DES加密\" class=\"headerlink\" title=\"3DES加密\"></a>3DES加密</h3><p>DES是一个经典的对称加密算法，但也缺陷明显，即56位的密钥安全性不足，已被证实可以在短时间内破解。为解决此问题，出现了3DES，也称Triple DES，3DES为DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密。为了兼容普通的DES，3DES并没有直接使用 <code>加密-&gt;加密-&gt;加密</code> 的方式，而是采用了<code>加密-&gt;解密-&gt;加密</code> 的方式。</p>\n<p><img src=\"http://oscd4dgpc.bkt.clouddn.com/00f3fb2538ec90b80eb9.jpg\" alt=\"\"></p>\n<p>当三重密钥均相同时，前两步相互抵消，相当于仅实现了一次加密，因此可实现对普通DES加密算法的兼容。</p>\n<p><img src=\"http://oscd4dgpc.bkt.clouddn.com/7de5d8dfcd0bd221596384.jpg\" alt=\"\"></p>\n<h3 id=\"3DES解密\"><a href=\"#3DES解密\" class=\"headerlink\" title=\"3DES解密\"></a>3DES解密</h3><p>3DES解密过程，与加密过程相反，即逆序使用密钥。是以密钥3、密钥2、密钥1的顺序执行 <code>解密-&gt;加密-&gt;解密</code>。</p>\n<p><img src=\"http://oscd4dgpc.bkt.clouddn.com/WX20180216-083713.png\" alt=\"\"></p>\n<p>相比DES，3DES因密钥长度变长，安全性有所提高，但其处理速度不高。因此又出现了AES加密算法，AES较于3DES速度更快、安全性更高。</p>"},{"title":"拜占庭PBFT简单实现","date":"2018-07-03T10:57:53.000Z","_content":"\n## PBFT（拜占庭容错）\n\n基于拜占庭将军问题，一致性的确保主要分为这三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)。流程如下图所示：\n\n![image](https://upload-images.jianshu.io/upload_images/971366-43e9a641f22f4faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n其中C为发送请求端，0123为服务端，3为宕机的服务端，具体步骤如下：\n1. Request：请求端C发送请求到任意一节点，这里是0\n2. Pre-Prepare：服务端0收到C的请求后进行广播，扩散至123\n3. Prepare：123,收到后记录并再次广播，1->023，2->013，3因为宕机无法广播\n4. Commit：0123节点在Prepare阶段，若收到超过一定数量的相同请求，则进入Commit阶段，广播Commit请求\n5.Reply：0123节点在Commit阶段，若收到超过一定数量的相同请求，则对C进行反馈\n\n<!--more-->\n\n## 代码实现\n\n```\npackage main\n\nimport (\n\t\"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"io\"\n)\n\n//声明节点信息,代表各个小国家\ntype nodeInfo struct {\n\t//标示\n\tid string\n\t//准备访问的方法\n\tpath string\n\t//服务器做出的相应\n\twriter http.ResponseWriter\n\n}\n\n//存放四个国家的地址\nvar nodeTable = make(map[string]string)\n\n//拜占庭在Fabric中的使用\nfunc main() {\n\n\t//获取执行的参数\n\tuserId :=os.Args[1]//获取执行的第一个参数\n\tfmt.Println(userId)\n\n\t//./main Apple\n\n\t//创建四个国家的地址\n\tnodeTable = map[string]string {\n\t\t\"Apple\":\"localhost:1111\",\n\t\t\"MS\":\"localhost:1112\",\n\t\t\"Google\":\"localhost:1113\",\n\t\t\"IBM\":\"localhost:1114\",\n\t}\n\n\tnode:=nodeInfo{userId,nodeTable[userId],nil}\n\tfmt.Println(node)\n\n\t//http协议的回调函数\n\t//http://localhost:1111/req?warTime=8888\n\thttp.HandleFunc(\"/req\",node.request)\n\thttp.HandleFunc(\"/prePrepare\",node.prePrepare)\n\thttp.HandleFunc(\"/prepare\",node.prepare)\n\thttp.HandleFunc(\"/commit\",node.commit)\n\n\t//启动服务器\n\tif err:=http.ListenAndServe(node.path,nil);err!=nil {\n\t\tfmt.Print(err)\n\t}\n\n\n\n}\n\n//此函数是http访问时候req命令的请求回调函数\nfunc (node *nodeInfo)request(writer http.ResponseWriter,request *http.Request){\n\t//设置允许解析参数\n\trequest.ParseForm()\n\t//如果有参数值，则继续处理\n\tif (len(request.Form[\"warTime\"])>0){\n\t\tnode.writer = writer\n\t\t//激活主节点后，广播给其他节点,通过Ａpple向其他节点做广播\n\t\tnode.broadcast(request.Form[\"warTime\"][0],\"/prePrepare\")\n\n\t}\n\n\n}\n\n\n//由主节点向其他节点做广播\nfunc (node *nodeInfo)broadcast(msg string ,path string ){\n\t//遍历所有的国家\n\tfor nodeId,url:=range nodeTable {\n\n\t\tif nodeId == node.id {\n\t\t\tcontinue\n\t\t}\n\t\t//调用Get请求\n\t\t//http.Get(\"http://localhost:1112/prePrepare?warTime=8888&nodeId=Apple\")\n\t\thttp.Get(\"http://\"+url+path+\"?warTime=\"+msg+\"&nodeId=\"+node.id)\n\t}\n\n}\n\nfunc (node *nodeInfo)prePrepare(writer http.ResponseWriter,request *http.Request) {\n\trequest.ParseForm()\n\t//fmt.Println(\"hello world\")\n\t//在做分发\n\tif(len(request.Form[\"warTime\"])>0){\n\t\t//分发给其他三个人\n\t\tnode.broadcast(request.Form[\"warTime\"][0],\"/prepare\")\n\t}\n\n}\n\nfunc (node *nodeInfo)prepare(writer http.ResponseWriter,request *http.Request){\n\n\trequest.ParseForm()\n\t//调用验证\n\tif len(request.Form[\"warTime\"])>0{\n\t\tfmt.Println(request.Form[\"warTime\"][0])\n\t}\n\tif len(request.Form[\"nodeId\"])>0 {\n\t\tfmt.Println(request.Form[\"nodeId\"][0])\n\t}\n\n\tnode.authentication(request)\n}\n\n\nvar authenticationsuccess = true\nvar authenticationMap = make(map[string]string)\n//获得除了本节点外的其他节点数据\nfunc (node *nodeInfo)authentication(request *http.Request) {\n\n\t//接收参数\n\trequest.ParseForm()\n\n\tif authenticationsuccess!=false  {\n\t\tif len(request.Form[\"nodeId\"])>0 {\n\t\t\tauthenticationMap[request.Form[\"nodeId\"][0]]=\"ok\"\n\t\t}\n\t}\n\n\tif len(authenticationMap)>len(nodeTable)/3 {\n\t\t//则拜占庭原理实现,通过commit反馈给浏览器\n\t\tnode.broadcast(request.Form[\"warTime\"][0],\"/commit\")\n\n\t}\n}\n\n\nfunc (node *nodeInfo)commit(writer http.ResponseWriter,request *http.Request){\n\n\t//给浏览器反馈相应\n\tio.WriteString(node.writer,\"ok\")\n\n}\n```\n\n如何运行：开启4个终端，eg：go run main.go Apple  ...\n然后在浏览器输入：`http://localhost:1112/req?warTime=1234`\n\n\n\n","source":"_posts/拜占庭PBFT简单实现.md","raw":"---\ntitle: 拜占庭PBFT简单实现\ncategories:\n  - 共识算法\ntags:\n  - 拜占庭\n  - PBFT\ndate: 2018-07-03 18:57:53\n---\n\n## PBFT（拜占庭容错）\n\n基于拜占庭将军问题，一致性的确保主要分为这三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)。流程如下图所示：\n\n![image](https://upload-images.jianshu.io/upload_images/971366-43e9a641f22f4faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n其中C为发送请求端，0123为服务端，3为宕机的服务端，具体步骤如下：\n1. Request：请求端C发送请求到任意一节点，这里是0\n2. Pre-Prepare：服务端0收到C的请求后进行广播，扩散至123\n3. Prepare：123,收到后记录并再次广播，1->023，2->013，3因为宕机无法广播\n4. Commit：0123节点在Prepare阶段，若收到超过一定数量的相同请求，则进入Commit阶段，广播Commit请求\n5.Reply：0123节点在Commit阶段，若收到超过一定数量的相同请求，则对C进行反馈\n\n<!--more-->\n\n## 代码实现\n\n```\npackage main\n\nimport (\n\t\"os\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"io\"\n)\n\n//声明节点信息,代表各个小国家\ntype nodeInfo struct {\n\t//标示\n\tid string\n\t//准备访问的方法\n\tpath string\n\t//服务器做出的相应\n\twriter http.ResponseWriter\n\n}\n\n//存放四个国家的地址\nvar nodeTable = make(map[string]string)\n\n//拜占庭在Fabric中的使用\nfunc main() {\n\n\t//获取执行的参数\n\tuserId :=os.Args[1]//获取执行的第一个参数\n\tfmt.Println(userId)\n\n\t//./main Apple\n\n\t//创建四个国家的地址\n\tnodeTable = map[string]string {\n\t\t\"Apple\":\"localhost:1111\",\n\t\t\"MS\":\"localhost:1112\",\n\t\t\"Google\":\"localhost:1113\",\n\t\t\"IBM\":\"localhost:1114\",\n\t}\n\n\tnode:=nodeInfo{userId,nodeTable[userId],nil}\n\tfmt.Println(node)\n\n\t//http协议的回调函数\n\t//http://localhost:1111/req?warTime=8888\n\thttp.HandleFunc(\"/req\",node.request)\n\thttp.HandleFunc(\"/prePrepare\",node.prePrepare)\n\thttp.HandleFunc(\"/prepare\",node.prepare)\n\thttp.HandleFunc(\"/commit\",node.commit)\n\n\t//启动服务器\n\tif err:=http.ListenAndServe(node.path,nil);err!=nil {\n\t\tfmt.Print(err)\n\t}\n\n\n\n}\n\n//此函数是http访问时候req命令的请求回调函数\nfunc (node *nodeInfo)request(writer http.ResponseWriter,request *http.Request){\n\t//设置允许解析参数\n\trequest.ParseForm()\n\t//如果有参数值，则继续处理\n\tif (len(request.Form[\"warTime\"])>0){\n\t\tnode.writer = writer\n\t\t//激活主节点后，广播给其他节点,通过Ａpple向其他节点做广播\n\t\tnode.broadcast(request.Form[\"warTime\"][0],\"/prePrepare\")\n\n\t}\n\n\n}\n\n\n//由主节点向其他节点做广播\nfunc (node *nodeInfo)broadcast(msg string ,path string ){\n\t//遍历所有的国家\n\tfor nodeId,url:=range nodeTable {\n\n\t\tif nodeId == node.id {\n\t\t\tcontinue\n\t\t}\n\t\t//调用Get请求\n\t\t//http.Get(\"http://localhost:1112/prePrepare?warTime=8888&nodeId=Apple\")\n\t\thttp.Get(\"http://\"+url+path+\"?warTime=\"+msg+\"&nodeId=\"+node.id)\n\t}\n\n}\n\nfunc (node *nodeInfo)prePrepare(writer http.ResponseWriter,request *http.Request) {\n\trequest.ParseForm()\n\t//fmt.Println(\"hello world\")\n\t//在做分发\n\tif(len(request.Form[\"warTime\"])>0){\n\t\t//分发给其他三个人\n\t\tnode.broadcast(request.Form[\"warTime\"][0],\"/prepare\")\n\t}\n\n}\n\nfunc (node *nodeInfo)prepare(writer http.ResponseWriter,request *http.Request){\n\n\trequest.ParseForm()\n\t//调用验证\n\tif len(request.Form[\"warTime\"])>0{\n\t\tfmt.Println(request.Form[\"warTime\"][0])\n\t}\n\tif len(request.Form[\"nodeId\"])>0 {\n\t\tfmt.Println(request.Form[\"nodeId\"][0])\n\t}\n\n\tnode.authentication(request)\n}\n\n\nvar authenticationsuccess = true\nvar authenticationMap = make(map[string]string)\n//获得除了本节点外的其他节点数据\nfunc (node *nodeInfo)authentication(request *http.Request) {\n\n\t//接收参数\n\trequest.ParseForm()\n\n\tif authenticationsuccess!=false  {\n\t\tif len(request.Form[\"nodeId\"])>0 {\n\t\t\tauthenticationMap[request.Form[\"nodeId\"][0]]=\"ok\"\n\t\t}\n\t}\n\n\tif len(authenticationMap)>len(nodeTable)/3 {\n\t\t//则拜占庭原理实现,通过commit反馈给浏览器\n\t\tnode.broadcast(request.Form[\"warTime\"][0],\"/commit\")\n\n\t}\n}\n\n\nfunc (node *nodeInfo)commit(writer http.ResponseWriter,request *http.Request){\n\n\t//给浏览器反馈相应\n\tio.WriteString(node.writer,\"ok\")\n\n}\n```\n\n如何运行：开启4个终端，eg：go run main.go Apple  ...\n然后在浏览器输入：`http://localhost:1112/req?warTime=1234`\n\n\n\n","slug":"拜占庭PBFT简单实现","published":1,"updated":"2018-07-03T11:00:39.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tff0036lx60wvn9tyu4","content":"<h2 id=\"PBFT（拜占庭容错）\"><a href=\"#PBFT（拜占庭容错）\" class=\"headerlink\" title=\"PBFT（拜占庭容错）\"></a>PBFT（拜占庭容错）</h2><p>基于拜占庭将军问题，一致性的确保主要分为这三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)。流程如下图所示：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/971366-43e9a641f22f4faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"image\"></p>\n<p>其中C为发送请求端，0123为服务端，3为宕机的服务端，具体步骤如下：</p>\n<ol>\n<li>Request：请求端C发送请求到任意一节点，这里是0</li>\n<li>Pre-Prepare：服务端0收到C的请求后进行广播，扩散至123</li>\n<li>Prepare：123,收到后记录并再次广播，1-&gt;023，2-&gt;013，3因为宕机无法广播</li>\n<li>Commit：0123节点在Prepare阶段，若收到超过一定数量的相同请求，则进入Commit阶段，广播Commit请求<br>5.Reply：0123节点在Commit阶段，若收到超过一定数量的相同请求，则对C进行反馈</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;os&quot;</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;net/http&quot;</div><div class=\"line\">\t&quot;io&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">//声明节点信息,代表各个小国家</div><div class=\"line\">type nodeInfo struct &#123;</div><div class=\"line\">\t//标示</div><div class=\"line\">\tid string</div><div class=\"line\">\t//准备访问的方法</div><div class=\"line\">\tpath string</div><div class=\"line\">\t//服务器做出的相应</div><div class=\"line\">\twriter http.ResponseWriter</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//存放四个国家的地址</div><div class=\"line\">var nodeTable = make(map[string]string)</div><div class=\"line\"></div><div class=\"line\">//拜占庭在Fabric中的使用</div><div class=\"line\">func main() &#123;</div><div class=\"line\"></div><div class=\"line\">\t//获取执行的参数</div><div class=\"line\">\tuserId :=os.Args[1]//获取执行的第一个参数</div><div class=\"line\">\tfmt.Println(userId)</div><div class=\"line\"></div><div class=\"line\">\t//./main Apple</div><div class=\"line\"></div><div class=\"line\">\t//创建四个国家的地址</div><div class=\"line\">\tnodeTable = map[string]string &#123;</div><div class=\"line\">\t\t&quot;Apple&quot;:&quot;localhost:1111&quot;,</div><div class=\"line\">\t\t&quot;MS&quot;:&quot;localhost:1112&quot;,</div><div class=\"line\">\t\t&quot;Google&quot;:&quot;localhost:1113&quot;,</div><div class=\"line\">\t\t&quot;IBM&quot;:&quot;localhost:1114&quot;,</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tnode:=nodeInfo&#123;userId,nodeTable[userId],nil&#125;</div><div class=\"line\">\tfmt.Println(node)</div><div class=\"line\"></div><div class=\"line\">\t//http协议的回调函数</div><div class=\"line\">\t//http://localhost:1111/req?warTime=8888</div><div class=\"line\">\thttp.HandleFunc(&quot;/req&quot;,node.request)</div><div class=\"line\">\thttp.HandleFunc(&quot;/prePrepare&quot;,node.prePrepare)</div><div class=\"line\">\thttp.HandleFunc(&quot;/prepare&quot;,node.prepare)</div><div class=\"line\">\thttp.HandleFunc(&quot;/commit&quot;,node.commit)</div><div class=\"line\"></div><div class=\"line\">\t//启动服务器</div><div class=\"line\">\tif err:=http.ListenAndServe(node.path,nil);err!=nil &#123;</div><div class=\"line\">\t\tfmt.Print(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//此函数是http访问时候req命令的请求回调函数</div><div class=\"line\">func (node *nodeInfo)request(writer http.ResponseWriter,request *http.Request)&#123;</div><div class=\"line\">\t//设置允许解析参数</div><div class=\"line\">\trequest.ParseForm()</div><div class=\"line\">\t//如果有参数值，则继续处理</div><div class=\"line\">\tif (len(request.Form[&quot;warTime&quot;])&gt;0)&#123;</div><div class=\"line\">\t\tnode.writer = writer</div><div class=\"line\">\t\t//激活主节点后，广播给其他节点,通过Ａpple向其他节点做广播</div><div class=\"line\">\t\tnode.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prePrepare&quot;)</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//由主节点向其他节点做广播</div><div class=\"line\">func (node *nodeInfo)broadcast(msg string ,path string )&#123;</div><div class=\"line\">\t//遍历所有的国家</div><div class=\"line\">\tfor nodeId,url:=range nodeTable &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tif nodeId == node.id &#123;</div><div class=\"line\">\t\t\tcontinue</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t//调用Get请求</div><div class=\"line\">\t\t//http.Get(&quot;http://localhost:1112/prePrepare?warTime=8888&amp;nodeId=Apple&quot;)</div><div class=\"line\">\t\thttp.Get(&quot;http://&quot;+url+path+&quot;?warTime=&quot;+msg+&quot;&amp;nodeId=&quot;+node.id)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (node *nodeInfo)prePrepare(writer http.ResponseWriter,request *http.Request) &#123;</div><div class=\"line\">\trequest.ParseForm()</div><div class=\"line\">\t//fmt.Println(&quot;hello world&quot;)</div><div class=\"line\">\t//在做分发</div><div class=\"line\">\tif(len(request.Form[&quot;warTime&quot;])&gt;0)&#123;</div><div class=\"line\">\t\t//分发给其他三个人</div><div class=\"line\">\t\tnode.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prepare&quot;)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (node *nodeInfo)prepare(writer http.ResponseWriter,request *http.Request)&#123;</div><div class=\"line\"></div><div class=\"line\">\trequest.ParseForm()</div><div class=\"line\">\t//调用验证</div><div class=\"line\">\tif len(request.Form[&quot;warTime&quot;])&gt;0&#123;</div><div class=\"line\">\t\tfmt.Println(request.Form[&quot;warTime&quot;][0])</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif len(request.Form[&quot;nodeId&quot;])&gt;0 &#123;</div><div class=\"line\">\t\tfmt.Println(request.Form[&quot;nodeId&quot;][0])</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tnode.authentication(request)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var authenticationsuccess = true</div><div class=\"line\">var authenticationMap = make(map[string]string)</div><div class=\"line\">//获得除了本节点外的其他节点数据</div><div class=\"line\">func (node *nodeInfo)authentication(request *http.Request) &#123;</div><div class=\"line\"></div><div class=\"line\">\t//接收参数</div><div class=\"line\">\trequest.ParseForm()</div><div class=\"line\"></div><div class=\"line\">\tif authenticationsuccess!=false  &#123;</div><div class=\"line\">\t\tif len(request.Form[&quot;nodeId&quot;])&gt;0 &#123;</div><div class=\"line\">\t\t\tauthenticationMap[request.Form[&quot;nodeId&quot;][0]]=&quot;ok&quot;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tif len(authenticationMap)&gt;len(nodeTable)/3 &#123;</div><div class=\"line\">\t\t//则拜占庭原理实现,通过commit反馈给浏览器</div><div class=\"line\">\t\tnode.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/commit&quot;)</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func (node *nodeInfo)commit(writer http.ResponseWriter,request *http.Request)&#123;</div><div class=\"line\"></div><div class=\"line\">\t//给浏览器反馈相应</div><div class=\"line\">\tio.WriteString(node.writer,&quot;ok&quot;)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如何运行：开启4个终端，eg：go run main.go Apple  …<br>然后在浏览器输入：<code>http://localhost:1112/req?warTime=1234</code></p>\n","excerpt":"<h2 id=\"PBFT（拜占庭容错）\"><a href=\"#PBFT（拜占庭容错）\" class=\"headerlink\" title=\"PBFT（拜占庭容错）\"></a>PBFT（拜占庭容错）</h2><p>基于拜占庭将军问题，一致性的确保主要分为这三个阶段：预准备（pre-prepare）、准备(prepare)和确认(commit)。流程如下图所示：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/971366-43e9a641f22f4faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"image\"></p>\n<p>其中C为发送请求端，0123为服务端，3为宕机的服务端，具体步骤如下：</p>\n<ol>\n<li>Request：请求端C发送请求到任意一节点，这里是0</li>\n<li>Pre-Prepare：服务端0收到C的请求后进行广播，扩散至123</li>\n<li>Prepare：123,收到后记录并再次广播，1-&gt;023，2-&gt;013，3因为宕机无法广播</li>\n<li>Commit：0123节点在Prepare阶段，若收到超过一定数量的相同请求，则进入Commit阶段，广播Commit请求<br>5.Reply：0123节点在Commit阶段，若收到超过一定数量的相同请求，则对C进行反馈</li>\n</ol>","more":"<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div></pre></td><td class=\"code\"><pre><div class=\"line\">package main</div><div class=\"line\"></div><div class=\"line\">import (</div><div class=\"line\">\t&quot;os&quot;</div><div class=\"line\">\t&quot;fmt&quot;</div><div class=\"line\">\t&quot;net/http&quot;</div><div class=\"line\">\t&quot;io&quot;</div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\">//声明节点信息,代表各个小国家</div><div class=\"line\">type nodeInfo struct &#123;</div><div class=\"line\">\t//标示</div><div class=\"line\">\tid string</div><div class=\"line\">\t//准备访问的方法</div><div class=\"line\">\tpath string</div><div class=\"line\">\t//服务器做出的相应</div><div class=\"line\">\twriter http.ResponseWriter</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//存放四个国家的地址</div><div class=\"line\">var nodeTable = make(map[string]string)</div><div class=\"line\"></div><div class=\"line\">//拜占庭在Fabric中的使用</div><div class=\"line\">func main() &#123;</div><div class=\"line\"></div><div class=\"line\">\t//获取执行的参数</div><div class=\"line\">\tuserId :=os.Args[1]//获取执行的第一个参数</div><div class=\"line\">\tfmt.Println(userId)</div><div class=\"line\"></div><div class=\"line\">\t//./main Apple</div><div class=\"line\"></div><div class=\"line\">\t//创建四个国家的地址</div><div class=\"line\">\tnodeTable = map[string]string &#123;</div><div class=\"line\">\t\t&quot;Apple&quot;:&quot;localhost:1111&quot;,</div><div class=\"line\">\t\t&quot;MS&quot;:&quot;localhost:1112&quot;,</div><div class=\"line\">\t\t&quot;Google&quot;:&quot;localhost:1113&quot;,</div><div class=\"line\">\t\t&quot;IBM&quot;:&quot;localhost:1114&quot;,</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tnode:=nodeInfo&#123;userId,nodeTable[userId],nil&#125;</div><div class=\"line\">\tfmt.Println(node)</div><div class=\"line\"></div><div class=\"line\">\t//http协议的回调函数</div><div class=\"line\">\t//http://localhost:1111/req?warTime=8888</div><div class=\"line\">\thttp.HandleFunc(&quot;/req&quot;,node.request)</div><div class=\"line\">\thttp.HandleFunc(&quot;/prePrepare&quot;,node.prePrepare)</div><div class=\"line\">\thttp.HandleFunc(&quot;/prepare&quot;,node.prepare)</div><div class=\"line\">\thttp.HandleFunc(&quot;/commit&quot;,node.commit)</div><div class=\"line\"></div><div class=\"line\">\t//启动服务器</div><div class=\"line\">\tif err:=http.ListenAndServe(node.path,nil);err!=nil &#123;</div><div class=\"line\">\t\tfmt.Print(err)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//此函数是http访问时候req命令的请求回调函数</div><div class=\"line\">func (node *nodeInfo)request(writer http.ResponseWriter,request *http.Request)&#123;</div><div class=\"line\">\t//设置允许解析参数</div><div class=\"line\">\trequest.ParseForm()</div><div class=\"line\">\t//如果有参数值，则继续处理</div><div class=\"line\">\tif (len(request.Form[&quot;warTime&quot;])&gt;0)&#123;</div><div class=\"line\">\t\tnode.writer = writer</div><div class=\"line\">\t\t//激活主节点后，广播给其他节点,通过Ａpple向其他节点做广播</div><div class=\"line\">\t\tnode.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prePrepare&quot;)</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//由主节点向其他节点做广播</div><div class=\"line\">func (node *nodeInfo)broadcast(msg string ,path string )&#123;</div><div class=\"line\">\t//遍历所有的国家</div><div class=\"line\">\tfor nodeId,url:=range nodeTable &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tif nodeId == node.id &#123;</div><div class=\"line\">\t\t\tcontinue</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t//调用Get请求</div><div class=\"line\">\t\t//http.Get(&quot;http://localhost:1112/prePrepare?warTime=8888&amp;nodeId=Apple&quot;)</div><div class=\"line\">\t\thttp.Get(&quot;http://&quot;+url+path+&quot;?warTime=&quot;+msg+&quot;&amp;nodeId=&quot;+node.id)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (node *nodeInfo)prePrepare(writer http.ResponseWriter,request *http.Request) &#123;</div><div class=\"line\">\trequest.ParseForm()</div><div class=\"line\">\t//fmt.Println(&quot;hello world&quot;)</div><div class=\"line\">\t//在做分发</div><div class=\"line\">\tif(len(request.Form[&quot;warTime&quot;])&gt;0)&#123;</div><div class=\"line\">\t\t//分发给其他三个人</div><div class=\"line\">\t\tnode.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/prepare&quot;)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func (node *nodeInfo)prepare(writer http.ResponseWriter,request *http.Request)&#123;</div><div class=\"line\"></div><div class=\"line\">\trequest.ParseForm()</div><div class=\"line\">\t//调用验证</div><div class=\"line\">\tif len(request.Form[&quot;warTime&quot;])&gt;0&#123;</div><div class=\"line\">\t\tfmt.Println(request.Form[&quot;warTime&quot;][0])</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif len(request.Form[&quot;nodeId&quot;])&gt;0 &#123;</div><div class=\"line\">\t\tfmt.Println(request.Form[&quot;nodeId&quot;][0])</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tnode.authentication(request)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">var authenticationsuccess = true</div><div class=\"line\">var authenticationMap = make(map[string]string)</div><div class=\"line\">//获得除了本节点外的其他节点数据</div><div class=\"line\">func (node *nodeInfo)authentication(request *http.Request) &#123;</div><div class=\"line\"></div><div class=\"line\">\t//接收参数</div><div class=\"line\">\trequest.ParseForm()</div><div class=\"line\"></div><div class=\"line\">\tif authenticationsuccess!=false  &#123;</div><div class=\"line\">\t\tif len(request.Form[&quot;nodeId&quot;])&gt;0 &#123;</div><div class=\"line\">\t\t\tauthenticationMap[request.Form[&quot;nodeId&quot;][0]]=&quot;ok&quot;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tif len(authenticationMap)&gt;len(nodeTable)/3 &#123;</div><div class=\"line\">\t\t//则拜占庭原理实现,通过commit反馈给浏览器</div><div class=\"line\">\t\tnode.broadcast(request.Form[&quot;warTime&quot;][0],&quot;/commit&quot;)</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">func (node *nodeInfo)commit(writer http.ResponseWriter,request *http.Request)&#123;</div><div class=\"line\"></div><div class=\"line\">\t//给浏览器反馈相应</div><div class=\"line\">\tio.WriteString(node.writer,&quot;ok&quot;)</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如何运行：开启4个终端，eg：go run main.go Apple  …<br>然后在浏览器输入：<code>http://localhost:1112/req?warTime=1234</code></p>"},{"title":"自定义刷新控件","_content":"\n### 一：前言\n记得工作中第一次用的刷新控件是`svpulltorefresh`，用法稍微有点麻烦，而且bug颇多，后来果断放弃，现在用的是`MJRefresh`,不管是用法还是bug，都比前一个好多了，但是不久前也遇到了一个致命的bug，有好些情况下会导致`MJRefresh`陷入一个死循环，导致不断的刷新，只能重启软件才行。`MJRefresh`工程比较庞大，找到了bug也很难修改，然后还是决定自己写一个，系统提供的`UIRefreshControl`我认为是最好的，缺点是不提供自定义UI的方法，那么我就自己基于它来自定义UI。我不是一开始就决定继承于`UIRefreshControl`，我同时也写了一个继承与`UIView`的control，两个进行对比，发现使用`UIview`会有很多弊端，这种弊端在一些复杂特殊的情况下一下子就暴露出来了，而且很难解决，当然，正常状态下是没什么问题的，有兴趣的同学倒是可以去试一试。本demo供大家学习和参考，如有发现bug，还请issues 我。\n\n### 二: 了解 UIRefreshControl\n* 基本使用方法\n\n```\n//初始化一个control\nUIRefreshControl *control = [[UIRefreshControl alloc] init];\n//给control 添加一个刷新方法\n[control addTarget:self action:@selector(refreshAction) forControlEvents:UIControlEventValueChanged];\n//把control 添加到 tableView\n[self.tableView addSubview:control];\n```\n\n* 存在的问题\n\t* 1. 刷新时的动画是一个灰色小菊花，很多情况下不符合app的刷新动画效果\n\t* 2. 经过多次反复测试，下拉的偏移量达到130以上才会触发刷新方法，很显然这个也不符合，一般的刷新控件的高度60左右，所以下拉的偏移量达到60就可以触发刷新的方法了。\n\n* 自定义控件的思路\n\t* 1. 去掉默认的动画效果\n\t* 2. 自定义自己的动画效果\n\t* 3. 改变满足刷新时的条件\n\t<!-- more -->\n### 三：FMRefreshControl\n\n* 先看一下我写完的这个控件的使用方法\n\n``` \nFMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];\n\n[self.tableView addSubview:control];\n```\n两行代码，用法比系统的还要稍微简单一点。\n\n* 再看一下效果\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/FMRefresh/1.gif)\n\n### 四：思路与代码\n#### 1. 关于 `UIRefreshControl` 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 `superViwe`,再执行 \n`[[_control.subviews objectAtIndex:0] setFrame:CGRectMake(0, 0, _control.bounds.size.width, 30)];`\n一开始我是想改变它的高度是否就能改变它的触发刷新的偏移量，然后我找到了这个方法可以修改它的高度，但实际上改变了高度还是无法改变触发下拉刷新的偏移量，所以我们需要自定义去触发刷新这个动作的时机。\n\n#### 2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。\n\n#### 3. 进入代码阶段\n```\nFMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];\n[self.tableView addSubview:control];\n```\n初始化的时候赋一个 target 和 一个 action，当满足条件的时候，我们需要知道让谁去执行刷新方法，有这两个参数足够，当执行到第二行 addSubView的时候，我们需要在control内部实现这个方法：\n```\n- (void)willMoveToSuperview:(UIView *)newSuperview {\n    [super willMoveToSuperview:newSuperview];\n    \n    if ([newSuperview isKindOfClass:[UIScrollView class]]) {\n        self.superScrollView = (UIScrollView *)newSuperview;\n        \n        [self.superScrollView addObserver:self forKeyPath:@\"contentOffset\" options:NSKeyValueObservingOptionNew context:nil];\n    }\n}\n```\n这样，我们就知道当前这个control被添加到哪个父视图上了，为了安全及代码的严谨，先判断父视图是否属于\n`UIScrollView`，如果是，就用KVO监听`contentOffset`属性，这样便能知道用户滑动的偏移量。\n\n这里我定义了3种状态：\n```\ntypedef NS_ENUM(NSInteger, FMRefreshState) {\n    FMRefreshStateNormal = 0,     /** 普通状态 */\n    FMRefreshStatePulling,        /** 释放刷新状态 */\n    FMRefreshStateRefreshing,     /** 正在刷新 */\n};\n```\n以及切换状态后UI的切换和方法的触发：\n```\n- (void)setCurrentStatus:(FMRefreshState)currentStatus {\n    _currentStatus = currentStatus;\n    switch (_currentStatus) {\n        case FMRefreshStateNormal:\n            NSLog(@\"切换到Normal\");\n            [self.imageView stopAnimating];\n            self.label.text = FM_Refresh_normal_title;\n            [self.label sizeToFit];\n            self.imageView.image = [UIImage imageNamed:@\"refresh_1\"];\n            \n            break;\n        case FMRefreshStatePulling:\n            NSLog(@\"切换到Pulling\");\n            self.label.text = FM_Refresh_pulling_title;\n            [self.label sizeToFit];\n            self.imageView.animationImages = self.refreshingImages;\n            self.imageView.animationDuration = 1.5;\n            [self.imageView startAnimating];\n            \n            break;\n        case FMRefreshStateRefreshing:\n            NSLog(@\"切换到Refreshing\");\n            self.label.text = FM_Refresh_Refreshing_title;\n            [self.label sizeToFit];\n            [self beginRefreshing];\n            self.imageView.animationImages = self.refreshingImages;\n            self.imageView.animationDuration = 1.5;\n            [self.imageView startAnimating];\n            [self doRefreshAction];\n            \n            break;\n    }\n}\n```\n切换到`FMRefreshStateNormal` 停止动画，切换到`FMRefreshStatePulling` 开始动画，达到这个状态，说明用户已经达到了刷新的偏移量，此时松手便可刷新，切换到`FMRefreshStateRefreshing`，如果此时往回滑动，小于临界值，那么状态重新切回`FMRefreshStateNormal`。\n满足刷新条件，则便可执行以下方法：\n```\n- (void)doRefreshAction\n{\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n    if (self.refreshTarget && [self.refreshTarget respondsToSelector:self.refreshAction])\n        [self.refreshTarget performSelector:self.refreshAction];\n#pragma clang diagnostic pop\n    \n}\n```\n下面看最关键的KVO方法，也是这里面最复杂的逻辑处理代码：\n```\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {\n    \n    //isDragging 属性是指用户手指是否在拖动\n    if (self.superScrollView.isDragging && !self.isRefreshing) {\n        if (!self.originalOffsetY) {\n            self.originalOffsetY = -self.superScrollView.contentInset.top;\n        }\n        CGFloat normalPullingOffset =  self.originalOffsetY - k_FMRefresh_Height;\n        if (self.currentStatus == FMRefreshStatePulling && self.superScrollView.contentOffset.y > normalPullingOffset) {\n            \n            self.currentStatus = FMRefreshStateNormal;\n        } else if (self.currentStatus == FMRefreshStateNormal && self.superScrollView.contentOffset.y < normalPullingOffset) {\n            self.currentStatus = FMRefreshStatePulling;\n        }\n    } else if(!self.superScrollView.isDragging){\n        \n        if (self.currentStatus == FMRefreshStatePulling) {\n            \n            self.currentStatus = FMRefreshStateRefreshing;\n        }\n    }\n\t//拖动的偏移量，转换成正数\n    CGFloat pullDistance = -self.frame.origin.y;\n    self.backgroundView.frame = CGRectMake(0, 0, k_FMRefresh_Width, pullDistance);\n    CGFloat totalWidth = 35 + 20 + self.label.bounds.size.width;\n    CGFloat imageViewX = (k_FMRefresh_Width - totalWidth)/2;\n    \n    self.imageView.frame = CGRectMake(imageViewX,  -k_FMRefresh_Height+pullDistance+(k_FMRefresh_Height - self.imageView.bounds.size.height)/2, self.imageView.frame.size.width, self.imageView.frame.size.height);\n    self.label.frame = CGRectMake(imageViewX + 35 + 20, -k_FMRefresh_Height + pullDistance + (k_FMRefresh_Height - self.label.bounds.size.height)/2, self.label.frame.size.width, self.label.frame.size.height);   \n}\n```\n这里最重要的就是处理两点：1. 根据偏移量和用户手指的拖动来切换状态，2. control上面的子视图需要我们根据偏移量来实时更新。\n\n还有一种情况，上面也提到过，用户先滑动到`FMRefreshStatePulling`状态，然后又往回滑动，此时的偏移量在0-`FMRefreshStatePulling`状态的偏移量之间，此时调用自身的 `endRefreshing`偏移量不会复原，还需要我们自己处理，看了几个老外写的自定义刷新控件，他们都没修复这个bug。他们也没封装，全部代码写在了控制器里，什么都没有改变，只是实现了一个动画效果，还多了个bug,动画效果倒是不错的。有兴趣的可以参考一番：\n[https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/](https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/)\n[https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/](https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/)\n\n\n```\n- (void)endRefreshing {\n    if (self.currentStatus != FMRefreshStateRefreshing) {\n        return;\n    }\n    self.currentStatus = FMRefreshStateNormal;\n    [super endRefreshing];\n    \n    //在执行刷新的状态中，用户手动拖动到 nornal 状态的 offset，[super endRefreshing] 无法回到初始位置，所以手动设置\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        if(self.superScrollView.contentOffset.y >= self.originalOffsetY - k_FMRefresh_Height && self.superScrollView.contentOffset.y <= self.originalOffsetY) {\n            CGPoint offset = self.superScrollView.contentOffset;\n            offset.y = self.originalOffsetY;\n            [self.superScrollView setContentOffset:offset animated:YES];\n        }\n    });\n\n}\n```\n最后还有一点不要忘记 `dealloc`移除监听：\n```\n- (void)dealloc {\n    [self.superScrollView removeObserver:self forKeyPath:@\"contentOffset\"];\n}\n```\n整篇文章从上至下是按照整个完整的思路写下来的，先是提出遇到的问题以及难点，然后最后的代码和思路也是由外至内一路写下来，希望方便大家阅读。这是上篇，下拉刷新的，还有下篇，上拉加载，过两天写，demo中已经有了，不过就是还没优化。\n\n[domo地址：https://github.com/suifengqjn/FMRefreshControl](https://github.com/suifengqjn/FMRefreshControl)\n\n\n\n\n\n\n\n","source":"_posts/自定义刷新控件.md","raw":"---\ntitle: 自定义刷新控件\ntags:\n  - iOS\n  - UIRefreshControl\ncategories:\n  - iOS技术\n---\n\n### 一：前言\n记得工作中第一次用的刷新控件是`svpulltorefresh`，用法稍微有点麻烦，而且bug颇多，后来果断放弃，现在用的是`MJRefresh`,不管是用法还是bug，都比前一个好多了，但是不久前也遇到了一个致命的bug，有好些情况下会导致`MJRefresh`陷入一个死循环，导致不断的刷新，只能重启软件才行。`MJRefresh`工程比较庞大，找到了bug也很难修改，然后还是决定自己写一个，系统提供的`UIRefreshControl`我认为是最好的，缺点是不提供自定义UI的方法，那么我就自己基于它来自定义UI。我不是一开始就决定继承于`UIRefreshControl`，我同时也写了一个继承与`UIView`的control，两个进行对比，发现使用`UIview`会有很多弊端，这种弊端在一些复杂特殊的情况下一下子就暴露出来了，而且很难解决，当然，正常状态下是没什么问题的，有兴趣的同学倒是可以去试一试。本demo供大家学习和参考，如有发现bug，还请issues 我。\n\n### 二: 了解 UIRefreshControl\n* 基本使用方法\n\n```\n//初始化一个control\nUIRefreshControl *control = [[UIRefreshControl alloc] init];\n//给control 添加一个刷新方法\n[control addTarget:self action:@selector(refreshAction) forControlEvents:UIControlEventValueChanged];\n//把control 添加到 tableView\n[self.tableView addSubview:control];\n```\n\n* 存在的问题\n\t* 1. 刷新时的动画是一个灰色小菊花，很多情况下不符合app的刷新动画效果\n\t* 2. 经过多次反复测试，下拉的偏移量达到130以上才会触发刷新方法，很显然这个也不符合，一般的刷新控件的高度60左右，所以下拉的偏移量达到60就可以触发刷新的方法了。\n\n* 自定义控件的思路\n\t* 1. 去掉默认的动画效果\n\t* 2. 自定义自己的动画效果\n\t* 3. 改变满足刷新时的条件\n\t<!-- more -->\n### 三：FMRefreshControl\n\n* 先看一下我写完的这个控件的使用方法\n\n``` \nFMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];\n\n[self.tableView addSubview:control];\n```\n两行代码，用法比系统的还要稍微简单一点。\n\n* 再看一下效果\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/FMRefresh/1.gif)\n\n### 四：思路与代码\n#### 1. 关于 `UIRefreshControl` 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 `superViwe`,再执行 \n`[[_control.subviews objectAtIndex:0] setFrame:CGRectMake(0, 0, _control.bounds.size.width, 30)];`\n一开始我是想改变它的高度是否就能改变它的触发刷新的偏移量，然后我找到了这个方法可以修改它的高度，但实际上改变了高度还是无法改变触发下拉刷新的偏移量，所以我们需要自定义去触发刷新这个动作的时机。\n\n#### 2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。\n\n#### 3. 进入代码阶段\n```\nFMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];\n[self.tableView addSubview:control];\n```\n初始化的时候赋一个 target 和 一个 action，当满足条件的时候，我们需要知道让谁去执行刷新方法，有这两个参数足够，当执行到第二行 addSubView的时候，我们需要在control内部实现这个方法：\n```\n- (void)willMoveToSuperview:(UIView *)newSuperview {\n    [super willMoveToSuperview:newSuperview];\n    \n    if ([newSuperview isKindOfClass:[UIScrollView class]]) {\n        self.superScrollView = (UIScrollView *)newSuperview;\n        \n        [self.superScrollView addObserver:self forKeyPath:@\"contentOffset\" options:NSKeyValueObservingOptionNew context:nil];\n    }\n}\n```\n这样，我们就知道当前这个control被添加到哪个父视图上了，为了安全及代码的严谨，先判断父视图是否属于\n`UIScrollView`，如果是，就用KVO监听`contentOffset`属性，这样便能知道用户滑动的偏移量。\n\n这里我定义了3种状态：\n```\ntypedef NS_ENUM(NSInteger, FMRefreshState) {\n    FMRefreshStateNormal = 0,     /** 普通状态 */\n    FMRefreshStatePulling,        /** 释放刷新状态 */\n    FMRefreshStateRefreshing,     /** 正在刷新 */\n};\n```\n以及切换状态后UI的切换和方法的触发：\n```\n- (void)setCurrentStatus:(FMRefreshState)currentStatus {\n    _currentStatus = currentStatus;\n    switch (_currentStatus) {\n        case FMRefreshStateNormal:\n            NSLog(@\"切换到Normal\");\n            [self.imageView stopAnimating];\n            self.label.text = FM_Refresh_normal_title;\n            [self.label sizeToFit];\n            self.imageView.image = [UIImage imageNamed:@\"refresh_1\"];\n            \n            break;\n        case FMRefreshStatePulling:\n            NSLog(@\"切换到Pulling\");\n            self.label.text = FM_Refresh_pulling_title;\n            [self.label sizeToFit];\n            self.imageView.animationImages = self.refreshingImages;\n            self.imageView.animationDuration = 1.5;\n            [self.imageView startAnimating];\n            \n            break;\n        case FMRefreshStateRefreshing:\n            NSLog(@\"切换到Refreshing\");\n            self.label.text = FM_Refresh_Refreshing_title;\n            [self.label sizeToFit];\n            [self beginRefreshing];\n            self.imageView.animationImages = self.refreshingImages;\n            self.imageView.animationDuration = 1.5;\n            [self.imageView startAnimating];\n            [self doRefreshAction];\n            \n            break;\n    }\n}\n```\n切换到`FMRefreshStateNormal` 停止动画，切换到`FMRefreshStatePulling` 开始动画，达到这个状态，说明用户已经达到了刷新的偏移量，此时松手便可刷新，切换到`FMRefreshStateRefreshing`，如果此时往回滑动，小于临界值，那么状态重新切回`FMRefreshStateNormal`。\n满足刷新条件，则便可执行以下方法：\n```\n- (void)doRefreshAction\n{\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n    if (self.refreshTarget && [self.refreshTarget respondsToSelector:self.refreshAction])\n        [self.refreshTarget performSelector:self.refreshAction];\n#pragma clang diagnostic pop\n    \n}\n```\n下面看最关键的KVO方法，也是这里面最复杂的逻辑处理代码：\n```\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {\n    \n    //isDragging 属性是指用户手指是否在拖动\n    if (self.superScrollView.isDragging && !self.isRefreshing) {\n        if (!self.originalOffsetY) {\n            self.originalOffsetY = -self.superScrollView.contentInset.top;\n        }\n        CGFloat normalPullingOffset =  self.originalOffsetY - k_FMRefresh_Height;\n        if (self.currentStatus == FMRefreshStatePulling && self.superScrollView.contentOffset.y > normalPullingOffset) {\n            \n            self.currentStatus = FMRefreshStateNormal;\n        } else if (self.currentStatus == FMRefreshStateNormal && self.superScrollView.contentOffset.y < normalPullingOffset) {\n            self.currentStatus = FMRefreshStatePulling;\n        }\n    } else if(!self.superScrollView.isDragging){\n        \n        if (self.currentStatus == FMRefreshStatePulling) {\n            \n            self.currentStatus = FMRefreshStateRefreshing;\n        }\n    }\n\t//拖动的偏移量，转换成正数\n    CGFloat pullDistance = -self.frame.origin.y;\n    self.backgroundView.frame = CGRectMake(0, 0, k_FMRefresh_Width, pullDistance);\n    CGFloat totalWidth = 35 + 20 + self.label.bounds.size.width;\n    CGFloat imageViewX = (k_FMRefresh_Width - totalWidth)/2;\n    \n    self.imageView.frame = CGRectMake(imageViewX,  -k_FMRefresh_Height+pullDistance+(k_FMRefresh_Height - self.imageView.bounds.size.height)/2, self.imageView.frame.size.width, self.imageView.frame.size.height);\n    self.label.frame = CGRectMake(imageViewX + 35 + 20, -k_FMRefresh_Height + pullDistance + (k_FMRefresh_Height - self.label.bounds.size.height)/2, self.label.frame.size.width, self.label.frame.size.height);   \n}\n```\n这里最重要的就是处理两点：1. 根据偏移量和用户手指的拖动来切换状态，2. control上面的子视图需要我们根据偏移量来实时更新。\n\n还有一种情况，上面也提到过，用户先滑动到`FMRefreshStatePulling`状态，然后又往回滑动，此时的偏移量在0-`FMRefreshStatePulling`状态的偏移量之间，此时调用自身的 `endRefreshing`偏移量不会复原，还需要我们自己处理，看了几个老外写的自定义刷新控件，他们都没修复这个bug。他们也没封装，全部代码写在了控制器里，什么都没有改变，只是实现了一个动画效果，还多了个bug,动画效果倒是不错的。有兴趣的可以参考一番：\n[https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/](https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/)\n[https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/](https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/)\n\n\n```\n- (void)endRefreshing {\n    if (self.currentStatus != FMRefreshStateRefreshing) {\n        return;\n    }\n    self.currentStatus = FMRefreshStateNormal;\n    [super endRefreshing];\n    \n    //在执行刷新的状态中，用户手动拖动到 nornal 状态的 offset，[super endRefreshing] 无法回到初始位置，所以手动设置\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        if(self.superScrollView.contentOffset.y >= self.originalOffsetY - k_FMRefresh_Height && self.superScrollView.contentOffset.y <= self.originalOffsetY) {\n            CGPoint offset = self.superScrollView.contentOffset;\n            offset.y = self.originalOffsetY;\n            [self.superScrollView setContentOffset:offset animated:YES];\n        }\n    });\n\n}\n```\n最后还有一点不要忘记 `dealloc`移除监听：\n```\n- (void)dealloc {\n    [self.superScrollView removeObserver:self forKeyPath:@\"contentOffset\"];\n}\n```\n整篇文章从上至下是按照整个完整的思路写下来的，先是提出遇到的问题以及难点，然后最后的代码和思路也是由外至内一路写下来，希望方便大家阅读。这是上篇，下拉刷新的，还有下篇，上拉加载，过两天写，demo中已经有了，不过就是还没优化。\n\n[domo地址：https://github.com/suifengqjn/FMRefreshControl](https://github.com/suifengqjn/FMRefreshControl)\n\n\n\n\n\n\n\n","slug":"自定义刷新控件","published":1,"date":"2016-11-16T15:05:20.000Z","updated":"2016-11-16T15:05:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tfg0039lx60pkewp9qq","content":"<h3 id=\"一：前言\"><a href=\"#一：前言\" class=\"headerlink\" title=\"一：前言\"></a>一：前言</h3><p>记得工作中第一次用的刷新控件是<code>svpulltorefresh</code>，用法稍微有点麻烦，而且bug颇多，后来果断放弃，现在用的是<code>MJRefresh</code>,不管是用法还是bug，都比前一个好多了，但是不久前也遇到了一个致命的bug，有好些情况下会导致<code>MJRefresh</code>陷入一个死循环，导致不断的刷新，只能重启软件才行。<code>MJRefresh</code>工程比较庞大，找到了bug也很难修改，然后还是决定自己写一个，系统提供的<code>UIRefreshControl</code>我认为是最好的，缺点是不提供自定义UI的方法，那么我就自己基于它来自定义UI。我不是一开始就决定继承于<code>UIRefreshControl</code>，我同时也写了一个继承与<code>UIView</code>的control，两个进行对比，发现使用<code>UIview</code>会有很多弊端，这种弊端在一些复杂特殊的情况下一下子就暴露出来了，而且很难解决，当然，正常状态下是没什么问题的，有兴趣的同学倒是可以去试一试。本demo供大家学习和参考，如有发现bug，还请issues 我。</p>\n<h3 id=\"二-了解-UIRefreshControl\"><a href=\"#二-了解-UIRefreshControl\" class=\"headerlink\" title=\"二: 了解 UIRefreshControl\"></a>二: 了解 UIRefreshControl</h3><ul>\n<li>基本使用方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化一个control</div><div class=\"line\">UIRefreshControl *control = [[UIRefreshControl alloc] init];</div><div class=\"line\">//给control 添加一个刷新方法</div><div class=\"line\">[control addTarget:self action:@selector(refreshAction) forControlEvents:UIControlEventValueChanged];</div><div class=\"line\">//把control 添加到 tableView</div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<ul>\n<li><p>存在的问题</p>\n<ul>\n<li><ol>\n<li>刷新时的动画是一个灰色小菊花，很多情况下不符合app的刷新动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>经过多次反复测试，下拉的偏移量达到130以上才会触发刷新方法，很显然这个也不符合，一般的刷新控件的高度60左右，所以下拉的偏移量达到60就可以触发刷新的方法了。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>自定义控件的思路</p>\n<ul>\n<li><ol>\n<li>去掉默认的动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>自定义自己的动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>改变满足刷新时的条件<a id=\"more\"></a>\n<h3 id=\"三：FMRefreshControl\"><a href=\"#三：FMRefreshControl\" class=\"headerlink\" title=\"三：FMRefreshControl\"></a>三：FMRefreshControl</h3></li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>先看一下我写完的这个控件的使用方法</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];</div><div class=\"line\"></div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<p>两行代码，用法比系统的还要稍微简单一点。</p>\n<ul>\n<li>再看一下效果</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/FMRefresh/1.gif\" alt=\"image\"></p>\n<h3 id=\"四：思路与代码\"><a href=\"#四：思路与代码\" class=\"headerlink\" title=\"四：思路与代码\"></a>四：思路与代码</h3><h4 id=\"1-关于-UIRefreshControl-的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到-superViwe-再执行\"><a href=\"#1-关于-UIRefreshControl-的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到-superViwe-再执行\" class=\"headerlink\" title=\"1. 关于 UIRefreshControl 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 superViwe,再执行\"></a>1. 关于 <code>UIRefreshControl</code> 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 <code>superViwe</code>,再执行</h4><p><code>[[_control.subviews objectAtIndex:0] setFrame:CGRectMake(0, 0, _control.bounds.size.width, 30)];</code><br>一开始我是想改变它的高度是否就能改变它的触发刷新的偏移量，然后我找到了这个方法可以修改它的高度，但实际上改变了高度还是无法改变触发下拉刷新的偏移量，所以我们需要自定义去触发刷新这个动作的时机。</p>\n<h4 id=\"2-手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow-因偏移量变动而导致非人为的刷新。\"><a href=\"#2-手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow-因偏移量变动而导致非人为的刷新。\" class=\"headerlink\" title=\"2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。\"></a>2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。</h4><h4 id=\"3-进入代码阶段\"><a href=\"#3-进入代码阶段\" class=\"headerlink\" title=\"3. 进入代码阶段\"></a>3. 进入代码阶段</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];</div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<p>初始化的时候赋一个 target 和 一个 action，当满足条件的时候，我们需要知道让谁去执行刷新方法，有这两个参数足够，当执行到第二行 addSubView的时候，我们需要在control内部实现这个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)willMoveToSuperview:(UIView *)newSuperview &#123;</div><div class=\"line\">    [super willMoveToSuperview:newSuperview];</div><div class=\"line\">    </div><div class=\"line\">    if ([newSuperview isKindOfClass:[UIScrollView class]]) &#123;</div><div class=\"line\">        self.superScrollView = (UIScrollView *)newSuperview;</div><div class=\"line\">        </div><div class=\"line\">        [self.superScrollView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样，我们就知道当前这个control被添加到哪个父视图上了，为了安全及代码的严谨，先判断父视图是否属于<br><code>UIScrollView</code>，如果是，就用KVO监听<code>contentOffset</code>属性，这样便能知道用户滑动的偏移量。</p>\n<p>这里我定义了3种状态：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, FMRefreshState) &#123;</div><div class=\"line\">    FMRefreshStateNormal = 0,     /** 普通状态 */</div><div class=\"line\">    FMRefreshStatePulling,        /** 释放刷新状态 */</div><div class=\"line\">    FMRefreshStateRefreshing,     /** 正在刷新 */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>以及切换状态后UI的切换和方法的触发：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setCurrentStatus:(FMRefreshState)currentStatus &#123;</div><div class=\"line\">    _currentStatus = currentStatus;</div><div class=\"line\">    switch (_currentStatus) &#123;</div><div class=\"line\">        case FMRefreshStateNormal:</div><div class=\"line\">            NSLog(@&quot;切换到Normal&quot;);</div><div class=\"line\">            [self.imageView stopAnimating];</div><div class=\"line\">            self.label.text = FM_Refresh_normal_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            self.imageView.image = [UIImage imageNamed:@&quot;refresh_1&quot;];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">        case FMRefreshStatePulling:</div><div class=\"line\">            NSLog(@&quot;切换到Pulling&quot;);</div><div class=\"line\">            self.label.text = FM_Refresh_pulling_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            self.imageView.animationImages = self.refreshingImages;</div><div class=\"line\">            self.imageView.animationDuration = 1.5;</div><div class=\"line\">            [self.imageView startAnimating];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">        case FMRefreshStateRefreshing:</div><div class=\"line\">            NSLog(@&quot;切换到Refreshing&quot;);</div><div class=\"line\">            self.label.text = FM_Refresh_Refreshing_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            [self beginRefreshing];</div><div class=\"line\">            self.imageView.animationImages = self.refreshingImages;</div><div class=\"line\">            self.imageView.animationDuration = 1.5;</div><div class=\"line\">            [self.imageView startAnimating];</div><div class=\"line\">            [self doRefreshAction];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>切换到<code>FMRefreshStateNormal</code> 停止动画，切换到<code>FMRefreshStatePulling</code> 开始动画，达到这个状态，说明用户已经达到了刷新的偏移量，此时松手便可刷新，切换到<code>FMRefreshStateRefreshing</code>，如果此时往回滑动，小于临界值，那么状态重新切回<code>FMRefreshStateNormal</code>。<br>满足刷新条件，则便可执行以下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)doRefreshAction</div><div class=\"line\">&#123;</div><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</div><div class=\"line\">    if (self.refreshTarget &amp;&amp; [self.refreshTarget respondsToSelector:self.refreshAction])</div><div class=\"line\">        [self.refreshTarget performSelector:self.refreshAction];</div><div class=\"line\">#pragma clang diagnostic pop</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面看最关键的KVO方法，也是这里面最复杂的逻辑处理代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</div><div class=\"line\">    </div><div class=\"line\">    //isDragging 属性是指用户手指是否在拖动</div><div class=\"line\">    if (self.superScrollView.isDragging &amp;&amp; !self.isRefreshing) &#123;</div><div class=\"line\">        if (!self.originalOffsetY) &#123;</div><div class=\"line\">            self.originalOffsetY = -self.superScrollView.contentInset.top;</div><div class=\"line\">        &#125;</div><div class=\"line\">        CGFloat normalPullingOffset =  self.originalOffsetY - k_FMRefresh_Height;</div><div class=\"line\">        if (self.currentStatus == FMRefreshStatePulling &amp;&amp; self.superScrollView.contentOffset.y &gt; normalPullingOffset) &#123;</div><div class=\"line\">            </div><div class=\"line\">            self.currentStatus = FMRefreshStateNormal;</div><div class=\"line\">        &#125; else if (self.currentStatus == FMRefreshStateNormal &amp;&amp; self.superScrollView.contentOffset.y &lt; normalPullingOffset) &#123;</div><div class=\"line\">            self.currentStatus = FMRefreshStatePulling;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else if(!self.superScrollView.isDragging)&#123;</div><div class=\"line\">        </div><div class=\"line\">        if (self.currentStatus == FMRefreshStatePulling) &#123;</div><div class=\"line\">            </div><div class=\"line\">            self.currentStatus = FMRefreshStateRefreshing;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t//拖动的偏移量，转换成正数</div><div class=\"line\">    CGFloat pullDistance = -self.frame.origin.y;</div><div class=\"line\">    self.backgroundView.frame = CGRectMake(0, 0, k_FMRefresh_Width, pullDistance);</div><div class=\"line\">    CGFloat totalWidth = 35 + 20 + self.label.bounds.size.width;</div><div class=\"line\">    CGFloat imageViewX = (k_FMRefresh_Width - totalWidth)/2;</div><div class=\"line\">    </div><div class=\"line\">    self.imageView.frame = CGRectMake(imageViewX,  -k_FMRefresh_Height+pullDistance+(k_FMRefresh_Height - self.imageView.bounds.size.height)/2, self.imageView.frame.size.width, self.imageView.frame.size.height);</div><div class=\"line\">    self.label.frame = CGRectMake(imageViewX + 35 + 20, -k_FMRefresh_Height + pullDistance + (k_FMRefresh_Height - self.label.bounds.size.height)/2, self.label.frame.size.width, self.label.frame.size.height);   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里最重要的就是处理两点：1. 根据偏移量和用户手指的拖动来切换状态，2. control上面的子视图需要我们根据偏移量来实时更新。</p>\n<p>还有一种情况，上面也提到过，用户先滑动到<code>FMRefreshStatePulling</code>状态，然后又往回滑动，此时的偏移量在0-<code>FMRefreshStatePulling</code>状态的偏移量之间，此时调用自身的 <code>endRefreshing</code>偏移量不会复原，还需要我们自己处理，看了几个老外写的自定义刷新控件，他们都没修复这个bug。他们也没封装，全部代码写在了控制器里，什么都没有改变，只是实现了一个动画效果，还多了个bug,动画效果倒是不错的。有兴趣的可以参考一番：<br><a href=\"https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/\" target=\"_blank\" rel=\"external\">https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/</a><br><a href=\"https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/\" target=\"_blank\" rel=\"external\">https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)endRefreshing &#123;</div><div class=\"line\">    if (self.currentStatus != FMRefreshStateRefreshing) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.currentStatus = FMRefreshStateNormal;</div><div class=\"line\">    [super endRefreshing];</div><div class=\"line\">    </div><div class=\"line\">    //在执行刷新的状态中，用户手动拖动到 nornal 状态的 offset，[super endRefreshing] 无法回到初始位置，所以手动设置</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        if(self.superScrollView.contentOffset.y &gt;= self.originalOffsetY - k_FMRefresh_Height &amp;&amp; self.superScrollView.contentOffset.y &lt;= self.originalOffsetY) &#123;</div><div class=\"line\">            CGPoint offset = self.superScrollView.contentOffset;</div><div class=\"line\">            offset.y = self.originalOffsetY;</div><div class=\"line\">            [self.superScrollView setContentOffset:offset animated:YES];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后还有一点不要忘记 <code>dealloc</code>移除监听：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)dealloc &#123;</div><div class=\"line\">    [self.superScrollView removeObserver:self forKeyPath:@&quot;contentOffset&quot;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>整篇文章从上至下是按照整个完整的思路写下来的，先是提出遇到的问题以及难点，然后最后的代码和思路也是由外至内一路写下来，希望方便大家阅读。这是上篇，下拉刷新的，还有下篇，上拉加载，过两天写，demo中已经有了，不过就是还没优化。</p>\n<p><a href=\"https://github.com/suifengqjn/FMRefreshControl\" target=\"_blank\" rel=\"external\">domo地址：https://github.com/suifengqjn/FMRefreshControl</a></p>\n","excerpt":"<h3 id=\"一：前言\"><a href=\"#一：前言\" class=\"headerlink\" title=\"一：前言\"></a>一：前言</h3><p>记得工作中第一次用的刷新控件是<code>svpulltorefresh</code>，用法稍微有点麻烦，而且bug颇多，后来果断放弃，现在用的是<code>MJRefresh</code>,不管是用法还是bug，都比前一个好多了，但是不久前也遇到了一个致命的bug，有好些情况下会导致<code>MJRefresh</code>陷入一个死循环，导致不断的刷新，只能重启软件才行。<code>MJRefresh</code>工程比较庞大，找到了bug也很难修改，然后还是决定自己写一个，系统提供的<code>UIRefreshControl</code>我认为是最好的，缺点是不提供自定义UI的方法，那么我就自己基于它来自定义UI。我不是一开始就决定继承于<code>UIRefreshControl</code>，我同时也写了一个继承与<code>UIView</code>的control，两个进行对比，发现使用<code>UIview</code>会有很多弊端，这种弊端在一些复杂特殊的情况下一下子就暴露出来了，而且很难解决，当然，正常状态下是没什么问题的，有兴趣的同学倒是可以去试一试。本demo供大家学习和参考，如有发现bug，还请issues 我。</p>\n<h3 id=\"二-了解-UIRefreshControl\"><a href=\"#二-了解-UIRefreshControl\" class=\"headerlink\" title=\"二: 了解 UIRefreshControl\"></a>二: 了解 UIRefreshControl</h3><ul>\n<li>基本使用方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化一个control</div><div class=\"line\">UIRefreshControl *control = [[UIRefreshControl alloc] init];</div><div class=\"line\">//给control 添加一个刷新方法</div><div class=\"line\">[control addTarget:self action:@selector(refreshAction) forControlEvents:UIControlEventValueChanged];</div><div class=\"line\">//把control 添加到 tableView</div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<ul>\n<li><p>存在的问题</p>\n<ul>\n<li><ol>\n<li>刷新时的动画是一个灰色小菊花，很多情况下不符合app的刷新动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>经过多次反复测试，下拉的偏移量达到130以上才会触发刷新方法，很显然这个也不符合，一般的刷新控件的高度60左右，所以下拉的偏移量达到60就可以触发刷新的方法了。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>自定义控件的思路</p>\n<ul>\n<li><ol>\n<li>去掉默认的动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>自定义自己的动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>改变满足刷新时的条件","more":"<h3 id=\"三：FMRefreshControl\"><a href=\"#三：FMRefreshControl\" class=\"headerlink\" title=\"三：FMRefreshControl\"></a>三：FMRefreshControl</h3></li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>先看一下我写完的这个控件的使用方法</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];</div><div class=\"line\"></div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<p>两行代码，用法比系统的还要稍微简单一点。</p>\n<ul>\n<li>再看一下效果</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/FMRefresh/1.gif\" alt=\"image\"></p>\n<h3 id=\"四：思路与代码\"><a href=\"#四：思路与代码\" class=\"headerlink\" title=\"四：思路与代码\"></a>四：思路与代码</h3><h4 id=\"1-关于-UIRefreshControl-的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到-superViwe-再执行\"><a href=\"#1-关于-UIRefreshControl-的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到-superViwe-再执行\" class=\"headerlink\" title=\"1. 关于 UIRefreshControl 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 superViwe,再执行\"></a>1. 关于 <code>UIRefreshControl</code> 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 <code>superViwe</code>,再执行</h4><p><code>[[_control.subviews objectAtIndex:0] setFrame:CGRectMake(0, 0, _control.bounds.size.width, 30)];</code><br>一开始我是想改变它的高度是否就能改变它的触发刷新的偏移量，然后我找到了这个方法可以修改它的高度，但实际上改变了高度还是无法改变触发下拉刷新的偏移量，所以我们需要自定义去触发刷新这个动作的时机。</p>\n<h4 id=\"2-手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow-因偏移量变动而导致非人为的刷新。\"><a href=\"#2-手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow-因偏移量变动而导致非人为的刷新。\" class=\"headerlink\" title=\"2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。\"></a>2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。</h4><h4 id=\"3-进入代码阶段\"><a href=\"#3-进入代码阶段\" class=\"headerlink\" title=\"3. 进入代码阶段\"></a>3. 进入代码阶段</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];</div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<p>初始化的时候赋一个 target 和 一个 action，当满足条件的时候，我们需要知道让谁去执行刷新方法，有这两个参数足够，当执行到第二行 addSubView的时候，我们需要在control内部实现这个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)willMoveToSuperview:(UIView *)newSuperview &#123;</div><div class=\"line\">    [super willMoveToSuperview:newSuperview];</div><div class=\"line\">    </div><div class=\"line\">    if ([newSuperview isKindOfClass:[UIScrollView class]]) &#123;</div><div class=\"line\">        self.superScrollView = (UIScrollView *)newSuperview;</div><div class=\"line\">        </div><div class=\"line\">        [self.superScrollView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样，我们就知道当前这个control被添加到哪个父视图上了，为了安全及代码的严谨，先判断父视图是否属于<br><code>UIScrollView</code>，如果是，就用KVO监听<code>contentOffset</code>属性，这样便能知道用户滑动的偏移量。</p>\n<p>这里我定义了3种状态：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, FMRefreshState) &#123;</div><div class=\"line\">    FMRefreshStateNormal = 0,     /** 普通状态 */</div><div class=\"line\">    FMRefreshStatePulling,        /** 释放刷新状态 */</div><div class=\"line\">    FMRefreshStateRefreshing,     /** 正在刷新 */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>以及切换状态后UI的切换和方法的触发：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setCurrentStatus:(FMRefreshState)currentStatus &#123;</div><div class=\"line\">    _currentStatus = currentStatus;</div><div class=\"line\">    switch (_currentStatus) &#123;</div><div class=\"line\">        case FMRefreshStateNormal:</div><div class=\"line\">            NSLog(@&quot;切换到Normal&quot;);</div><div class=\"line\">            [self.imageView stopAnimating];</div><div class=\"line\">            self.label.text = FM_Refresh_normal_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            self.imageView.image = [UIImage imageNamed:@&quot;refresh_1&quot;];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">        case FMRefreshStatePulling:</div><div class=\"line\">            NSLog(@&quot;切换到Pulling&quot;);</div><div class=\"line\">            self.label.text = FM_Refresh_pulling_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            self.imageView.animationImages = self.refreshingImages;</div><div class=\"line\">            self.imageView.animationDuration = 1.5;</div><div class=\"line\">            [self.imageView startAnimating];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">        case FMRefreshStateRefreshing:</div><div class=\"line\">            NSLog(@&quot;切换到Refreshing&quot;);</div><div class=\"line\">            self.label.text = FM_Refresh_Refreshing_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            [self beginRefreshing];</div><div class=\"line\">            self.imageView.animationImages = self.refreshingImages;</div><div class=\"line\">            self.imageView.animationDuration = 1.5;</div><div class=\"line\">            [self.imageView startAnimating];</div><div class=\"line\">            [self doRefreshAction];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>切换到<code>FMRefreshStateNormal</code> 停止动画，切换到<code>FMRefreshStatePulling</code> 开始动画，达到这个状态，说明用户已经达到了刷新的偏移量，此时松手便可刷新，切换到<code>FMRefreshStateRefreshing</code>，如果此时往回滑动，小于临界值，那么状态重新切回<code>FMRefreshStateNormal</code>。<br>满足刷新条件，则便可执行以下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)doRefreshAction</div><div class=\"line\">&#123;</div><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</div><div class=\"line\">    if (self.refreshTarget &amp;&amp; [self.refreshTarget respondsToSelector:self.refreshAction])</div><div class=\"line\">        [self.refreshTarget performSelector:self.refreshAction];</div><div class=\"line\">#pragma clang diagnostic pop</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面看最关键的KVO方法，也是这里面最复杂的逻辑处理代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</div><div class=\"line\">    </div><div class=\"line\">    //isDragging 属性是指用户手指是否在拖动</div><div class=\"line\">    if (self.superScrollView.isDragging &amp;&amp; !self.isRefreshing) &#123;</div><div class=\"line\">        if (!self.originalOffsetY) &#123;</div><div class=\"line\">            self.originalOffsetY = -self.superScrollView.contentInset.top;</div><div class=\"line\">        &#125;</div><div class=\"line\">        CGFloat normalPullingOffset =  self.originalOffsetY - k_FMRefresh_Height;</div><div class=\"line\">        if (self.currentStatus == FMRefreshStatePulling &amp;&amp; self.superScrollView.contentOffset.y &gt; normalPullingOffset) &#123;</div><div class=\"line\">            </div><div class=\"line\">            self.currentStatus = FMRefreshStateNormal;</div><div class=\"line\">        &#125; else if (self.currentStatus == FMRefreshStateNormal &amp;&amp; self.superScrollView.contentOffset.y &lt; normalPullingOffset) &#123;</div><div class=\"line\">            self.currentStatus = FMRefreshStatePulling;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else if(!self.superScrollView.isDragging)&#123;</div><div class=\"line\">        </div><div class=\"line\">        if (self.currentStatus == FMRefreshStatePulling) &#123;</div><div class=\"line\">            </div><div class=\"line\">            self.currentStatus = FMRefreshStateRefreshing;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t//拖动的偏移量，转换成正数</div><div class=\"line\">    CGFloat pullDistance = -self.frame.origin.y;</div><div class=\"line\">    self.backgroundView.frame = CGRectMake(0, 0, k_FMRefresh_Width, pullDistance);</div><div class=\"line\">    CGFloat totalWidth = 35 + 20 + self.label.bounds.size.width;</div><div class=\"line\">    CGFloat imageViewX = (k_FMRefresh_Width - totalWidth)/2;</div><div class=\"line\">    </div><div class=\"line\">    self.imageView.frame = CGRectMake(imageViewX,  -k_FMRefresh_Height+pullDistance+(k_FMRefresh_Height - self.imageView.bounds.size.height)/2, self.imageView.frame.size.width, self.imageView.frame.size.height);</div><div class=\"line\">    self.label.frame = CGRectMake(imageViewX + 35 + 20, -k_FMRefresh_Height + pullDistance + (k_FMRefresh_Height - self.label.bounds.size.height)/2, self.label.frame.size.width, self.label.frame.size.height);   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里最重要的就是处理两点：1. 根据偏移量和用户手指的拖动来切换状态，2. control上面的子视图需要我们根据偏移量来实时更新。</p>\n<p>还有一种情况，上面也提到过，用户先滑动到<code>FMRefreshStatePulling</code>状态，然后又往回滑动，此时的偏移量在0-<code>FMRefreshStatePulling</code>状态的偏移量之间，此时调用自身的 <code>endRefreshing</code>偏移量不会复原，还需要我们自己处理，看了几个老外写的自定义刷新控件，他们都没修复这个bug。他们也没封装，全部代码写在了控制器里，什么都没有改变，只是实现了一个动画效果，还多了个bug,动画效果倒是不错的。有兴趣的可以参考一番：<br><a href=\"https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/\">https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/</a><br><a href=\"https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/\">https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)endRefreshing &#123;</div><div class=\"line\">    if (self.currentStatus != FMRefreshStateRefreshing) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.currentStatus = FMRefreshStateNormal;</div><div class=\"line\">    [super endRefreshing];</div><div class=\"line\">    </div><div class=\"line\">    //在执行刷新的状态中，用户手动拖动到 nornal 状态的 offset，[super endRefreshing] 无法回到初始位置，所以手动设置</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        if(self.superScrollView.contentOffset.y &gt;= self.originalOffsetY - k_FMRefresh_Height &amp;&amp; self.superScrollView.contentOffset.y &lt;= self.originalOffsetY) &#123;</div><div class=\"line\">            CGPoint offset = self.superScrollView.contentOffset;</div><div class=\"line\">            offset.y = self.originalOffsetY;</div><div class=\"line\">            [self.superScrollView setContentOffset:offset animated:YES];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后还有一点不要忘记 <code>dealloc</code>移除监听：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)dealloc &#123;</div><div class=\"line\">    [self.superScrollView removeObserver:self forKeyPath:@&quot;contentOffset&quot;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>整篇文章从上至下是按照整个完整的思路写下来的，先是提出遇到的问题以及难点，然后最后的代码和思路也是由外至内一路写下来，希望方便大家阅读。这是上篇，下拉刷新的，还有下篇，上拉加载，过两天写，demo中已经有了，不过就是还没优化。</p>\n<p><a href=\"https://github.com/suifengqjn/FMRefreshControl\">domo地址：https://github.com/suifengqjn/FMRefreshControl</a></p>"},{"title":"非对称加密RSA原理简介及使用","date":"2018-06-27T10:54:38.000Z","_content":"\n## 什么是RSA\n\nRSA是一种公钥密码算法，它的名字是由它的三位开发者，即Ron Rivest、Adi Shamir 和 Leonard Adleman的姓氏的首字母组成的( Rivest-Shamir-Adleman )。\n\nRSA可以被用于公钥密码和数字签名。\n\n\n## RSA加密\n\n在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达：\n\n**密文=明文<sup>E</sup> mod N** (RSA加密)\n\nRSA的密文是对代表明文的数字的E次方求mod N的结果。换句话说，就是将\n明文和自己做E次乘法,然后将其结果除以N求余数，这个余数就是密文。\n\n加密公式中出现的两个数`E`和 `N`，到底都是什么数呢? RSA的加密是求明文的\n`E`次方mod `N`，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，`E` 和 `N`是RSA加密的密钥，也就是说，`E` 和 `N`的组合就是公钥。\n\n<!--more-->\n\n## RSA解密\n\nRSA的解密和加密一样简单，可以用下面的公式来表达:\n\n**明文=密文 <sup>D</sup> mod N** ( RSA解密)\n\n表示密文的数字的D次方求 mod N就可以得到明文。\n\n这里所使用的数字N和加密时使用的数字N是相同的。数 `D` 和数 `N` 组合起来就是RSA的解密密钥，因此D和N的组合就是私钥。\n\n在RSA中，加密和解密的形式是相同的。加密是求“明文的E次方的 mod \nN\"，而解密则是求“密文的D次方的 mod N\"。\n\n## 生成密钥对\n\n在RSA中，加密是求“明文的E次方的 mod \nN\"，而解密则是求“密文的D次方的 mod N\"。\n\n由于E和N是公钥，D和N是私钥，因此求E、D和N这三个数就是生成密钥对。\n\n## 生成私钥公钥步骤\n\n用 Linux或者mac 上自带，命令如下，完成制作非对称加密的秘钥对（公钥和私钥）\n\n\n1.生成 RSA 私钥（传统格式的）\n\n`openssl genrsa -out rsa_private_key.pem 1024`\n\n2.将传统格式的私钥转换成 PKCS#8 格式的（JAVA需要使用的私钥需要经过PKCS#8编码，PHP程序不需要，可以直接略过）,这个过程需要输入两遍密码，是针对私钥的密码，不要密码直接按回车\n\n`openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM`\n\n3.生成 RSA 公钥\n\n`openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem`\n\n\n此时在系统根目录已经生成了两个文件。可以直接使用`cat`命令查看文件中的内容\n\n## 代码实现加密以及解密过程\n```\n\nvar privateKey = []byte(`-----BEGIN RSA PRIVATE KEY-----\nMIICXQIBAAKBgQCQRttulLHUA3DkckkD7Bco5fY0nBDe8RlDZuIV2pu3Ry4qgZNL\nd7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWOjmpPXZfc3NAiW0iboLa6qld0\nTfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxxLjPiWq1HQhmywNv3BQIDAQAB\nAoGAPKJ64Ct/3QGhNXFOfGaBiT+0TIH2mSusmWYoyFR6svkoTtbsJ4BkL2+sqPew\nMtEvZbcBjxSdCIcNhWMhUm10PTur6mOhcAABxTjdFEbIbJRHVlrsDYkyGPLOaaem\nUOZeTAtnNQVAnbQpXIwLmwkSSmbJPyvFc534/c7fMkHg1RUCQQDAL5kgijYHox/1\nybqKoBxKrlIjwCpgJ7XIIXRu+AyCLNvzRRviIGGQQ5Q605hSKB+j/6lYKO/kjiNA\nJh5pYPr7AkEAwC7VLAjLQeHD/QD8SaEwQr9WgE3WxF0LuS+AI767Kluw2N2RSDhw\nnfNaBhFe1j7mUQLP4C/HIFFjmi1+HiQ1/wJBAKHXM3dAjJFP4HkmAO3+OPT26Xrr\nt4OzzRQUgC12u2ngBvVMrFd3d1F6Z1hGmc4Ntd9wS5ZPGv14aNz7fL63CYMCQQC9\nT+TxwZ/nwCu+GLBtH3lY5v6g2QyM1lNsEpyZmZLpwPTOTESG7gIRtdyiSY4wYjmi\n57A6WRZAgawp/lJUArulAkA3LKFGfViQVjRWkoIYN65R87L6DohHH1LXVg4wUUtF\nIXwDFSCbHsQko+vzIlBtSXr5/hO+1CkZLtI0tisWHPCi\n-----END RSA PRIVATE KEY-----`)\n\nvar publicKey = []byte(`-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCQRttulLHUA3DkckkD7Bco5fY0\nnBDe8RlDZuIV2pu3Ry4qgZNLd7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWO\njmpPXZfc3NAiW0iboLa6qld0TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxx\nLjPiWq1HQhmywNv3BQIDAQAB\n-----END PUBLIC KEY-----`)\n\nfunc main()  {\n\n\n\tdata := []byte(\"hello world\")\n\n\tcry := RSAEncrypt(data)\n\n\tfmt.Println(hex.EncodeToString(cry))\n\n\n\tori := RSADecrypt(cry)\n\tfmt.Println(string(ori))\n\n\n}\n\nfunc RSAEncrypt(plaintxt []byte) []byte  {\n\n\t//公钥加密\n\tblock, _:= pem.Decode(publicKey)\n\n\t//解析公钥\n\tpubInterface, _ := x509.ParsePKIXPublicKey(block.Bytes)\n\n\t//加载公钥\n\tpub := pubInterface.(*rsa.PublicKey)\n\n\t//加密明文\n\tbits,_ := rsa.EncryptPKCS1v15(rand.Reader, pub, plaintxt)\n\n\t//bits为最终的密文\n\treturn bits\n}\n\nfunc RSADecrypt(cryptTxt []byte) []byte  {\n\n\tblock,_:= pem.Decode(privateKey)\n\n\tpriv,_:= x509.ParsePKCS1PrivateKey(block.Bytes)\n\n\tbits,_ := rsa.DecryptPKCS1v15(rand.Reader, priv, cryptTxt)\n\n\treturn bits\n}\n```\n\n输出\n```\n4bf96c2a3d83a71745ebc15441046f2ca0bc2cffab73a0a452bcb5c3b58ee717585e779df5046a31f71a6abf650e097f86e4ee95cb14ddd121794763a556987a965be2ec9eb47ff1cf17adcc166bc349a2471f24b924d50927b41bb61d4c0f357949a05e1f00db870582e00e7234e35923e6f1eae3021892590458af3b790f8a\nhello world\n```\n\n\n## 代码实现生成公钥私钥来加密和解密\n```\nfunc main()  {\n\n\tprikey := CreatePrivateKey()\n\tpubKey := CreatePublic(prikey)\n\t\n\t// 加密和解密\n\tori:=[]byte(\"hello world!!!\")\n\t//通过oaep函数实现公钥加密\n\t//第一个参数作用，将不同长度的明文，通过hash散列实现相同的散列值，此过程就是生成密文摘要\n\tcipherTxt,_ :=rsa.EncryptOAEP(md5.New(), rand.Reader, &pubKey, ori, nil)\n\n\tfmt.Println(cipherTxt)\n\n\t//解密\n\tplainTxt,_ := rsa.DecryptOAEP(md5.New(), rand.Reader, prikey,cipherTxt, nil)\n\tfmt.Println(string(plainTxt))\n\t\n}\n\n// 创建私钥\nfunc CreatePrivateKey() *rsa.PrivateKey  {\n\n\t// 长度为1024 位 的私钥\n\tpri,_:= rsa.GenerateKey(rand.Reader, 1024)\n\treturn pri\n\n}\n// 生成公钥\nfunc CreatePublic(prikey *rsa.PrivateKey) rsa.PublicKey  {\n\treturn prikey.PublicKey\n}\n```\n\n\n\n","source":"_posts/非对称加密RSA原理简介及使用.md","raw":"---\ntitle: 非对称加密RSA原理简介及使用\ncategories:\n  - 加密算法\ntags:\n  - 非对称加密\n  - RSA\ndate: 2018-06-27 18:54:38\n---\n\n## 什么是RSA\n\nRSA是一种公钥密码算法，它的名字是由它的三位开发者，即Ron Rivest、Adi Shamir 和 Leonard Adleman的姓氏的首字母组成的( Rivest-Shamir-Adleman )。\n\nRSA可以被用于公钥密码和数字签名。\n\n\n## RSA加密\n\n在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达：\n\n**密文=明文<sup>E</sup> mod N** (RSA加密)\n\nRSA的密文是对代表明文的数字的E次方求mod N的结果。换句话说，就是将\n明文和自己做E次乘法,然后将其结果除以N求余数，这个余数就是密文。\n\n加密公式中出现的两个数`E`和 `N`，到底都是什么数呢? RSA的加密是求明文的\n`E`次方mod `N`，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，`E` 和 `N`是RSA加密的密钥，也就是说，`E` 和 `N`的组合就是公钥。\n\n<!--more-->\n\n## RSA解密\n\nRSA的解密和加密一样简单，可以用下面的公式来表达:\n\n**明文=密文 <sup>D</sup> mod N** ( RSA解密)\n\n表示密文的数字的D次方求 mod N就可以得到明文。\n\n这里所使用的数字N和加密时使用的数字N是相同的。数 `D` 和数 `N` 组合起来就是RSA的解密密钥，因此D和N的组合就是私钥。\n\n在RSA中，加密和解密的形式是相同的。加密是求“明文的E次方的 mod \nN\"，而解密则是求“密文的D次方的 mod N\"。\n\n## 生成密钥对\n\n在RSA中，加密是求“明文的E次方的 mod \nN\"，而解密则是求“密文的D次方的 mod N\"。\n\n由于E和N是公钥，D和N是私钥，因此求E、D和N这三个数就是生成密钥对。\n\n## 生成私钥公钥步骤\n\n用 Linux或者mac 上自带，命令如下，完成制作非对称加密的秘钥对（公钥和私钥）\n\n\n1.生成 RSA 私钥（传统格式的）\n\n`openssl genrsa -out rsa_private_key.pem 1024`\n\n2.将传统格式的私钥转换成 PKCS#8 格式的（JAVA需要使用的私钥需要经过PKCS#8编码，PHP程序不需要，可以直接略过）,这个过程需要输入两遍密码，是针对私钥的密码，不要密码直接按回车\n\n`openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM`\n\n3.生成 RSA 公钥\n\n`openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem`\n\n\n此时在系统根目录已经生成了两个文件。可以直接使用`cat`命令查看文件中的内容\n\n## 代码实现加密以及解密过程\n```\n\nvar privateKey = []byte(`-----BEGIN RSA PRIVATE KEY-----\nMIICXQIBAAKBgQCQRttulLHUA3DkckkD7Bco5fY0nBDe8RlDZuIV2pu3Ry4qgZNL\nd7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWOjmpPXZfc3NAiW0iboLa6qld0\nTfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxxLjPiWq1HQhmywNv3BQIDAQAB\nAoGAPKJ64Ct/3QGhNXFOfGaBiT+0TIH2mSusmWYoyFR6svkoTtbsJ4BkL2+sqPew\nMtEvZbcBjxSdCIcNhWMhUm10PTur6mOhcAABxTjdFEbIbJRHVlrsDYkyGPLOaaem\nUOZeTAtnNQVAnbQpXIwLmwkSSmbJPyvFc534/c7fMkHg1RUCQQDAL5kgijYHox/1\nybqKoBxKrlIjwCpgJ7XIIXRu+AyCLNvzRRviIGGQQ5Q605hSKB+j/6lYKO/kjiNA\nJh5pYPr7AkEAwC7VLAjLQeHD/QD8SaEwQr9WgE3WxF0LuS+AI767Kluw2N2RSDhw\nnfNaBhFe1j7mUQLP4C/HIFFjmi1+HiQ1/wJBAKHXM3dAjJFP4HkmAO3+OPT26Xrr\nt4OzzRQUgC12u2ngBvVMrFd3d1F6Z1hGmc4Ntd9wS5ZPGv14aNz7fL63CYMCQQC9\nT+TxwZ/nwCu+GLBtH3lY5v6g2QyM1lNsEpyZmZLpwPTOTESG7gIRtdyiSY4wYjmi\n57A6WRZAgawp/lJUArulAkA3LKFGfViQVjRWkoIYN65R87L6DohHH1LXVg4wUUtF\nIXwDFSCbHsQko+vzIlBtSXr5/hO+1CkZLtI0tisWHPCi\n-----END RSA PRIVATE KEY-----`)\n\nvar publicKey = []byte(`-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCQRttulLHUA3DkckkD7Bco5fY0\nnBDe8RlDZuIV2pu3Ry4qgZNLd7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWO\njmpPXZfc3NAiW0iboLa6qld0TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxx\nLjPiWq1HQhmywNv3BQIDAQAB\n-----END PUBLIC KEY-----`)\n\nfunc main()  {\n\n\n\tdata := []byte(\"hello world\")\n\n\tcry := RSAEncrypt(data)\n\n\tfmt.Println(hex.EncodeToString(cry))\n\n\n\tori := RSADecrypt(cry)\n\tfmt.Println(string(ori))\n\n\n}\n\nfunc RSAEncrypt(plaintxt []byte) []byte  {\n\n\t//公钥加密\n\tblock, _:= pem.Decode(publicKey)\n\n\t//解析公钥\n\tpubInterface, _ := x509.ParsePKIXPublicKey(block.Bytes)\n\n\t//加载公钥\n\tpub := pubInterface.(*rsa.PublicKey)\n\n\t//加密明文\n\tbits,_ := rsa.EncryptPKCS1v15(rand.Reader, pub, plaintxt)\n\n\t//bits为最终的密文\n\treturn bits\n}\n\nfunc RSADecrypt(cryptTxt []byte) []byte  {\n\n\tblock,_:= pem.Decode(privateKey)\n\n\tpriv,_:= x509.ParsePKCS1PrivateKey(block.Bytes)\n\n\tbits,_ := rsa.DecryptPKCS1v15(rand.Reader, priv, cryptTxt)\n\n\treturn bits\n}\n```\n\n输出\n```\n4bf96c2a3d83a71745ebc15441046f2ca0bc2cffab73a0a452bcb5c3b58ee717585e779df5046a31f71a6abf650e097f86e4ee95cb14ddd121794763a556987a965be2ec9eb47ff1cf17adcc166bc349a2471f24b924d50927b41bb61d4c0f357949a05e1f00db870582e00e7234e35923e6f1eae3021892590458af3b790f8a\nhello world\n```\n\n\n## 代码实现生成公钥私钥来加密和解密\n```\nfunc main()  {\n\n\tprikey := CreatePrivateKey()\n\tpubKey := CreatePublic(prikey)\n\t\n\t// 加密和解密\n\tori:=[]byte(\"hello world!!!\")\n\t//通过oaep函数实现公钥加密\n\t//第一个参数作用，将不同长度的明文，通过hash散列实现相同的散列值，此过程就是生成密文摘要\n\tcipherTxt,_ :=rsa.EncryptOAEP(md5.New(), rand.Reader, &pubKey, ori, nil)\n\n\tfmt.Println(cipherTxt)\n\n\t//解密\n\tplainTxt,_ := rsa.DecryptOAEP(md5.New(), rand.Reader, prikey,cipherTxt, nil)\n\tfmt.Println(string(plainTxt))\n\t\n}\n\n// 创建私钥\nfunc CreatePrivateKey() *rsa.PrivateKey  {\n\n\t// 长度为1024 位 的私钥\n\tpri,_:= rsa.GenerateKey(rand.Reader, 1024)\n\treturn pri\n\n}\n// 生成公钥\nfunc CreatePublic(prikey *rsa.PrivateKey) rsa.PublicKey  {\n\treturn prikey.PublicKey\n}\n```\n\n\n\n","slug":"非对称加密RSA原理简介及使用","published":1,"updated":"2018-06-28T10:36:59.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjkvv5tfh003blx60ibomhqyx","content":"<h2 id=\"什么是RSA\"><a href=\"#什么是RSA\" class=\"headerlink\" title=\"什么是RSA\"></a>什么是RSA</h2><p>RSA是一种公钥密码算法，它的名字是由它的三位开发者，即Ron Rivest、Adi Shamir 和 Leonard Adleman的姓氏的首字母组成的( Rivest-Shamir-Adleman )。</p>\n<p>RSA可以被用于公钥密码和数字签名。</p>\n<h2 id=\"RSA加密\"><a href=\"#RSA加密\" class=\"headerlink\" title=\"RSA加密\"></a>RSA加密</h2><p>在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达：</p>\n<p><strong>密文=明文<sup>E</sup> mod N</strong> (RSA加密)</p>\n<p>RSA的密文是对代表明文的数字的E次方求mod N的结果。换句话说，就是将<br>明文和自己做E次乘法,然后将其结果除以N求余数，这个余数就是密文。</p>\n<p>加密公式中出现的两个数<code>E</code>和 <code>N</code>，到底都是什么数呢? RSA的加密是求明文的<br><code>E</code>次方mod <code>N</code>，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，<code>E</code> 和 <code>N</code>是RSA加密的密钥，也就是说，<code>E</code> 和 <code>N</code>的组合就是公钥。</p>\n<a id=\"more\"></a>\n<h2 id=\"RSA解密\"><a href=\"#RSA解密\" class=\"headerlink\" title=\"RSA解密\"></a>RSA解密</h2><p>RSA的解密和加密一样简单，可以用下面的公式来表达:</p>\n<p><strong>明文=密文 <sup>D</sup> mod N</strong> ( RSA解密)</p>\n<p>表示密文的数字的D次方求 mod N就可以得到明文。</p>\n<p>这里所使用的数字N和加密时使用的数字N是相同的。数 <code>D</code> 和数 <code>N</code> 组合起来就是RSA的解密密钥，因此D和N的组合就是私钥。</p>\n<p>在RSA中，加密和解密的形式是相同的。加密是求“明文的E次方的 mod<br>N”，而解密则是求“密文的D次方的 mod N”。</p>\n<h2 id=\"生成密钥对\"><a href=\"#生成密钥对\" class=\"headerlink\" title=\"生成密钥对\"></a>生成密钥对</h2><p>在RSA中，加密是求“明文的E次方的 mod<br>N”，而解密则是求“密文的D次方的 mod N”。</p>\n<p>由于E和N是公钥，D和N是私钥，因此求E、D和N这三个数就是生成密钥对。</p>\n<h2 id=\"生成私钥公钥步骤\"><a href=\"#生成私钥公钥步骤\" class=\"headerlink\" title=\"生成私钥公钥步骤\"></a>生成私钥公钥步骤</h2><p>用 Linux或者mac 上自带，命令如下，完成制作非对称加密的秘钥对（公钥和私钥）</p>\n<p>1.生成 RSA 私钥（传统格式的）</p>\n<p><code>openssl genrsa -out rsa_private_key.pem 1024</code></p>\n<p>2.将传统格式的私钥转换成 PKCS#8 格式的（JAVA需要使用的私钥需要经过PKCS#8编码，PHP程序不需要，可以直接略过）,这个过程需要输入两遍密码，是针对私钥的密码，不要密码直接按回车</p>\n<p><code>openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM</code></p>\n<p>3.生成 RSA 公钥</p>\n<p><code>openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem</code></p>\n<p>此时在系统根目录已经生成了两个文件。可以直接使用<code>cat</code>命令查看文件中的内容</p>\n<h2 id=\"代码实现加密以及解密过程\"><a href=\"#代码实现加密以及解密过程\" class=\"headerlink\" title=\"代码实现加密以及解密过程\"></a>代码实现加密以及解密过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">var privateKey = []byte(`-----BEGIN RSA PRIVATE KEY-----</div><div class=\"line\">MIICXQIBAAKBgQCQRttulLHUA3DkckkD7Bco5fY0nBDe8RlDZuIV2pu3Ry4qgZNL</div><div class=\"line\">d7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWOjmpPXZfc3NAiW0iboLa6qld0</div><div class=\"line\">TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxxLjPiWq1HQhmywNv3BQIDAQAB</div><div class=\"line\">AoGAPKJ64Ct/3QGhNXFOfGaBiT+0TIH2mSusmWYoyFR6svkoTtbsJ4BkL2+sqPew</div><div class=\"line\">MtEvZbcBjxSdCIcNhWMhUm10PTur6mOhcAABxTjdFEbIbJRHVlrsDYkyGPLOaaem</div><div class=\"line\">UOZeTAtnNQVAnbQpXIwLmwkSSmbJPyvFc534/c7fMkHg1RUCQQDAL5kgijYHox/1</div><div class=\"line\">ybqKoBxKrlIjwCpgJ7XIIXRu+AyCLNvzRRviIGGQQ5Q605hSKB+j/6lYKO/kjiNA</div><div class=\"line\">Jh5pYPr7AkEAwC7VLAjLQeHD/QD8SaEwQr9WgE3WxF0LuS+AI767Kluw2N2RSDhw</div><div class=\"line\">nfNaBhFe1j7mUQLP4C/HIFFjmi1+HiQ1/wJBAKHXM3dAjJFP4HkmAO3+OPT26Xrr</div><div class=\"line\">t4OzzRQUgC12u2ngBvVMrFd3d1F6Z1hGmc4Ntd9wS5ZPGv14aNz7fL63CYMCQQC9</div><div class=\"line\">T+TxwZ/nwCu+GLBtH3lY5v6g2QyM1lNsEpyZmZLpwPTOTESG7gIRtdyiSY4wYjmi</div><div class=\"line\">57A6WRZAgawp/lJUArulAkA3LKFGfViQVjRWkoIYN65R87L6DohHH1LXVg4wUUtF</div><div class=\"line\">IXwDFSCbHsQko+vzIlBtSXr5/hO+1CkZLtI0tisWHPCi</div><div class=\"line\">-----END RSA PRIVATE KEY-----`)</div><div class=\"line\"></div><div class=\"line\">var publicKey = []byte(`-----BEGIN PUBLIC KEY-----</div><div class=\"line\">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCQRttulLHUA3DkckkD7Bco5fY0</div><div class=\"line\">nBDe8RlDZuIV2pu3Ry4qgZNLd7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWO</div><div class=\"line\">jmpPXZfc3NAiW0iboLa6qld0TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxx</div><div class=\"line\">LjPiWq1HQhmywNv3BQIDAQAB</div><div class=\"line\">-----END PUBLIC KEY-----`)</div><div class=\"line\"></div><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tdata := []byte(&quot;hello world&quot;)</div><div class=\"line\"></div><div class=\"line\">\tcry := RSAEncrypt(data)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(cry))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tori := RSADecrypt(cry)</div><div class=\"line\">\tfmt.Println(string(ori))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func RSAEncrypt(plaintxt []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//公钥加密</div><div class=\"line\">\tblock, _:= pem.Decode(publicKey)</div><div class=\"line\"></div><div class=\"line\">\t//解析公钥</div><div class=\"line\">\tpubInterface, _ := x509.ParsePKIXPublicKey(block.Bytes)</div><div class=\"line\"></div><div class=\"line\">\t//加载公钥</div><div class=\"line\">\tpub := pubInterface.(*rsa.PublicKey)</div><div class=\"line\"></div><div class=\"line\">\t//加密明文</div><div class=\"line\">\tbits,_ := rsa.EncryptPKCS1v15(rand.Reader, pub, plaintxt)</div><div class=\"line\"></div><div class=\"line\">\t//bits为最终的密文</div><div class=\"line\">\treturn bits</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func RSADecrypt(cryptTxt []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\tblock,_:= pem.Decode(privateKey)</div><div class=\"line\"></div><div class=\"line\">\tpriv,_:= x509.ParsePKCS1PrivateKey(block.Bytes)</div><div class=\"line\"></div><div class=\"line\">\tbits,_ := rsa.DecryptPKCS1v15(rand.Reader, priv, cryptTxt)</div><div class=\"line\"></div><div class=\"line\">\treturn bits</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">4bf96c2a3d83a71745ebc15441046f2ca0bc2cffab73a0a452bcb5c3b58ee717585e779df5046a31f71a6abf650e097f86e4ee95cb14ddd121794763a556987a965be2ec9eb47ff1cf17adcc166bc349a2471f24b924d50927b41bb61d4c0f357949a05e1f00db870582e00e7234e35923e6f1eae3021892590458af3b790f8a</div><div class=\"line\">hello world</div></pre></td></tr></table></figure></p>\n<h2 id=\"代码实现生成公钥私钥来加密和解密\"><a href=\"#代码实现生成公钥私钥来加密和解密\" class=\"headerlink\" title=\"代码实现生成公钥私钥来加密和解密\"></a>代码实现生成公钥私钥来加密和解密</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tprikey := CreatePrivateKey()</div><div class=\"line\">\tpubKey := CreatePublic(prikey)</div><div class=\"line\">\t</div><div class=\"line\">\t// 加密和解密</div><div class=\"line\">\tori:=[]byte(&quot;hello world!!!&quot;)</div><div class=\"line\">\t//通过oaep函数实现公钥加密</div><div class=\"line\">\t//第一个参数作用，将不同长度的明文，通过hash散列实现相同的散列值，此过程就是生成密文摘要</div><div class=\"line\">\tcipherTxt,_ :=rsa.EncryptOAEP(md5.New(), rand.Reader, &amp;pubKey, ori, nil)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(cipherTxt)</div><div class=\"line\"></div><div class=\"line\">\t//解密</div><div class=\"line\">\tplainTxt,_ := rsa.DecryptOAEP(md5.New(), rand.Reader, prikey,cipherTxt, nil)</div><div class=\"line\">\tfmt.Println(string(plainTxt))</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 创建私钥</div><div class=\"line\">func CreatePrivateKey() *rsa.PrivateKey  &#123;</div><div class=\"line\"></div><div class=\"line\">\t// 长度为1024 位 的私钥</div><div class=\"line\">\tpri,_:= rsa.GenerateKey(rand.Reader, 1024)</div><div class=\"line\">\treturn pri</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">// 生成公钥</div><div class=\"line\">func CreatePublic(prikey *rsa.PrivateKey) rsa.PublicKey  &#123;</div><div class=\"line\">\treturn prikey.PublicKey</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<h2 id=\"什么是RSA\"><a href=\"#什么是RSA\" class=\"headerlink\" title=\"什么是RSA\"></a>什么是RSA</h2><p>RSA是一种公钥密码算法，它的名字是由它的三位开发者，即Ron Rivest、Adi Shamir 和 Leonard Adleman的姓氏的首字母组成的( Rivest-Shamir-Adleman )。</p>\n<p>RSA可以被用于公钥密码和数字签名。</p>\n<h2 id=\"RSA加密\"><a href=\"#RSA加密\" class=\"headerlink\" title=\"RSA加密\"></a>RSA加密</h2><p>在RSA中，明文、密钥和密文都是数字。RSA的加密过程可以用下列公式来表达：</p>\n<p><strong>密文=明文<sup>E</sup> mod N</strong> (RSA加密)</p>\n<p>RSA的密文是对代表明文的数字的E次方求mod N的结果。换句话说，就是将<br>明文和自己做E次乘法,然后将其结果除以N求余数，这个余数就是密文。</p>\n<p>加密公式中出现的两个数<code>E</code>和 <code>N</code>，到底都是什么数呢? RSA的加密是求明文的<br><code>E</code>次方mod <code>N</code>，因此只要知道E和N这两个数，任何人都可以完成加密的运算。所以说，<code>E</code> 和 <code>N</code>是RSA加密的密钥，也就是说，<code>E</code> 和 <code>N</code>的组合就是公钥。</p>","more":"<h2 id=\"RSA解密\"><a href=\"#RSA解密\" class=\"headerlink\" title=\"RSA解密\"></a>RSA解密</h2><p>RSA的解密和加密一样简单，可以用下面的公式来表达:</p>\n<p><strong>明文=密文 <sup>D</sup> mod N</strong> ( RSA解密)</p>\n<p>表示密文的数字的D次方求 mod N就可以得到明文。</p>\n<p>这里所使用的数字N和加密时使用的数字N是相同的。数 <code>D</code> 和数 <code>N</code> 组合起来就是RSA的解密密钥，因此D和N的组合就是私钥。</p>\n<p>在RSA中，加密和解密的形式是相同的。加密是求“明文的E次方的 mod<br>N”，而解密则是求“密文的D次方的 mod N”。</p>\n<h2 id=\"生成密钥对\"><a href=\"#生成密钥对\" class=\"headerlink\" title=\"生成密钥对\"></a>生成密钥对</h2><p>在RSA中，加密是求“明文的E次方的 mod<br>N”，而解密则是求“密文的D次方的 mod N”。</p>\n<p>由于E和N是公钥，D和N是私钥，因此求E、D和N这三个数就是生成密钥对。</p>\n<h2 id=\"生成私钥公钥步骤\"><a href=\"#生成私钥公钥步骤\" class=\"headerlink\" title=\"生成私钥公钥步骤\"></a>生成私钥公钥步骤</h2><p>用 Linux或者mac 上自带，命令如下，完成制作非对称加密的秘钥对（公钥和私钥）</p>\n<p>1.生成 RSA 私钥（传统格式的）</p>\n<p><code>openssl genrsa -out rsa_private_key.pem 1024</code></p>\n<p>2.将传统格式的私钥转换成 PKCS#8 格式的（JAVA需要使用的私钥需要经过PKCS#8编码，PHP程序不需要，可以直接略过）,这个过程需要输入两遍密码，是针对私钥的密码，不要密码直接按回车</p>\n<p><code>openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM</code></p>\n<p>3.生成 RSA 公钥</p>\n<p><code>openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem</code></p>\n<p>此时在系统根目录已经生成了两个文件。可以直接使用<code>cat</code>命令查看文件中的内容</p>\n<h2 id=\"代码实现加密以及解密过程\"><a href=\"#代码实现加密以及解密过程\" class=\"headerlink\" title=\"代码实现加密以及解密过程\"></a>代码实现加密以及解密过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">var privateKey = []byte(`-----BEGIN RSA PRIVATE KEY-----</div><div class=\"line\">MIICXQIBAAKBgQCQRttulLHUA3DkckkD7Bco5fY0nBDe8RlDZuIV2pu3Ry4qgZNL</div><div class=\"line\">d7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWOjmpPXZfc3NAiW0iboLa6qld0</div><div class=\"line\">TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxxLjPiWq1HQhmywNv3BQIDAQAB</div><div class=\"line\">AoGAPKJ64Ct/3QGhNXFOfGaBiT+0TIH2mSusmWYoyFR6svkoTtbsJ4BkL2+sqPew</div><div class=\"line\">MtEvZbcBjxSdCIcNhWMhUm10PTur6mOhcAABxTjdFEbIbJRHVlrsDYkyGPLOaaem</div><div class=\"line\">UOZeTAtnNQVAnbQpXIwLmwkSSmbJPyvFc534/c7fMkHg1RUCQQDAL5kgijYHox/1</div><div class=\"line\">ybqKoBxKrlIjwCpgJ7XIIXRu+AyCLNvzRRviIGGQQ5Q605hSKB+j/6lYKO/kjiNA</div><div class=\"line\">Jh5pYPr7AkEAwC7VLAjLQeHD/QD8SaEwQr9WgE3WxF0LuS+AI767Kluw2N2RSDhw</div><div class=\"line\">nfNaBhFe1j7mUQLP4C/HIFFjmi1+HiQ1/wJBAKHXM3dAjJFP4HkmAO3+OPT26Xrr</div><div class=\"line\">t4OzzRQUgC12u2ngBvVMrFd3d1F6Z1hGmc4Ntd9wS5ZPGv14aNz7fL63CYMCQQC9</div><div class=\"line\">T+TxwZ/nwCu+GLBtH3lY5v6g2QyM1lNsEpyZmZLpwPTOTESG7gIRtdyiSY4wYjmi</div><div class=\"line\">57A6WRZAgawp/lJUArulAkA3LKFGfViQVjRWkoIYN65R87L6DohHH1LXVg4wUUtF</div><div class=\"line\">IXwDFSCbHsQko+vzIlBtSXr5/hO+1CkZLtI0tisWHPCi</div><div class=\"line\">-----END RSA PRIVATE KEY-----`)</div><div class=\"line\"></div><div class=\"line\">var publicKey = []byte(`-----BEGIN PUBLIC KEY-----</div><div class=\"line\">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCQRttulLHUA3DkckkD7Bco5fY0</div><div class=\"line\">nBDe8RlDZuIV2pu3Ry4qgZNLd7OiYkgTcow0LIXeW4HpLJZI9oxCS3p4Y+w3AAWO</div><div class=\"line\">jmpPXZfc3NAiW0iboLa6qld0TfWogHurC2ArSkONEGzGzdgZrBUDGt8s+sdKmRxx</div><div class=\"line\">LjPiWq1HQhmywNv3BQIDAQAB</div><div class=\"line\">-----END PUBLIC KEY-----`)</div><div class=\"line\"></div><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tdata := []byte(&quot;hello world&quot;)</div><div class=\"line\"></div><div class=\"line\">\tcry := RSAEncrypt(data)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(hex.EncodeToString(cry))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\tori := RSADecrypt(cry)</div><div class=\"line\">\tfmt.Println(string(ori))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func RSAEncrypt(plaintxt []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\t//公钥加密</div><div class=\"line\">\tblock, _:= pem.Decode(publicKey)</div><div class=\"line\"></div><div class=\"line\">\t//解析公钥</div><div class=\"line\">\tpubInterface, _ := x509.ParsePKIXPublicKey(block.Bytes)</div><div class=\"line\"></div><div class=\"line\">\t//加载公钥</div><div class=\"line\">\tpub := pubInterface.(*rsa.PublicKey)</div><div class=\"line\"></div><div class=\"line\">\t//加密明文</div><div class=\"line\">\tbits,_ := rsa.EncryptPKCS1v15(rand.Reader, pub, plaintxt)</div><div class=\"line\"></div><div class=\"line\">\t//bits为最终的密文</div><div class=\"line\">\treturn bits</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">func RSADecrypt(cryptTxt []byte) []byte  &#123;</div><div class=\"line\"></div><div class=\"line\">\tblock,_:= pem.Decode(privateKey)</div><div class=\"line\"></div><div class=\"line\">\tpriv,_:= x509.ParsePKCS1PrivateKey(block.Bytes)</div><div class=\"line\"></div><div class=\"line\">\tbits,_ := rsa.DecryptPKCS1v15(rand.Reader, priv, cryptTxt)</div><div class=\"line\"></div><div class=\"line\">\treturn bits</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">4bf96c2a3d83a71745ebc15441046f2ca0bc2cffab73a0a452bcb5c3b58ee717585e779df5046a31f71a6abf650e097f86e4ee95cb14ddd121794763a556987a965be2ec9eb47ff1cf17adcc166bc349a2471f24b924d50927b41bb61d4c0f357949a05e1f00db870582e00e7234e35923e6f1eae3021892590458af3b790f8a</div><div class=\"line\">hello world</div></pre></td></tr></table></figure></p>\n<h2 id=\"代码实现生成公钥私钥来加密和解密\"><a href=\"#代码实现生成公钥私钥来加密和解密\" class=\"headerlink\" title=\"代码实现生成公钥私钥来加密和解密\"></a>代码实现生成公钥私钥来加密和解密</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">func main()  &#123;</div><div class=\"line\"></div><div class=\"line\">\tprikey := CreatePrivateKey()</div><div class=\"line\">\tpubKey := CreatePublic(prikey)</div><div class=\"line\">\t</div><div class=\"line\">\t// 加密和解密</div><div class=\"line\">\tori:=[]byte(&quot;hello world!!!&quot;)</div><div class=\"line\">\t//通过oaep函数实现公钥加密</div><div class=\"line\">\t//第一个参数作用，将不同长度的明文，通过hash散列实现相同的散列值，此过程就是生成密文摘要</div><div class=\"line\">\tcipherTxt,_ :=rsa.EncryptOAEP(md5.New(), rand.Reader, &amp;pubKey, ori, nil)</div><div class=\"line\"></div><div class=\"line\">\tfmt.Println(cipherTxt)</div><div class=\"line\"></div><div class=\"line\">\t//解密</div><div class=\"line\">\tplainTxt,_ := rsa.DecryptOAEP(md5.New(), rand.Reader, prikey,cipherTxt, nil)</div><div class=\"line\">\tfmt.Println(string(plainTxt))</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 创建私钥</div><div class=\"line\">func CreatePrivateKey() *rsa.PrivateKey  &#123;</div><div class=\"line\"></div><div class=\"line\">\t// 长度为1024 位 的私钥</div><div class=\"line\">\tpri,_:= rsa.GenerateKey(rand.Reader, 1024)</div><div class=\"line\">\treturn pri</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">// 生成公钥</div><div class=\"line\">func CreatePublic(prikey *rsa.PrivateKey) rsa.PublicKey  &#123;</div><div class=\"line\">\treturn prikey.PublicKey</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjkvv5td20000lx60t4xkb8uk","category_id":"cjkvv5td90004lx60tp50yygo","_id":"cjkvv5tdk000elx60twvmaa24"},{"post_id":"cjkvv5td60002lx60v6uat6f2","category_id":"cjkvv5tdg000blx60khajht9b","_id":"cjkvv5tdv000klx607gztwvfm"},{"post_id":"cjkvv5tdp000ilx60ctsu6tri","category_id":"cjkvv5td90004lx60tp50yygo","_id":"cjkvv5te0000olx60s2vsgs6g"},{"post_id":"cjkvv5tdb0006lx60yarqs2eo","category_id":"cjkvv5tdl000glx60zy19tiq0","_id":"cjkvv5te1000qlx60nji9haqi"},{"post_id":"cjkvv5tdv000jlx60b4vt3pn9","category_id":"cjkvv5tdg000blx60khajht9b","_id":"cjkvv5te4000vlx606jmea0za"},{"post_id":"cjkvv5tdd0008lx60d02szh8h","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5te5000ylx60q8i8swan"},{"post_id":"cjkvv5te4000wlx6074tvjcij","category_id":"cjkvv5tdl000glx60zy19tiq0","_id":"cjkvv5te90015lx60pc2t6pkq"},{"post_id":"cjkvv5tdf000alx60ebvkp0hh","category_id":"cjkvv5te1000rlx6095nxza2c","_id":"cjkvv5teb0019lx604433o7co"},{"post_id":"cjkvv5te80013lx6082p6wkla","category_id":"cjkvv5td90004lx60tp50yygo","_id":"cjkvv5tec001blx60dxkrge50"},{"post_id":"cjkvv5tdh000dlx60zxys0fmr","category_id":"cjkvv5te1000rlx6095nxza2c","_id":"cjkvv5tee001flx60iqxgia5b"},{"post_id":"cjkvv5teb001alx60cmyuuct8","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5teg001hlx6075zy5275"},{"post_id":"cjkvv5tdk000flx60f2vmpiws","category_id":"cjkvv5te1000rlx6095nxza2c","_id":"cjkvv5teh001klx600ui769c7"},{"post_id":"cjkvv5ted001clx60ceyj4jof","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5tei001nlx600clfnrje"},{"post_id":"cjkvv5tef001glx60ytclyb1u","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5tek001qlx6079aeuwye"},{"post_id":"cjkvv5tdx000nlx60fc98whkl","category_id":"cjkvv5ted001dlx60bbaef09t","_id":"cjkvv5tel001tlx60ecbeswg6"},{"post_id":"cjkvv5teg001ilx60ybc6to8e","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5ten001xlx60k7z3qoky"},{"post_id":"cjkvv5teh001mlx60t2aljd93","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5tes0021lx60kjzvzidj"},{"post_id":"cjkvv5te0000plx60303bt08j","category_id":"cjkvv5teg001jlx60y93hjhpa","_id":"cjkvv5tev0024lx60lh89bnzd"},{"post_id":"cjkvv5tej001olx60pn4gbqpt","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5tez0029lx606wox7601"},{"post_id":"cjkvv5tek001rlx60j706nmxc","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5tf0002clx600vf8uzmq"},{"post_id":"cjkvv5te2000tlx60w9ylsric","category_id":"cjkvv5teg001jlx60y93hjhpa","_id":"cjkvv5tf2002flx60wgewrnno"},{"post_id":"cjkvv5tem001vlx60yiah7cna","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5tf4002jlx60e8z64y9w"},{"post_id":"cjkvv5teo001zlx60ds8v0ro6","category_id":"cjkvv5ten001wlx60ig5ucfri","_id":"cjkvv5tf5002llx60dv88yz9b"},{"post_id":"cjkvv5te5000zlx6062460h7g","category_id":"cjkvv5ten001wlx60ig5ucfri","_id":"cjkvv5tf7002plx60ea9zcv98"},{"post_id":"cjkvv5tet0023lx600fifjlhz","category_id":"cjkvv5ten001wlx60ig5ucfri","_id":"cjkvv5tf9002slx60mqd6juht"},{"post_id":"cjkvv5tew0027lx602qvlfbkf","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5tfa002wlx605jwzbg7v"},{"post_id":"cjkvv5te90016lx60tvf9o00v","category_id":"cjkvv5ted001dlx60bbaef09t","_id":"cjkvv5tfc002zlx60rlqm9e6z"},{"post_id":"cjkvv5tez002blx60efos7j92","category_id":"cjkvv5tdg000blx60khajht9b","_id":"cjkvv5tfd0032lx60pi2v3szv"},{"post_id":"cjkvv5tf1002elx60bb94cnkg","category_id":"cjkvv5ten001wlx60ig5ucfri","_id":"cjkvv5tff0035lx60gc5rvmts"},{"post_id":"cjkvv5tf3002ilx60s3i6nfjv","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5tfg0037lx60lk5tjlt6"},{"post_id":"cjkvv5tf9002ulx60zgmxamyw","category_id":"cjkvv5teg001jlx60y93hjhpa","_id":"cjkvv5tfh003alx60darqqct8"},{"post_id":"cjkvv5tf4002klx60zobu9101","category_id":"cjkvv5tf7002olx60hk4dpncf","_id":"cjkvv5tfj003clx60twnaxapo"},{"post_id":"cjkvv5tfa002xlx60c1tphbrc","category_id":"cjkvv5ten001wlx60ig5ucfri","_id":"cjkvv5tfk003elx60f4amua3d"},{"post_id":"cjkvv5tfc0030lx609f7vx4p7","category_id":"cjkvv5td90004lx60tp50yygo","_id":"cjkvv5tfk003glx608kyecywe"},{"post_id":"cjkvv5tf5002mlx606vyqnatm","category_id":"cjkvv5tf7002olx60hk4dpncf","_id":"cjkvv5tfm003jlx60jr02aail"},{"post_id":"cjkvv5tfd0033lx60ihwb6yj9","category_id":"cjkvv5td90004lx60tp50yygo","_id":"cjkvv5tfm003llx60pxy8ia3p"},{"post_id":"cjkvv5tff0036lx60wvn9tyu4","category_id":"cjkvv5tf7002olx60hk4dpncf","_id":"cjkvv5tfm003olx60h7rfm2ql"},{"post_id":"cjkvv5tf8002rlx60z85g2khg","category_id":"cjkvv5tf7002olx60hk4dpncf","_id":"cjkvv5tfn003plx60zxsxm0ly"},{"post_id":"cjkvv5tfg0039lx60pkewp9qq","category_id":"cjkvv5tdw000llx60y8upbiu2","_id":"cjkvv5tfo003rlx601nr6404z"},{"post_id":"cjkvv5tfh003blx60ibomhqyx","category_id":"cjkvv5td90004lx60tp50yygo","_id":"cjkvv5tfo003tlx60qdwx54h6"}],"PostTag":[{"post_id":"cjkvv5td20000lx60t4xkb8uk","tag_id":"cjkvv5tda0005lx6058v788kf","_id":"cjkvv5te3000ulx60qzanr5wx"},{"post_id":"cjkvv5td20000lx60t4xkb8uk","tag_id":"cjkvv5tdg000clx60dotd2lsn","_id":"cjkvv5te5000xlx6096wpfqet"},{"post_id":"cjkvv5td20000lx60t4xkb8uk","tag_id":"cjkvv5tdn000hlx60b2cmqjzr","_id":"cjkvv5te70012lx60y8flgwo5"},{"post_id":"cjkvv5td20000lx60t4xkb8uk","tag_id":"cjkvv5tdw000mlx60z2ggcxfy","_id":"cjkvv5te90014lx606pmy7stw"},{"post_id":"cjkvv5td60002lx60v6uat6f2","tag_id":"cjkvv5te2000slx60as8kxev8","_id":"cjkvv5tel001ulx60qiff7jhy"},{"post_id":"cjkvv5td60002lx60v6uat6f2","tag_id":"cjkvv5te60011lx60f9qml3u5","_id":"cjkvv5teo001ylx60neau3f7q"},{"post_id":"cjkvv5td60002lx60v6uat6f2","tag_id":"cjkvv5teb0018lx601v35h1bv","_id":"cjkvv5tes0022lx60e2t1rolu"},{"post_id":"cjkvv5td60002lx60v6uat6f2","tag_id":"cjkvv5tee001elx60wihskzv3","_id":"cjkvv5tew0026lx601t7c23js"},{"post_id":"cjkvv5td60002lx60v6uat6f2","tag_id":"cjkvv5teh001llx604284ey01","_id":"cjkvv5tez002alx60sjm2s9rr"},{"post_id":"cjkvv5tdb0006lx60yarqs2eo","tag_id":"cjkvv5tel001slx602iwgh9fe","_id":"cjkvv5tf1002dlx6026idrcwe"},{"post_id":"cjkvv5tdb0006lx60yarqs2eo","tag_id":"cjkvv5tes0020lx608acivo1y","_id":"cjkvv5tf3002hlx60kzony2ru"},{"post_id":"cjkvv5tdd0008lx60d02szh8h","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tf7002qlx60qxog7ydt"},{"post_id":"cjkvv5tdd0008lx60d02szh8h","tag_id":"cjkvv5tf3002glx60ng9hafo1","_id":"cjkvv5tf9002tlx60ree5rcdc"},{"post_id":"cjkvv5tdf000alx60ebvkp0hh","tag_id":"cjkvv5tf6002nlx60c09ogsue","_id":"cjkvv5tfk003flx60id44ppy8"},{"post_id":"cjkvv5tdf000alx60ebvkp0hh","tag_id":"cjkvv5tfa002vlx606lfnhde1","_id":"cjkvv5tfk003hlx60k15prfpq"},{"post_id":"cjkvv5tdf000alx60ebvkp0hh","tag_id":"cjkvv5tfd0031lx60rvmti4xw","_id":"cjkvv5tfm003klx60tzmvkcg4"},{"post_id":"cjkvv5tdf000alx60ebvkp0hh","tag_id":"cjkvv5tfg0038lx60552o66ui","_id":"cjkvv5tfm003mlx60cillk5pi"},{"post_id":"cjkvv5tdh000dlx60zxys0fmr","tag_id":"cjkvv5tf6002nlx60c09ogsue","_id":"cjkvv5tfo003slx60rb5hvycg"},{"post_id":"cjkvv5tdh000dlx60zxys0fmr","tag_id":"cjkvv5tfa002vlx606lfnhde1","_id":"cjkvv5tfo003ulx601i27izdr"},{"post_id":"cjkvv5tdh000dlx60zxys0fmr","tag_id":"cjkvv5tfm003nlx60goijg1ob","_id":"cjkvv5tfp003wlx603nmzvr2f"},{"post_id":"cjkvv5tdk000flx60f2vmpiws","tag_id":"cjkvv5tf6002nlx60c09ogsue","_id":"cjkvv5tfq003zlx60d6h82bg4"},{"post_id":"cjkvv5tdk000flx60f2vmpiws","tag_id":"cjkvv5tfa002vlx606lfnhde1","_id":"cjkvv5tfq0040lx60mbrvic9w"},{"post_id":"cjkvv5tdk000flx60f2vmpiws","tag_id":"cjkvv5tfp003xlx605t5zkvng","_id":"cjkvv5tfr0042lx60zduoz1th"},{"post_id":"cjkvv5tdp000ilx60ctsu6tri","tag_id":"cjkvv5tfp003ylx60jvwq47zi","_id":"cjkvv5tfs0044lx60luutr860"},{"post_id":"cjkvv5tdp000ilx60ctsu6tri","tag_id":"cjkvv5tdn000hlx60b2cmqjzr","_id":"cjkvv5tfs0045lx601pqigr0i"},{"post_id":"cjkvv5tdp000ilx60ctsu6tri","tag_id":"cjkvv5tdw000mlx60z2ggcxfy","_id":"cjkvv5tfs0047lx603jjw3mrm"},{"post_id":"cjkvv5tdv000jlx60b4vt3pn9","tag_id":"cjkvv5te2000slx60as8kxev8","_id":"cjkvv5tfu004clx608zqh51l0"},{"post_id":"cjkvv5tdv000jlx60b4vt3pn9","tag_id":"cjkvv5tfs0046lx60b52hrpio","_id":"cjkvv5tfu004dlx60spmk2m9o"},{"post_id":"cjkvv5tdv000jlx60b4vt3pn9","tag_id":"cjkvv5tfs0048lx60km9lunhq","_id":"cjkvv5tfv004flx60yhm4l0yk"},{"post_id":"cjkvv5tdv000jlx60b4vt3pn9","tag_id":"cjkvv5tft0049lx60abe0wvys","_id":"cjkvv5tfv004glx60w29o0onz"},{"post_id":"cjkvv5tdv000jlx60b4vt3pn9","tag_id":"cjkvv5tft004alx603vtc31qc","_id":"cjkvv5tfw004ilx60wliqhjzv"},{"post_id":"cjkvv5tdx000nlx60fc98whkl","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tfw004jlx60zsurnttl"},{"post_id":"cjkvv5tdx000nlx60fc98whkl","tag_id":"cjkvv5tfu004elx60p5555ztq","_id":"cjkvv5tfw004llx60ch3w6yd1"},{"post_id":"cjkvv5te0000plx60303bt08j","tag_id":"cjkvv5tfv004hlx60q9s0px4f","_id":"cjkvv5tfx004nlx60sn6b89gi"},{"post_id":"cjkvv5te0000plx60303bt08j","tag_id":"cjkvv5tfw004klx603luu6ick","_id":"cjkvv5tfx004olx604h0aln5r"},{"post_id":"cjkvv5te2000tlx60w9ylsric","tag_id":"cjkvv5tfv004hlx60q9s0px4f","_id":"cjkvv5tfz004slx60hnil17y3"},{"post_id":"cjkvv5te2000tlx60w9ylsric","tag_id":"cjkvv5tfw004klx603luu6ick","_id":"cjkvv5tfz004tlx60ffkwy8jd"},{"post_id":"cjkvv5te2000tlx60w9ylsric","tag_id":"cjkvv5tfy004qlx60nuoqnu1s","_id":"cjkvv5tg0004vlx608deeo3ok"},{"post_id":"cjkvv5te4000wlx6074tvjcij","tag_id":"cjkvv5tel001slx602iwgh9fe","_id":"cjkvv5tg0004xlx60mljvrjuo"},{"post_id":"cjkvv5te4000wlx6074tvjcij","tag_id":"cjkvv5tfz004ulx607ddjjylg","_id":"cjkvv5tg0004ylx60v5dsok0b"},{"post_id":"cjkvv5te5000zlx6062460h7g","tag_id":"cjkvv5tg0004wlx60gjqsz8vi","_id":"cjkvv5tg10051lx60wijjmoqg"},{"post_id":"cjkvv5te5000zlx6062460h7g","tag_id":"cjkvv5tg0004zlx60didsicx3","_id":"cjkvv5tg10052lx6019i63y8d"},{"post_id":"cjkvv5te80013lx6082p6wkla","tag_id":"cjkvv5tg10050lx60slhtso3k","_id":"cjkvv5tg40059lx602c3f8wn7"},{"post_id":"cjkvv5te80013lx6082p6wkla","tag_id":"cjkvv5tg10053lx60ty6wxrze","_id":"cjkvv5tg5005alx608gdrqaym"},{"post_id":"cjkvv5te80013lx6082p6wkla","tag_id":"cjkvv5tg20054lx60jotq7d8o","_id":"cjkvv5tg5005clx60860kjlkq"},{"post_id":"cjkvv5te80013lx6082p6wkla","tag_id":"cjkvv5tg30055lx60x0a1d1ky","_id":"cjkvv5tg5005dlx60vg2mu7do"},{"post_id":"cjkvv5te80013lx6082p6wkla","tag_id":"cjkvv5tg30056lx60sl9w9hxy","_id":"cjkvv5tg6005flx60vnnx0b9w"},{"post_id":"cjkvv5te80013lx6082p6wkla","tag_id":"cjkvv5tg0004zlx60didsicx3","_id":"cjkvv5tg6005glx603zm8k6kc"},{"post_id":"cjkvv5te90016lx60tvf9o00v","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tg6005ilx6024ezfii0"},{"post_id":"cjkvv5te90016lx60tvf9o00v","tag_id":"cjkvv5tg5005blx60e85vl9w8","_id":"cjkvv5tg7005jlx60rlyd94h2"},{"post_id":"cjkvv5teb001alx60cmyuuct8","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tg8005mlx6050vawz1f"},{"post_id":"cjkvv5teb001alx60cmyuuct8","tag_id":"cjkvv5tg6005hlx60foe5o1wt","_id":"cjkvv5tg8005nlx60aiims1ao"},{"post_id":"cjkvv5teb001alx60cmyuuct8","tag_id":"cjkvv5tg7005klx60il6ubcgf","_id":"cjkvv5tg9005plx6035fi5c9u"},{"post_id":"cjkvv5ted001clx60ceyj4jof","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tgb005slx6040w63uc6"},{"post_id":"cjkvv5ted001clx60ceyj4jof","tag_id":"cjkvv5tg8005olx602d18t0w5","_id":"cjkvv5tgc005tlx608imkuj6t"},{"post_id":"cjkvv5ted001clx60ceyj4jof","tag_id":"cjkvv5tfu004elx60p5555ztq","_id":"cjkvv5tgc005vlx60behses1k"},{"post_id":"cjkvv5tef001glx60ytclyb1u","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tge005xlx60plqtzj6z"},{"post_id":"cjkvv5tef001glx60ytclyb1u","tag_id":"cjkvv5tgc005ulx60w0t991bw","_id":"cjkvv5tge005ylx60l56k90xd"},{"post_id":"cjkvv5teg001ilx60ybc6to8e","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tgg0061lx60z9fxrxlu"},{"post_id":"cjkvv5teg001ilx60ybc6to8e","tag_id":"cjkvv5tge005zlx605tizcs31","_id":"cjkvv5tgg0062lx60veotlzzi"},{"post_id":"cjkvv5teh001mlx60t2aljd93","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tgj0068lx603hkjo85l"},{"post_id":"cjkvv5teh001mlx60t2aljd93","tag_id":"cjkvv5tgg0063lx60ogs2imdm","_id":"cjkvv5tgj0069lx60mo5cjo93"},{"post_id":"cjkvv5teh001mlx60t2aljd93","tag_id":"cjkvv5tgh0064lx60v4dsu1fn","_id":"cjkvv5tgk006blx60p4pzvh8m"},{"post_id":"cjkvv5teh001mlx60t2aljd93","tag_id":"cjkvv5tgh0065lx60g33wtyvv","_id":"cjkvv5tgk006clx60et8jb0x2"},{"post_id":"cjkvv5teh001mlx60t2aljd93","tag_id":"cjkvv5tgh0066lx60vg9a4v44","_id":"cjkvv5tgl006elx602rzjmhwf"},{"post_id":"cjkvv5tej001olx60pn4gbqpt","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tgm006glx60p3dmfzxi"},{"post_id":"cjkvv5tej001olx60pn4gbqpt","tag_id":"cjkvv5tgc005ulx60w0t991bw","_id":"cjkvv5tgm006hlx60154ittob"},{"post_id":"cjkvv5tej001olx60pn4gbqpt","tag_id":"cjkvv5tge005zlx605tizcs31","_id":"cjkvv5tgn006jlx605csht5vq"},{"post_id":"cjkvv5tek001rlx60j706nmxc","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tgo006llx60s5clikf5"},{"post_id":"cjkvv5tek001rlx60j706nmxc","tag_id":"cjkvv5tgm006ilx60gxmd4suz","_id":"cjkvv5tgo006mlx605g4mpyp1"},{"post_id":"cjkvv5tem001vlx60yiah7cna","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tgr006rlx60v7olhvge"},{"post_id":"cjkvv5tem001vlx60yiah7cna","tag_id":"cjkvv5tgo006nlx60drvjt6y9","_id":"cjkvv5tgr006slx60358r0ybc"},{"post_id":"cjkvv5tem001vlx60yiah7cna","tag_id":"cjkvv5tgh0066lx60vg9a4v44","_id":"cjkvv5tgr006ulx60ndqyvi1r"},{"post_id":"cjkvv5tem001vlx60yiah7cna","tag_id":"cjkvv5tge005zlx605tizcs31","_id":"cjkvv5tgs006vlx60510lg30u"},{"post_id":"cjkvv5teo001zlx60ds8v0ro6","tag_id":"cjkvv5tgq006qlx60ycon83am","_id":"cjkvv5tgu006ylx60rxxjays3"},{"post_id":"cjkvv5teo001zlx60ds8v0ro6","tag_id":"cjkvv5tgr006tlx60112pvgyb","_id":"cjkvv5tgu006zlx60ewb3xeue"},{"post_id":"cjkvv5teo001zlx60ds8v0ro6","tag_id":"cjkvv5tfw004klx603luu6ick","_id":"cjkvv5tgu0071lx60cdmlunmo"},{"post_id":"cjkvv5tet0023lx600fifjlhz","tag_id":"cjkvv5tg0004zlx60didsicx3","_id":"cjkvv5tgv0073lx6014i8bbuk"},{"post_id":"cjkvv5tet0023lx600fifjlhz","tag_id":"cjkvv5tgu0070lx60njrzwrwl","_id":"cjkvv5tgv0074lx60mofle6c1"},{"post_id":"cjkvv5tew0027lx602qvlfbkf","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5tgx0078lx60ljhcq786"},{"post_id":"cjkvv5tew0027lx602qvlfbkf","tag_id":"cjkvv5tgv0075lx60q6wg6nv2","_id":"cjkvv5tgx0079lx60ws3eu0qx"},{"post_id":"cjkvv5tew0027lx602qvlfbkf","tag_id":"cjkvv5tgw0076lx60i1b1kk8t","_id":"cjkvv5tgy007blx60iyv49zit"},{"post_id":"cjkvv5tez002blx60efos7j92","tag_id":"cjkvv5te2000slx60as8kxev8","_id":"cjkvv5tgy007clx60yispouys"},{"post_id":"cjkvv5tez002blx60efos7j92","tag_id":"cjkvv5tgx0077lx6067ep12av","_id":"cjkvv5tgy007elx60etnvpi2d"},{"post_id":"cjkvv5tf1002elx60bb94cnkg","tag_id":"cjkvv5tg0004zlx60didsicx3","_id":"cjkvv5tgz007hlx60japf6mf0"},{"post_id":"cjkvv5tf1002elx60bb94cnkg","tag_id":"cjkvv5tgy007dlx60w8rx8uvy","_id":"cjkvv5th0007ilx60djrdtieb"},{"post_id":"cjkvv5tf1002elx60bb94cnkg","tag_id":"cjkvv5tgz007flx60uwdl0cy6","_id":"cjkvv5th0007klx60o9g24zny"},{"post_id":"cjkvv5tf3002ilx60s3i6nfjv","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5th1007llx60ken5sqmr"},{"post_id":"cjkvv5tf3002ilx60s3i6nfjv","tag_id":"cjkvv5tgz007glx60gywwwdl7","_id":"cjkvv5th1007nlx602wo6wtpo"},{"post_id":"cjkvv5tf4002klx60zobu9101","tag_id":"cjkvv5th0007jlx60ank1wae9","_id":"cjkvv5th1007plx60xl1e5osf"},{"post_id":"cjkvv5tf4002klx60zobu9101","tag_id":"cjkvv5th1007mlx6098jp0pjy","_id":"cjkvv5th2007qlx601046474v"},{"post_id":"cjkvv5tf5002mlx606vyqnatm","tag_id":"cjkvv5th1007olx60ot9x0w1q","_id":"cjkvv5th3007tlx60wzw3upw4"},{"post_id":"cjkvv5tf5002mlx606vyqnatm","tag_id":"cjkvv5th1007mlx6098jp0pjy","_id":"cjkvv5th3007ulx60eutjccca"},{"post_id":"cjkvv5tf8002rlx60z85g2khg","tag_id":"cjkvv5th2007slx609xbhcire","_id":"cjkvv5th4007xlx60yarwmmtg"},{"post_id":"cjkvv5tf8002rlx60z85g2khg","tag_id":"cjkvv5th1007mlx6098jp0pjy","_id":"cjkvv5th5007ylx6029rwlgfd"},{"post_id":"cjkvv5tf9002ulx60zgmxamyw","tag_id":"cjkvv5tfw004klx603luu6ick","_id":"cjkvv5th70081lx60riqij4d6"},{"post_id":"cjkvv5tf9002ulx60zgmxamyw","tag_id":"cjkvv5th5007zlx60ng15k5fu","_id":"cjkvv5th70082lx60hflnih53"},{"post_id":"cjkvv5tfa002xlx60c1tphbrc","tag_id":"cjkvv5tg0004zlx60didsicx3","_id":"cjkvv5th90086lx60xuh9md2v"},{"post_id":"cjkvv5tfa002xlx60c1tphbrc","tag_id":"cjkvv5th70083lx600cfe3q8p","_id":"cjkvv5th90087lx60a4hptkd2"},{"post_id":"cjkvv5tfa002xlx60c1tphbrc","tag_id":"cjkvv5th80084lx60gycq1zx8","_id":"cjkvv5th90089lx60nlywhizj"},{"post_id":"cjkvv5tfc0030lx609f7vx4p7","tag_id":"cjkvv5th80085lx6025bd0jkt","_id":"cjkvv5tha008blx60h5vc4ezc"},{"post_id":"cjkvv5tfc0030lx609f7vx4p7","tag_id":"cjkvv5th90088lx60e2pbq4pv","_id":"cjkvv5tha008clx60i57rykou"},{"post_id":"cjkvv5tfd0033lx60ihwb6yj9","tag_id":"cjkvv5th90088lx60e2pbq4pv","_id":"cjkvv5thc008glx60ursbrzq9"},{"post_id":"cjkvv5tfd0033lx60ihwb6yj9","tag_id":"cjkvv5thb008dlx6092zfoqb1","_id":"cjkvv5thc008hlx607qg1lfa0"},{"post_id":"cjkvv5tfd0033lx60ihwb6yj9","tag_id":"cjkvv5thb008elx60mghnytp3","_id":"cjkvv5thd008jlx60zdc5x8wh"},{"post_id":"cjkvv5tff0036lx60wvn9tyu4","tag_id":"cjkvv5thb008flx60w5nget7x","_id":"cjkvv5the008llx60o8zow4l6"},{"post_id":"cjkvv5tff0036lx60wvn9tyu4","tag_id":"cjkvv5thc008ilx6091qc60cn","_id":"cjkvv5the008mlx6058l79zmp"},{"post_id":"cjkvv5tfg0039lx60pkewp9qq","tag_id":"cjkvv5tey0028lx60qxzyz5pv","_id":"cjkvv5the008olx60w9lz2uc3"},{"post_id":"cjkvv5tfg0039lx60pkewp9qq","tag_id":"cjkvv5thd008klx60g7m4t22n","_id":"cjkvv5the008plx605ggsp55d"},{"post_id":"cjkvv5tfh003blx60ibomhqyx","tag_id":"cjkvv5the008nlx60smx6x4cn","_id":"cjkvv5thf008rlx60t31jo35r"},{"post_id":"cjkvv5tfh003blx60ibomhqyx","tag_id":"cjkvv5tfp003ylx60jvwq47zi","_id":"cjkvv5thg008slx60fk4c5yzb"}],"Tag":[{"name":"DSA","_id":"cjkvv5tda0005lx6058v788kf"},{"name":"ECC","_id":"cjkvv5tdg000clx60dotd2lsn"},{"name":"签名","_id":"cjkvv5tdn000hlx60b2cmqjzr"},{"name":"验签","_id":"cjkvv5tdw000mlx60z2ggcxfy"},{"name":"Swift","_id":"cjkvv5te2000slx60as8kxev8"},{"name":"Gif","_id":"cjkvv5te60011lx60f9qml3u5"},{"name":"动画","_id":"cjkvv5teb0018lx601v35h1bv"},{"name":"runloop","_id":"cjkvv5tee001elx60wihskzv3"},{"name":"CADisplayLink","_id":"cjkvv5teh001llx604284ey01"},{"name":"github","_id":"cjkvv5tel001slx602iwgh9fe"},{"name":"hexo","_id":"cjkvv5tes0020lx608acivo1y"},{"name":"iOS","_id":"cjkvv5tey0028lx60qxzyz5pv"},{"name":"语音识别","_id":"cjkvv5tf3002glx60ng9hafo1"},{"name":"macOS","_id":"cjkvv5tf6002nlx60c09ogsue"},{"name":"macOSApp","_id":"cjkvv5tfa002vlx606lfnhde1"},{"name":"图片去重","_id":"cjkvv5tfd0031lx60rvmti4xw"},{"name":"图片相似查询","_id":"cjkvv5tfg0038lx60552o66ui"},{"name":"文件处理","_id":"cjkvv5tfm003nlx60goijg1ob"},{"name":"文件重命名","_id":"cjkvv5tfp003xlx605t5zkvng"},{"name":"RSA","_id":"cjkvv5tfp003ylx60jvwq47zi"},{"name":"单例","_id":"cjkvv5tfs0046lx60b52hrpio"},{"name":"懒加载","_id":"cjkvv5tfs0048lx60km9lunhq"},{"name":"extension","_id":"cjkvv5tft0049lx60abe0wvys"},{"name":"网络请求","_id":"cjkvv5tft004alx603vtc31qc"},{"name":"workspace","_id":"cjkvv5tfu004elx60p5555ztq"},{"name":"etcd","_id":"cjkvv5tfv004hlx60q9s0px4f"},{"name":"分布式","_id":"cjkvv5tfw004klx603luu6ick"},{"name":"服务器集群","_id":"cjkvv5tfy004qlx60nuoqnu1s"},{"name":"ssh key","_id":"cjkvv5tfz004ulx607ddjjylg"},{"name":"数组","_id":"cjkvv5tg0004wlx60gjqsz8vi"},{"name":"go","_id":"cjkvv5tg0004zlx60didsicx3"},{"name":"加密算法","_id":"cjkvv5tg10050lx60slhtso3k"},{"name":"hash","_id":"cjkvv5tg10053lx60ty6wxrze"},{"name":"MD5","_id":"cjkvv5tg20054lx60jotq7d8o"},{"name":"sha256","_id":"cjkvv5tg30055lx60x0a1d1ky"},{"name":"rpemd160","_id":"cjkvv5tg30056lx60sl9w9hxy"},{"name":"配置","_id":"cjkvv5tg5005blx60e85vl9w8"},{"name":"视频","_id":"cjkvv5tg6005hlx60foe5o1wt"},{"name":"录制视频","_id":"cjkvv5tg7005klx60il6ubcgf"},{"name":"公共库","_id":"cjkvv5tg8005olx602d18t0w5"},{"name":"缓存","_id":"cjkvv5tgc005ulx60w0t991bw"},{"name":"性能","_id":"cjkvv5tge005zlx605tizcs31"},{"name":"越界","_id":"cjkvv5tgg0063lx60ogs2imdm"},{"name":"NSArray","_id":"cjkvv5tgh0064lx60v4dsu1fn"},{"name":"NSMutableArray","_id":"cjkvv5tgh0065lx60g33wtyvv"},{"name":"crash","_id":"cjkvv5tgh0066lx60vg9a4v44"},{"name":"AVplayer","_id":"cjkvv5tgm006ilx60gxmd4suz"},{"name":"instruments","_id":"cjkvv5tgo006nlx60drvjt6y9"},{"name":"mongodb","_id":"cjkvv5tgq006qlx60ycon83am"},{"name":"数据库","_id":"cjkvv5tgr006tlx60112pvgyb"},{"name":"环境变量","_id":"cjkvv5tgu0070lx60njrzwrwl"},{"name":"runtime","_id":"cjkvv5tgv0075lx60q6wg6nv2"},{"name":"Method Swizzling","_id":"cjkvv5tgw0076lx60i1b1kk8t"},{"name":"自动布局","_id":"cjkvv5tgx0077lx6067ep12av"},{"name":"slice","_id":"cjkvv5tgy007dlx60w8rx8uvy"},{"name":"排序","_id":"cjkvv5tgz007flx60uwdl0cy6"},{"name":"UI","_id":"cjkvv5tgz007glx60gywwwdl7"},{"name":"POS","_id":"cjkvv5th0007jlx60ank1wae9"},{"name":"共识算法","_id":"cjkvv5th1007mlx6098jp0pjy"},{"name":"DPOS","_id":"cjkvv5th1007olx60ot9x0w1q"},{"name":"POW","_id":"cjkvv5th2007slx609xbhcire"},{"name":"Raft","_id":"cjkvv5th5007zlx60ng15k5fu"},{"name":"strings","_id":"cjkvv5th70083lx600cfe3q8p"},{"name":"字符串操作","_id":"cjkvv5th80084lx60gycq1zx8"},{"name":"AES","_id":"cjkvv5th80085lx6025bd0jkt"},{"name":"对称加密","_id":"cjkvv5th90088lx60e2pbq4pv"},{"name":"DES","_id":"cjkvv5thb008dlx6092zfoqb1"},{"name":"3DES","_id":"cjkvv5thb008elx60mghnytp3"},{"name":"拜占庭","_id":"cjkvv5thb008flx60w5nget7x"},{"name":"PBFT","_id":"cjkvv5thc008ilx6091qc60cn"},{"name":"UIRefreshControl","_id":"cjkvv5thd008klx60g7m4t22n"},{"name":"非对称加密","_id":"cjkvv5the008nlx60smx6x4cn"}]}}