{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/weixin.jpg","path":"images/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/zhifubao.jpg","path":"images/zhifubao.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"fbaa8154c2fd3a8f1b1e5c7c14b155a4f55a9f66","modified":1479909569000},{"_id":"themes/next/.DS_Store","hash":"b4031ca706d0e344ab2ab686d4decf4474d9e602","modified":1480003795000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1462394086000},{"_id":"themes/next/_config.yml","hash":"6193d746faf3afca354b95d6f2ff0a07111702b8","modified":1479913202000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1462394086000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1462394086000},{"_id":"source/_posts/IOS10语音识别详解.md","hash":"716758911074616581f1737ed407738ac31707c5","modified":1479394641000},{"_id":"source/_posts/Xcode多工程联编及工程依赖.md","hash":"49ede9c4ff66cf48eaed5022bbf22d1252f2a78a","modified":1479392778000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1479308584000},{"_id":"source/_posts/GitHub+Hexo.md","hash":"ecf8da93260805b1e34b36625bb38c32109edc16","modified":1479308720000},{"_id":"source/_posts/iOS-release-debug版设置不同的AppIcon.md","hash":"db3f7a0062abcb716edea491f533b0c58b323b13","modified":1479390672000},{"_id":"source/_posts/iOS公共库.md","hash":"3151544c94e5c4195759978bf89f455346ded775","modified":1479394874000},{"_id":"source/_posts/github ssh key问题.md","hash":"f4fd13d586c3c624cd2424b8102a5fde42afbc83","modified":1479308720000},{"_id":"source/_posts/iOS三种录制视频方式.md","hash":"ba92b0970b2bb41cd18e932d9440e5c388e2264b","modified":1479394801000},{"_id":"source/_posts/iOS缓存机制-非结构化存储.md","hash":"99ebdeafd337d9578dd29d3609212bee9775bd6a","modified":1479394856000},{"_id":"source/_posts/iOS开发小技巧.md","hash":"bf14f40b127d5e6c7e89239466afb347614a6387","modified":1479395031000},{"_id":"source/_posts/iOS卡顿监控.md","hash":"a65f309fc720c3906ce44033de8cfb298387e4a7","modified":1479394830000},{"_id":"source/_posts/iOS构建自动化打包脚本.md","hash":"e261092785b7a409bb3eee607ec7c718f5e24be5","modified":1479712391000},{"_id":"source/_posts/iOS视频边下边播-缓存视频数据流.md","hash":"76f47b49d63539846f1d2dd6df7bb21fd63c62e2","modified":1479394789000},{"_id":"source/_posts/一分钟学会环形进度条.md","hash":"0692e39b0c80c4c244b4d141ed0c2db0031afae7","modified":1479394749000},{"_id":"source/_posts/swift自动布局.md","hash":"bedef801f6d5bac89785701eed5b69a0fcfbd73d","modified":1480002605000},{"_id":"source/_posts/runtime详解.md","hash":"c408545e0309792e379bcb3646ec7c4384bd7467","modified":1479390504000},{"_id":"source/tags/index.md","hash":"861615a062df253884ac923defb36324fb53787c","modified":1479224240000},{"_id":"source/categories/index.md","hash":"d9171c0731f852a47b8222b9a19c1867ce334011","modified":1479308954000},{"_id":"source/_posts/自定义刷新控件.md","hash":"2aa2503c623611c00718fb4973275038350c5910","modified":1479308720000},{"_id":"source/about/index.md","hash":"d41e4873ac67f38cad27017b0d70da0ba1620a24","modified":1479910252000},{"_id":"source/photo/index.md","hash":"030ee47820d31ddcc3a7ded608a050d8166c92f5","modified":1479912772000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1462394086000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1462394086000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1462394086000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1462394086000},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1462394086000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1462394086000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1462394086000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1462394086000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"5225445ea99e2d86babf42cae50fe8307af194d1","modified":1479912843000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1462394086000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1462394086000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1479310511000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1462394086000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1462394086000},{"_id":"themes/next/layout/.DS_Store","hash":"3846e5ec0495b1629bd13b6539ee80f6793487d7","modified":1479309415000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1462394086000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1462394086000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1462394086000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1462394086000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1462394086000},{"_id":"themes/next/scripts/.DS_Store","hash":"2ecca5dd0b7260968763bb4ded8695e5748d3d0e","modified":1479309426000},{"_id":"themes/next/source/404.html","hash":"f1aba17a5418c5373b74ff66e13a1568fcbad85a","modified":1479306070000},{"_id":"themes/next/source/.DS_Store","hash":"497a22c1b44426182974566cd0d9e7ebb9602fd7","modified":1479309431000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1462394086000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1462394086000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1462394086000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1462394086000},{"_id":"themes/next/layout/_macro/post.swig","hash":"1ca03011bed92614832b1343b65be92183957dc5","modified":1462394086000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b883289054ee54a374caad5d4883591beb94bd8b","modified":1462394086000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1462394086000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1462394086000},{"_id":"themes/next/layout/_partials/.DS_Store","hash":"ac37a342cd76e1cbf8a9794d8d235f01f6298ca0","modified":1479912977000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"82a9bc2ba60ce68419128ff60624bd74b15dfb78","modified":1462394086000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1462394086000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"821936c82367fa08633cc11b72b13042e0d1d9d8","modified":1480139215000},{"_id":"themes/next/layout/_partials/head.swig","hash":"f83b1c55bedd2c1a3eb734c72c6997795a4e5f99","modified":1462394086000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1462394086000},{"_id":"themes/next/layout/_partials/header.swig","hash":"963a765dc00e6ac43cfc53ffaf5725eb854cf95e","modified":1462394086000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1462394086000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1462394086000},{"_id":"themes/next/layout/_scripts/.DS_Store","hash":"70fd979797dc5474f4aee387a84314bc9bb122d8","modified":1479309420000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1462394086000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1462394086000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1462394086000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1462394086000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1462394086000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1462394086000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1462394086000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1462394086000},{"_id":"themes/next/source/css/.DS_Store","hash":"bbd874d841ee8ed19a25b4fd8382ed8fc6f2c115","modified":1479309953000},{"_id":"themes/next/source/images/avatar.gif","hash":"69d416815d29d64a23b27271ebe6f9844fc2a956","modified":1479281285000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1462394086000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1462394086000},{"_id":"themes/next/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1479293752000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1462394086000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1462394086000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1462394086000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1462394086000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1462394086000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1462394086000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1462394086000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1462394086000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1462394086000},{"_id":"themes/next/source/images/weixin.jpg","hash":"bb32f026574b2f072279157b2e15146bc9583885","modified":1479302089000},{"_id":"themes/next/source/js/.DS_Store","hash":"bd7c5ffc965c42df1b10ea6b51aa93e782056006","modified":1479309439000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1462394086000},{"_id":"themes/next/source/images/zhifubao.jpg","hash":"5975ae7e6a34a09a3c9329d320eca5b1b0aa68bc","modified":1479658083000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1462394086000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1462394086000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1462394086000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1462394086000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1462394086000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1462394086000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1462394086000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1462394086000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"069bb17fb1db3bc7c85c88efa3ed94ab6becbe2c","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1462394086000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1462394086000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1462394086000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1462394086000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1462394086000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1462394086000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"17624186f7a1f28daddea258d044f8e03b2f4bea","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/.DS_Store","hash":"75f24243df3ef5d4c6e6bf22e39100ca38f57b06","modified":1479309953000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1462394086000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1462394086000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1462394086000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1462394086000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1462394086000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1462394086000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1462394086000},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1462394086000},{"_id":"themes/next/source/js/src/.DS_Store","hash":"741f0f6de4a16ba2e97985b249c7d6c30c7caf70","modified":1479309445000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1462394086000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1462394086000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1462394086000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"8c7af79407d223486fba72b8150fe045a553bf70","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1462394086000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1462394086000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1462394086000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1462394086000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1462394086000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1462394086000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1462394086000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1462394086000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1462394086000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1462394086000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1462394086000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1462394086000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1462394086000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1462394086000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1462394086000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1462394086000},{"_id":"public/atom.xml","hash":"b6f403708256ed4d3cdba93635ee1ecf61a6e293","modified":1480139168699},{"_id":"public/search.xml","hash":"d53da2b1185c8b4ac97be1e5289220ea74595791","modified":1480139168722},{"_id":"public/tags/index.html","hash":"c7b5165533755ae6f341ffd753b1a7e7d72d7c38","modified":1480139226071},{"_id":"public/categories/index.html","hash":"2f18b094b9bb751290c8dfa4ff04c37e8fbb5686","modified":1480139226071},{"_id":"public/about/index.html","hash":"8ae290338c082b8d02aa20a2986352266475736a","modified":1480139226071},{"_id":"public/photo/index.html","hash":"c6f80297ef7bddd92edd4fed61b7159ba6212368","modified":1480139226071},{"_id":"public/2016/11/21/iOS构建自动化打包脚本/index.html","hash":"cb4a7484dc375621df04109f327996fbd9fddd11","modified":1480139226071},{"_id":"public/2016/11/16/IOS10语音识别详解/index.html","hash":"b00fdebbdd63c556ef1fbdf49ddb723f41ad3a78","modified":1480139226071},{"_id":"public/2016/11/16/自定义刷新控件/index.html","hash":"b8f22c7079155ba31e3019c45981d957db735ee4","modified":1480139226071},{"_id":"public/2016/04/16/runtime详解/index.html","hash":"adc100c7f076713375480a78d3bc7683a4ada503","modified":1480139226071},{"_id":"public/2016/04/13/iOS-release-debug版设置不同的AppIcon/index.html","hash":"9355fc98242c7e6e74121ec0656ec96a8103e464","modified":1480139226071},{"_id":"public/2016/04/06/iOS公共库/index.html","hash":"e0a6986454c74b70a3527bd97e00556ece9e514e","modified":1480139226071},{"_id":"public/2016/03/20/iOS三种录制视频方式/index.html","hash":"286ff82d3b5ff6a774927d7838814c6225e3c6e3","modified":1480139226071},{"_id":"public/2016/03/15/iOS开发小技巧/index.html","hash":"aebfd7f6444875420052ec1be5db469077754cae","modified":1480139226071},{"_id":"public/2016/03/12/Xcode多工程联编及工程依赖/index.html","hash":"3f181f876a5cf708ff54108390f1877fb4ac0d96","modified":1480139226071},{"_id":"public/2016/03/12/iOS缓存机制-非结构化存储/index.html","hash":"243fda5c10c0444d619e2e9feed9ed5a94b59cb0","modified":1480139226072},{"_id":"public/2016/02/27/一分钟学会环形进度条/index.html","hash":"ba62011f118600f778895349e330f680fa6e6c2a","modified":1480139226072},{"_id":"public/2016/02/27/github ssh key问题/index.html","hash":"ebccbc060b70a880aa26034b59adfce54835658c","modified":1480139226072},{"_id":"public/2016/02/25/iOS视频边下边播-缓存视频数据流/index.html","hash":"1a7db7a9277b95653a5f480b16558f02f02dd076","modified":1480139226072},{"_id":"public/2016/02/25/iOS卡顿监控/index.html","hash":"4e34694c02c259c6c3f1fd21c51676fea087098c","modified":1480139226072},{"_id":"public/2016/02/23/GitHub+Hexo/index.html","hash":"e750a6d52fb609465e43322f4467016557810788","modified":1480139226072},{"_id":"public/categories/iOS技术/index.html","hash":"76a258318f972fa3a5c05583e37c39d812066bc4","modified":1480139226072},{"_id":"public/categories/iOS技术/page/2/index.html","hash":"b0c9e1f023071de7997f4a1c9a7cad8c040e5b7e","modified":1480139226072},{"_id":"public/categories/iOS技术/page/3/index.html","hash":"f5859992e6463a8aaa39c485efadbfe9a8bd4855","modified":1480139226072},{"_id":"public/categories/iOS配置/index.html","hash":"6978fb82a5e4876e1c9685cfc110a5a86d0844e8","modified":1480139226072},{"_id":"public/categories/随笔/index.html","hash":"059e80d7e266560da3d0c2ac00a5ad69befce7db","modified":1480139226072},{"_id":"public/archives/index.html","hash":"5289186e56da909d58b7cede1ac579dbfda763a5","modified":1480139226072},{"_id":"public/archives/page/2/index.html","hash":"0d76d6a20e5ef4eba6dcd585418a42c754847c01","modified":1480139226072},{"_id":"public/archives/page/3/index.html","hash":"39edce8bd9ee91758bd684caf1447594c7e5ed8d","modified":1480139226072},{"_id":"public/archives/page/4/index.html","hash":"ccaa67de85978aa8c40694b818a85c481fc573e1","modified":1480139226072},{"_id":"public/archives/2016/index.html","hash":"e96f23b70ff183d7981968045bbc8f1e580e008c","modified":1480139226072},{"_id":"public/archives/2016/page/2/index.html","hash":"e1e0b343691ec1b6c6260d66962e15d9bfa65369","modified":1480139226072},{"_id":"public/archives/2016/page/3/index.html","hash":"1dfd0d899df4efe13bed9948b23906f85d56d73b","modified":1480139226072},{"_id":"public/archives/2016/page/4/index.html","hash":"5a60752452a71aa43ab0dcda8aa1d77e235783f3","modified":1480139226072},{"_id":"public/archives/2016/02/page/2/index.html","hash":"3b408b9ba85167c075add14df53866eb74f02e4d","modified":1480139226072},{"_id":"public/archives/2016/03/index.html","hash":"22459fb9218863b780edd67731e0a56ca4126dd0","modified":1480139226072},{"_id":"public/archives/2016/02/index.html","hash":"c7fab21fd2eb964f40b5add2abc6cd0c43e32511","modified":1480139226072},{"_id":"public/archives/2016/04/index.html","hash":"c82317f7e3f4288918529d5acbce2a738613aabe","modified":1480139226072},{"_id":"public/archives/2016/11/index.html","hash":"f264235099b9c749501a29d7b685c7b20fd08ff7","modified":1480139226073},{"_id":"public/tags/iOS/index.html","hash":"f2d84f9eb95252e6265676ef7eff2a08e801c7cd","modified":1480139226073},{"_id":"public/tags/iOS/page/2/index.html","hash":"5b5372e51b45fe70b495ce681c12e36fa9e46e52","modified":1480139226073},{"_id":"public/tags/iOS/page/3/index.html","hash":"f7c3c989dd352289c3bcad97000836726f5980b6","modified":1480139226073},{"_id":"public/tags/iOS/page/4/index.html","hash":"fc23756ffbfa855d57da065bbaabca3c5542fc3b","modified":1480139226074},{"_id":"public/tags/语音识别/index.html","hash":"0bc282107b997ee509cf52d2db0750abc421077b","modified":1480139226074},{"_id":"public/tags/workspace/index.html","hash":"feed387fb52b6a2cdaa2884f1960e8df4f8389c3","modified":1480139226074},{"_id":"public/tags/github/index.html","hash":"b3416c0528e2a30506b5a9b47fa4b058c8091351","modified":1480139226074},{"_id":"public/tags/hexo/index.html","hash":"48b80980d81aedd61c6352ed22bab6ad0f7c6240","modified":1480139226074},{"_id":"public/tags/公共库/index.html","hash":"675e0e3129fc8fc6c9e8fd3de0f6543bb75a677b","modified":1480139226074},{"_id":"public/tags/ssh-key/index.html","hash":"e395dcb3b00f533b4a4a6b8557716e2804bb05ae","modified":1480139226074},{"_id":"public/tags/视频录制/index.html","hash":"c0e36cad83e6f7b4ad61a183d781d4cad29dc597","modified":1480139226074},{"_id":"public/tags/缓存/index.html","hash":"833e1e96018da07e9df151014c243c87c7ae53e6","modified":1480139226074},{"_id":"public/tags/性能/index.html","hash":"46fd8025b375178e6b2d9d323260ea780eafc67d","modified":1480139226074},{"_id":"public/tags/Archive/index.html","hash":"b11b74d11d9540c8a7681aa9d1057f192c335c58","modified":1480139226074},{"_id":"public/tags/targit/index.html","hash":"61cd0ec832ae0e4f47bc13c0162dfaa828f93e28","modified":1480139226074},{"_id":"public/tags/配置/index.html","hash":"fa6156f81d2babb7910bb30bf725db8e54f40d1a","modified":1480139226074},{"_id":"public/tags/UI/index.html","hash":"03c6776008b0aca5ae90d6af23a66ccbc3fc04e0","modified":1480139226074},{"_id":"public/2016/11/24/swift自动布局/index.html","hash":"3a4140a7e1f9d2201a5a4786e5a489d8ed51b71b","modified":1480139226071},{"_id":"public/tags/AVplayer/index.html","hash":"d6cc4682a4b2bff1fe103e6d458e8c81068b351b","modified":1480139226076},{"_id":"public/tags/runtime/index.html","hash":"1482b26936c5ac22b971cf4b67f633ba538cf333","modified":1480139226076},{"_id":"public/tags/Method-Swizzling/index.html","hash":"809d9b7e681de8a423d3d45ccf124cba88da2c95","modified":1480139226076},{"_id":"public/tags/UIRefreshControl/index.html","hash":"22b1551bf407dd48dc1d6dfd0bbae11221244021","modified":1480139226076},{"_id":"public/index.html","hash":"a399c2e1cc452afccd734bd7ff880b24145f16d1","modified":1480139226073},{"_id":"public/page/2/index.html","hash":"c9e644d11fe8178e101922ccd7c48446db749a6b","modified":1480139226073},{"_id":"public/page/3/index.html","hash":"67a80b69113c67c3f259dcb81f881099371668d6","modified":1480139226073},{"_id":"public/page/4/index.html","hash":"a1afe3b64fb2d1a377a9d3e67afd698e1f87ec36","modified":1480139226073},{"_id":"public/categories/swfit/index.html","hash":"ce8ee81ff459bcb6e08582fcfe06c6b06ba43bf5","modified":1480139226072},{"_id":"public/tags/swift/index.html","hash":"0df855402bff6ab1a0606be45ae03b25b55d837b","modified":1480139226074},{"_id":"public/tags/自动布局/index.html","hash":"f7e35df1eb9b05d25d0647dd5f1454236e5161c9","modified":1480139226075}],"Category":[{"name":"iOS技术","_id":"civyshmem0002co60qm2lbiyk"},{"name":"iOS配置","_id":"civyshmf80007co60miipwxdj"},{"name":"随笔","_id":"civyshmgk000cco60uvl8e8xl"},{"name":"swfit","_id":"civyshmif0010co60ei373e3y"}],"Data":[],"Page":[{"title":"tags","date":"2016-10-19T22:49:50.000Z","type":"tags","comments":0,"_content":"\n\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-10-20 06:49:50\ntype: \"tags\"\ncomments: false\n---\n\n\n","updated":"2016-11-15T15:37:20.000Z","path":"tags/index.html","layout":"page","_id":"civyshmon002fco6039ml66v5","content":"","excerpt":"","more":""},{"title":"分类","date":"2016-11-16T14:01:22.000Z","type":"categories","comments":0,"_content":"\n\n","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2016-11-16 22:01:22\ntype: \"categories\"\ncomments: false\n---\n\n\n","updated":"2016-11-16T15:09:14.000Z","path":"categories/index.html","layout":"page","_id":"civyshmor002hco60ggh02reg","content":"","excerpt":"","more":""},{"title":"about","date":"2016-11-23T13:58:16.000Z","comments":0,"_content":"\n## 关于我\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=29803270&auto=1&height=66\"></iframe>\n\n### 钱佳能\n\n> 毕业于景德镇陶瓷大学\n> 90后 双鱼座  coding studying\n> 旅行 爬山 乒乓球 卡丁车\n\n### 联系方式\n> 微信：cywt123\n> 邮箱：dearqjn@gmail.com\n\n### 当前地址\n> 北京●朝阳●望京\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-11-23 21:58:16\ncomments: false\n---\n\n## 关于我\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=29803270&auto=1&height=66\"></iframe>\n\n### 钱佳能\n\n> 毕业于景德镇陶瓷大学\n> 90后 双鱼座  coding studying\n> 旅行 爬山 乒乓球 卡丁车\n\n### 联系方式\n> 微信：cywt123\n> 邮箱：dearqjn@gmail.com\n\n### 当前地址\n> 北京●朝阳●望京\n\n","updated":"2016-11-23T14:10:52.000Z","path":"about/index.html","layout":"page","_id":"civyshmov002jco60zfsoxbua","content":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"http://music.163.com/outchain/player?type=2&id=29803270&auto=1&height=66\"></iframe>\n\n<h3 id=\"钱佳能\"><a href=\"#钱佳能\" class=\"headerlink\" title=\"钱佳能\"></a>钱佳能</h3><blockquote>\n<p>毕业于景德镇陶瓷大学<br>90后 双鱼座  coding studying<br>旅行 爬山 乒乓球 卡丁车</p>\n</blockquote>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><blockquote>\n<p>微信：cywt123<br>邮箱：dearqjn@gmail.com</p>\n</blockquote>\n<h3 id=\"当前地址\"><a href=\"#当前地址\" class=\"headerlink\" title=\"当前地址\"></a>当前地址</h3><blockquote>\n<p>北京●朝阳●望京</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h2><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2&id=29803270&auto=1&height=66\"></iframe>\n\n<h3 id=\"钱佳能\"><a href=\"#钱佳能\" class=\"headerlink\" title=\"钱佳能\"></a>钱佳能</h3><blockquote>\n<p>毕业于景德镇陶瓷大学<br>90后 双鱼座  coding studying<br>旅行 爬山 乒乓球 卡丁车</p>\n</blockquote>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><blockquote>\n<p>微信：cywt123<br>邮箱：dearqjn@gmail.com</p>\n</blockquote>\n<h3 id=\"当前地址\"><a href=\"#当前地址\" class=\"headerlink\" title=\"当前地址\"></a>当前地址</h3><blockquote>\n<p>北京●朝阳●望京</p>\n</blockquote>\n"},{"title":"photo","date":"2016-11-23T14:52:52.000Z","_content":"","source":"photo/index.md","raw":"---\ntitle: photo\ndate: 2016-11-23 22:52:52\n---\n","updated":"2016-11-23T14:52:52.000Z","path":"photo/index.html","comments":1,"layout":"page","_id":"civyshmoy002lco607m610rjq","content":"","excerpt":"","more":""}],"Post":[{"title":"iOS语音识别","author":[{"name":"千寻墨","url":"http://www.jianshu.com/users/527ecf8c8753/latest_articles"}],"_content":"\n公司项目需要实现语音搜索，正好记录一下这个iOS10新出的API。\n\n\tiOS10是一个变化比价大的版本，开放了很多接口，这样也更方便开发者自定义各种功能。本文主要讲解一下新增的Speech框架，有了这个框架，我们想要为自己的app增加语音识别功能，不要依赖第三方的服务，几十行代码就可以轻松搞定。demo地址在文章末尾。\n\n### 一：基本配置\n- Xcode8，iOS10系统真机\n- 导入头文件：OC `#import<Speech/Speech.h>`   swift `import Speech`\n- 配置info.plist文件:配置两个权限，语音识别和麦克风\n\n\n```\n<key>NSMicrophoneUsageDescription</key>\n    <string>Your microphone will be used to record your speech when you press the \"Start Recording\" button.</string>\n    \n    <key>NSSpeechRecognitionUsageDescription</key>\n    <string>Speech recognition will be used to determine which words you speak into this device's microphone.</string>\n  \n```\n\n### 二：用到的几个类\n\n` AVAudioEngine `                           语音引擎，负责提供语音输入\n` SFSpeechAudioBufferRecognitionRequest `   处理语音识别请求\n` SFSpeechRecognizer`                       语音识别器\n` SFSpeechRecognitionTask `                 输出语音识别对象的结果\n` NSLocale `                                语言类型               \n语音识别一共就用到了这几个类，整体的流程也容易理解，语音识别器通过语音引擎，处理语音识别请求，把结果交给`SFSpeechRecognitionTask`处理，最后输出文字。\n` SFSpeechRecognizer` 自身有几个代理方法，实际上，如果只是将语音转化成文字，是不需要这几个代理方法的。\n<!--more-->\n```\n//当开始检测音频源中的语音时首先调用此方法\n-(void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task\n{\n  \n}\n//当识别出一条可用的信息后 会调用\n/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法 */\n-(void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription\n{\n   \n}\n//当识别完成所有可用的结果后调用\n- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult\n{\n    \n}\n//当不再接受音频输入时调用 即开始处理语音识别任务时调用\n- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task\n{\n    \n}\n//当语音识别任务被取消时调用\n- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task\n{\n    \n}\n//语音识别任务完成时被调用\n- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully\n{\n\n}\n```\n\n### 三：重点代码\n有两点需要注意：\n\n* 语音识别会很耗电以及会使用很多数据\n* 语音识别一次只持续大概一分钟的时间\n\n我先定义了这几个属性\n\n```\n@property (nonatomic, strong) AVAudioEngine         *audioEngine;\n@property (nonatomic, strong) SFSpeechRecognizer    *speechRecognizer;\n@property (nonatomic, strong) SFSpeechAudioBufferRecognitionRequest     *recognitionRequest;\n@property (nonatomic, strong) SFSpeechRecognitionTask   *recognitionTask;\n@property (nonatomic, strong) NSLocale                  *locale;\n```\n1. 语音权限的判断\n```\n[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) {\n        BOOL isAuthorized = NO;\n       switch (status) {\n                //结果未知 用户尚未进行选择\n            case SFSpeechRecognizerAuthorizationStatusNotDetermined:\n                isAuthorized = NO;\n                break;\n                //用户拒绝授权语音识别\n            case SFSpeechRecognizerAuthorizationStatusDenied:\n                isAuthorized = NO;\n                break;\n                //设备不支持语音识别功能\n            case SFSpeechRecognizerAuthorizationStatusRestricted:\n                isAuthorized = NO;\n                break;\n                //用户授权语音识别\n            case SFSpeechRecognizerAuthorizationStatusAuthorized:\n                isAuthorized = YES;\n                \n                break;\n                \n            default:\n                break;\n        }\n        \n        if (callback) {\n            callback(isAuthorized, status);\n        }\n    }];\n```\n2. 将语音引擎得到的语音数据添加到语音识别的请求中，这个过程也就是开始录音后的流程\n```\nAVAudioFormat *recordingFormat = [[self.audioEngine inputNode] outputFormatForBus:0];\n    [[self.audioEngine inputNode] installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) {\n        [self.recognitionRequest appendAudioPCMBuffer:buffer];\n    }];\n```\n\n3. `SFSpeechRecognitionTask ` 把上一过程中得到的语音请求转化成文字，这个过程是试试进行的。\n\n```\nself.recognitionTask = [self.speechRecognizer recognitionTaskWithRequest:self.recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) {\n        BOOL isFinal = NO;\n        NSString *bestResult = [[result bestTranscription] formattedString];\n        isFinal = result.isFinal;\n        if (error || isFinal) {\n            [self endTask];\n            if (self.delegate && [self.delegate respondsToSelector:@selector(recognizeFail:)]) {\n                [self.delegate recognizeFail:error];\n            }\n        } else {\n            if (self.delegate && [self.delegate respondsToSelector:@selector(recognizeSuccess:)]) {\n                [self.delegate recognizeSuccess:bestResult];\n            }\n        }\n    }];\n```\n### 四：提取录音文件中的文字\n1. 也需要先获取用户的授权，授权代码与上面一致。\n2. 对文件的处理相对较为简单\n```\n    //初始化一个识别器\n    SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc] initWithLocale:[NSLocale localeWithLocaleIdentifier:@\"zh_CN\"]];\n    //初始化mp3的url\n    NSURL *url = [[NSBundle mainBundle] URLForResource:@\"test.mp3\" withExtension:nil];\n    //初始化一个识别的请求\n    SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url];\n    //发起请求\n    [recognizer recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) {\n        if(error != nil)\n        {\n            NSLog(@\"识别错误:%@\",error);\n        }\n        NSString *resultString = result.bestTranscription.formattedString;\n        NSLog(@\"%@\",resultString);\n        \n    }];\n```\n\n[github地址：https://github.com/suifengqjn/IOS10Speech](https://github.com/suifengqjn/IOS10Speech)\n\n\n","source":"_posts/IOS10语音识别详解.md","raw":"---\ntitle: iOS语音识别\ntags:\n  - iOS\n  - 语音识别\ncategories:\n  - iOS技术\nauthor:\n  - name: 千寻墨\n    url: http://www.jianshu.com/users/527ecf8c8753/latest_articles\n---\n\n公司项目需要实现语音搜索，正好记录一下这个iOS10新出的API。\n\n\tiOS10是一个变化比价大的版本，开放了很多接口，这样也更方便开发者自定义各种功能。本文主要讲解一下新增的Speech框架，有了这个框架，我们想要为自己的app增加语音识别功能，不要依赖第三方的服务，几十行代码就可以轻松搞定。demo地址在文章末尾。\n\n### 一：基本配置\n- Xcode8，iOS10系统真机\n- 导入头文件：OC `#import<Speech/Speech.h>`   swift `import Speech`\n- 配置info.plist文件:配置两个权限，语音识别和麦克风\n\n\n```\n<key>NSMicrophoneUsageDescription</key>\n    <string>Your microphone will be used to record your speech when you press the \"Start Recording\" button.</string>\n    \n    <key>NSSpeechRecognitionUsageDescription</key>\n    <string>Speech recognition will be used to determine which words you speak into this device's microphone.</string>\n  \n```\n\n### 二：用到的几个类\n\n` AVAudioEngine `                           语音引擎，负责提供语音输入\n` SFSpeechAudioBufferRecognitionRequest `   处理语音识别请求\n` SFSpeechRecognizer`                       语音识别器\n` SFSpeechRecognitionTask `                 输出语音识别对象的结果\n` NSLocale `                                语言类型               \n语音识别一共就用到了这几个类，整体的流程也容易理解，语音识别器通过语音引擎，处理语音识别请求，把结果交给`SFSpeechRecognitionTask`处理，最后输出文字。\n` SFSpeechRecognizer` 自身有几个代理方法，实际上，如果只是将语音转化成文字，是不需要这几个代理方法的。\n<!--more-->\n```\n//当开始检测音频源中的语音时首先调用此方法\n-(void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task\n{\n  \n}\n//当识别出一条可用的信息后 会调用\n/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法 */\n-(void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription\n{\n   \n}\n//当识别完成所有可用的结果后调用\n- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult\n{\n    \n}\n//当不再接受音频输入时调用 即开始处理语音识别任务时调用\n- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task\n{\n    \n}\n//当语音识别任务被取消时调用\n- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task\n{\n    \n}\n//语音识别任务完成时被调用\n- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully\n{\n\n}\n```\n\n### 三：重点代码\n有两点需要注意：\n\n* 语音识别会很耗电以及会使用很多数据\n* 语音识别一次只持续大概一分钟的时间\n\n我先定义了这几个属性\n\n```\n@property (nonatomic, strong) AVAudioEngine         *audioEngine;\n@property (nonatomic, strong) SFSpeechRecognizer    *speechRecognizer;\n@property (nonatomic, strong) SFSpeechAudioBufferRecognitionRequest     *recognitionRequest;\n@property (nonatomic, strong) SFSpeechRecognitionTask   *recognitionTask;\n@property (nonatomic, strong) NSLocale                  *locale;\n```\n1. 语音权限的判断\n```\n[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) {\n        BOOL isAuthorized = NO;\n       switch (status) {\n                //结果未知 用户尚未进行选择\n            case SFSpeechRecognizerAuthorizationStatusNotDetermined:\n                isAuthorized = NO;\n                break;\n                //用户拒绝授权语音识别\n            case SFSpeechRecognizerAuthorizationStatusDenied:\n                isAuthorized = NO;\n                break;\n                //设备不支持语音识别功能\n            case SFSpeechRecognizerAuthorizationStatusRestricted:\n                isAuthorized = NO;\n                break;\n                //用户授权语音识别\n            case SFSpeechRecognizerAuthorizationStatusAuthorized:\n                isAuthorized = YES;\n                \n                break;\n                \n            default:\n                break;\n        }\n        \n        if (callback) {\n            callback(isAuthorized, status);\n        }\n    }];\n```\n2. 将语音引擎得到的语音数据添加到语音识别的请求中，这个过程也就是开始录音后的流程\n```\nAVAudioFormat *recordingFormat = [[self.audioEngine inputNode] outputFormatForBus:0];\n    [[self.audioEngine inputNode] installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) {\n        [self.recognitionRequest appendAudioPCMBuffer:buffer];\n    }];\n```\n\n3. `SFSpeechRecognitionTask ` 把上一过程中得到的语音请求转化成文字，这个过程是试试进行的。\n\n```\nself.recognitionTask = [self.speechRecognizer recognitionTaskWithRequest:self.recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) {\n        BOOL isFinal = NO;\n        NSString *bestResult = [[result bestTranscription] formattedString];\n        isFinal = result.isFinal;\n        if (error || isFinal) {\n            [self endTask];\n            if (self.delegate && [self.delegate respondsToSelector:@selector(recognizeFail:)]) {\n                [self.delegate recognizeFail:error];\n            }\n        } else {\n            if (self.delegate && [self.delegate respondsToSelector:@selector(recognizeSuccess:)]) {\n                [self.delegate recognizeSuccess:bestResult];\n            }\n        }\n    }];\n```\n### 四：提取录音文件中的文字\n1. 也需要先获取用户的授权，授权代码与上面一致。\n2. 对文件的处理相对较为简单\n```\n    //初始化一个识别器\n    SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc] initWithLocale:[NSLocale localeWithLocaleIdentifier:@\"zh_CN\"]];\n    //初始化mp3的url\n    NSURL *url = [[NSBundle mainBundle] URLForResource:@\"test.mp3\" withExtension:nil];\n    //初始化一个识别的请求\n    SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url];\n    //发起请求\n    [recognizer recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) {\n        if(error != nil)\n        {\n            NSLog(@\"识别错误:%@\",error);\n        }\n        NSString *resultString = result.bestTranscription.formattedString;\n        NSLog(@\"%@\",resultString);\n        \n    }];\n```\n\n[github地址：https://github.com/suifengqjn/IOS10Speech](https://github.com/suifengqjn/IOS10Speech)\n\n\n","slug":"IOS10语音识别详解","published":1,"date":"2016-11-16T15:05:20.000Z","updated":"2016-11-17T14:57:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshme80000co60hc5z5z7w","content":"<p>公司项目需要实现语音搜索，正好记录一下这个iOS10新出的API。</p>\n<pre><code>iOS10是一个变化比价大的版本，开放了很多接口，这样也更方便开发者自定义各种功能。本文主要讲解一下新增的Speech框架，有了这个框架，我们想要为自己的app增加语音识别功能，不要依赖第三方的服务，几十行代码就可以轻松搞定。demo地址在文章末尾。\n</code></pre><h3 id=\"一：基本配置\"><a href=\"#一：基本配置\" class=\"headerlink\" title=\"一：基本配置\"></a>一：基本配置</h3><ul>\n<li>Xcode8，iOS10系统真机</li>\n<li>导入头文件：OC <code>#import&lt;Speech/Speech.h&gt;</code>   swift <code>import Speech</code></li>\n<li>配置info.plist文件:配置两个权限，语音识别和麦克风</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;</div><div class=\"line\">    &lt;string&gt;Your microphone will be used to record your speech when you press the &quot;Start Recording&quot; button.&lt;/string&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;key&gt;NSSpeechRecognitionUsageDescription&lt;/key&gt;</div><div class=\"line\">    &lt;string&gt;Speech recognition will be used to determine which words you speak into this device&apos;s microphone.&lt;/string&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"二：用到的几个类\"><a href=\"#二：用到的几个类\" class=\"headerlink\" title=\"二：用到的几个类\"></a>二：用到的几个类</h3><p><code>AVAudioEngine</code>                           语音引擎，负责提供语音输入<br><code>SFSpeechAudioBufferRecognitionRequest</code>   处理语音识别请求<br><code>SFSpeechRecognizer</code>                       语音识别器<br><code>SFSpeechRecognitionTask</code>                 输出语音识别对象的结果<br><code>NSLocale</code>                                语言类型<br>语音识别一共就用到了这几个类，整体的流程也容易理解，语音识别器通过语音引擎，处理语音识别请求，把结果交给<code>SFSpeechRecognitionTask</code>处理，最后输出文字。<br><code>SFSpeechRecognizer</code> 自身有几个代理方法，实际上，如果只是将语音转化成文字，是不需要这几个代理方法的。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">//当开始检测音频源中的语音时首先调用此方法</div><div class=\"line\">-(void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div><div class=\"line\">//当识别出一条可用的信息后 会调用</div><div class=\"line\">/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法 */</div><div class=\"line\">-(void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription</div><div class=\"line\">&#123;</div><div class=\"line\">   </div><div class=\"line\">&#125;</div><div class=\"line\">//当识别完成所有可用的结果后调用</div><div class=\"line\">- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//当不再接受音频输入时调用 即开始处理语音识别任务时调用</div><div class=\"line\">- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//当语音识别任务被取消时调用</div><div class=\"line\">- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//语音识别任务完成时被调用</div><div class=\"line\">- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"三：重点代码\"><a href=\"#三：重点代码\" class=\"headerlink\" title=\"三：重点代码\"></a>三：重点代码</h3><p>有两点需要注意：</p>\n<ul>\n<li>语音识别会很耗电以及会使用很多数据</li>\n<li>语音识别一次只持续大概一分钟的时间</li>\n</ul>\n<p>我先定义了这几个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) AVAudioEngine         *audioEngine;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechRecognizer    *speechRecognizer;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechAudioBufferRecognitionRequest     *recognitionRequest;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechRecognitionTask   *recognitionTask;</div><div class=\"line\">@property (nonatomic, strong) NSLocale                  *locale;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>语音权限的判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123;</div><div class=\"line\">        BOOL isAuthorized = NO;</div><div class=\"line\">       switch (status) &#123;</div><div class=\"line\">                //结果未知 用户尚未进行选择</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusNotDetermined:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //用户拒绝授权语音识别</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusDenied:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //设备不支持语音识别功能</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusRestricted:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //用户授权语音识别</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusAuthorized:</div><div class=\"line\">                isAuthorized = YES;</div><div class=\"line\">                </div><div class=\"line\">                break;</div><div class=\"line\">                </div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if (callback) &#123;</div><div class=\"line\">            callback(isAuthorized, status);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n</li>\n<li><p>将语音引擎得到的语音数据添加到语音识别的请求中，这个过程也就是开始录音后的流程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">AVAudioFormat *recordingFormat = [[self.audioEngine inputNode] outputFormatForBus:0];</div><div class=\"line\">    [[self.audioEngine inputNode] installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) &#123;</div><div class=\"line\">        [self.recognitionRequest appendAudioPCMBuffer:buffer];</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>SFSpeechRecognitionTask</code> 把上一过程中得到的语音请求转化成文字，这个过程是试试进行的。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.recognitionTask = [self.speechRecognizer recognitionTaskWithRequest:self.recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123;</div><div class=\"line\">        BOOL isFinal = NO;</div><div class=\"line\">        NSString *bestResult = [[result bestTranscription] formattedString];</div><div class=\"line\">        isFinal = result.isFinal;</div><div class=\"line\">        if (error || isFinal) &#123;</div><div class=\"line\">            [self endTask];</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeFail:)]) &#123;</div><div class=\"line\">                [self.delegate recognizeFail:error];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeSuccess:)]) &#123;</div><div class=\"line\">                [self.delegate recognizeSuccess:bestResult];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<h3 id=\"四：提取录音文件中的文字\"><a href=\"#四：提取录音文件中的文字\" class=\"headerlink\" title=\"四：提取录音文件中的文字\"></a>四：提取录音文件中的文字</h3><ol>\n<li>也需要先获取用户的授权，授权代码与上面一致。</li>\n<li>对文件的处理相对较为简单<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化一个识别器</div><div class=\"line\">SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc] initWithLocale:[NSLocale localeWithLocaleIdentifier:@&quot;zh_CN&quot;]];</div><div class=\"line\">//初始化mp3的url</div><div class=\"line\">NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;test.mp3&quot; withExtension:nil];</div><div class=\"line\">//初始化一个识别的请求</div><div class=\"line\">SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url];</div><div class=\"line\">//发起请求</div><div class=\"line\">[recognizer recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123;</div><div class=\"line\">    if(error != nil)</div><div class=\"line\">    &#123;</div><div class=\"line\">        NSLog(@&quot;识别错误:%@&quot;,error);</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSString *resultString = result.bestTranscription.formattedString;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,resultString);</div><div class=\"line\">    </div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><a href=\"https://github.com/suifengqjn/IOS10Speech\" target=\"_blank\" rel=\"external\">github地址：https://github.com/suifengqjn/IOS10Speech</a></p>\n","excerpt":"<p>公司项目需要实现语音搜索，正好记录一下这个iOS10新出的API。</p>\n<pre><code>iOS10是一个变化比价大的版本，开放了很多接口，这样也更方便开发者自定义各种功能。本文主要讲解一下新增的Speech框架，有了这个框架，我们想要为自己的app增加语音识别功能，不要依赖第三方的服务，几十行代码就可以轻松搞定。demo地址在文章末尾。\n</code></pre><h3 id=\"一：基本配置\"><a href=\"#一：基本配置\" class=\"headerlink\" title=\"一：基本配置\"></a>一：基本配置</h3><ul>\n<li>Xcode8，iOS10系统真机</li>\n<li>导入头文件：OC <code>#import&lt;Speech/Speech.h&gt;</code>   swift <code>import Speech</code></li>\n<li>配置info.plist文件:配置两个权限，语音识别和麦克风</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;</div><div class=\"line\">    &lt;string&gt;Your microphone will be used to record your speech when you press the &quot;Start Recording&quot; button.&lt;/string&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;key&gt;NSSpeechRecognitionUsageDescription&lt;/key&gt;</div><div class=\"line\">    &lt;string&gt;Speech recognition will be used to determine which words you speak into this device&apos;s microphone.&lt;/string&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"二：用到的几个类\"><a href=\"#二：用到的几个类\" class=\"headerlink\" title=\"二：用到的几个类\"></a>二：用到的几个类</h3><p><code>AVAudioEngine</code>                           语音引擎，负责提供语音输入<br><code>SFSpeechAudioBufferRecognitionRequest</code>   处理语音识别请求<br><code>SFSpeechRecognizer</code>                       语音识别器<br><code>SFSpeechRecognitionTask</code>                 输出语音识别对象的结果<br><code>NSLocale</code>                                语言类型<br>语音识别一共就用到了这几个类，整体的流程也容易理解，语音识别器通过语音引擎，处理语音识别请求，把结果交给<code>SFSpeechRecognitionTask</code>处理，最后输出文字。<br><code>SFSpeechRecognizer</code> 自身有几个代理方法，实际上，如果只是将语音转化成文字，是不需要这几个代理方法的。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">//当开始检测音频源中的语音时首先调用此方法</div><div class=\"line\">-(void)speechRecognitionDidDetectSpeech:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">  </div><div class=\"line\">&#125;</div><div class=\"line\">//当识别出一条可用的信息后 会调用</div><div class=\"line\">/*需要注意，apple的语音识别服务会根据提供的音频源识别出多个可能的结果 每有一条结果可用 都会调用此方法 */</div><div class=\"line\">-(void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didHypothesizeTranscription:(SFTranscription *)transcription</div><div class=\"line\">&#123;</div><div class=\"line\">   </div><div class=\"line\">&#125;</div><div class=\"line\">//当识别完成所有可用的结果后调用</div><div class=\"line\">- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishRecognition:(SFSpeechRecognitionResult *)recognitionResult</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//当不再接受音频输入时调用 即开始处理语音识别任务时调用</div><div class=\"line\">- (void)speechRecognitionTaskFinishedReadingAudio:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//当语音识别任务被取消时调用</div><div class=\"line\">- (void)speechRecognitionTaskWasCancelled:(SFSpeechRecognitionTask *)task</div><div class=\"line\">&#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\">//语音识别任务完成时被调用</div><div class=\"line\">- (void)speechRecognitionTask:(SFSpeechRecognitionTask *)task didFinishSuccessfully:(BOOL)successfully</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"三：重点代码\"><a href=\"#三：重点代码\" class=\"headerlink\" title=\"三：重点代码\"></a>三：重点代码</h3><p>有两点需要注意：</p>\n<ul>\n<li>语音识别会很耗电以及会使用很多数据</li>\n<li>语音识别一次只持续大概一分钟的时间</li>\n</ul>\n<p>我先定义了这几个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) AVAudioEngine         *audioEngine;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechRecognizer    *speechRecognizer;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechAudioBufferRecognitionRequest     *recognitionRequest;</div><div class=\"line\">@property (nonatomic, strong) SFSpeechRecognitionTask   *recognitionTask;</div><div class=\"line\">@property (nonatomic, strong) NSLocale                  *locale;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>语音权限的判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">[SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) &#123;</div><div class=\"line\">        BOOL isAuthorized = NO;</div><div class=\"line\">       switch (status) &#123;</div><div class=\"line\">                //结果未知 用户尚未进行选择</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusNotDetermined:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //用户拒绝授权语音识别</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusDenied:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //设备不支持语音识别功能</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusRestricted:</div><div class=\"line\">                isAuthorized = NO;</div><div class=\"line\">                break;</div><div class=\"line\">                //用户授权语音识别</div><div class=\"line\">            case SFSpeechRecognizerAuthorizationStatusAuthorized:</div><div class=\"line\">                isAuthorized = YES;</div><div class=\"line\">                </div><div class=\"line\">                break;</div><div class=\"line\">                </div><div class=\"line\">            default:</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if (callback) &#123;</div><div class=\"line\">            callback(isAuthorized, status);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n</li>\n<li><p>将语音引擎得到的语音数据添加到语音识别的请求中，这个过程也就是开始录音后的流程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">AVAudioFormat *recordingFormat = [[self.audioEngine inputNode] outputFormatForBus:0];</div><div class=\"line\">    [[self.audioEngine inputNode] installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) &#123;</div><div class=\"line\">        [self.recognitionRequest appendAudioPCMBuffer:buffer];</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>SFSpeechRecognitionTask</code> 把上一过程中得到的语音请求转化成文字，这个过程是试试进行的。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.recognitionTask = [self.speechRecognizer recognitionTaskWithRequest:self.recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123;</div><div class=\"line\">        BOOL isFinal = NO;</div><div class=\"line\">        NSString *bestResult = [[result bestTranscription] formattedString];</div><div class=\"line\">        isFinal = result.isFinal;</div><div class=\"line\">        if (error || isFinal) &#123;</div><div class=\"line\">            [self endTask];</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeFail:)]) &#123;</div><div class=\"line\">                [self.delegate recognizeFail:error];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(recognizeSuccess:)]) &#123;</div><div class=\"line\">                [self.delegate recognizeSuccess:bestResult];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;];</div></pre></td></tr></table></figure>\n<h3 id=\"四：提取录音文件中的文字\"><a href=\"#四：提取录音文件中的文字\" class=\"headerlink\" title=\"四：提取录音文件中的文字\"></a>四：提取录音文件中的文字</h3><ol>\n<li>也需要先获取用户的授权，授权代码与上面一致。</li>\n<li>对文件的处理相对较为简单<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化一个识别器</div><div class=\"line\">SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc] initWithLocale:[NSLocale localeWithLocaleIdentifier:@&quot;zh_CN&quot;]];</div><div class=\"line\">//初始化mp3的url</div><div class=\"line\">NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;test.mp3&quot; withExtension:nil];</div><div class=\"line\">//初始化一个识别的请求</div><div class=\"line\">SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url];</div><div class=\"line\">//发起请求</div><div class=\"line\">[recognizer recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) &#123;</div><div class=\"line\">    if(error != nil)</div><div class=\"line\">    &#123;</div><div class=\"line\">        NSLog(@&quot;识别错误:%@&quot;,error);</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSString *resultString = result.bestTranscription.formattedString;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,resultString);</div><div class=\"line\">    </div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><a href=\"https://github.com/suifengqjn/IOS10Speech\">github地址：https://github.com/suifengqjn/IOS10Speech</a></p>"},{"title":"Xcode多工程联编及工程依赖","date":"2016-03-12T15:47:36.000Z","_content":"\n\n在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。\n\n### 一:target\n\ntarget指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。\n\ntarget会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。\n\n若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。\n\n<!-- more -->\n\n### 二:project\n\nxcode project是存储构建一个或多个软件产品所需的所有文件，资源和信息的仓库。\nproject包含构建product所需的所有要素并维护它们之间的关系，它包含一个或多个targets(target指定了构建product的方式)。\nproject定义了所有target的默认build settings，各target可以重载。Xcode project文件包含如下信息：源文件的引用：源代码（包括头文件和实现文件），library和framework(xcode内部或者外部),资源文件，interface builder文件文件结构列表中组织源文件的Groupsproject级别的build选项targetsdebug或测试program的可执行环境：从xcode运行或调试时启动哪些可以执行文件，传给可执行文件的命令行参数，程序运行时设置的环境变量总之，project可以单独存在也可以包含在workspace中，同时可以在Scheme中指定哪个Target、build配置、哪个可执行配置在某个时刻是有效的。\n\n### 三:build settings\n\n一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。\n\n### 四:workspace\n\nworkspace 是组织projects和其他协同工作的文档的一份文档。除此之外，它还维护project和target之间的显性及隐性的依赖关系。默认workspace中的所有Xcode projects都在同一个目录下构建，称为workspace build directory，由于所有project的所有文件都在同一个目录下，所以所有文件都对每个project可见。\n比如两个project使用同一个库，则不用复制到另一个project目录中。workspace中的每个project都有其独立id,同时project可以属于多个workspace，可以单独打开project或者在其他workspace中打开，且都不用重新配置project或者workspace。\n可以使用workspace默认的build 目录，也可以指定一个。如果project指定了构建目录，这个目录会被project构建时所在的workspace的build目录覆盖。\n\n### 五:xcode schemexcode \n\nscheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。\n\n一般的某个应用单独新建一个 project 就可以了，然后把所有的程序文件都放在里面，这个可以满足大部分普通的需求，但是有时候，项目有可能要使用其他的项目文件，或者引入其他的静态库文件，这个时候 workspace 就派上用场了，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，如果不用 workspace，以前的做法是如果用到其他项目的文件，要手动 copy 文件到当前的项目，在 workspace 里这个步骤不需要了。\n\n### 六:案例\n\n下面是我自己的例子 ，现在用 workspace 管理2个 project，其中一个是 static library: MyStaticLib，另外一个是依赖这个静态库的 project:  MyUseStatic，菜单 xocde7 > file > New Workspace 新建一个空的workspace，名字可以随便取。\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/1.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/2.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/3.png)\n\n在左边 project navigator 右键菜单 New Project ,然后选择 Ios > Framework & Library > Cocoa Touch Static Library , 然后输入项目名称 MyStaticLib，这样就新建了一个空白的静态库项目，接着新建个类文件，名字为 MyLib, 选中 MyLib.h头文件，打开右边的 File inspector 窗口，在 Target membership 中将 MyStaticLib 后面的 project改成 public 。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/4.png)\n\n在左边的 project navigator 右键菜单 New Project ,然后选择 Ios > Application > Single View Application，然后输入项目名称 MyUseStatic，下面配置让它依赖 MyStaticLib，打开 Build Phases配置选项 然后展开 Link Binary With Libraries ，点击 + 会看到 Workspace > libMyStaticLib.a ，选中它，就让此项目产生了对 MyStaticLib的依赖关系，然后在 Build S Setting配置选项里 搜索 USER_HEADER_SEARCH_PATHS，将它的值设为 MyStaticLib 的build prouect 路径，在import静态库中的新文件时，会到这个路径中寻找。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/6.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/7.png)\n现在编译  MyUseStatic 会自动先编译依赖的 MyStaticLib。\n\n参考文章：http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory\n\n[!更多文章可前往我的blog：http://gcblog.github.io](http://gcblog.github.io)\n\n\n\n\n\n\n","source":"_posts/Xcode多工程联编及工程依赖.md","raw":"---\ntitle: Xcode多工程联编及工程依赖\ntags:\n  - iOS\n  - workspace\ncategories:\n  - iOS配置\ndate: 2016-03-12 23:47:36\n---\n\n\n在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。\n\n### 一:target\n\ntarget指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。\n\ntarget会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。\n\n若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。\n\n<!-- more -->\n\n### 二:project\n\nxcode project是存储构建一个或多个软件产品所需的所有文件，资源和信息的仓库。\nproject包含构建product所需的所有要素并维护它们之间的关系，它包含一个或多个targets(target指定了构建product的方式)。\nproject定义了所有target的默认build settings，各target可以重载。Xcode project文件包含如下信息：源文件的引用：源代码（包括头文件和实现文件），library和framework(xcode内部或者外部),资源文件，interface builder文件文件结构列表中组织源文件的Groupsproject级别的build选项targetsdebug或测试program的可执行环境：从xcode运行或调试时启动哪些可以执行文件，传给可执行文件的命令行参数，程序运行时设置的环境变量总之，project可以单独存在也可以包含在workspace中，同时可以在Scheme中指定哪个Target、build配置、哪个可执行配置在某个时刻是有效的。\n\n### 三:build settings\n\n一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。\n\n### 四:workspace\n\nworkspace 是组织projects和其他协同工作的文档的一份文档。除此之外，它还维护project和target之间的显性及隐性的依赖关系。默认workspace中的所有Xcode projects都在同一个目录下构建，称为workspace build directory，由于所有project的所有文件都在同一个目录下，所以所有文件都对每个project可见。\n比如两个project使用同一个库，则不用复制到另一个project目录中。workspace中的每个project都有其独立id,同时project可以属于多个workspace，可以单独打开project或者在其他workspace中打开，且都不用重新配置project或者workspace。\n可以使用workspace默认的build 目录，也可以指定一个。如果project指定了构建目录，这个目录会被project构建时所在的workspace的build目录覆盖。\n\n### 五:xcode schemexcode \n\nscheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。\n\n一般的某个应用单独新建一个 project 就可以了，然后把所有的程序文件都放在里面，这个可以满足大部分普通的需求，但是有时候，项目有可能要使用其他的项目文件，或者引入其他的静态库文件，这个时候 workspace 就派上用场了，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，如果不用 workspace，以前的做法是如果用到其他项目的文件，要手动 copy 文件到当前的项目，在 workspace 里这个步骤不需要了。\n\n### 六:案例\n\n下面是我自己的例子 ，现在用 workspace 管理2个 project，其中一个是 static library: MyStaticLib，另外一个是依赖这个静态库的 project:  MyUseStatic，菜单 xocde7 > file > New Workspace 新建一个空的workspace，名字可以随便取。\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/1.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/2.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/3.png)\n\n在左边 project navigator 右键菜单 New Project ,然后选择 Ios > Framework & Library > Cocoa Touch Static Library , 然后输入项目名称 MyStaticLib，这样就新建了一个空白的静态库项目，接着新建个类文件，名字为 MyLib, 选中 MyLib.h头文件，打开右边的 File inspector 窗口，在 Target membership 中将 MyStaticLib 后面的 project改成 public 。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/4.png)\n\n在左边的 project navigator 右键菜单 New Project ,然后选择 Ios > Application > Single View Application，然后输入项目名称 MyUseStatic，下面配置让它依赖 MyStaticLib，打开 Build Phases配置选项 然后展开 Link Binary With Libraries ，点击 + 会看到 Workspace > libMyStaticLib.a ，选中它，就让此项目产生了对 MyStaticLib的依赖关系，然后在 Build S Setting配置选项里 搜索 USER_HEADER_SEARCH_PATHS，将它的值设为 MyStaticLib 的build prouect 路径，在import静态库中的新文件时，会到这个路径中寻找。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/6.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/7.png)\n现在编译  MyUseStatic 会自动先编译依赖的 MyStaticLib。\n\n参考文章：http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory\n\n[!更多文章可前往我的blog：http://gcblog.github.io](http://gcblog.github.io)\n\n\n\n\n\n\n","slug":"Xcode多工程联编及工程依赖","published":1,"updated":"2016-11-17T14:26:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmeg0001co604hq2f6sa","content":"<p>在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。</p>\n<h3 id=\"一-target\"><a href=\"#一-target\" class=\"headerlink\" title=\"一:target\"></a>一:target</h3><p>target指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。</p>\n<p>target会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。</p>\n<p>若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。</p>\n<a id=\"more\"></a>\n<h3 id=\"二-project\"><a href=\"#二-project\" class=\"headerlink\" title=\"二:project\"></a>二:project</h3><p>xcode project是存储构建一个或多个软件产品所需的所有文件，资源和信息的仓库。<br>project包含构建product所需的所有要素并维护它们之间的关系，它包含一个或多个targets(target指定了构建product的方式)。<br>project定义了所有target的默认build settings，各target可以重载。Xcode project文件包含如下信息：源文件的引用：源代码（包括头文件和实现文件），library和framework(xcode内部或者外部),资源文件，interface builder文件文件结构列表中组织源文件的Groupsproject级别的build选项targetsdebug或测试program的可执行环境：从xcode运行或调试时启动哪些可以执行文件，传给可执行文件的命令行参数，程序运行时设置的环境变量总之，project可以单独存在也可以包含在workspace中，同时可以在Scheme中指定哪个Target、build配置、哪个可执行配置在某个时刻是有效的。</p>\n<h3 id=\"三-build-settings\"><a href=\"#三-build-settings\" class=\"headerlink\" title=\"三:build settings\"></a>三:build settings</h3><p>一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。</p>\n<h3 id=\"四-workspace\"><a href=\"#四-workspace\" class=\"headerlink\" title=\"四:workspace\"></a>四:workspace</h3><p>workspace 是组织projects和其他协同工作的文档的一份文档。除此之外，它还维护project和target之间的显性及隐性的依赖关系。默认workspace中的所有Xcode projects都在同一个目录下构建，称为workspace build directory，由于所有project的所有文件都在同一个目录下，所以所有文件都对每个project可见。<br>比如两个project使用同一个库，则不用复制到另一个project目录中。workspace中的每个project都有其独立id,同时project可以属于多个workspace，可以单独打开project或者在其他workspace中打开，且都不用重新配置project或者workspace。<br>可以使用workspace默认的build 目录，也可以指定一个。如果project指定了构建目录，这个目录会被project构建时所在的workspace的build目录覆盖。</p>\n<h3 id=\"五-xcode-schemexcode\"><a href=\"#五-xcode-schemexcode\" class=\"headerlink\" title=\"五:xcode schemexcode\"></a>五:xcode schemexcode</h3><p>scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。</p>\n<p>一般的某个应用单独新建一个 project 就可以了，然后把所有的程序文件都放在里面，这个可以满足大部分普通的需求，但是有时候，项目有可能要使用其他的项目文件，或者引入其他的静态库文件，这个时候 workspace 就派上用场了，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，如果不用 workspace，以前的做法是如果用到其他项目的文件，要手动 copy 文件到当前的项目，在 workspace 里这个步骤不需要了。</p>\n<h3 id=\"六-案例\"><a href=\"#六-案例\" class=\"headerlink\" title=\"六:案例\"></a>六:案例</h3><p>下面是我自己的例子 ，现在用 workspace 管理2个 project，其中一个是 static library: MyStaticLib，另外一个是依赖这个静态库的 project:  MyUseStatic，菜单 xocde7 &gt; file &gt; New Workspace 新建一个空的workspace，名字可以随便取。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/1.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/2.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/3.png\" alt=\"image\"></p>\n<p>在左边 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Framework &amp; Library &gt; Cocoa Touch Static Library , 然后输入项目名称 MyStaticLib，这样就新建了一个空白的静态库项目，接着新建个类文件，名字为 MyLib, 选中 MyLib.h头文件，打开右边的 File inspector 窗口，在 Target membership 中将 MyStaticLib 后面的 project改成 public 。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/4.png\" alt=\"image\"></p>\n<p>在左边的 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Application &gt; Single View Application，然后输入项目名称 MyUseStatic，下面配置让它依赖 MyStaticLib，打开 Build Phases配置选项 然后展开 Link Binary With Libraries ，点击 + 会看到 Workspace &gt; libMyStaticLib.a ，选中它，就让此项目产生了对 MyStaticLib的依赖关系，然后在 Build S Setting配置选项里 搜索 USER_HEADER_SEARCH_PATHS，将它的值设为 MyStaticLib 的build prouect 路径，在import静态库中的新文件时，会到这个路径中寻找。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/6.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/7.png\" alt=\"image\"><br>现在编译  MyUseStatic 会自动先编译依赖的 MyStaticLib。</p>\n<p>参考文章：<a href=\"http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory\" target=\"_blank\" rel=\"external\">http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory</a></p>\n<p><a href=\"http://gcblog.github.io\" target=\"_blank\" rel=\"external\">!更多文章可前往我的blog：http://gcblog.github.io</a></p>\n","excerpt":"<p>在了解xcode构建原则之前，需要熟悉workspace相关的概念，即workspace,project和target。</p>\n<h3 id=\"一-target\"><a href=\"#一-target\" class=\"headerlink\" title=\"一:target\"></a>一:target</h3><p>target指定了构建的product,包含将workspace或project中的一组文件构建成product的指令。单个target定义一个product,它将输入（源文件和处理这些源文件的指令（包含所设定的构建settings和phases））组织进构建系统中。project和target是一对多的关系。</p>\n<p>target会继承project的build settings，但可以以target为粒度设置build settings,且Xcode中当前一次只会有一个有效target,此有效target在xcode scheme中标识。</p>\n<p>若target A依赖target B的输出来构建，则A依赖B，当它们存在于一个xcode workspace中的时候，Xcode会发现此依赖关系并按顺序构建。这种依赖称为隐性依赖，当然也可以在build settings中声明显性依赖，也可将隐性依赖的两个target显性声明为没有依赖。比如可能在同一个workspace中同时构建一个库并构建一个依赖这个库的应用，则xcode会选择先构建库。但如果应用想链接库的某个特定版本，则可以显性声明这个依赖关系，此时隐性依赖即被覆盖了。</p>","more":"<h3 id=\"二-project\"><a href=\"#二-project\" class=\"headerlink\" title=\"二:project\"></a>二:project</h3><p>xcode project是存储构建一个或多个软件产品所需的所有文件，资源和信息的仓库。<br>project包含构建product所需的所有要素并维护它们之间的关系，它包含一个或多个targets(target指定了构建product的方式)。<br>project定义了所有target的默认build settings，各target可以重载。Xcode project文件包含如下信息：源文件的引用：源代码（包括头文件和实现文件），library和framework(xcode内部或者外部),资源文件，interface builder文件文件结构列表中组织源文件的Groupsproject级别的build选项targetsdebug或测试program的可执行环境：从xcode运行或调试时启动哪些可以执行文件，传给可执行文件的命令行参数，程序运行时设置的环境变量总之，project可以单独存在也可以包含在workspace中，同时可以在Scheme中指定哪个Target、build配置、哪个可执行配置在某个时刻是有效的。</p>\n<h3 id=\"三-build-settings\"><a href=\"#三-build-settings\" class=\"headerlink\" title=\"三:build settings\"></a>三:build settings</h3><p>一个build setting是一个指示产品某个方面构建方式的变量，比如决定xcode传给编译器的参数选项是怎样。其是一个常量或者一个公式供给xcode在构建的时候计算build setting。</p>\n<h3 id=\"四-workspace\"><a href=\"#四-workspace\" class=\"headerlink\" title=\"四:workspace\"></a>四:workspace</h3><p>workspace 是组织projects和其他协同工作的文档的一份文档。除此之外，它还维护project和target之间的显性及隐性的依赖关系。默认workspace中的所有Xcode projects都在同一个目录下构建，称为workspace build directory，由于所有project的所有文件都在同一个目录下，所以所有文件都对每个project可见。<br>比如两个project使用同一个库，则不用复制到另一个project目录中。workspace中的每个project都有其独立id,同时project可以属于多个workspace，可以单独打开project或者在其他workspace中打开，且都不用重新配置project或者workspace。<br>可以使用workspace默认的build 目录，也可以指定一个。如果project指定了构建目录，这个目录会被project构建时所在的workspace的build目录覆盖。</p>\n<h3 id=\"五-xcode-schemexcode\"><a href=\"#五-xcode-schemexcode\" class=\"headerlink\" title=\"五:xcode schemexcode\"></a>五:xcode schemexcode</h3><p>scheme定义了一系列构建的targets，构建时的配置，和一系列执行的测试。可以有很多scheme,但同一时刻只能有一个有效的。选择scheme时，意味着你也选择了一个运行目标（product构建的硬件平台)。可以指定scheme是否存储在project中，以便包含此project的所有workspace都可以使用些scheme,当然也可以指定只存储在某个workspace中。</p>\n<p>一般的某个应用单独新建一个 project 就可以了，然后把所有的程序文件都放在里面，这个可以满足大部分普通的需求，但是有时候，项目有可能要使用其他的项目文件，或者引入其他的静态库文件，这个时候 workspace 就派上用场了，workspace 即可以单独管理多个项目，又可以通过配置，让各个项目相互依赖，如果不用 workspace，以前的做法是如果用到其他项目的文件，要手动 copy 文件到当前的项目，在 workspace 里这个步骤不需要了。</p>\n<h3 id=\"六-案例\"><a href=\"#六-案例\" class=\"headerlink\" title=\"六:案例\"></a>六:案例</h3><p>下面是我自己的例子 ，现在用 workspace 管理2个 project，其中一个是 static library: MyStaticLib，另外一个是依赖这个静态库的 project:  MyUseStatic，菜单 xocde7 &gt; file &gt; New Workspace 新建一个空的workspace，名字可以随便取。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/1.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/2.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/3.png\" alt=\"image\"></p>\n<p>在左边 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Framework &amp; Library &gt; Cocoa Touch Static Library , 然后输入项目名称 MyStaticLib，这样就新建了一个空白的静态库项目，接着新建个类文件，名字为 MyLib, 选中 MyLib.h头文件，打开右边的 File inspector 窗口，在 Target membership 中将 MyStaticLib 后面的 project改成 public 。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/4.png\" alt=\"image\"></p>\n<p>在左边的 project navigator 右键菜单 New Project ,然后选择 Ios &gt; Application &gt; Single View Application，然后输入项目名称 MyUseStatic，下面配置让它依赖 MyStaticLib，打开 Build Phases配置选项 然后展开 Link Binary With Libraries ，点击 + 会看到 Workspace &gt; libMyStaticLib.a ，选中它，就让此项目产生了对 MyStaticLib的依赖关系，然后在 Build S Setting配置选项里 搜索 USER_HEADER_SEARCH_PATHS，将它的值设为 MyStaticLib 的build prouect 路径，在import静态库中的新文件时，会到这个路径中寻找。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/6.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/XcodeWorkSpace/7.png\" alt=\"image\"><br>现在编译  MyUseStatic 会自动先编译依赖的 MyStaticLib。</p>\n<p>参考文章：<a href=\"http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory\">http://blog.carbonfive.com/2011/04/04/using-open-source-static-libraries-in-xcode-4/#set_the_installation_directory</a></p>\n<p><a href=\"http://gcblog.github.io\">!更多文章可前往我的blog：http://gcblog.github.io</a></p>"},{"title":"使用GitHub搭建Hexo博客","date":"2016-02-23T10:29:00.000Z","description":"来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。","_content":"\n来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。\n国内也有不多少的代码托管平台，本文将就用GitHub的GitHub Pages 功能来搭建，比起WordPress，hexo的搭建更加简洁，配合上markdown的使用，更加便捷的管理自己的学习文档。\n\n<!--more-->\n\n# 概况\n>1. 为什么选择[GitHub Pages](1)\n1、[GitHub Pages](1)有免费的代码托管空间，资料自己管理，保存可靠；\n2、学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多；\n3、顺便理解 GitHub 工作原理，最好的团队协作流程；\n4、GitHub建立私有仓库才会收费，所以会有很多开源代码。\n>2. [GitHub Pages](1)是什么\n应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的\"Initialize this repository with a README\" 。\n>3. [hexo](2)出自何人\nhexo出自台湾大学生 tommy351 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。\n\n# 安装准备\n>环境搭建：\n1. [Node.js](http://nodejs.org/)：下载[地址](https://nodejs.org/en/)\n2. [Git](http://git-scm.com/)：下载[地址](https://git-scm.com/download/win)\n3. [Sublime](http://www.sublimetext.com/)：下载[地址](http://www.sublimetext.com/2)\n## 安装Node \n到 Node.js 官网下载相应平台的 最新版本 ，一路安装即可。我用的是 node-v0.10.22-x86.msi\n## 安装Git \nGit的客户端很多，我用的是 msysgit ，喜欢用绿色版本 Portable application for official Git for Windows 1.8.4 ，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。\n## 安装Sublime\nSublime Text 2 在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的 Sublime Text 3 。\n\n\n# GitHub注册与配置\n\n>1. 注册：\n访问：[GitHub](0)，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。注册过程比较简单，详细也可以看：\n使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考[官方文档](https://pages.github.com/)\n\n>1. 配置和使用Github\n以下教程主要参考beiyuu的[《使用Github Pages建独立博客》](http://beiyuu.com/github-pages/)写成。\n\n>1. 配置SSH keys\n我们如何让本地git项目与远程的github建立联系呢？用SSH keys。\n打开Git Bash工具，执行以下操作\n\n>1. 检查SSH keys的设置\n\n```\n    首先我们需要检查你电脑上现有的ssh key：\n\n$ cd ~/. ssh 检查本机的ssh密钥\n\n    如果提示：No such file or directory 说明你是第一次使用git。\n\n    生成新的SSH Key：\n\n$ ssh-keygen -t rsa -C \"邮件地址@youremail.com\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key \n(/Users/your_user_directory/.ssh/id_rsa):<回车就好>\n```\n注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；\n注意2: 此处的「-C」的是大写的「C」\n\n    然后系统会要你输入密码：\nEnter passphrase (empty for no passphrase):<输入加密串>\nEnter same passphrase again:<再次输入加密串>\n\n在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。\n\n注意：输入密码的时候没有*字样的，你直接输入就可以了。\n\n最后看到这样的界面，就成功设置ssh key了：\n```\n\n```\n\n>5. 添加SSH Key到GitHub\n在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。\n>1. 打开本地C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。\n>2. 登陆github系统。点击右上角的 Account Settings--->SSH Public keys ---> add another public keys\n>3. 把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了\n\n>6. 测试\n\n```\n    可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：\n\n$ ssh -T git@github.com\n\n    如果是下面的反馈：\n\nThe authenticity of host 'github.com (207.97.227.239)' can't be established.\nRSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\nAre you sure you want to continue connecting (yes/no)?\n\n    不要紧张，输入yes就好，然后会看到：\n\nHi cnfeat! You've successfully authenticated, \nbut GitHub does not provide shell access.\n\n\n\n    设置用户信息：\n    现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。\n    Git会根据用户的名字和邮箱来记录提交。\n    GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。\n\n$ git config --global user.name \"cnfeat\"//用户名\n$ git config --global user.email \"cnfeat@gmail.com\"//填写自己的邮箱\n\n    SSH Key配置成功，本机已成功连接到github。\n\n```\n# Hexo博客\n\n>Hexo\nHexo的作者是[tommy351](https://github.com/tommy351/hexo)，根据[官方介绍](http://hexo.io/docs/index.html)，Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。hexo的主题列表 [Hexo Themes](http://github.com/tommy351/hexo/wiki/Themes)。 我比较喜欢 [pacman](http://github.com/A-limon/pacman) ， [modernist](http://github.com/heroicyang/hexo-theme-modernist) 、 [ishgo](http://github.com/DavidKk/Hexo.ishgo) ， [raytaylorism](http://github.com/raytaylorlin/hexo-theme-raytaylorism) 。 \n\n\n\n## 安装Hexo\n\n打开Git Bash工具（前提确保Node.js已经安装，环境配置OK）\n\n    $ npm install -g hexo\n\n>注释：\n\n执行命令：npm install -g hexo，报错如下：\n\n```\nnpm ERR! Error: shasum check failed for C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\npm\n-30024-KDJHJzgP\\registry.npmjs.org\\hexo-cli\\-\\hexo-cli-0.1.6.tgz\nnpm ERR! Expected: 7dc3ab939d0889c4bed6a961605ff3e2d67f67a2\nnpm ERR! Actual:   41de7d67a9b764352eb07c49c32fc38dd7f479b9\nnpm ERR! From:     https://registry.npmjs.org/hexo-cli/-/hexo-cli-0.1.6.tgz\nnpm ERR!     at d:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\sha\\index.\njs:38:8\nnpm ERR!     at ReadStream.<anonymous> (d:\\Program Files\\nodejs\\node_modules\\npm\n\\node_modules\\sha\\index.js:85:7)\nnpm ERR!     at ReadStream.emit (events.js:117:20)\nnpm ERR!     at _stream_readable.js:943:16\nnpm ERR!     at process._tickCallback (node.js:419:13)\nnpm ERR! If you need help, you may report this *entire* log,\nnpm ERR! including the npm and node versions, at:\nnpm ERR!     <http://github.com/npm/npm/issues>\n\nnpm ERR! System Windows_NT 6.2.9200\nnpm ERR! command \"d:\\\\Program Files\\\\nodejs\\\\node.exe\" \"d:\\\\Program Files\\\\nodej\ns\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\" \"install\" \"-g\" \"hexo\"\nnpm ERR! cwd C:\\Users\\Administrator\\Desktop\nnpm ERR! node -v v0.10.31\nnpm ERR! npm -v 1.4.23\nnpm ERR! registry error parsing json\nnpm ERR!\nnpm ERR! Additional logging details can be found in:\nnpm ERR!     C:\\Users\\Administrator\\Desktop\\npm-debug.log\nnpm ERR! not ok code 0\n\n    莫非是因为被墙了？换国内镜像源试试。\nnpm config set registry=\"http://registry.cnpmjs.org\"，\n    然后再次执行npm install -g hexo，成功！\n```\n\n## 部署Hexo\n\n```\n    在我的电脑中建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash。\n\n$ hexo init\n\n    如果无法使用右击“Git Bash”，则可以切换到指定目录\n\n    UUhike@UUhike-pc MINGW64 ~\n$ cd j:/github/hexo\n    UUhike@UUhike-pc MINGW64 /j/github/hexo\n\n    安装依赖包\n$ npm install\n\n    Hexo随后会自动在目标文件夹建立网站所需要的所有文件。\n    现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000看看。\n\n    本地查看\n\n$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）\n\n$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n```\n## 部署到GitHub\n\n```\n\n编辑E:\\hexo下的_config.yml，修改Deployment部分：\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n    repository: https://github.com/luuman/luuman.github.io.git\n    branch: master\n```\n>注释：\n\nhexo d，执行该命令，报错：\n\n```\nERROR Deployer not found: git\n\n执行命令：\nnpm install hexo-deployer-git --save\n再次执行hexo d,报错：\n\nINFO  Deploying: git\nINFO  Clearing .deploy folder...\nINFO  Copying files from public folder...\nwarning: LF will be replaced by CRLF in 2015/05/30/hello-world/index.html.\nThe file will have its original line endings in your working directory.\n......\n*** Please tell me who you are.\n\nRun\n\n  git config --global user.email \"you@example.com\"\n  git config --global user.name \"Your Name\"\n\nto set your account's default identity.\nOmit --global to set the identity only in this repository.\n\nfatal: unable to auto-detect email address (got 'Administrator@PC-201505290750.(none)')\nUsername for 'https://github.com': voidking\nPassword for 'https://voidking@github.com':\nerror: src refspec master does not match any.\nerror: failed to push some refs to 'https://github.com/voidking/voidking.github.io.git'\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: error: src refspec master does not match any.\nerror: failed to push some refs to 'https://github.com/voidking/voidking.github.io.git'\n\n    at ChildProcess.<anonymous> (E:\\hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:42:17)\n    at ChildProcess.emit (events.js:98:17)\n    at maybeClose (child_process.js:756:16)\n    at Process.ChildProcess._handle.onexit (child_process.js:823:5)\n```\nhexo d，执行该命令，报错：\n## 复制cnfeat的主题\n\n以下进入复制主题环节，如果那一步出现问题，或者修改后没有显示修改的结果，建议来来一个，再看看，可以解决很多问题。\n\n```\n    $ hexo clean\n\n    $ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）\n\n    $ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\n    建立了Hexo文件，复制我的主题了到themes文件夹中\n    yilia\n    $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n    modernist\n    $ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist\n    jacman\n    $ git clone https://github.com/cnfeat/cnfeat.git themes/jacman\n```\n\n\n## 启用cnfeat的主题\n\n修改Hexo目录下的config.yml配置文件中的theme属性，将其设置为jacman。同时请设置stylus属性中的compress值为true。\ntheme: jacman\n\n注意：Hexo有两个config.yml文件，一个在根目录，一个在theme下，此时修改的是在根目录下的。\n\n    更新主题\n\n    $ cd themes/jacman\n    $ git pull\n\n注意：为避免出错，请先备份你的_config.yml 文件后再升级\n本地查看调试\n\n```\n    $ hexo g #生成\n    $ hexo s #启动本地服务，进行文章预览调试\n\n    或者直接作用组合命令\n\n    $ hexo deploy -g\n    $ hexo server -g\n\n    简写：\n\n    hexo n == hexo new\n    hexo g == hexo generate\n    hexo s == hexo server\n    hexo d == hexo deploy\n```\n>4、浏览器中查看效果\n\n浏览器输入[http://localhost:4000](http://localhost:4000) ，查看搭建效果。此后的每次变更_config.yml文件或者上传文件都可以先用此命令调试，非常好用，尤其是当你想调试出自己想要的主题时。\n\n#进阶篇：Hexo设置\n\n网站搭建完成后，就可以根据自己爱好来对Hexo生成的网站进行设置了，对整站的设置，只要修改项目目录的hexo/_config.yml就可以了，这是我的设置，可供参考。\n\n>默认目录结构：\n\n```\n    .\n    ├── .deploy\n    ├── public\n    ├── scaffolds\n    ├── scripts\n    ├── source\n    |   ├── _drafts\n    |   └── _posts\n    ├── themes\n    ├── _config.yml\n    └── package.json\n```\n>hexo/_config.yml\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site #整站的基本信息\ntitle: 1000 words a Day #网站标题\nsubtitle: Writing 1000 Words a Day Changes My Life #网站副标题\ndescription: 学习总结 思考感悟 知识管理 #网站描述\nauthor:  cnFeat #网站作者，在下方显示\nemail: cnFeat@gmail.com #联系邮箱\nlanguage: zh-CN #主题实际的文件名称\ntimezone:\n\n# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing 文章布局、写作格式的定义，不修改\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format 日期格式，不修改\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination 每页显示文章数，可以自定义，我将10改成了5\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n\n# Disqus Disqus插件，我们会替换成“多说”，不修改\ndisqus_shortname:\n\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: spfk\n\n\n# 自动生成sitemap\nsitemap:\npath: sitemap.xml\nbaidusitemap:\npath: baidusitemap.xml\n\n\n# Deployment 站点部署到github要配置，上一节中已经讲过\n## Docs: http://zespia.tw/hexo/docs/deploy.html\ndeploy:\n  type: git\n  repository: git@github.com:luuman/luuman.github.io.git\n  branch: master\n```\n\n修改局部页面\n\n页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\主题名称\\中：\n>hexo\\themes\\\n\n```\n├── languages  #多语言\n|   ├── default.yml#默认语言\n|   └── zh-CN.yml  #中文语言\n├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制\n|   ├── _partial   #局部的布局，此目录下的*.ejs是对头尾等局部的控制\n|   └── _widget#小挂件的布局，页面下方小挂件的控制\n├── source #源码\n|   ├── css#css源码 \n|   |   ├── _base  #*.styl基础css\n|   |   ├── _partial   #*.styl局部css\n|   |   ├── fonts  #字体\n|   |   ├── images #图片\n|   |   └── style.styl #*.styl引入需要的css源码\n|   ├── fancybox   #fancybox效果源码\n|   └── js #javascript源代码\n├── _config.yml#主题配置文件\n└── README.md  #用GitHub的都知道\n```\n\n主题文档的配置\n>hexo\\themes/_config.yml\n\n```\n# Header\nmenu:\n  主页: /\n  所有文章: /archives\n  # 随笔: /tags/随笔\n\n# SubNav\nsubnav:\n  github: \"#\"\n  weibo: \"#\"\n  rss: \"#\"\n  zhihu: \"#\"\n  #douban: \"#\"\n  #mail: \"#\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\nrss: /atom.xml\n\n# Content\nexcerpt_link: more\nfancybox: true\nmathjax: true\n\n# Miscellaneous\ngoogle_analytics: ''\nfavicon: /favicon.png\n\n#你的头像url\navatar: \"\"\n#是否开启分享\nshare: true\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: true\n#是否开启云标签\ntagcloud: true\n\n#是否开启友情链接\n#不开启——\n#friends: false\n#开启——\nfriends:\n  奥巴马的博客: http://localhost:4000/\n  卡卡的美丽传说: http://localhost:4000/\n  本泽马的博客: http://localhost:4000/\n  吉格斯的博客: http://localhost:4000/\n  习大大大不同: http://localhost:4000/\n  托蒂的博客: http://localhost:4000/\n\n#是否开启“关于我”。\n#不开启——\n#aboutme: false\n#开启——\naboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n```\n\n# 参考资料：\n[hexo你的博客](http://ibruce.info/2013/11/22/hexo-your-blog/)\n[如何搭建一个独立博客——简明Github Pages与Hexo教程](http://www.jianshu.com/p/05289a4bc8b2#)\n[Hexo的使用介绍](http://luuman.github.io/2015/12/25/Hexo/)\n[Hexo插件安装](http://luuman.github.io/2015/12/27/Hexo-plug/)\n\n[0]: https://github.com/ \"GitHub\"\n[1]: https://pages.github.com/ \"GitHub Pages\"\n[2]: http://zespia.tw/hexo/ \"hexo\"\n\n","source":"_posts/GitHub+Hexo.md","raw":"title: 使用GitHub搭建Hexo博客\ndate: 2016-02-23 18:29:00\ndescription: 来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。\ntags: [github, hexo]\ncategories: \n- 随笔\n---\n\n来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。\n国内也有不多少的代码托管平台，本文将就用GitHub的GitHub Pages 功能来搭建，比起WordPress，hexo的搭建更加简洁，配合上markdown的使用，更加便捷的管理自己的学习文档。\n\n<!--more-->\n\n# 概况\n>1. 为什么选择[GitHub Pages](1)\n1、[GitHub Pages](1)有免费的代码托管空间，资料自己管理，保存可靠；\n2、学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多；\n3、顺便理解 GitHub 工作原理，最好的团队协作流程；\n4、GitHub建立私有仓库才会收费，所以会有很多开源代码。\n>2. [GitHub Pages](1)是什么\n应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的\"Initialize this repository with a README\" 。\n>3. [hexo](2)出自何人\nhexo出自台湾大学生 tommy351 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。\n\n# 安装准备\n>环境搭建：\n1. [Node.js](http://nodejs.org/)：下载[地址](https://nodejs.org/en/)\n2. [Git](http://git-scm.com/)：下载[地址](https://git-scm.com/download/win)\n3. [Sublime](http://www.sublimetext.com/)：下载[地址](http://www.sublimetext.com/2)\n## 安装Node \n到 Node.js 官网下载相应平台的 最新版本 ，一路安装即可。我用的是 node-v0.10.22-x86.msi\n## 安装Git \nGit的客户端很多，我用的是 msysgit ，喜欢用绿色版本 Portable application for official Git for Windows 1.8.4 ，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。\n## 安装Sublime\nSublime Text 2 在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的 Sublime Text 3 。\n\n\n# GitHub注册与配置\n\n>1. 注册：\n访问：[GitHub](0)，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。注册过程比较简单，详细也可以看：\n使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考[官方文档](https://pages.github.com/)\n\n>1. 配置和使用Github\n以下教程主要参考beiyuu的[《使用Github Pages建独立博客》](http://beiyuu.com/github-pages/)写成。\n\n>1. 配置SSH keys\n我们如何让本地git项目与远程的github建立联系呢？用SSH keys。\n打开Git Bash工具，执行以下操作\n\n>1. 检查SSH keys的设置\n\n```\n    首先我们需要检查你电脑上现有的ssh key：\n\n$ cd ~/. ssh 检查本机的ssh密钥\n\n    如果提示：No such file or directory 说明你是第一次使用git。\n\n    生成新的SSH Key：\n\n$ ssh-keygen -t rsa -C \"邮件地址@youremail.com\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key \n(/Users/your_user_directory/.ssh/id_rsa):<回车就好>\n```\n注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；\n注意2: 此处的「-C」的是大写的「C」\n\n    然后系统会要你输入密码：\nEnter passphrase (empty for no passphrase):<输入加密串>\nEnter same passphrase again:<再次输入加密串>\n\n在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。\n\n注意：输入密码的时候没有*字样的，你直接输入就可以了。\n\n最后看到这样的界面，就成功设置ssh key了：\n```\n\n```\n\n>5. 添加SSH Key到GitHub\n在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。\n>1. 打开本地C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。\n>2. 登陆github系统。点击右上角的 Account Settings--->SSH Public keys ---> add another public keys\n>3. 把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了\n\n>6. 测试\n\n```\n    可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：\n\n$ ssh -T git@github.com\n\n    如果是下面的反馈：\n\nThe authenticity of host 'github.com (207.97.227.239)' can't be established.\nRSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\nAre you sure you want to continue connecting (yes/no)?\n\n    不要紧张，输入yes就好，然后会看到：\n\nHi cnfeat! You've successfully authenticated, \nbut GitHub does not provide shell access.\n\n\n\n    设置用户信息：\n    现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。\n    Git会根据用户的名字和邮箱来记录提交。\n    GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。\n\n$ git config --global user.name \"cnfeat\"//用户名\n$ git config --global user.email \"cnfeat@gmail.com\"//填写自己的邮箱\n\n    SSH Key配置成功，本机已成功连接到github。\n\n```\n# Hexo博客\n\n>Hexo\nHexo的作者是[tommy351](https://github.com/tommy351/hexo)，根据[官方介绍](http://hexo.io/docs/index.html)，Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。hexo的主题列表 [Hexo Themes](http://github.com/tommy351/hexo/wiki/Themes)。 我比较喜欢 [pacman](http://github.com/A-limon/pacman) ， [modernist](http://github.com/heroicyang/hexo-theme-modernist) 、 [ishgo](http://github.com/DavidKk/Hexo.ishgo) ， [raytaylorism](http://github.com/raytaylorlin/hexo-theme-raytaylorism) 。 \n\n\n\n## 安装Hexo\n\n打开Git Bash工具（前提确保Node.js已经安装，环境配置OK）\n\n    $ npm install -g hexo\n\n>注释：\n\n执行命令：npm install -g hexo，报错如下：\n\n```\nnpm ERR! Error: shasum check failed for C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\npm\n-30024-KDJHJzgP\\registry.npmjs.org\\hexo-cli\\-\\hexo-cli-0.1.6.tgz\nnpm ERR! Expected: 7dc3ab939d0889c4bed6a961605ff3e2d67f67a2\nnpm ERR! Actual:   41de7d67a9b764352eb07c49c32fc38dd7f479b9\nnpm ERR! From:     https://registry.npmjs.org/hexo-cli/-/hexo-cli-0.1.6.tgz\nnpm ERR!     at d:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\sha\\index.\njs:38:8\nnpm ERR!     at ReadStream.<anonymous> (d:\\Program Files\\nodejs\\node_modules\\npm\n\\node_modules\\sha\\index.js:85:7)\nnpm ERR!     at ReadStream.emit (events.js:117:20)\nnpm ERR!     at _stream_readable.js:943:16\nnpm ERR!     at process._tickCallback (node.js:419:13)\nnpm ERR! If you need help, you may report this *entire* log,\nnpm ERR! including the npm and node versions, at:\nnpm ERR!     <http://github.com/npm/npm/issues>\n\nnpm ERR! System Windows_NT 6.2.9200\nnpm ERR! command \"d:\\\\Program Files\\\\nodejs\\\\node.exe\" \"d:\\\\Program Files\\\\nodej\ns\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js\" \"install\" \"-g\" \"hexo\"\nnpm ERR! cwd C:\\Users\\Administrator\\Desktop\nnpm ERR! node -v v0.10.31\nnpm ERR! npm -v 1.4.23\nnpm ERR! registry error parsing json\nnpm ERR!\nnpm ERR! Additional logging details can be found in:\nnpm ERR!     C:\\Users\\Administrator\\Desktop\\npm-debug.log\nnpm ERR! not ok code 0\n\n    莫非是因为被墙了？换国内镜像源试试。\nnpm config set registry=\"http://registry.cnpmjs.org\"，\n    然后再次执行npm install -g hexo，成功！\n```\n\n## 部署Hexo\n\n```\n    在我的电脑中建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash。\n\n$ hexo init\n\n    如果无法使用右击“Git Bash”，则可以切换到指定目录\n\n    UUhike@UUhike-pc MINGW64 ~\n$ cd j:/github/hexo\n    UUhike@UUhike-pc MINGW64 /j/github/hexo\n\n    安装依赖包\n$ npm install\n\n    Hexo随后会自动在目标文件夹建立网站所需要的所有文件。\n    现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000看看。\n\n    本地查看\n\n$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）\n\n$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n```\n## 部署到GitHub\n\n```\n\n编辑E:\\hexo下的_config.yml，修改Deployment部分：\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n    repository: https://github.com/luuman/luuman.github.io.git\n    branch: master\n```\n>注释：\n\nhexo d，执行该命令，报错：\n\n```\nERROR Deployer not found: git\n\n执行命令：\nnpm install hexo-deployer-git --save\n再次执行hexo d,报错：\n\nINFO  Deploying: git\nINFO  Clearing .deploy folder...\nINFO  Copying files from public folder...\nwarning: LF will be replaced by CRLF in 2015/05/30/hello-world/index.html.\nThe file will have its original line endings in your working directory.\n......\n*** Please tell me who you are.\n\nRun\n\n  git config --global user.email \"you@example.com\"\n  git config --global user.name \"Your Name\"\n\nto set your account's default identity.\nOmit --global to set the identity only in this repository.\n\nfatal: unable to auto-detect email address (got 'Administrator@PC-201505290750.(none)')\nUsername for 'https://github.com': voidking\nPassword for 'https://voidking@github.com':\nerror: src refspec master does not match any.\nerror: failed to push some refs to 'https://github.com/voidking/voidking.github.io.git'\nFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html\nError: error: src refspec master does not match any.\nerror: failed to push some refs to 'https://github.com/voidking/voidking.github.io.git'\n\n    at ChildProcess.<anonymous> (E:\\hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:42:17)\n    at ChildProcess.emit (events.js:98:17)\n    at maybeClose (child_process.js:756:16)\n    at Process.ChildProcess._handle.onexit (child_process.js:823:5)\n```\nhexo d，执行该命令，报错：\n## 复制cnfeat的主题\n\n以下进入复制主题环节，如果那一步出现问题，或者修改后没有显示修改的结果，建议来来一个，再看看，可以解决很多问题。\n\n```\n    $ hexo clean\n\n    $ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）\n\n    $ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\n    建立了Hexo文件，复制我的主题了到themes文件夹中\n    yilia\n    $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n    modernist\n    $ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist\n    jacman\n    $ git clone https://github.com/cnfeat/cnfeat.git themes/jacman\n```\n\n\n## 启用cnfeat的主题\n\n修改Hexo目录下的config.yml配置文件中的theme属性，将其设置为jacman。同时请设置stylus属性中的compress值为true。\ntheme: jacman\n\n注意：Hexo有两个config.yml文件，一个在根目录，一个在theme下，此时修改的是在根目录下的。\n\n    更新主题\n\n    $ cd themes/jacman\n    $ git pull\n\n注意：为避免出错，请先备份你的_config.yml 文件后再升级\n本地查看调试\n\n```\n    $ hexo g #生成\n    $ hexo s #启动本地服务，进行文章预览调试\n\n    或者直接作用组合命令\n\n    $ hexo deploy -g\n    $ hexo server -g\n\n    简写：\n\n    hexo n == hexo new\n    hexo g == hexo generate\n    hexo s == hexo server\n    hexo d == hexo deploy\n```\n>4、浏览器中查看效果\n\n浏览器输入[http://localhost:4000](http://localhost:4000) ，查看搭建效果。此后的每次变更_config.yml文件或者上传文件都可以先用此命令调试，非常好用，尤其是当你想调试出自己想要的主题时。\n\n#进阶篇：Hexo设置\n\n网站搭建完成后，就可以根据自己爱好来对Hexo生成的网站进行设置了，对整站的设置，只要修改项目目录的hexo/_config.yml就可以了，这是我的设置，可供参考。\n\n>默认目录结构：\n\n```\n    .\n    ├── .deploy\n    ├── public\n    ├── scaffolds\n    ├── scripts\n    ├── source\n    |   ├── _drafts\n    |   └── _posts\n    ├── themes\n    ├── _config.yml\n    └── package.json\n```\n>hexo/_config.yml\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site #整站的基本信息\ntitle: 1000 words a Day #网站标题\nsubtitle: Writing 1000 Words a Day Changes My Life #网站副标题\ndescription: 学习总结 思考感悟 知识管理 #网站描述\nauthor:  cnFeat #网站作者，在下方显示\nemail: cnFeat@gmail.com #联系邮箱\nlanguage: zh-CN #主题实际的文件名称\ntimezone:\n\n# URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: http://yoursite.com\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing 文章布局、写作格式的定义，不修改\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date / Time format 日期格式，不修改\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination 每页显示文章数，可以自定义，我将10改成了5\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n\n# Disqus Disqus插件，我们会替换成“多说”，不修改\ndisqus_shortname:\n\n# Extensions\n## Plugins: http://hexo.io/plugins/\n## Themes: http://hexo.io/themes/\ntheme: spfk\n\n\n# 自动生成sitemap\nsitemap:\npath: sitemap.xml\nbaidusitemap:\npath: baidusitemap.xml\n\n\n# Deployment 站点部署到github要配置，上一节中已经讲过\n## Docs: http://zespia.tw/hexo/docs/deploy.html\ndeploy:\n  type: git\n  repository: git@github.com:luuman/luuman.github.io.git\n  branch: master\n```\n\n修改局部页面\n\n页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\主题名称\\中：\n>hexo\\themes\\\n\n```\n├── languages  #多语言\n|   ├── default.yml#默认语言\n|   └── zh-CN.yml  #中文语言\n├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制\n|   ├── _partial   #局部的布局，此目录下的*.ejs是对头尾等局部的控制\n|   └── _widget#小挂件的布局，页面下方小挂件的控制\n├── source #源码\n|   ├── css#css源码 \n|   |   ├── _base  #*.styl基础css\n|   |   ├── _partial   #*.styl局部css\n|   |   ├── fonts  #字体\n|   |   ├── images #图片\n|   |   └── style.styl #*.styl引入需要的css源码\n|   ├── fancybox   #fancybox效果源码\n|   └── js #javascript源代码\n├── _config.yml#主题配置文件\n└── README.md  #用GitHub的都知道\n```\n\n主题文档的配置\n>hexo\\themes/_config.yml\n\n```\n# Header\nmenu:\n  主页: /\n  所有文章: /archives\n  # 随笔: /tags/随笔\n\n# SubNav\nsubnav:\n  github: \"#\"\n  weibo: \"#\"\n  rss: \"#\"\n  zhihu: \"#\"\n  #douban: \"#\"\n  #mail: \"#\"\n  #facebook: \"#\"\n  #google: \"#\"\n  #twitter: \"#\"\n  #linkedin: \"#\"\n\nrss: /atom.xml\n\n# Content\nexcerpt_link: more\nfancybox: true\nmathjax: true\n\n# Miscellaneous\ngoogle_analytics: ''\nfavicon: /favicon.png\n\n#你的头像url\navatar: \"\"\n#是否开启分享\nshare: true\n#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）\n#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论\nduoshuo: true\n#是否开启云标签\ntagcloud: true\n\n#是否开启友情链接\n#不开启——\n#friends: false\n#开启——\nfriends:\n  奥巴马的博客: http://localhost:4000/\n  卡卡的美丽传说: http://localhost:4000/\n  本泽马的博客: http://localhost:4000/\n  吉格斯的博客: http://localhost:4000/\n  习大大大不同: http://localhost:4000/\n  托蒂的博客: http://localhost:4000/\n\n#是否开启“关于我”。\n#不开启——\n#aboutme: false\n#开启——\naboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…\n```\n\n# 参考资料：\n[hexo你的博客](http://ibruce.info/2013/11/22/hexo-your-blog/)\n[如何搭建一个独立博客——简明Github Pages与Hexo教程](http://www.jianshu.com/p/05289a4bc8b2#)\n[Hexo的使用介绍](http://luuman.github.io/2015/12/25/Hexo/)\n[Hexo插件安装](http://luuman.github.io/2015/12/27/Hexo-plug/)\n\n[0]: https://github.com/ \"GitHub\"\n[1]: https://pages.github.com/ \"GitHub Pages\"\n[2]: http://zespia.tw/hexo/ \"hexo\"\n\n","slug":"GitHub+Hexo","published":1,"updated":"2016-11-16T15:05:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmes0004co60nzt3rahs","content":"<p>来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。<br>国内也有不多少的代码托管平台，本文将就用GitHub的GitHub Pages 功能来搭建，比起WordPress，hexo的搭建更加简洁，配合上markdown的使用，更加便捷的管理自己的学习文档。</p>\n<a id=\"more\"></a>\n<h1 id=\"概况\"><a href=\"#概况\" class=\"headerlink\" title=\"概况\"></a>概况</h1><blockquote>\n<ol>\n<li>为什么选择<a href=\"1\">GitHub Pages</a><br>1、<a href=\"1\">GitHub Pages</a>有免费的代码托管空间，资料自己管理，保存可靠；<br>2、学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多；<br>3、顺便理解 GitHub 工作原理，最好的团队协作流程；<br>4、GitHub建立私有仓库才会收费，所以会有很多开源代码。</li>\n<li><a href=\"1\">GitHub Pages</a>是什么<br>应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README” 。</li>\n<li><a href=\"2\">hexo</a>出自何人<br>hexo出自台湾大学生 tommy351 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。</li>\n</ol>\n</blockquote>\n<h1 id=\"安装准备\"><a href=\"#安装准备\" class=\"headerlink\" title=\"安装准备\"></a>安装准备</h1><blockquote>\n<p>环境搭建：</p>\n<ol>\n<li><a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"external\">Node.js</a>：下载<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">地址</a></li>\n<li><a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"external\">Git</a>：下载<a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"external\">地址</a></li>\n<li><a href=\"http://www.sublimetext.com/\" target=\"_blank\" rel=\"external\">Sublime</a>：下载<a href=\"http://www.sublimetext.com/2\" target=\"_blank\" rel=\"external\">地址</a><h2 id=\"安装Node\"><a href=\"#安装Node\" class=\"headerlink\" title=\"安装Node\"></a>安装Node</h2>到 Node.js 官网下载相应平台的 最新版本 ，一路安装即可。我用的是 node-v0.10.22-x86.msi<h2 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h2>Git的客户端很多，我用的是 msysgit ，喜欢用绿色版本 Portable application for official Git for Windows 1.8.4 ，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。<h2 id=\"安装Sublime\"><a href=\"#安装Sublime\" class=\"headerlink\" title=\"安装Sublime\"></a>安装Sublime</h2>Sublime Text 2 在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的 Sublime Text 3 。</li>\n</ol>\n</blockquote>\n<h1 id=\"GitHub注册与配置\"><a href=\"#GitHub注册与配置\" class=\"headerlink\" title=\"GitHub注册与配置\"></a>GitHub注册与配置</h1><blockquote>\n<ol>\n<li><p>注册：<br>访问：<a href=\"0\">GitHub</a>，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。注册过程比较简单，详细也可以看：<br>使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考<a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">官方文档</a></p>\n</li>\n<li><p>配置和使用Github<br>以下教程主要参考beiyuu的<a href=\"http://beiyuu.com/github-pages/\" target=\"_blank\" rel=\"external\">《使用Github Pages建独立博客》</a>写成。</p>\n</li>\n<li><p>配置SSH keys<br>我们如何让本地git项目与远程的github建立联系呢？用SSH keys。<br>打开Git Bash工具，执行以下操作</p>\n</li>\n<li><p>检查SSH keys的设置</p>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">    首先我们需要检查你电脑上现有的ssh key：</div><div class=\"line\"></div><div class=\"line\">$ cd ~/. ssh 检查本机的ssh密钥</div><div class=\"line\"></div><div class=\"line\">    如果提示：No such file or directory 说明你是第一次使用git。</div><div class=\"line\"></div><div class=\"line\">    生成新的SSH Key：</div><div class=\"line\"></div><div class=\"line\">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</div><div class=\"line\">Generating public/private rsa key pair.</div><div class=\"line\">Enter file in which to save the key </div><div class=\"line\">(/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</div></pre></td></tr></table></figure>\n<p>注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；<br>注意2: 此处的「-C」的是大写的「C」</p>\n<pre><code>然后系统会要你输入密码：\n</code></pre><p>Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;<br>Enter same passphrase again:&lt;再次输入加密串&gt;</p>\n<p>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p>\n<p>注意：输入密码的时候没有*字样的，你直接输入就可以了。</p>\n<p>最后看到这样的界面，就成功设置ssh key了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<blockquote>\n<ol>\n<li>添加SSH Key到GitHub<br>在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。</li>\n<li>打开本地C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。</li>\n<li>登陆github系统。点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys</li>\n<li><p>把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了</p>\n</li>\n<li><p>测试</p>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">    可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：</div><div class=\"line\"></div><div class=\"line\">$ ssh -T git@github.com</div><div class=\"line\"></div><div class=\"line\">    如果是下面的反馈：</div><div class=\"line\"></div><div class=\"line\">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div><div class=\"line\"></div><div class=\"line\">    不要紧张，输入yes就好，然后会看到：</div><div class=\"line\"></div><div class=\"line\">Hi cnfeat! You&apos;ve successfully authenticated, </div><div class=\"line\">but GitHub does not provide shell access.</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    设置用户信息：</div><div class=\"line\">    现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。</div><div class=\"line\">    Git会根据用户的名字和邮箱来记录提交。</div><div class=\"line\">    GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。</div><div class=\"line\"></div><div class=\"line\">$ git config --global user.name &quot;cnfeat&quot;//用户名</div><div class=\"line\">$ git config --global user.email &quot;cnfeat@gmail.com&quot;//填写自己的邮箱</div><div class=\"line\"></div><div class=\"line\">    SSH Key配置成功，本机已成功连接到github。</div></pre></td></tr></table></figure>\n<h1 id=\"Hexo博客\"><a href=\"#Hexo博客\" class=\"headerlink\" title=\"Hexo博客\"></a>Hexo博客</h1><blockquote>\n<p>Hexo<br>Hexo的作者是<a href=\"https://github.com/tommy351/hexo\" target=\"_blank\" rel=\"external\">tommy351</a>，根据<a href=\"http://hexo.io/docs/index.html\" target=\"_blank\" rel=\"external\">官方介绍</a>，Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。hexo的主题列表 <a href=\"http://github.com/tommy351/hexo/wiki/Themes\" target=\"_blank\" rel=\"external\">Hexo Themes</a>。 我比较喜欢 <a href=\"http://github.com/A-limon/pacman\" target=\"_blank\" rel=\"external\">pacman</a> ， <a href=\"http://github.com/heroicyang/hexo-theme-modernist\" target=\"_blank\" rel=\"external\">modernist</a> 、 <a href=\"http://github.com/DavidKk/Hexo.ishgo\" target=\"_blank\" rel=\"external\">ishgo</a> ， <a href=\"http://github.com/raytaylorlin/hexo-theme-raytaylorism\" target=\"_blank\" rel=\"external\">raytaylorism</a> 。 </p>\n</blockquote>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>打开Git Bash工具（前提确保Node.js已经安装，环境配置OK）</p>\n<pre><code>$ npm install -g hexo\n</code></pre><blockquote>\n<p>注释：</p>\n</blockquote>\n<p>执行命令：npm install -g hexo，报错如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm ERR! Error: shasum check failed for C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\npm</div><div class=\"line\">-30024-KDJHJzgP\\registry.npmjs.org\\hexo-cli\\-\\hexo-cli-0.1.6.tgz</div><div class=\"line\">npm ERR! Expected: 7dc3ab939d0889c4bed6a961605ff3e2d67f67a2</div><div class=\"line\">npm ERR! Actual:   41de7d67a9b764352eb07c49c32fc38dd7f479b9</div><div class=\"line\">npm ERR! From:     https://registry.npmjs.org/hexo-cli/-/hexo-cli-0.1.6.tgz</div><div class=\"line\">npm ERR!     at d:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\sha\\index.</div><div class=\"line\">js:38:8</div><div class=\"line\">npm ERR!     at ReadStream.&lt;anonymous&gt; (d:\\Program Files\\nodejs\\node_modules\\npm</div><div class=\"line\">\\node_modules\\sha\\index.js:85:7)</div><div class=\"line\">npm ERR!     at ReadStream.emit (events.js:117:20)</div><div class=\"line\">npm ERR!     at _stream_readable.js:943:16</div><div class=\"line\">npm ERR!     at process._tickCallback (node.js:419:13)</div><div class=\"line\">npm ERR! If you need help, you may report this *entire* log,</div><div class=\"line\">npm ERR! including the npm and node versions, at:</div><div class=\"line\">npm ERR!     &lt;http://github.com/npm/npm/issues&gt;</div><div class=\"line\"></div><div class=\"line\">npm ERR! System Windows_NT 6.2.9200</div><div class=\"line\">npm ERR! command &quot;d:\\\\Program Files\\\\nodejs\\\\node.exe&quot; &quot;d:\\\\Program Files\\\\nodej</div><div class=\"line\">s\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js&quot; &quot;install&quot; &quot;-g&quot; &quot;hexo&quot;</div><div class=\"line\">npm ERR! cwd C:\\Users\\Administrator\\Desktop</div><div class=\"line\">npm ERR! node -v v0.10.31</div><div class=\"line\">npm ERR! npm -v 1.4.23</div><div class=\"line\">npm ERR! registry error parsing json</div><div class=\"line\">npm ERR!</div><div class=\"line\">npm ERR! Additional logging details can be found in:</div><div class=\"line\">npm ERR!     C:\\Users\\Administrator\\Desktop\\npm-debug.log</div><div class=\"line\">npm ERR! not ok code 0</div><div class=\"line\"></div><div class=\"line\">    莫非是因为被墙了？换国内镜像源试试。</div><div class=\"line\">npm config set registry=&quot;http://registry.cnpmjs.org&quot;，</div><div class=\"line\">    然后再次执行npm install -g hexo，成功！</div></pre></td></tr></table></figure>\n<h2 id=\"部署Hexo\"><a href=\"#部署Hexo\" class=\"headerlink\" title=\"部署Hexo\"></a>部署Hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">    在我的电脑中建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash。</div><div class=\"line\"></div><div class=\"line\">$ hexo init</div><div class=\"line\"></div><div class=\"line\">    如果无法使用右击“Git Bash”，则可以切换到指定目录</div><div class=\"line\"></div><div class=\"line\">    UUhike@UUhike-pc MINGW64 ~</div><div class=\"line\">$ cd j:/github/hexo</div><div class=\"line\">    UUhike@UUhike-pc MINGW64 /j/github/hexo</div><div class=\"line\"></div><div class=\"line\">    安装依赖包</div><div class=\"line\">$ npm install</div><div class=\"line\"></div><div class=\"line\">    Hexo随后会自动在目标文件夹建立网站所需要的所有文件。</div><div class=\"line\">    现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000看看。</div><div class=\"line\"></div><div class=\"line\">    本地查看</div><div class=\"line\"></div><div class=\"line\">$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）</div><div class=\"line\"></div><div class=\"line\">$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div></pre></td></tr></table></figure>\n<h2 id=\"部署到GitHub\"><a href=\"#部署到GitHub\" class=\"headerlink\" title=\"部署到GitHub\"></a>部署到GitHub</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">编辑E:\\hexo下的_config.yml，修改Deployment部分：</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: http://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">    repository: https://github.com/luuman/luuman.github.io.git</div><div class=\"line\">    branch: master</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注释：</p>\n</blockquote>\n<p>hexo d，执行该命令，报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR Deployer not found: git</div><div class=\"line\"></div><div class=\"line\">执行命令：</div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\">再次执行hexo d,报错：</div><div class=\"line\"></div><div class=\"line\">INFO  Deploying: git</div><div class=\"line\">INFO  Clearing .deploy folder...</div><div class=\"line\">INFO  Copying files from public folder...</div><div class=\"line\">warning: LF will be replaced by CRLF in 2015/05/30/hello-world/index.html.</div><div class=\"line\">The file will have its original line endings in your working directory.</div><div class=\"line\">......</div><div class=\"line\">*** Please tell me who you are.</div><div class=\"line\"></div><div class=\"line\">Run</div><div class=\"line\"></div><div class=\"line\">  git config --global user.email &quot;you@example.com&quot;</div><div class=\"line\">  git config --global user.name &quot;Your Name&quot;</div><div class=\"line\"></div><div class=\"line\">to set your account&apos;s default identity.</div><div class=\"line\">Omit --global to set the identity only in this repository.</div><div class=\"line\"></div><div class=\"line\">fatal: unable to auto-detect email address (got &apos;Administrator@PC-201505290750.(none)&apos;)</div><div class=\"line\">Username for &apos;https://github.com&apos;: voidking</div><div class=\"line\">Password for &apos;https://voidking@github.com&apos;:</div><div class=\"line\">error: src refspec master does not match any.</div><div class=\"line\">error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos;</div><div class=\"line\">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</div><div class=\"line\">Error: error: src refspec master does not match any.</div><div class=\"line\">error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos;</div><div class=\"line\"></div><div class=\"line\">    at ChildProcess.&lt;anonymous&gt; (E:\\hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:42:17)</div><div class=\"line\">    at ChildProcess.emit (events.js:98:17)</div><div class=\"line\">    at maybeClose (child_process.js:756:16)</div><div class=\"line\">    at Process.ChildProcess._handle.onexit (child_process.js:823:5)</div></pre></td></tr></table></figure>\n<p>hexo d，执行该命令，报错：</p>\n<h2 id=\"复制cnfeat的主题\"><a href=\"#复制cnfeat的主题\" class=\"headerlink\" title=\"复制cnfeat的主题\"></a>复制cnfeat的主题</h2><p>以下进入复制主题环节，如果那一步出现问题，或者修改后没有显示修改的结果，建议来来一个，再看看，可以解决很多问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo clean</div><div class=\"line\"></div><div class=\"line\">$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）</div><div class=\"line\"></div><div class=\"line\">$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div><div class=\"line\"></div><div class=\"line\">建立了Hexo文件，复制我的主题了到themes文件夹中</div><div class=\"line\">yilia</div><div class=\"line\">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</div><div class=\"line\">modernist</div><div class=\"line\">$ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist</div><div class=\"line\">jacman</div><div class=\"line\">$ git clone https://github.com/cnfeat/cnfeat.git themes/jacman</div></pre></td></tr></table></figure>\n<h2 id=\"启用cnfeat的主题\"><a href=\"#启用cnfeat的主题\" class=\"headerlink\" title=\"启用cnfeat的主题\"></a>启用cnfeat的主题</h2><p>修改Hexo目录下的config.yml配置文件中的theme属性，将其设置为jacman。同时请设置stylus属性中的compress值为true。<br>theme: jacman</p>\n<p>注意：Hexo有两个config.yml文件，一个在根目录，一个在theme下，此时修改的是在根目录下的。</p>\n<pre><code>更新主题\n\n$ cd themes/jacman\n$ git pull\n</code></pre><p>注意：为避免出错，请先备份你的_config.yml 文件后再升级<br>本地查看调试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g #生成</div><div class=\"line\">$ hexo s #启动本地服务，进行文章预览调试</div><div class=\"line\"></div><div class=\"line\">或者直接作用组合命令</div><div class=\"line\"></div><div class=\"line\">$ hexo deploy -g</div><div class=\"line\">$ hexo server -g</div><div class=\"line\"></div><div class=\"line\">简写：</div><div class=\"line\"></div><div class=\"line\">hexo n == hexo new</div><div class=\"line\">hexo g == hexo generate</div><div class=\"line\">hexo s == hexo server</div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure>\n<blockquote>\n<p>4、浏览器中查看效果</p>\n</blockquote>\n<p>浏览器输入<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> ，查看搭建效果。此后的每次变更_config.yml文件或者上传文件都可以先用此命令调试，非常好用，尤其是当你想调试出自己想要的主题时。</p>\n<p>#进阶篇：Hexo设置</p>\n<p>网站搭建完成后，就可以根据自己爱好来对Hexo生成的网站进行设置了，对整站的设置，只要修改项目目录的hexo/_config.yml就可以了，这是我的设置，可供参考。</p>\n<blockquote>\n<p>默认目录结构：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── .deploy</div><div class=\"line\">├── public</div><div class=\"line\">├── scaffolds</div><div class=\"line\">├── scripts</div><div class=\"line\">├── source</div><div class=\"line\">|   ├── _drafts</div><div class=\"line\">|   └── _posts</div><div class=\"line\">├── themes</div><div class=\"line\">├── _config.yml</div><div class=\"line\">└── package.json</div></pre></td></tr></table></figure>\n<blockquote>\n<p>hexo/_config.yml</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: http://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site #整站的基本信息</div><div class=\"line\">title: 1000 words a Day #网站标题</div><div class=\"line\">subtitle: Writing 1000 Words a Day Changes My Life #网站副标题</div><div class=\"line\">description: 学习总结 思考感悟 知识管理 #网站描述</div><div class=\"line\">author:  cnFeat #网站作者，在下方显示</div><div class=\"line\">email: cnFeat@gmail.com #联系邮箱</div><div class=\"line\">language: zh-CN #主题实际的文件名称</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项</div><div class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class=\"line\">url: http://yoursite.com</div><div class=\"line\">root: /</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"></div><div class=\"line\"># Directory</div><div class=\"line\">source_dir: source</div><div class=\"line\">public_dir: public</div><div class=\"line\">tag_dir: tags</div><div class=\"line\">archive_dir: archives</div><div class=\"line\">category_dir: categories</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">i18n_dir: :lang</div><div class=\"line\">skip_render:</div><div class=\"line\"></div><div class=\"line\"># Writing 文章布局、写作格式的定义，不修改</div><div class=\"line\">new_post_name: :title.md # File name of new posts</div><div class=\"line\">default_layout: post</div><div class=\"line\">titlecase: false # Transform title into titlecase</div><div class=\"line\">external_link: true # Open external links in new tab</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">future: true</div><div class=\"line\">highlight:</div><div class=\"line\">  enable: true</div><div class=\"line\">  line_number: true</div><div class=\"line\">  auto_detect: true</div><div class=\"line\">  tab_replace:</div><div class=\"line\"></div><div class=\"line\"># Category &amp; Tag</div><div class=\"line\">default_category: uncategorized</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"></div><div class=\"line\"># Date / Time format 日期格式，不修改</div><div class=\"line\">## Hexo uses Moment.js to parse and display date</div><div class=\"line\">## You can customize the date format as defined in</div><div class=\"line\">## http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">date_format: YYYY-MM-DD</div><div class=\"line\">time_format: HH:mm:ss</div><div class=\"line\"></div><div class=\"line\"># Pagination 每页显示文章数，可以自定义，我将10改成了5</div><div class=\"line\">## Set per_page to 0 to disable pagination</div><div class=\"line\">per_page: 5</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"></div><div class=\"line\"># Disqus Disqus插件，我们会替换成“多说”，不修改</div><div class=\"line\">disqus_shortname:</div><div class=\"line\"></div><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: http://hexo.io/plugins/</div><div class=\"line\">## Themes: http://hexo.io/themes/</div><div class=\"line\">theme: spfk</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># 自动生成sitemap</div><div class=\"line\">sitemap:</div><div class=\"line\">path: sitemap.xml</div><div class=\"line\">baidusitemap:</div><div class=\"line\">path: baidusitemap.xml</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># Deployment 站点部署到github要配置，上一节中已经讲过</div><div class=\"line\">## Docs: http://zespia.tw/hexo/docs/deploy.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:luuman/luuman.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>修改局部页面</p>\n<p>页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\主题名称\\中：</p>\n<blockquote>\n<p>hexo\\themes\\</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── languages  #多语言</div><div class=\"line\">|   ├── default.yml#默认语言</div><div class=\"line\">|   └── zh-CN.yml  #中文语言</div><div class=\"line\">├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制</div><div class=\"line\">|   ├── _partial   #局部的布局，此目录下的*.ejs是对头尾等局部的控制</div><div class=\"line\">|   └── _widget#小挂件的布局，页面下方小挂件的控制</div><div class=\"line\">├── source #源码</div><div class=\"line\">|   ├── css#css源码 </div><div class=\"line\">|   |   ├── _base  #*.styl基础css</div><div class=\"line\">|   |   ├── _partial   #*.styl局部css</div><div class=\"line\">|   |   ├── fonts  #字体</div><div class=\"line\">|   |   ├── images #图片</div><div class=\"line\">|   |   └── style.styl #*.styl引入需要的css源码</div><div class=\"line\">|   ├── fancybox   #fancybox效果源码</div><div class=\"line\">|   └── js #javascript源代码</div><div class=\"line\">├── _config.yml#主题配置文件</div><div class=\"line\">└── README.md  #用GitHub的都知道</div></pre></td></tr></table></figure>\n<p>主题文档的配置</p>\n<blockquote>\n<p>hexo\\themes/_config.yml</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Header</div><div class=\"line\">menu:</div><div class=\"line\">  主页: /</div><div class=\"line\">  所有文章: /archives</div><div class=\"line\">  # 随笔: /tags/随笔</div><div class=\"line\"></div><div class=\"line\"># SubNav</div><div class=\"line\">subnav:</div><div class=\"line\">  github: &quot;#&quot;</div><div class=\"line\">  weibo: &quot;#&quot;</div><div class=\"line\">  rss: &quot;#&quot;</div><div class=\"line\">  zhihu: &quot;#&quot;</div><div class=\"line\">  #douban: &quot;#&quot;</div><div class=\"line\">  #mail: &quot;#&quot;</div><div class=\"line\">  #facebook: &quot;#&quot;</div><div class=\"line\">  #google: &quot;#&quot;</div><div class=\"line\">  #twitter: &quot;#&quot;</div><div class=\"line\">  #linkedin: &quot;#&quot;</div><div class=\"line\"></div><div class=\"line\">rss: /atom.xml</div><div class=\"line\"></div><div class=\"line\"># Content</div><div class=\"line\">excerpt_link: more</div><div class=\"line\">fancybox: true</div><div class=\"line\">mathjax: true</div><div class=\"line\"></div><div class=\"line\"># Miscellaneous</div><div class=\"line\">google_analytics: &apos;&apos;</div><div class=\"line\">favicon: /favicon.png</div><div class=\"line\"></div><div class=\"line\">#你的头像url</div><div class=\"line\">avatar: &quot;&quot;</div><div class=\"line\">#是否开启分享</div><div class=\"line\">share: true</div><div class=\"line\">#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）</div><div class=\"line\">#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论</div><div class=\"line\">duoshuo: true</div><div class=\"line\">#是否开启云标签</div><div class=\"line\">tagcloud: true</div><div class=\"line\"></div><div class=\"line\">#是否开启友情链接</div><div class=\"line\">#不开启——</div><div class=\"line\">#friends: false</div><div class=\"line\">#开启——</div><div class=\"line\">friends:</div><div class=\"line\">  奥巴马的博客: http://localhost:4000/</div><div class=\"line\">  卡卡的美丽传说: http://localhost:4000/</div><div class=\"line\">  本泽马的博客: http://localhost:4000/</div><div class=\"line\">  吉格斯的博客: http://localhost:4000/</div><div class=\"line\">  习大大大不同: http://localhost:4000/</div><div class=\"line\">  托蒂的博客: http://localhost:4000/</div><div class=\"line\"></div><div class=\"line\">#是否开启“关于我”。</div><div class=\"line\">#不开启——</div><div class=\"line\">#aboutme: false</div><div class=\"line\">#开启——</div><div class=\"line\">aboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div></pre></td></tr></table></figure>\n<h1 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h1><p><a href=\"http://ibruce.info/2013/11/22/hexo-your-blog/\" target=\"_blank\" rel=\"external\">hexo你的博客</a><br><a href=\"http://www.jianshu.com/p/05289a4bc8b2#\" target=\"_blank\" rel=\"external\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br><a href=\"http://luuman.github.io/2015/12/25/Hexo/\" target=\"_blank\" rel=\"external\">Hexo的使用介绍</a><br><a href=\"http://luuman.github.io/2015/12/27/Hexo-plug/\" target=\"_blank\" rel=\"external\">Hexo插件安装</a></p>\n","excerpt":"<p>来到GitHub这么长时间，才开始真真的了解GitHub，这个国外的代码托管平台，充满着大牛的身影。<br>国内也有不多少的代码托管平台，本文将就用GitHub的GitHub Pages 功能来搭建，比起WordPress，hexo的搭建更加简洁，配合上markdown的使用，更加便捷的管理自己的学习文档。</p>","more":"<h1 id=\"概况\"><a href=\"#概况\" class=\"headerlink\" title=\"概况\"></a>概况</h1><blockquote>\n<ol>\n<li>为什么选择<a href=\"1\">GitHub Pages</a><br>1、<a href=\"1\">GitHub Pages</a>有免费的代码托管空间，资料自己管理，保存可靠；<br>2、学着用 GitHub，享受 GitHub 的便利，上面有很多大牛，眼界会开阔很多；<br>3、顺便理解 GitHub 工作原理，最好的团队协作流程；<br>4、GitHub建立私有仓库才会收费，所以会有很多开源代码。</li>\n<li><a href=\"1\">GitHub Pages</a>是什么<br>应用GitHub Pages创建属于自己的个人博客，GitHub将提供免费的空间。GitHub提供的域名（用户名+github+io）,在Repository name对应处填写资源名，其需要使用自己的用户名，每个用户名下面只能建立一个，并且资源命名必须符合这样的规则username/username.github.io，之后勾选下面的”Initialize this repository with a README” 。</li>\n<li><a href=\"2\">hexo</a>出自何人<br>hexo出自台湾大学生 tommy351 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。</li>\n</ol>\n</blockquote>\n<h1 id=\"安装准备\"><a href=\"#安装准备\" class=\"headerlink\" title=\"安装准备\"></a>安装准备</h1><blockquote>\n<p>环境搭建：</p>\n<ol>\n<li><a href=\"http://nodejs.org/\">Node.js</a>：下载<a href=\"https://nodejs.org/en/\">地址</a></li>\n<li><a href=\"http://git-scm.com/\">Git</a>：下载<a href=\"https://git-scm.com/download/win\">地址</a></li>\n<li><a href=\"http://www.sublimetext.com/\">Sublime</a>：下载<a href=\"http://www.sublimetext.com/2\">地址</a><h2 id=\"安装Node\"><a href=\"#安装Node\" class=\"headerlink\" title=\"安装Node\"></a>安装Node</h2>到 Node.js 官网下载相应平台的 最新版本 ，一路安装即可。我用的是 node-v0.10.22-x86.msi<h2 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h2>Git的客户端很多，我用的是 msysgit ，喜欢用绿色版本 Portable application for official Git for Windows 1.8.4 ，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。<h2 id=\"安装Sublime\"><a href=\"#安装Sublime\" class=\"headerlink\" title=\"安装Sublime\"></a>安装Sublime</h2>Sublime Text 2 在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的 Sublime Text 3 。</li>\n</ol>\n</blockquote>\n<h1 id=\"GitHub注册与配置\"><a href=\"#GitHub注册与配置\" class=\"headerlink\" title=\"GitHub注册与配置\"></a>GitHub注册与配置</h1><blockquote>\n<ol>\n<li><p>注册：<br>访问：<a href=\"0\">GitHub</a>，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。注册过程比较简单，详细也可以看：<br>使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考<a href=\"https://pages.github.com/\">官方文档</a></p>\n</li>\n<li><p>配置和使用Github<br>以下教程主要参考beiyuu的<a href=\"http://beiyuu.com/github-pages/\">《使用Github Pages建独立博客》</a>写成。</p>\n</li>\n<li><p>配置SSH keys<br>我们如何让本地git项目与远程的github建立联系呢？用SSH keys。<br>打开Git Bash工具，执行以下操作</p>\n</li>\n<li><p>检查SSH keys的设置</p>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">    首先我们需要检查你电脑上现有的ssh key：</div><div class=\"line\"></div><div class=\"line\">$ cd ~/. ssh 检查本机的ssh密钥</div><div class=\"line\"></div><div class=\"line\">    如果提示：No such file or directory 说明你是第一次使用git。</div><div class=\"line\"></div><div class=\"line\">    生成新的SSH Key：</div><div class=\"line\"></div><div class=\"line\">$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;</div><div class=\"line\">Generating public/private rsa key pair.</div><div class=\"line\">Enter file in which to save the key </div><div class=\"line\">(/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</div></pre></td></tr></table></figure>\n<p>注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；<br>注意2: 此处的「-C」的是大写的「C」</p>\n<pre><code>然后系统会要你输入密码：\n</code></pre><p>Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;<br>Enter same passphrase again:&lt;再次输入加密串&gt;</p>\n<p>在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。</p>\n<p>注意：输入密码的时候没有*字样的，你直接输入就可以了。</p>\n<p>最后看到这样的界面，就成功设置ssh key了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n<blockquote>\n<ol>\n<li>添加SSH Key到GitHub<br>在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。</li>\n<li>打开本地C:\\Documents and Settings\\Administrator.ssh\\id_rsa.pub文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。</li>\n<li>登陆github系统。点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys</li>\n<li><p>把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了</p>\n</li>\n<li><p>测试</p>\n</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">    可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：</div><div class=\"line\"></div><div class=\"line\">$ ssh -T git@github.com</div><div class=\"line\"></div><div class=\"line\">    如果是下面的反馈：</div><div class=\"line\"></div><div class=\"line\">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</div><div class=\"line\">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</div><div class=\"line\">Are you sure you want to continue connecting (yes/no)?</div><div class=\"line\"></div><div class=\"line\">    不要紧张，输入yes就好，然后会看到：</div><div class=\"line\"></div><div class=\"line\">Hi cnfeat! You&apos;ve successfully authenticated, </div><div class=\"line\">but GitHub does not provide shell access.</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    设置用户信息：</div><div class=\"line\">    现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。</div><div class=\"line\">    Git会根据用户的名字和邮箱来记录提交。</div><div class=\"line\">    GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。</div><div class=\"line\"></div><div class=\"line\">$ git config --global user.name &quot;cnfeat&quot;//用户名</div><div class=\"line\">$ git config --global user.email &quot;cnfeat@gmail.com&quot;//填写自己的邮箱</div><div class=\"line\"></div><div class=\"line\">    SSH Key配置成功，本机已成功连接到github。</div></pre></td></tr></table></figure>\n<h1 id=\"Hexo博客\"><a href=\"#Hexo博客\" class=\"headerlink\" title=\"Hexo博客\"></a>Hexo博客</h1><blockquote>\n<p>Hexo<br>Hexo的作者是<a href=\"https://github.com/tommy351/hexo\">tommy351</a>，根据<a href=\"http://hexo.io/docs/index.html\">官方介绍</a>，Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式。hexo的主题列表 <a href=\"http://github.com/tommy351/hexo/wiki/Themes\">Hexo Themes</a>。 我比较喜欢 <a href=\"http://github.com/A-limon/pacman\">pacman</a> ， <a href=\"http://github.com/heroicyang/hexo-theme-modernist\">modernist</a> 、 <a href=\"http://github.com/DavidKk/Hexo.ishgo\">ishgo</a> ， <a href=\"http://github.com/raytaylorlin/hexo-theme-raytaylorism\">raytaylorism</a> 。 </p>\n</blockquote>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p>打开Git Bash工具（前提确保Node.js已经安装，环境配置OK）</p>\n<pre><code>$ npm install -g hexo\n</code></pre><blockquote>\n<p>注释：</p>\n</blockquote>\n<p>执行命令：npm install -g hexo，报错如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm ERR! Error: shasum check failed for C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\npm</div><div class=\"line\">-30024-KDJHJzgP\\registry.npmjs.org\\hexo-cli\\-\\hexo-cli-0.1.6.tgz</div><div class=\"line\">npm ERR! Expected: 7dc3ab939d0889c4bed6a961605ff3e2d67f67a2</div><div class=\"line\">npm ERR! Actual:   41de7d67a9b764352eb07c49c32fc38dd7f479b9</div><div class=\"line\">npm ERR! From:     https://registry.npmjs.org/hexo-cli/-/hexo-cli-0.1.6.tgz</div><div class=\"line\">npm ERR!     at d:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\sha\\index.</div><div class=\"line\">js:38:8</div><div class=\"line\">npm ERR!     at ReadStream.&lt;anonymous&gt; (d:\\Program Files\\nodejs\\node_modules\\npm</div><div class=\"line\">\\node_modules\\sha\\index.js:85:7)</div><div class=\"line\">npm ERR!     at ReadStream.emit (events.js:117:20)</div><div class=\"line\">npm ERR!     at _stream_readable.js:943:16</div><div class=\"line\">npm ERR!     at process._tickCallback (node.js:419:13)</div><div class=\"line\">npm ERR! If you need help, you may report this *entire* log,</div><div class=\"line\">npm ERR! including the npm and node versions, at:</div><div class=\"line\">npm ERR!     &lt;http://github.com/npm/npm/issues&gt;</div><div class=\"line\"></div><div class=\"line\">npm ERR! System Windows_NT 6.2.9200</div><div class=\"line\">npm ERR! command &quot;d:\\\\Program Files\\\\nodejs\\\\node.exe&quot; &quot;d:\\\\Program Files\\\\nodej</div><div class=\"line\">s\\\\node_modules\\\\npm\\\\bin\\\\npm-cli.js&quot; &quot;install&quot; &quot;-g&quot; &quot;hexo&quot;</div><div class=\"line\">npm ERR! cwd C:\\Users\\Administrator\\Desktop</div><div class=\"line\">npm ERR! node -v v0.10.31</div><div class=\"line\">npm ERR! npm -v 1.4.23</div><div class=\"line\">npm ERR! registry error parsing json</div><div class=\"line\">npm ERR!</div><div class=\"line\">npm ERR! Additional logging details can be found in:</div><div class=\"line\">npm ERR!     C:\\Users\\Administrator\\Desktop\\npm-debug.log</div><div class=\"line\">npm ERR! not ok code 0</div><div class=\"line\"></div><div class=\"line\">    莫非是因为被墙了？换国内镜像源试试。</div><div class=\"line\">npm config set registry=&quot;http://registry.cnpmjs.org&quot;，</div><div class=\"line\">    然后再次执行npm install -g hexo，成功！</div></pre></td></tr></table></figure>\n<h2 id=\"部署Hexo\"><a href=\"#部署Hexo\" class=\"headerlink\" title=\"部署Hexo\"></a>部署Hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">    在我的电脑中建立一个名字叫「Hexo」的文件夹，然后在此文件夹中右键打开Git Bash。</div><div class=\"line\"></div><div class=\"line\">$ hexo init</div><div class=\"line\"></div><div class=\"line\">    如果无法使用右击“Git Bash”，则可以切换到指定目录</div><div class=\"line\"></div><div class=\"line\">    UUhike@UUhike-pc MINGW64 ~</div><div class=\"line\">$ cd j:/github/hexo</div><div class=\"line\">    UUhike@UUhike-pc MINGW64 /j/github/hexo</div><div class=\"line\"></div><div class=\"line\">    安装依赖包</div><div class=\"line\">$ npm install</div><div class=\"line\"></div><div class=\"line\">    Hexo随后会自动在目标文件夹建立网站所需要的所有文件。</div><div class=\"line\">    现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\\hexo)，然后到浏览器输入localhost:4000看看。</div><div class=\"line\"></div><div class=\"line\">    本地查看</div><div class=\"line\"></div><div class=\"line\">$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）</div><div class=\"line\"></div><div class=\"line\">$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div></pre></td></tr></table></figure>\n<h2 id=\"部署到GitHub\"><a href=\"#部署到GitHub\" class=\"headerlink\" title=\"部署到GitHub\"></a>部署到GitHub</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">编辑E:\\hexo下的_config.yml，修改Deployment部分：</div><div class=\"line\"></div><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: http://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">    repository: https://github.com/luuman/luuman.github.io.git</div><div class=\"line\">    branch: master</div></pre></td></tr></table></figure>\n<blockquote>\n<p>注释：</p>\n</blockquote>\n<p>hexo d，执行该命令，报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">ERROR Deployer not found: git</div><div class=\"line\"></div><div class=\"line\">执行命令：</div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\">再次执行hexo d,报错：</div><div class=\"line\"></div><div class=\"line\">INFO  Deploying: git</div><div class=\"line\">INFO  Clearing .deploy folder...</div><div class=\"line\">INFO  Copying files from public folder...</div><div class=\"line\">warning: LF will be replaced by CRLF in 2015/05/30/hello-world/index.html.</div><div class=\"line\">The file will have its original line endings in your working directory.</div><div class=\"line\">......</div><div class=\"line\">*** Please tell me who you are.</div><div class=\"line\"></div><div class=\"line\">Run</div><div class=\"line\"></div><div class=\"line\">  git config --global user.email &quot;you@example.com&quot;</div><div class=\"line\">  git config --global user.name &quot;Your Name&quot;</div><div class=\"line\"></div><div class=\"line\">to set your account&apos;s default identity.</div><div class=\"line\">Omit --global to set the identity only in this repository.</div><div class=\"line\"></div><div class=\"line\">fatal: unable to auto-detect email address (got &apos;Administrator@PC-201505290750.(none)&apos;)</div><div class=\"line\">Username for &apos;https://github.com&apos;: voidking</div><div class=\"line\">Password for &apos;https://voidking@github.com&apos;:</div><div class=\"line\">error: src refspec master does not match any.</div><div class=\"line\">error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos;</div><div class=\"line\">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</div><div class=\"line\">Error: error: src refspec master does not match any.</div><div class=\"line\">error: failed to push some refs to &apos;https://github.com/voidking/voidking.github.io.git&apos;</div><div class=\"line\"></div><div class=\"line\">    at ChildProcess.&lt;anonymous&gt; (E:\\hexo\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:42:17)</div><div class=\"line\">    at ChildProcess.emit (events.js:98:17)</div><div class=\"line\">    at maybeClose (child_process.js:756:16)</div><div class=\"line\">    at Process.ChildProcess._handle.onexit (child_process.js:823:5)</div></pre></td></tr></table></figure>\n<p>hexo d，执行该命令，报错：</p>\n<h2 id=\"复制cnfeat的主题\"><a href=\"#复制cnfeat的主题\" class=\"headerlink\" title=\"复制cnfeat的主题\"></a>复制cnfeat的主题</h2><p>以下进入复制主题环节，如果那一步出现问题，或者修改后没有显示修改的结果，建议来来一个，再看看，可以解决很多问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo clean</div><div class=\"line\"></div><div class=\"line\">$ hexo generate #生成静态页面至public目录（最终上传这个文件到GitHub）</div><div class=\"line\"></div><div class=\"line\">$ hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div><div class=\"line\"></div><div class=\"line\">建立了Hexo文件，复制我的主题了到themes文件夹中</div><div class=\"line\">yilia</div><div class=\"line\">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</div><div class=\"line\">modernist</div><div class=\"line\">$ git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist</div><div class=\"line\">jacman</div><div class=\"line\">$ git clone https://github.com/cnfeat/cnfeat.git themes/jacman</div></pre></td></tr></table></figure>\n<h2 id=\"启用cnfeat的主题\"><a href=\"#启用cnfeat的主题\" class=\"headerlink\" title=\"启用cnfeat的主题\"></a>启用cnfeat的主题</h2><p>修改Hexo目录下的config.yml配置文件中的theme属性，将其设置为jacman。同时请设置stylus属性中的compress值为true。<br>theme: jacman</p>\n<p>注意：Hexo有两个config.yml文件，一个在根目录，一个在theme下，此时修改的是在根目录下的。</p>\n<pre><code>更新主题\n\n$ cd themes/jacman\n$ git pull\n</code></pre><p>注意：为避免出错，请先备份你的_config.yml 文件后再升级<br>本地查看调试</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g #生成</div><div class=\"line\">$ hexo s #启动本地服务，进行文章预览调试</div><div class=\"line\"></div><div class=\"line\">或者直接作用组合命令</div><div class=\"line\"></div><div class=\"line\">$ hexo deploy -g</div><div class=\"line\">$ hexo server -g</div><div class=\"line\"></div><div class=\"line\">简写：</div><div class=\"line\"></div><div class=\"line\">hexo n == hexo new</div><div class=\"line\">hexo g == hexo generate</div><div class=\"line\">hexo s == hexo server</div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure>\n<blockquote>\n<p>4、浏览器中查看效果</p>\n</blockquote>\n<p>浏览器输入<a href=\"http://localhost:4000\">http://localhost:4000</a> ，查看搭建效果。此后的每次变更_config.yml文件或者上传文件都可以先用此命令调试，非常好用，尤其是当你想调试出自己想要的主题时。</p>\n<p>#进阶篇：Hexo设置</p>\n<p>网站搭建完成后，就可以根据自己爱好来对Hexo生成的网站进行设置了，对整站的设置，只要修改项目目录的hexo/_config.yml就可以了，这是我的设置，可供参考。</p>\n<blockquote>\n<p>默认目录结构：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── .deploy</div><div class=\"line\">├── public</div><div class=\"line\">├── scaffolds</div><div class=\"line\">├── scripts</div><div class=\"line\">├── source</div><div class=\"line\">|   ├── _drafts</div><div class=\"line\">|   └── _posts</div><div class=\"line\">├── themes</div><div class=\"line\">├── _config.yml</div><div class=\"line\">└── package.json</div></pre></td></tr></table></figure>\n<blockquote>\n<p>hexo/_config.yml</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: http://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"></div><div class=\"line\"># Site #整站的基本信息</div><div class=\"line\">title: 1000 words a Day #网站标题</div><div class=\"line\">subtitle: Writing 1000 Words a Day Changes My Life #网站副标题</div><div class=\"line\">description: 学习总结 思考感悟 知识管理 #网站描述</div><div class=\"line\">author:  cnFeat #网站作者，在下方显示</div><div class=\"line\">email: cnFeat@gmail.com #联系邮箱</div><div class=\"line\">language: zh-CN #主题实际的文件名称</div><div class=\"line\">timezone:</div><div class=\"line\"></div><div class=\"line\"># URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项</div><div class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class=\"line\">url: http://yoursite.com</div><div class=\"line\">root: /</div><div class=\"line\">permalink: :year/:month/:day/:title/</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"></div><div class=\"line\"># Directory</div><div class=\"line\">source_dir: source</div><div class=\"line\">public_dir: public</div><div class=\"line\">tag_dir: tags</div><div class=\"line\">archive_dir: archives</div><div class=\"line\">category_dir: categories</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">i18n_dir: :lang</div><div class=\"line\">skip_render:</div><div class=\"line\"></div><div class=\"line\"># Writing 文章布局、写作格式的定义，不修改</div><div class=\"line\">new_post_name: :title.md # File name of new posts</div><div class=\"line\">default_layout: post</div><div class=\"line\">titlecase: false # Transform title into titlecase</div><div class=\"line\">external_link: true # Open external links in new tab</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">future: true</div><div class=\"line\">highlight:</div><div class=\"line\">  enable: true</div><div class=\"line\">  line_number: true</div><div class=\"line\">  auto_detect: true</div><div class=\"line\">  tab_replace:</div><div class=\"line\"></div><div class=\"line\"># Category &amp; Tag</div><div class=\"line\">default_category: uncategorized</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"></div><div class=\"line\"># Date / Time format 日期格式，不修改</div><div class=\"line\">## Hexo uses Moment.js to parse and display date</div><div class=\"line\">## You can customize the date format as defined in</div><div class=\"line\">## http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">date_format: YYYY-MM-DD</div><div class=\"line\">time_format: HH:mm:ss</div><div class=\"line\"></div><div class=\"line\"># Pagination 每页显示文章数，可以自定义，我将10改成了5</div><div class=\"line\">## Set per_page to 0 to disable pagination</div><div class=\"line\">per_page: 5</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"></div><div class=\"line\"># Disqus Disqus插件，我们会替换成“多说”，不修改</div><div class=\"line\">disqus_shortname:</div><div class=\"line\"></div><div class=\"line\"># Extensions</div><div class=\"line\">## Plugins: http://hexo.io/plugins/</div><div class=\"line\">## Themes: http://hexo.io/themes/</div><div class=\"line\">theme: spfk</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># 自动生成sitemap</div><div class=\"line\">sitemap:</div><div class=\"line\">path: sitemap.xml</div><div class=\"line\">baidusitemap:</div><div class=\"line\">path: baidusitemap.xml</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"># Deployment 站点部署到github要配置，上一节中已经讲过</div><div class=\"line\">## Docs: http://zespia.tw/hexo/docs/deploy.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:luuman/luuman.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p>修改局部页面</p>\n<p>页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\主题名称\\中：</p>\n<blockquote>\n<p>hexo\\themes\\</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── languages  #多语言</div><div class=\"line\">|   ├── default.yml#默认语言</div><div class=\"line\">|   └── zh-CN.yml  #中文语言</div><div class=\"line\">├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制</div><div class=\"line\">|   ├── _partial   #局部的布局，此目录下的*.ejs是对头尾等局部的控制</div><div class=\"line\">|   └── _widget#小挂件的布局，页面下方小挂件的控制</div><div class=\"line\">├── source #源码</div><div class=\"line\">|   ├── css#css源码 </div><div class=\"line\">|   |   ├── _base  #*.styl基础css</div><div class=\"line\">|   |   ├── _partial   #*.styl局部css</div><div class=\"line\">|   |   ├── fonts  #字体</div><div class=\"line\">|   |   ├── images #图片</div><div class=\"line\">|   |   └── style.styl #*.styl引入需要的css源码</div><div class=\"line\">|   ├── fancybox   #fancybox效果源码</div><div class=\"line\">|   └── js #javascript源代码</div><div class=\"line\">├── _config.yml#主题配置文件</div><div class=\"line\">└── README.md  #用GitHub的都知道</div></pre></td></tr></table></figure>\n<p>主题文档的配置</p>\n<blockquote>\n<p>hexo\\themes/_config.yml</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Header</div><div class=\"line\">menu:</div><div class=\"line\">  主页: /</div><div class=\"line\">  所有文章: /archives</div><div class=\"line\">  # 随笔: /tags/随笔</div><div class=\"line\"></div><div class=\"line\"># SubNav</div><div class=\"line\">subnav:</div><div class=\"line\">  github: &quot;#&quot;</div><div class=\"line\">  weibo: &quot;#&quot;</div><div class=\"line\">  rss: &quot;#&quot;</div><div class=\"line\">  zhihu: &quot;#&quot;</div><div class=\"line\">  #douban: &quot;#&quot;</div><div class=\"line\">  #mail: &quot;#&quot;</div><div class=\"line\">  #facebook: &quot;#&quot;</div><div class=\"line\">  #google: &quot;#&quot;</div><div class=\"line\">  #twitter: &quot;#&quot;</div><div class=\"line\">  #linkedin: &quot;#&quot;</div><div class=\"line\"></div><div class=\"line\">rss: /atom.xml</div><div class=\"line\"></div><div class=\"line\"># Content</div><div class=\"line\">excerpt_link: more</div><div class=\"line\">fancybox: true</div><div class=\"line\">mathjax: true</div><div class=\"line\"></div><div class=\"line\"># Miscellaneous</div><div class=\"line\">google_analytics: &apos;&apos;</div><div class=\"line\">favicon: /favicon.png</div><div class=\"line\"></div><div class=\"line\">#你的头像url</div><div class=\"line\">avatar: &quot;&quot;</div><div class=\"line\">#是否开启分享</div><div class=\"line\">share: true</div><div class=\"line\">#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key（http://duoshuo-key.duoshuo.com/）</div><div class=\"line\">#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论</div><div class=\"line\">duoshuo: true</div><div class=\"line\">#是否开启云标签</div><div class=\"line\">tagcloud: true</div><div class=\"line\"></div><div class=\"line\">#是否开启友情链接</div><div class=\"line\">#不开启——</div><div class=\"line\">#friends: false</div><div class=\"line\">#开启——</div><div class=\"line\">friends:</div><div class=\"line\">  奥巴马的博客: http://localhost:4000/</div><div class=\"line\">  卡卡的美丽传说: http://localhost:4000/</div><div class=\"line\">  本泽马的博客: http://localhost:4000/</div><div class=\"line\">  吉格斯的博客: http://localhost:4000/</div><div class=\"line\">  习大大大不同: http://localhost:4000/</div><div class=\"line\">  托蒂的博客: http://localhost:4000/</div><div class=\"line\"></div><div class=\"line\">#是否开启“关于我”。</div><div class=\"line\">#不开启——</div><div class=\"line\">#aboutme: false</div><div class=\"line\">#开启——</div><div class=\"line\">aboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div></pre></td></tr></table></figure>\n<h1 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h1><p><a href=\"http://ibruce.info/2013/11/22/hexo-your-blog/\">hexo你的博客</a><br><a href=\"http://www.jianshu.com/p/05289a4bc8b2#\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br><a href=\"http://luuman.github.io/2015/12/25/Hexo/\">Hexo的使用介绍</a><br><a href=\"http://luuman.github.io/2015/12/27/Hexo-plug/\">Hexo插件安装</a></p>"},{"title":"iOS公共库","author":[{"name":"千寻墨","url":"http://www.jianshu.com/users/527ecf8c8753/latest_articles"}],"date":"2016-04-06T08:59:52.000Z","_content":"\n\n### 第一步\n\n>打开Xcode，file->new->WorkSpace,我们使用WorkSpace来管理工程和依赖库\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/1.png)\n\n<!-- more -->\n\n### 第二步\n\n>file->new->project->Application,创建我们的工程，创建好后关闭工程\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/2.png)\n\n### 第三步\n\n>file->new->project->Framework&Library->Cocoa Touch Framework,创建依赖库\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/3.png)\n\n### 第四步\n\n>新建一个Tool类，然后在Amy.h里面引入，引入的方式：`#import<Amy/Tool.h>`\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/4.png)\n\n### 第五步\n\n>回到我们的workspace目录，workspace，依赖库和工程最好放到同一目录下面。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/5.png)\n\n### 第六步\n\n>打开workspace，通过 `file-> AddFile to` 依次把工程和依赖添加到workspace中。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/6.png)\n\n### 第七步\n\n>在workspace中选中工程，然后点击Build Phases，选择 link Binary With Libraries 点击 + 号，添加Amy.framework\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/7.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/8.png)\n\t\n### 第八步\n\n>在我们的工程中可以引入依赖使用了。\n引入方式：`#import<Amy/Tool.h>`\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/9.png)\n\n\n\n","source":"_posts/iOS公共库.md","raw":"---\ntitle: iOS公共库\ntags:\n  - iOS\n  - 公共库\n  - workspace\ncategories:\n  - iOS技术\nauthor:\n  - name: 千寻墨\n    url: 'http://www.jianshu.com/users/527ecf8c8753/latest_articles'\ndate: 2016-04-06 16:59:52\n---\n\n\n### 第一步\n\n>打开Xcode，file->new->WorkSpace,我们使用WorkSpace来管理工程和依赖库\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/1.png)\n\n<!-- more -->\n\n### 第二步\n\n>file->new->project->Application,创建我们的工程，创建好后关闭工程\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/2.png)\n\n### 第三步\n\n>file->new->project->Framework&Library->Cocoa Touch Framework,创建依赖库\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/3.png)\n\n### 第四步\n\n>新建一个Tool类，然后在Amy.h里面引入，引入的方式：`#import<Amy/Tool.h>`\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/4.png)\n\n### 第五步\n\n>回到我们的workspace目录，workspace，依赖库和工程最好放到同一目录下面。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/5.png)\n\n### 第六步\n\n>打开workspace，通过 `file-> AddFile to` 依次把工程和依赖添加到workspace中。\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/6.png)\n\n### 第七步\n\n>在workspace中选中工程，然后点击Build Phases，选择 link Binary With Libraries 点击 + 号，添加Amy.framework\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/7.png)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/8.png)\n\t\n### 第八步\n\n>在我们的工程中可以引入依赖使用了。\n引入方式：`#import<Amy/Tool.h>`\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/9.png)\n\n\n\n","slug":"iOS公共库","published":1,"updated":"2016-11-17T15:01:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmev0005co60q6ig7xx3","content":"<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><blockquote>\n<p>打开Xcode，file-&gt;new-&gt;WorkSpace,我们使用WorkSpace来管理工程和依赖库</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/1.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><blockquote>\n<p>file-&gt;new-&gt;project-&gt;Application,创建我们的工程，创建好后关闭工程</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/2.png\" alt=\"image\"></p>\n<h3 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><blockquote>\n<p>file-&gt;new-&gt;project-&gt;Framework&amp;Library-&gt;Cocoa Touch Framework,创建依赖库</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/3.png\" alt=\"image\"></p>\n<h3 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><blockquote>\n<p>新建一个Tool类，然后在Amy.h里面引入，引入的方式：<code>#import&lt;Amy/Tool.h&gt;</code></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/4.png\" alt=\"image\"></p>\n<h3 id=\"第五步\"><a href=\"#第五步\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><blockquote>\n<p>回到我们的workspace目录，workspace，依赖库和工程最好放到同一目录下面。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/5.png\" alt=\"image\"></p>\n<h3 id=\"第六步\"><a href=\"#第六步\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><blockquote>\n<p>打开workspace，通过 <code>file-&gt; AddFile to</code> 依次把工程和依赖添加到workspace中。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/6.png\" alt=\"image\"></p>\n<h3 id=\"第七步\"><a href=\"#第七步\" class=\"headerlink\" title=\"第七步\"></a>第七步</h3><blockquote>\n<p>在workspace中选中工程，然后点击Build Phases，选择 link Binary With Libraries 点击 + 号，添加Amy.framework</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/7.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/8.png\" alt=\"image\"></p>\n<h3 id=\"第八步\"><a href=\"#第八步\" class=\"headerlink\" title=\"第八步\"></a>第八步</h3><blockquote>\n<p>在我们的工程中可以引入依赖使用了。<br>引入方式：<code>#import&lt;Amy/Tool.h&gt;</code><br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/9.png\" alt=\"image\"></p>\n</blockquote>\n","excerpt":"<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><blockquote>\n<p>打开Xcode，file-&gt;new-&gt;WorkSpace,我们使用WorkSpace来管理工程和依赖库</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/1.png\" alt=\"image\"></p>","more":"<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><blockquote>\n<p>file-&gt;new-&gt;project-&gt;Application,创建我们的工程，创建好后关闭工程</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/2.png\" alt=\"image\"></p>\n<h3 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><blockquote>\n<p>file-&gt;new-&gt;project-&gt;Framework&amp;Library-&gt;Cocoa Touch Framework,创建依赖库</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/3.png\" alt=\"image\"></p>\n<h3 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><blockquote>\n<p>新建一个Tool类，然后在Amy.h里面引入，引入的方式：<code>#import&lt;Amy/Tool.h&gt;</code></p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/4.png\" alt=\"image\"></p>\n<h3 id=\"第五步\"><a href=\"#第五步\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><blockquote>\n<p>回到我们的workspace目录，workspace，依赖库和工程最好放到同一目录下面。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/5.png\" alt=\"image\"></p>\n<h3 id=\"第六步\"><a href=\"#第六步\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><blockquote>\n<p>打开workspace，通过 <code>file-&gt; AddFile to</code> 依次把工程和依赖添加到workspace中。</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/6.png\" alt=\"image\"></p>\n<h3 id=\"第七步\"><a href=\"#第七步\" class=\"headerlink\" title=\"第七步\"></a>第七步</h3><blockquote>\n<p>在workspace中选中工程，然后点击Build Phases，选择 link Binary With Libraries 点击 + 号，添加Amy.framework</p>\n</blockquote>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/7.png\" alt=\"image\"></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/8.png\" alt=\"image\"></p>\n<h3 id=\"第八步\"><a href=\"#第八步\" class=\"headerlink\" title=\"第八步\"></a>第八步</h3><blockquote>\n<p>在我们的工程中可以引入依赖使用了。<br>引入方式：<code>#import&lt;Amy/Tool.h&gt;</code><br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/%E5%85%AC%E5%85%B1%E4%BE%9D%E8%B5%96%E5%BA%93/9.png\" alt=\"image\"></p>\n</blockquote>"},{"title":"github ssh key 问题","date":"2016-02-27T09:02:21.000Z","_content":"   \n   当我部署hexo在github上的时候去看了一下ssh key，发现github上早就有ssh key了，但是我从来没有手动去生成过，并且这个key的名字与手动生成的不一样，文件名是这样github_rsa，当然还有另外一个pub格式的，而如果我们手动生成的话，必然是id_rsa,除非我们自己改名。这个key应该是我安装github客户端的时候生成的，不过我可以在github提交代码，hexo也部署成功了，这些东西也从来没去了解过，然后这次出问题了，折腾了很久。\n   <!-- more -->\n   我打算把博客迁移到gitcafe上，然后我申请了一个gitcafe账号，然后也是配置相关ssh key，当我生成了gitcafe 的ssh key 后，我的github 就不能提交代码了。可恶的是我在gitcafe上添加ssh key后，也是提交不了代码，现在我两个地方都不能用了。现在我的ssh是这样的，github是github_rsa，gitcafe是id_rsa，然后我又在网上搜索管理多个ssh key方法，通过config配置，但是还是没有用。最后搞了很久，实在没有办法，我就先把gitcafe 的 key 给删了，看看github能不能用了，结果发现github还是不能用，这回蛋疼了。最后终于决定，我把ssh目录给清空了，然后重新手动生成github ssh key，这回github能用了，有点劫后余生的感觉，毕竟公司的代码就托管在github上，要是不能用了，工作都做不了。然后我又有些不甘心，再次尝试 gitcafe的 ssh key，然后在通过config管理，这回能用了。\n   原因就在于第一个github的key不是我自己生成的，如果你也遇到此类问题，可以试试清空哪些不是自己生成的key。\n\n","source":"_posts/github ssh key问题.md","raw":"---\ntitle: github ssh key 问题\ndate: 2016-02-27 17:02:21\ntags: [github, ssh key]\ncategories: \n- 随笔\n---\n   \n   当我部署hexo在github上的时候去看了一下ssh key，发现github上早就有ssh key了，但是我从来没有手动去生成过，并且这个key的名字与手动生成的不一样，文件名是这样github_rsa，当然还有另外一个pub格式的，而如果我们手动生成的话，必然是id_rsa,除非我们自己改名。这个key应该是我安装github客户端的时候生成的，不过我可以在github提交代码，hexo也部署成功了，这些东西也从来没去了解过，然后这次出问题了，折腾了很久。\n   <!-- more -->\n   我打算把博客迁移到gitcafe上，然后我申请了一个gitcafe账号，然后也是配置相关ssh key，当我生成了gitcafe 的ssh key 后，我的github 就不能提交代码了。可恶的是我在gitcafe上添加ssh key后，也是提交不了代码，现在我两个地方都不能用了。现在我的ssh是这样的，github是github_rsa，gitcafe是id_rsa，然后我又在网上搜索管理多个ssh key方法，通过config配置，但是还是没有用。最后搞了很久，实在没有办法，我就先把gitcafe 的 key 给删了，看看github能不能用了，结果发现github还是不能用，这回蛋疼了。最后终于决定，我把ssh目录给清空了，然后重新手动生成github ssh key，这回github能用了，有点劫后余生的感觉，毕竟公司的代码就托管在github上，要是不能用了，工作都做不了。然后我又有些不甘心，再次尝试 gitcafe的 ssh key，然后在通过config管理，这回能用了。\n   原因就在于第一个github的key不是我自己生成的，如果你也遇到此类问题，可以试试清空哪些不是自己生成的key。\n\n","slug":"github ssh key问题","published":1,"updated":"2016-11-16T15:05:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmf70006co60eh0sa00l","content":"<p>   当我部署hexo在github上的时候去看了一下ssh key，发现github上早就有ssh key了，但是我从来没有手动去生成过，并且这个key的名字与手动生成的不一样，文件名是这样github_rsa，当然还有另外一个pub格式的，而如果我们手动生成的话，必然是id_rsa,除非我们自己改名。这个key应该是我安装github客户端的时候生成的，不过我可以在github提交代码，hexo也部署成功了，这些东西也从来没去了解过，然后这次出问题了，折腾了很久。<br>   <a id=\"more\"></a><br>   我打算把博客迁移到gitcafe上，然后我申请了一个gitcafe账号，然后也是配置相关ssh key，当我生成了gitcafe 的ssh key 后，我的github 就不能提交代码了。可恶的是我在gitcafe上添加ssh key后，也是提交不了代码，现在我两个地方都不能用了。现在我的ssh是这样的，github是github_rsa，gitcafe是id_rsa，然后我又在网上搜索管理多个ssh key方法，通过config配置，但是还是没有用。最后搞了很久，实在没有办法，我就先把gitcafe 的 key 给删了，看看github能不能用了，结果发现github还是不能用，这回蛋疼了。最后终于决定，我把ssh目录给清空了，然后重新手动生成github ssh key，这回github能用了，有点劫后余生的感觉，毕竟公司的代码就托管在github上，要是不能用了，工作都做不了。然后我又有些不甘心，再次尝试 gitcafe的 ssh key，然后在通过config管理，这回能用了。<br>   原因就在于第一个github的key不是我自己生成的，如果你也遇到此类问题，可以试试清空哪些不是自己生成的key。</p>\n","excerpt":"<p>   当我部署hexo在github上的时候去看了一下ssh key，发现github上早就有ssh key了，但是我从来没有手动去生成过，并且这个key的名字与手动生成的不一样，文件名是这样github_rsa，当然还有另外一个pub格式的，而如果我们手动生成的话，必然是id_rsa,除非我们自己改名。这个key应该是我安装github客户端的时候生成的，不过我可以在github提交代码，hexo也部署成功了，这些东西也从来没去了解过，然后这次出问题了，折腾了很久。<br>","more":"<br>   我打算把博客迁移到gitcafe上，然后我申请了一个gitcafe账号，然后也是配置相关ssh key，当我生成了gitcafe 的ssh key 后，我的github 就不能提交代码了。可恶的是我在gitcafe上添加ssh key后，也是提交不了代码，现在我两个地方都不能用了。现在我的ssh是这样的，github是github_rsa，gitcafe是id_rsa，然后我又在网上搜索管理多个ssh key方法，通过config配置，但是还是没有用。最后搞了很久，实在没有办法，我就先把gitcafe 的 key 给删了，看看github能不能用了，结果发现github还是不能用，这回蛋疼了。最后终于决定，我把ssh目录给清空了，然后重新手动生成github ssh key，这回github能用了，有点劫后余生的感觉，毕竟公司的代码就托管在github上，要是不能用了，工作都做不了。然后我又有些不甘心，再次尝试 gitcafe的 ssh key，然后在通过config管理，这回能用了。<br>   原因就在于第一个github的key不是我自己生成的，如果你也遇到此类问题，可以试试清空哪些不是自己生成的key。</p>"},{"title":"iOS三种录制视频方式","author":[{"name":"千寻墨","url":"http://www.jianshu.com/users/527ecf8c8753/latest_articles"}],"date":"2016-03-20T14:13:17.000Z","_content":"\n\n>A sample project demonstrating different video capture pipelines on iOS\n\n### 一:相机相关知识\nUIImagePickerController\nAVCaptureSession + AVMovieFileOutput\nAVCaptureSession + AVAssetWriter\n\n随着每一代 iPhone 处理能力和相机硬件配置的提高，使用它来捕获视频也变得更加有意思。它们小巧，轻便，低调，而且与专业摄像机之间的差距已经变得非常小，小到在某些情况下，iPhone 可以真正替代它们。\n\n这篇文章讨论了关于如何配置视频捕获管线 (pipeline) 和最大限度地利用硬件性能的一些不同选择。 这里有个使用了不同管线的样例 app，可以在 [GitHub](https://github.com/suifengqjn/VideoCaptureDemo) 查看。\n\n`UIImagePickerController`\n目前，将视频捕获集成到你的应用中的最简单的方法是使用 `UIImagePickerController`。这是一个封装了完整视频捕获管线和相机 UI 的 `view controller`。\n\n在实例化相机之前，首先要检查设备是否支持相机录制：\n\n```\nif ([UIImagePickerController  \n       isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) {\n    NSArray *availableMediaTypes = [UIImagePickerController\n      availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];\n    if ([availableMediaTypes containsObject:(NSString *)kUTTypeMovie]) {\n        // 支持视频录制\n    }\n}\n```\n然后创建一个 UIImagePickerController 对象，设置好代理便于进一步处理录制好的视频 (比如存到相册) 以及对于用户关闭相机作出响应：\n\n<!-- more -->\n\n```\nUIImagePickerController *camera = [UIImagePickerController new];  \ncamera.sourceType = UIImagePickerControllerSourceTypeCamera;  \ncamera.mediaTypes = @[(NSString *)kUTTypeMovie];  \ncamera.delegate = self; \n```\n \n这是你实现一个功能完善的摄像机所需要写的所有代码。\n\n相机配置\n`UIImagePickerController` 提供了额外的配置选项。\n\n通过设置 `cameraDevice` 属性可以选择一个特定的相机。这是一个 `UIImagePickerControllerCameraDevice` 枚举，默认情况下是 `UIImagePickerControllerCameraDeviceRear`，你也可以把它设置为 `UIImagePickerControllerCameraDeviceFront`。每次都应事先确认你想要设置的相机是可用的：\n\n```\nUIImagePickerController *camera = …  \nif ([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront]) {  \n    [camera setCameraDevice:UIImagePickerControllerCameraDeviceFront];\n}\n```\n\n`videoQuality` 属性用于控制录制视频的质量。它允许你设置一个特定的编码预设，从而改变视频的比特率和分辨率。以下是六种预设：\n\n```\nenum {  \n   UIImagePickerControllerQualityTypeHigh             = 0,\n   UIImagePickerControllerQualityTypeMedium           = 1,  // default  value\n   UIImagePickerControllerQualityTypeLow              = 2,\n   UIImagePickerControllerQualityType640x480          = 3,\n   UIImagePickerControllerQualityTypeIFrame1280x720   = 4,\n   UIImagePickerControllerQualityTypeIFrame960x540    = 5\n};\ntypedef NSUInteger  UIImagePickerControllerQualityType; \n``` \n前三种为相对预设 (low, medium, high)。这些预设的编码配置会因设备不同而不同。如果选择 high，那么你选定的相机会提供给你该设备所能支持的最高画质。后面三种是特定分辨率的预设 (640x480 VGA, 960x540 iFrame, 和 1280x720 iFrame)。\n\n自定义 UI\n就像上面提到的，`UIImagePickerController` 自带一套相机 UI，可以直接使用。然而，你也可以自定义相机的控件，通过隐藏默认控件，然后创建带有控件的自定义视图，并覆盖在相机预览图层上面：\n\n```\nUIView *cameraOverlay = …  \npicker.showsCameraControls = NO;\npicker.cameraOverlayView = cameraOverlay;\n\n```\n\n>然后你需要将你覆盖层上的控件关联上 `UIImagePickerController` 的控制方法 (比如，`startVideoCapture` 和 `stopVideoCapture`)。\n\n<!--more-->\n\n### 二:AVFoundation\n\n\n>如果你想要更多关于处理捕获视频的方法，而这些方法是 `UIImagePickerController` 所不能提供的，那么你需要使用 `AVFoundation`。\n\n> `AVFoundation` 中关于视频捕获的主要的类是 `AVCaptureSession`。它负责调配影音输入与输出之间的数据流：\n\n#### AVCaptureSession setup\n\n>使用一个 `capture session`，你需要先实例化，添加输入与输出，接着启动从输入到输出之间的数据流：\n\n\n```\nAVCaptureSession *captureSession = [AVCaptureSession new];  \nAVCaptureDeviceInput *cameraDeviceInput = …  \nAVCaptureDeviceInput *micDeviceInput = …  \nAVCaptureMovieFileOutput *movieFileOutput = …  \nif ([captureSession canAddInput:cameraDeviceInput]) {  \n    [captureSession addInput:cameraDeviceInput];\n}\nif ([captureSession canAddInput:micDeviceInput]) {  \n    [captureSession addInput:micDeviceInput];\n}\nif ([captureSession canAddOutput:movieFileOutput]) {  \n    [captureSession addOutput:movieFileOutput];\n}\n\n[captureSession startRunning];\n```\n\n\n(为了简单起见，调度队列 (dispatch queue) 的相关代码已经从上面那段代码中省略了。所有对 `capture session` 的调用都是阻塞的，因此建议将它们分配到后台串行队列中。)\n\n`capture session` 可以通过一个 `sessionPreset` \n来进一步配置，这可以用来指定输出质量的等级。有 11 种不同的预设模式：\n\n```\nNSString *const  AVCaptureSessionPresetPhoto;  \nNSString *const  AVCaptureSessionPresetHigh;  \nNSString *const  AVCaptureSessionPresetMedium;  \nNSString *const  AVCaptureSessionPresetLow;  \nNSString *const  AVCaptureSessionPreset352x288;  \nNSString *const  AVCaptureSessionPreset640x480;  \nNSString *const  AVCaptureSessionPreset1280x720;  \nNSString *const  AVCaptureSessionPreset1920x1080;  \nNSString *const  AVCaptureSessionPresetiFrame960x540;  \nNSString *const  AVCaptureSessionPresetiFrame1280x720;  \nNSString *const  AVCaptureSessionPresetInputPriority;  \n```\n\n第一个代表高像素图片输出。 接下来的九个和之前我们在设置 `UIImagePickerController` 的 `videoQuality` 时看到过的 `UIImagePickerControllerQualityType` 选项非常相似，不同的是，这里有一些额外可用于 `capture session` 的预设。 最后一个 (AVCaptureSessionPresetInputPriority) 代表 `capture session` 不去控制音频与视频输出设置。而是通过已连接的捕获设备的 `activeFormat` 来反过来控制 `capture session` 的输出质量等级。在下一节，我们将会看到更多关于设备和设备格式的细节。\n\n#### 输入\n\n`AVCaptureSession` 的输入其实就是一个或多个的 `AVCaptureDevice` 对象，这些对象通过 `AVCaptureDeviceInput` 连接上 `capture session`。\n\n我们可以使用 `[AVCaptureDevice devices]` 来寻找可用的捕获设备。以 iPhone 6 为例：\n\n```\n(\n    “<AVCaptureFigVideoDevice: 0x136514db0 [Back Camera][com.apple.avfoundation.avcapturedevice.built-in_video:0]>”,\n    “<AVCaptureFigVideoDevice: 0x13660be80 [Front Camera][com.apple.avfoundation.avcapturedevice.built-in_video:1]>”,\n    “<AVCaptureFigAudioDevice: 0x174265e80 [iPhone Microphone][com.apple.avfoundation.avcapturedevice.built-in_audio:0]>”\n)\n```\n\n#### 视频输入\n\n- 配置相机输入，需要实例化一个 `AVCaptureDeviceInput` 对象，参数是你期望的相机设备，然后把它添加到 `capture session`：\n\n\n```\nAVCaptureSession *captureSession = …  \nAVCaptureDevice *cameraDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];  \nNSError *error;  \nAVCaptureDeviceInput *cameraDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:cameraDevice error:&error];  \nif ([captureSession canAddInput:input]) {  \n    [captureSession addInput:cameraDeviceInput];\n}\n```\n\n如果上面提到的 `capture session` 预设列表里能满足你的需求，那你就不需要做更多的事情了。如果不够，比如你想要高的帧率，你将需要配置具体的设备格式。一个视频捕获设备有许多设备格式，每个都带有特定的属性和功能。下面是对于 iPhone6 的后置摄像头的一些例子 (一共有 22 种可用格式)：\n\n```\n格式\t分辨率\tFPS\tHRSI\tFOV\tVIS\t最大放大比例\tUpscales\tAF\tISO\tSS\tHDR\n420v\t1280x720\t5 - 240\t1280x720\t54.626\tYES\t49.12\t1.09\t1\t29.0 - 928\t0.000003-0.200000\tNO\n420f\t1280x720\t5 - 240\t1280x720\t54.626\tYES\t49.12\t1.09\t1\t29.0 - 928\t0.000003-0.200000\tNO\n420v\t1920x1080\t2 - 30\t3264x1836\t58.040\tYES\t95.62\t1.55\t2\t29.0 - 464\t0.000013-0.500000\tYES\n420f\t1920x1080\t2 - 30\t3264x1836\t58.040\tYES\t95.62\t1.55\t2\t29.0 - 464\t0.000013-0.500000\tYES\n420v\t1920x1080\t2 - 60\t3264x1836\t58.040\tYES\t95.62\t1.55\t2\t29.0 - 464\t0.000008-0.500000\tYES\n420f\t1920x1080\t2 - 60\t3264x1836\t58.040\tYES\t95.62\t1.55\t2\t29.0 - 464\t0.000008-0.500000\tYES\n格式 = 像素格式\nFPS = 支持帧数范围\nHRSI = 高像素静态图片尺寸\nFOV = 视角\nVIS = 该格式支持视频防抖\nUpscales = 加入数字 upscaling 时的放大比例\nAF = 自动对焦系统（1 是反差对焦，2 是相位对焦）\nISO = 支持感光度范围\nSS = 支持曝光时间范围\nHDR = 支持高动态范围图像\n```\n\n通过上面的那些格式，你会发现如果要录制 240 帧每秒的视频的话，可以根据想要的像素格式选用第一个或第二个格式。另外若是要捕获 1920x1080 的分辨率的视频的话，是不支持 240 帧每秒的。\n\n配置一个具体设备格式，你首先需要调用 `lockForConfiguration`: 来获取设备的配置属性的独占访问权限。接着你简单地使用 `setActiveFormat`: 来设置设备的捕获格式。这将会自动把 `capture session` 的预设设置为 `AVCaptureSessionPresetInputPriority`。\n\n一旦你设置了预想的设备格式，你就可以在这种设备格式的约束参数范围内进行进一步的配置了。\n\n对于视频捕获的对焦，曝光和白平衡的设置，与图像捕获时一样，具体可参考第 21 期“iOS 上的相机捕捉”。除了那些，这里还有一些视频特有的配置选项。\n\n你可以用捕获设备的 `activeVideoMinFrameDuration` 和 `activeVideoMaxFrameDuration` 属性设置帧速率，一帧的时长是帧速率的倒数。设置帧速率之前，要先确认它是否在设备格式所支持的范围内，然后锁住捕获设备来进行配置。为了确保帧速率恒定，可以将最小与最大的帧时长设置成一样的值：\n\n```\nNSError *error;  \nCMTime frameDuration = CMTimeMake(1, 60);  \nNSArray *supportedFrameRateRanges = [device.activeFormat videoSupportedFrameRateRanges];  \nBOOL frameRateSupported = NO;  \nfor (AVFrameRateRange *range in supportedFrameRateRanges) {  \n    if (CMTIME_COMPARE_INLINE(frameDuration, >=, range.minFrameDuration) &&\n        CMTIME_COMPARE_INLINE(frameDuration, <=, range.maxFrameDuration)) {\n        frameRateSupported = YES;\n    }\n}\n\nif (frameRateSupported && [device lockForConfiguration:&error]) {  \n    [device setActiveVideoMaxFrameDuration:frameDuration];\n    [device setActiveVideoMinFrameDuration:frameDuration];\n    [device unlockForConfiguration];\n}\n```\n\n视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 `AVCaptureConnection` 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持：\n\n```\nAVCaptureDevice *device = ...;  \nAVCaptureConnection *connection = ...;\n\nAVCaptureVideoStabilizationMode stabilizationMode = AVCaptureVideoStabilizationModeCinematic;  \nif ([device.activeFormat isVideoStabilizationModeSupported:stabilizationMode]) {  \n    [connection setPreferredVideoStabilizationMode:stabilizationMode];\n}\n```\n\niPhone 6 的另一个新特性就是视频 HDR (高动态范围图像)，它是“高动态范围的视频流，与传统的将不同曝光度的静态图像合成成一张高动态范围图像的方法完全不同”，它是内建在传感器中的。有两种方法可以配置视频 HDR：直接将 `capture device` 的 `videoHDREnabled` 设置为启用或禁用，或者使用 `automaticallyAdjustsVideoHDREnabled` 属性来留给系统处理。\n\n技术参考：iPhone 6 和 iPhone Plus 的新 AV Foundation 相机特性\n\n#### 音频输入\n\n之前展示的捕获设备列表里面只有一个音频设备，你可能觉得奇怪，毕竟 iPhone 6 有 3 个麦克风。然而因为有时会放在一起使用，便于优化性能，因此可能被当做一个设备来使用。例如在 iPhone 5 及以上的手机录制视频时，会同时使用前置和后置麦克风，用于定向降噪。\n\nTechnical Q&A: AVAudioSession - Microphone Selection\n\n大多数情况下，设置成默认的麦克风配置即可。后置麦克风会自动搭配后置摄像头使用 (前置麦克风则用于降噪)，前置麦克风和前置摄像头也是一样。\n\n然而想要访问和配置单独的麦克风也是可行的。例如，当用户正在使用后置摄像头捕获场景的时候，使用前置麦克风来录制解说也应是可能的。这就要依赖于 `AVAudioSession`。 为了变更要访问的音频，`audio session` 首先需要设置为支持这样做的类别。然后我们需要遍历 `audio session` 的输入端口和端口数据来源，来找到我们想要的麦克风：\n\n```\n// 配置 audio session\nAVAudioSession *audioSession = [AVAudioSession sharedInstance];  \n[audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];\n[audioSession setActive:YES error:nil];\n\n// 寻找期望的输入端口\nNSArray* inputs = [audioSession availableInputs];  \nAVAudioSessionPortDescription *builtInMic = nil;  \nfor (AVAudioSessionPortDescription* port in inputs) {  \n    if ([port.portType isEqualToString:AVAudioSessionPortBuiltInMic]) {\n        builtInMic = port;\n        break;\n    }\n}\n\n// 寻找期望的麦克风\nfor (AVAudioSessionDataSourceDescription* source in builtInMic.dataSources) {  \n    if ([source.orientation isEqual:AVAudioSessionOrientationFront]) {\n        [builtInMic setPreferredDataSource:source error:nil];\n        [audioSession setPreferredInput:builtInMic error:&error];\n        break;\n    }\n}\n```\n\n除了设置非默认的麦克风配置，你也可以使用 `AVAudioSession` 来配置其他音频设置，比如音频增益和采样率等。\n\n#### 访问权限\n\n有件事你需要记住，访问相机和麦克风需要先获得用户授权。当你给视频或音频创建第一个 AVCaptureDeviceInput 对象时，iOS 会自动弹出一次对话框，请求用户授权，但你最好还是自己实现下。之后你就可以在还没有被授权的时候，使用相同的代码来提示用户进行授权。当用户未授权时，对于录制视频或音频的尝试，得到的将是黑色画面和无声。\n\n#### 输出\n\n输入配置完了，现在把我们的注意力转向 `capture session` 的输出。\n\n`AVCaptureMovieFileOutput`\n将视频写入文件，最简单的选择就是使用 `AVCaptureMovieFileOutput` 对象。把它作为输出添加到 `capture session` 中，就可以将视频和音频写入 `QuickTime` 文件，这只需很少的配置。\n\n```\nAVCaptureMovieFileOutput *movieFileOutput = [AVCaptureMovieFileOutput new];  \nif([captureSession canAddOutput:movieFileOutput]){  \n    [captureSession addOutput:movieFileOutput];\n}\n\n// 开始录制\nNSURL *outputURL = …  \n[movieFileOutput startRecordingToOutputFileURL:outputURL recordingDelegate:self];\n```\n\n当实际的录制开始或停止时，想要接收回调的话就必须要一个录制代理。当录制停止时，输出通常还在写入数据，等它完成之后会调用代理方法。\n\n`AVCaptureMovieFileOutput` 有一些其他的配置选项，比如在某段时间后，在达到某个指定的文件尺寸时，或者当设备的最小磁盘剩余空间达到某个阈值时停止录制。如果你还需要更多设置，比如自定义视频音频的压缩率，或者你想要在写入文件之前，处理视频音频的样本，那么你需要一些更复杂的操作。\n\n`AVCaptureDataOutput` 和 `AVAssetWriter`\n如果你想要对影音输出有更多的操作，你可以使用 `AVCaptureVideoDataOutput` 和 `AVCaptureAudioDataOutput` 而不是我们上节讨论的 `AVCaptureMovieFileOutput`。\n\n这些输出将会各自捕获视频和音频的样本缓存，接着发送到它们的代理。代理要么对采样缓冲进行处理 (比如给视频加滤镜)，要么保持原样传送。使用 `AVAssetWriter` 对象可以将样本缓存写入文件：\n\nUsing an AVAssetWriter\n\n配置一个 asset writer 需要定义一个输出 URL 和文件格式，并添加一个或多个输入来接收采样的缓冲。我们还需要将输入的 `expectsMediaInRealTime`属性设置为 YES，因为它们需要从 `capture session` 实时获得数据。\n\n```\nNSURL *url = …;  \nAVAssetWriter *assetWriter = [AVAssetWriter assetWriterWithURL:url fileType:AVFileTypeMPEG4 error:nil];  \nAVAssetWriterInput *videoInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:nil];  \nvideoInput.expectsMediaDataInRealTime = YES;  \nAVAssetWriterInput *audioInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeAudio outputSettings:nil];  \naudioInput.expectsMediaDataInRealTime = YES;  \nif ([assetWriter canAddInput:videoInput]) {  \n    [assetWriter addInput:videoInput];\n}\nif ([assetWriter canAddInput:audioInput]) {  \n    [assetWriter addInput:audioInput];\n}\n```\n\n(这里推荐将 asset writer 派送到后台串行队列中调用。)\n\n在上面的示例代码中，我们将 `asset writer` 的 `outputSettings` 设置为 nil。这就意味着附加上来的样本不会再被重新编码。如果你确实想要重新编码这些样本，那么需要提供一个包含具体输出参数的字典。关于音频输出设置的键值被定义在这里, 关于视频输出设置的键值定义在这里。\n\n为了更简单点，`AVCaptureVideoDataOutput` 和 `AVCaptureAudioDataOutput` 分别带有 `recommendedVideoSettingsForAssetWriterWithOutputFileType`: 和 `recommendedAudioSettingsForAssetWriterWithOutputFileType`: 方法，可以生成与 `asset writer` 兼容的带有全部键值对的字典。所以你可以通过在这个字典里调整你想要重写的属性，来简单地定义你自己的输出设置。比如，增加视频比特率来提高视频质量等。\n\n或者，你也可以使用 `AVOutputSettingsAssistant` 来配置输出设置的字典，但是从我的经验来看，使用上面的方法会更好，它们会提供更实用的输出设置，比如视频比特率。另外，`AVOutputSettingsAssistant` 似乎存在一些缺点，例如，当你改变希望的视频的帧速率时，视频的比特率并不会改变。\n\n实时预览\n当使用 AVFoundation 来做图像捕获时，我们必须提供一套自定义的用户界面。其中一个关键的相机交互组件是实时预览图。最简单的实现方式是通过把 `AVCaptureVideoPreviewLayer` 对象作为一个 `sublayer` 加到相机图层上去：\n\n```\nAVCaptureSession *captureSession = ...;  \nAVCaptureVideoPreviewLayer *previewLayer = [AVCaptureVideoPreviewLayer layerWithSession:captureSession];  \nUIView *cameraView = ...;  \npreviewLayer.frame = cameraView.bounds;  \n[cameraView.layer addSublayer:previewLayer];\n```\n\n如果你想要更进一步操作，比如，在实时预览图加滤镜，你需要将 `AVCaptureVideoDataOutput` 对象加到 `capture session`，并且使用 OpenGL 展示画面，具体可查看该文“iOS 上的相机捕捉”\n\n总结\n有许多不同的方法可以给 iOS 上的视频捕获配置管线，从最直接的 `UIImagePickerController`，到精密配合的 `AVCaptureSession` 与 `AVAssetWriter`。如何抉择取决于你的项目要求，比如期望的视频质量和压缩率，或者是你想要展示给用户的相机控件。\n\n[demo下载](https://github.com/suifengqjn/VideoCaptureDemo)\n\n\n\n\n\n\n\n\n\n","source":"_posts/iOS三种录制视频方式.md","raw":"---\ntitle: iOS三种录制视频方式\ntags:\n  - iOS\n  - 视频录制\ncategories:\n  - iOS技术\nauthor:\n  - name: 千寻墨\n    url: http://www.jianshu.com/users/527ecf8c8753/latest_articles\ndate: 2016-03-20 22:13:17\n---\n\n\n>A sample project demonstrating different video capture pipelines on iOS\n\n### 一:相机相关知识\nUIImagePickerController\nAVCaptureSession + AVMovieFileOutput\nAVCaptureSession + AVAssetWriter\n\n随着每一代 iPhone 处理能力和相机硬件配置的提高，使用它来捕获视频也变得更加有意思。它们小巧，轻便，低调，而且与专业摄像机之间的差距已经变得非常小，小到在某些情况下，iPhone 可以真正替代它们。\n\n这篇文章讨论了关于如何配置视频捕获管线 (pipeline) 和最大限度地利用硬件性能的一些不同选择。 这里有个使用了不同管线的样例 app，可以在 [GitHub](https://github.com/suifengqjn/VideoCaptureDemo) 查看。\n\n`UIImagePickerController`\n目前，将视频捕获集成到你的应用中的最简单的方法是使用 `UIImagePickerController`。这是一个封装了完整视频捕获管线和相机 UI 的 `view controller`。\n\n在实例化相机之前，首先要检查设备是否支持相机录制：\n\n```\nif ([UIImagePickerController  \n       isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) {\n    NSArray *availableMediaTypes = [UIImagePickerController\n      availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];\n    if ([availableMediaTypes containsObject:(NSString *)kUTTypeMovie]) {\n        // 支持视频录制\n    }\n}\n```\n然后创建一个 UIImagePickerController 对象，设置好代理便于进一步处理录制好的视频 (比如存到相册) 以及对于用户关闭相机作出响应：\n\n<!-- more -->\n\n```\nUIImagePickerController *camera = [UIImagePickerController new];  \ncamera.sourceType = UIImagePickerControllerSourceTypeCamera;  \ncamera.mediaTypes = @[(NSString *)kUTTypeMovie];  \ncamera.delegate = self; \n```\n \n这是你实现一个功能完善的摄像机所需要写的所有代码。\n\n相机配置\n`UIImagePickerController` 提供了额外的配置选项。\n\n通过设置 `cameraDevice` 属性可以选择一个特定的相机。这是一个 `UIImagePickerControllerCameraDevice` 枚举，默认情况下是 `UIImagePickerControllerCameraDeviceRear`，你也可以把它设置为 `UIImagePickerControllerCameraDeviceFront`。每次都应事先确认你想要设置的相机是可用的：\n\n```\nUIImagePickerController *camera = …  \nif ([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront]) {  \n    [camera setCameraDevice:UIImagePickerControllerCameraDeviceFront];\n}\n```\n\n`videoQuality` 属性用于控制录制视频的质量。它允许你设置一个特定的编码预设，从而改变视频的比特率和分辨率。以下是六种预设：\n\n```\nenum {  \n   UIImagePickerControllerQualityTypeHigh             = 0,\n   UIImagePickerControllerQualityTypeMedium           = 1,  // default  value\n   UIImagePickerControllerQualityTypeLow              = 2,\n   UIImagePickerControllerQualityType640x480          = 3,\n   UIImagePickerControllerQualityTypeIFrame1280x720   = 4,\n   UIImagePickerControllerQualityTypeIFrame960x540    = 5\n};\ntypedef NSUInteger  UIImagePickerControllerQualityType; \n``` \n前三种为相对预设 (low, medium, high)。这些预设的编码配置会因设备不同而不同。如果选择 high，那么你选定的相机会提供给你该设备所能支持的最高画质。后面三种是特定分辨率的预设 (640x480 VGA, 960x540 iFrame, 和 1280x720 iFrame)。\n\n自定义 UI\n就像上面提到的，`UIImagePickerController` 自带一套相机 UI，可以直接使用。然而，你也可以自定义相机的控件，通过隐藏默认控件，然后创建带有控件的自定义视图，并覆盖在相机预览图层上面：\n\n```\nUIView *cameraOverlay = …  \npicker.showsCameraControls = NO;\npicker.cameraOverlayView = cameraOverlay;\n\n```\n\n>然后你需要将你覆盖层上的控件关联上 `UIImagePickerController` 的控制方法 (比如，`startVideoCapture` 和 `stopVideoCapture`)。\n\n<!--more-->\n\n### 二:AVFoundation\n\n\n>如果你想要更多关于处理捕获视频的方法，而这些方法是 `UIImagePickerController` 所不能提供的，那么你需要使用 `AVFoundation`。\n\n> `AVFoundation` 中关于视频捕获的主要的类是 `AVCaptureSession`。它负责调配影音输入与输出之间的数据流：\n\n#### AVCaptureSession setup\n\n>使用一个 `capture session`，你需要先实例化，添加输入与输出，接着启动从输入到输出之间的数据流：\n\n\n```\nAVCaptureSession *captureSession = [AVCaptureSession new];  \nAVCaptureDeviceInput *cameraDeviceInput = …  \nAVCaptureDeviceInput *micDeviceInput = …  \nAVCaptureMovieFileOutput *movieFileOutput = …  \nif ([captureSession canAddInput:cameraDeviceInput]) {  \n    [captureSession addInput:cameraDeviceInput];\n}\nif ([captureSession canAddInput:micDeviceInput]) {  \n    [captureSession addInput:micDeviceInput];\n}\nif ([captureSession canAddOutput:movieFileOutput]) {  \n    [captureSession addOutput:movieFileOutput];\n}\n\n[captureSession startRunning];\n```\n\n\n(为了简单起见，调度队列 (dispatch queue) 的相关代码已经从上面那段代码中省略了。所有对 `capture session` 的调用都是阻塞的，因此建议将它们分配到后台串行队列中。)\n\n`capture session` 可以通过一个 `sessionPreset` \n来进一步配置，这可以用来指定输出质量的等级。有 11 种不同的预设模式：\n\n```\nNSString *const  AVCaptureSessionPresetPhoto;  \nNSString *const  AVCaptureSessionPresetHigh;  \nNSString *const  AVCaptureSessionPresetMedium;  \nNSString *const  AVCaptureSessionPresetLow;  \nNSString *const  AVCaptureSessionPreset352x288;  \nNSString *const  AVCaptureSessionPreset640x480;  \nNSString *const  AVCaptureSessionPreset1280x720;  \nNSString *const  AVCaptureSessionPreset1920x1080;  \nNSString *const  AVCaptureSessionPresetiFrame960x540;  \nNSString *const  AVCaptureSessionPresetiFrame1280x720;  \nNSString *const  AVCaptureSessionPresetInputPriority;  \n```\n\n第一个代表高像素图片输出。 接下来的九个和之前我们在设置 `UIImagePickerController` 的 `videoQuality` 时看到过的 `UIImagePickerControllerQualityType` 选项非常相似，不同的是，这里有一些额外可用于 `capture session` 的预设。 最后一个 (AVCaptureSessionPresetInputPriority) 代表 `capture session` 不去控制音频与视频输出设置。而是通过已连接的捕获设备的 `activeFormat` 来反过来控制 `capture session` 的输出质量等级。在下一节，我们将会看到更多关于设备和设备格式的细节。\n\n#### 输入\n\n`AVCaptureSession` 的输入其实就是一个或多个的 `AVCaptureDevice` 对象，这些对象通过 `AVCaptureDeviceInput` 连接上 `capture session`。\n\n我们可以使用 `[AVCaptureDevice devices]` 来寻找可用的捕获设备。以 iPhone 6 为例：\n\n```\n(\n    “<AVCaptureFigVideoDevice: 0x136514db0 [Back Camera][com.apple.avfoundation.avcapturedevice.built-in_video:0]>”,\n    “<AVCaptureFigVideoDevice: 0x13660be80 [Front Camera][com.apple.avfoundation.avcapturedevice.built-in_video:1]>”,\n    “<AVCaptureFigAudioDevice: 0x174265e80 [iPhone Microphone][com.apple.avfoundation.avcapturedevice.built-in_audio:0]>”\n)\n```\n\n#### 视频输入\n\n- 配置相机输入，需要实例化一个 `AVCaptureDeviceInput` 对象，参数是你期望的相机设备，然后把它添加到 `capture session`：\n\n\n```\nAVCaptureSession *captureSession = …  \nAVCaptureDevice *cameraDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];  \nNSError *error;  \nAVCaptureDeviceInput *cameraDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:cameraDevice error:&error];  \nif ([captureSession canAddInput:input]) {  \n    [captureSession addInput:cameraDeviceInput];\n}\n```\n\n如果上面提到的 `capture session` 预设列表里能满足你的需求，那你就不需要做更多的事情了。如果不够，比如你想要高的帧率，你将需要配置具体的设备格式。一个视频捕获设备有许多设备格式，每个都带有特定的属性和功能。下面是对于 iPhone6 的后置摄像头的一些例子 (一共有 22 种可用格式)：\n\n```\n格式\t分辨率\tFPS\tHRSI\tFOV\tVIS\t最大放大比例\tUpscales\tAF\tISO\tSS\tHDR\n420v\t1280x720\t5 - 240\t1280x720\t54.626\tYES\t49.12\t1.09\t1\t29.0 - 928\t0.000003-0.200000\tNO\n420f\t1280x720\t5 - 240\t1280x720\t54.626\tYES\t49.12\t1.09\t1\t29.0 - 928\t0.000003-0.200000\tNO\n420v\t1920x1080\t2 - 30\t3264x1836\t58.040\tYES\t95.62\t1.55\t2\t29.0 - 464\t0.000013-0.500000\tYES\n420f\t1920x1080\t2 - 30\t3264x1836\t58.040\tYES\t95.62\t1.55\t2\t29.0 - 464\t0.000013-0.500000\tYES\n420v\t1920x1080\t2 - 60\t3264x1836\t58.040\tYES\t95.62\t1.55\t2\t29.0 - 464\t0.000008-0.500000\tYES\n420f\t1920x1080\t2 - 60\t3264x1836\t58.040\tYES\t95.62\t1.55\t2\t29.0 - 464\t0.000008-0.500000\tYES\n格式 = 像素格式\nFPS = 支持帧数范围\nHRSI = 高像素静态图片尺寸\nFOV = 视角\nVIS = 该格式支持视频防抖\nUpscales = 加入数字 upscaling 时的放大比例\nAF = 自动对焦系统（1 是反差对焦，2 是相位对焦）\nISO = 支持感光度范围\nSS = 支持曝光时间范围\nHDR = 支持高动态范围图像\n```\n\n通过上面的那些格式，你会发现如果要录制 240 帧每秒的视频的话，可以根据想要的像素格式选用第一个或第二个格式。另外若是要捕获 1920x1080 的分辨率的视频的话，是不支持 240 帧每秒的。\n\n配置一个具体设备格式，你首先需要调用 `lockForConfiguration`: 来获取设备的配置属性的独占访问权限。接着你简单地使用 `setActiveFormat`: 来设置设备的捕获格式。这将会自动把 `capture session` 的预设设置为 `AVCaptureSessionPresetInputPriority`。\n\n一旦你设置了预想的设备格式，你就可以在这种设备格式的约束参数范围内进行进一步的配置了。\n\n对于视频捕获的对焦，曝光和白平衡的设置，与图像捕获时一样，具体可参考第 21 期“iOS 上的相机捕捉”。除了那些，这里还有一些视频特有的配置选项。\n\n你可以用捕获设备的 `activeVideoMinFrameDuration` 和 `activeVideoMaxFrameDuration` 属性设置帧速率，一帧的时长是帧速率的倒数。设置帧速率之前，要先确认它是否在设备格式所支持的范围内，然后锁住捕获设备来进行配置。为了确保帧速率恒定，可以将最小与最大的帧时长设置成一样的值：\n\n```\nNSError *error;  \nCMTime frameDuration = CMTimeMake(1, 60);  \nNSArray *supportedFrameRateRanges = [device.activeFormat videoSupportedFrameRateRanges];  \nBOOL frameRateSupported = NO;  \nfor (AVFrameRateRange *range in supportedFrameRateRanges) {  \n    if (CMTIME_COMPARE_INLINE(frameDuration, >=, range.minFrameDuration) &&\n        CMTIME_COMPARE_INLINE(frameDuration, <=, range.maxFrameDuration)) {\n        frameRateSupported = YES;\n    }\n}\n\nif (frameRateSupported && [device lockForConfiguration:&error]) {  \n    [device setActiveVideoMaxFrameDuration:frameDuration];\n    [device setActiveVideoMinFrameDuration:frameDuration];\n    [device unlockForConfiguration];\n}\n```\n\n视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 `AVCaptureConnection` 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持：\n\n```\nAVCaptureDevice *device = ...;  \nAVCaptureConnection *connection = ...;\n\nAVCaptureVideoStabilizationMode stabilizationMode = AVCaptureVideoStabilizationModeCinematic;  \nif ([device.activeFormat isVideoStabilizationModeSupported:stabilizationMode]) {  \n    [connection setPreferredVideoStabilizationMode:stabilizationMode];\n}\n```\n\niPhone 6 的另一个新特性就是视频 HDR (高动态范围图像)，它是“高动态范围的视频流，与传统的将不同曝光度的静态图像合成成一张高动态范围图像的方法完全不同”，它是内建在传感器中的。有两种方法可以配置视频 HDR：直接将 `capture device` 的 `videoHDREnabled` 设置为启用或禁用，或者使用 `automaticallyAdjustsVideoHDREnabled` 属性来留给系统处理。\n\n技术参考：iPhone 6 和 iPhone Plus 的新 AV Foundation 相机特性\n\n#### 音频输入\n\n之前展示的捕获设备列表里面只有一个音频设备，你可能觉得奇怪，毕竟 iPhone 6 有 3 个麦克风。然而因为有时会放在一起使用，便于优化性能，因此可能被当做一个设备来使用。例如在 iPhone 5 及以上的手机录制视频时，会同时使用前置和后置麦克风，用于定向降噪。\n\nTechnical Q&A: AVAudioSession - Microphone Selection\n\n大多数情况下，设置成默认的麦克风配置即可。后置麦克风会自动搭配后置摄像头使用 (前置麦克风则用于降噪)，前置麦克风和前置摄像头也是一样。\n\n然而想要访问和配置单独的麦克风也是可行的。例如，当用户正在使用后置摄像头捕获场景的时候，使用前置麦克风来录制解说也应是可能的。这就要依赖于 `AVAudioSession`。 为了变更要访问的音频，`audio session` 首先需要设置为支持这样做的类别。然后我们需要遍历 `audio session` 的输入端口和端口数据来源，来找到我们想要的麦克风：\n\n```\n// 配置 audio session\nAVAudioSession *audioSession = [AVAudioSession sharedInstance];  \n[audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];\n[audioSession setActive:YES error:nil];\n\n// 寻找期望的输入端口\nNSArray* inputs = [audioSession availableInputs];  \nAVAudioSessionPortDescription *builtInMic = nil;  \nfor (AVAudioSessionPortDescription* port in inputs) {  \n    if ([port.portType isEqualToString:AVAudioSessionPortBuiltInMic]) {\n        builtInMic = port;\n        break;\n    }\n}\n\n// 寻找期望的麦克风\nfor (AVAudioSessionDataSourceDescription* source in builtInMic.dataSources) {  \n    if ([source.orientation isEqual:AVAudioSessionOrientationFront]) {\n        [builtInMic setPreferredDataSource:source error:nil];\n        [audioSession setPreferredInput:builtInMic error:&error];\n        break;\n    }\n}\n```\n\n除了设置非默认的麦克风配置，你也可以使用 `AVAudioSession` 来配置其他音频设置，比如音频增益和采样率等。\n\n#### 访问权限\n\n有件事你需要记住，访问相机和麦克风需要先获得用户授权。当你给视频或音频创建第一个 AVCaptureDeviceInput 对象时，iOS 会自动弹出一次对话框，请求用户授权，但你最好还是自己实现下。之后你就可以在还没有被授权的时候，使用相同的代码来提示用户进行授权。当用户未授权时，对于录制视频或音频的尝试，得到的将是黑色画面和无声。\n\n#### 输出\n\n输入配置完了，现在把我们的注意力转向 `capture session` 的输出。\n\n`AVCaptureMovieFileOutput`\n将视频写入文件，最简单的选择就是使用 `AVCaptureMovieFileOutput` 对象。把它作为输出添加到 `capture session` 中，就可以将视频和音频写入 `QuickTime` 文件，这只需很少的配置。\n\n```\nAVCaptureMovieFileOutput *movieFileOutput = [AVCaptureMovieFileOutput new];  \nif([captureSession canAddOutput:movieFileOutput]){  \n    [captureSession addOutput:movieFileOutput];\n}\n\n// 开始录制\nNSURL *outputURL = …  \n[movieFileOutput startRecordingToOutputFileURL:outputURL recordingDelegate:self];\n```\n\n当实际的录制开始或停止时，想要接收回调的话就必须要一个录制代理。当录制停止时，输出通常还在写入数据，等它完成之后会调用代理方法。\n\n`AVCaptureMovieFileOutput` 有一些其他的配置选项，比如在某段时间后，在达到某个指定的文件尺寸时，或者当设备的最小磁盘剩余空间达到某个阈值时停止录制。如果你还需要更多设置，比如自定义视频音频的压缩率，或者你想要在写入文件之前，处理视频音频的样本，那么你需要一些更复杂的操作。\n\n`AVCaptureDataOutput` 和 `AVAssetWriter`\n如果你想要对影音输出有更多的操作，你可以使用 `AVCaptureVideoDataOutput` 和 `AVCaptureAudioDataOutput` 而不是我们上节讨论的 `AVCaptureMovieFileOutput`。\n\n这些输出将会各自捕获视频和音频的样本缓存，接着发送到它们的代理。代理要么对采样缓冲进行处理 (比如给视频加滤镜)，要么保持原样传送。使用 `AVAssetWriter` 对象可以将样本缓存写入文件：\n\nUsing an AVAssetWriter\n\n配置一个 asset writer 需要定义一个输出 URL 和文件格式，并添加一个或多个输入来接收采样的缓冲。我们还需要将输入的 `expectsMediaInRealTime`属性设置为 YES，因为它们需要从 `capture session` 实时获得数据。\n\n```\nNSURL *url = …;  \nAVAssetWriter *assetWriter = [AVAssetWriter assetWriterWithURL:url fileType:AVFileTypeMPEG4 error:nil];  \nAVAssetWriterInput *videoInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:nil];  \nvideoInput.expectsMediaDataInRealTime = YES;  \nAVAssetWriterInput *audioInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeAudio outputSettings:nil];  \naudioInput.expectsMediaDataInRealTime = YES;  \nif ([assetWriter canAddInput:videoInput]) {  \n    [assetWriter addInput:videoInput];\n}\nif ([assetWriter canAddInput:audioInput]) {  \n    [assetWriter addInput:audioInput];\n}\n```\n\n(这里推荐将 asset writer 派送到后台串行队列中调用。)\n\n在上面的示例代码中，我们将 `asset writer` 的 `outputSettings` 设置为 nil。这就意味着附加上来的样本不会再被重新编码。如果你确实想要重新编码这些样本，那么需要提供一个包含具体输出参数的字典。关于音频输出设置的键值被定义在这里, 关于视频输出设置的键值定义在这里。\n\n为了更简单点，`AVCaptureVideoDataOutput` 和 `AVCaptureAudioDataOutput` 分别带有 `recommendedVideoSettingsForAssetWriterWithOutputFileType`: 和 `recommendedAudioSettingsForAssetWriterWithOutputFileType`: 方法，可以生成与 `asset writer` 兼容的带有全部键值对的字典。所以你可以通过在这个字典里调整你想要重写的属性，来简单地定义你自己的输出设置。比如，增加视频比特率来提高视频质量等。\n\n或者，你也可以使用 `AVOutputSettingsAssistant` 来配置输出设置的字典，但是从我的经验来看，使用上面的方法会更好，它们会提供更实用的输出设置，比如视频比特率。另外，`AVOutputSettingsAssistant` 似乎存在一些缺点，例如，当你改变希望的视频的帧速率时，视频的比特率并不会改变。\n\n实时预览\n当使用 AVFoundation 来做图像捕获时，我们必须提供一套自定义的用户界面。其中一个关键的相机交互组件是实时预览图。最简单的实现方式是通过把 `AVCaptureVideoPreviewLayer` 对象作为一个 `sublayer` 加到相机图层上去：\n\n```\nAVCaptureSession *captureSession = ...;  \nAVCaptureVideoPreviewLayer *previewLayer = [AVCaptureVideoPreviewLayer layerWithSession:captureSession];  \nUIView *cameraView = ...;  \npreviewLayer.frame = cameraView.bounds;  \n[cameraView.layer addSublayer:previewLayer];\n```\n\n如果你想要更进一步操作，比如，在实时预览图加滤镜，你需要将 `AVCaptureVideoDataOutput` 对象加到 `capture session`，并且使用 OpenGL 展示画面，具体可查看该文“iOS 上的相机捕捉”\n\n总结\n有许多不同的方法可以给 iOS 上的视频捕获配置管线，从最直接的 `UIImagePickerController`，到精密配合的 `AVCaptureSession` 与 `AVAssetWriter`。如何抉择取决于你的项目要求，比如期望的视频质量和压缩率，或者是你想要展示给用户的相机控件。\n\n[demo下载](https://github.com/suifengqjn/VideoCaptureDemo)\n\n\n\n\n\n\n\n\n\n","slug":"iOS三种录制视频方式","published":1,"updated":"2016-11-17T15:00:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmfb0009co606fi25hfy","content":"<blockquote>\n<p>A sample project demonstrating different video capture pipelines on iOS</p>\n</blockquote>\n<h3 id=\"一-相机相关知识\"><a href=\"#一-相机相关知识\" class=\"headerlink\" title=\"一:相机相关知识\"></a>一:相机相关知识</h3><p>UIImagePickerController<br>AVCaptureSession + AVMovieFileOutput<br>AVCaptureSession + AVAssetWriter</p>\n<p>随着每一代 iPhone 处理能力和相机硬件配置的提高，使用它来捕获视频也变得更加有意思。它们小巧，轻便，低调，而且与专业摄像机之间的差距已经变得非常小，小到在某些情况下，iPhone 可以真正替代它们。</p>\n<p>这篇文章讨论了关于如何配置视频捕获管线 (pipeline) 和最大限度地利用硬件性能的一些不同选择。 这里有个使用了不同管线的样例 app，可以在 <a href=\"https://github.com/suifengqjn/VideoCaptureDemo\" target=\"_blank\" rel=\"external\">GitHub</a> 查看。</p>\n<p><code>UIImagePickerController</code><br>目前，将视频捕获集成到你的应用中的最简单的方法是使用 <code>UIImagePickerController</code>。这是一个封装了完整视频捕获管线和相机 UI 的 <code>view controller</code>。</p>\n<p>在实例化相机之前，首先要检查设备是否支持相机录制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if ([UIImagePickerController  </div><div class=\"line\">       isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) &#123;</div><div class=\"line\">    NSArray *availableMediaTypes = [UIImagePickerController</div><div class=\"line\">      availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];</div><div class=\"line\">    if ([availableMediaTypes containsObject:(NSString *)kUTTypeMovie]) &#123;</div><div class=\"line\">        // 支持视频录制</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后创建一个 UIImagePickerController 对象，设置好代理便于进一步处理录制好的视频 (比如存到相册) 以及对于用户关闭相机作出响应：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIImagePickerController *camera = [UIImagePickerController new];  </div><div class=\"line\">camera.sourceType = UIImagePickerControllerSourceTypeCamera;  </div><div class=\"line\">camera.mediaTypes = @[(NSString *)kUTTypeMovie];  </div><div class=\"line\">camera.delegate = self;</div></pre></td></tr></table></figure>\n<p>这是你实现一个功能完善的摄像机所需要写的所有代码。</p>\n<p>相机配置<br><code>UIImagePickerController</code> 提供了额外的配置选项。</p>\n<p>通过设置 <code>cameraDevice</code> 属性可以选择一个特定的相机。这是一个 <code>UIImagePickerControllerCameraDevice</code> 枚举，默认情况下是 <code>UIImagePickerControllerCameraDeviceRear</code>，你也可以把它设置为 <code>UIImagePickerControllerCameraDeviceFront</code>。每次都应事先确认你想要设置的相机是可用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIImagePickerController *camera = …  </div><div class=\"line\">if ([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront]) &#123;  </div><div class=\"line\">    [camera setCameraDevice:UIImagePickerControllerCameraDeviceFront];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>videoQuality</code> 属性用于控制录制视频的质量。它允许你设置一个特定的编码预设，从而改变视频的比特率和分辨率。以下是六种预设：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum &#123;  </div><div class=\"line\">   UIImagePickerControllerQualityTypeHigh             = 0,</div><div class=\"line\">   UIImagePickerControllerQualityTypeMedium           = 1,  // default  value</div><div class=\"line\">   UIImagePickerControllerQualityTypeLow              = 2,</div><div class=\"line\">   UIImagePickerControllerQualityType640x480          = 3,</div><div class=\"line\">   UIImagePickerControllerQualityTypeIFrame1280x720   = 4,</div><div class=\"line\">   UIImagePickerControllerQualityTypeIFrame960x540    = 5</div><div class=\"line\">&#125;;</div><div class=\"line\">typedef NSUInteger  UIImagePickerControllerQualityType; </div><div class=\"line\">``` </div><div class=\"line\">前三种为相对预设 (low, medium, high)。这些预设的编码配置会因设备不同而不同。如果选择 high，那么你选定的相机会提供给你该设备所能支持的最高画质。后面三种是特定分辨率的预设 (640x480 VGA, 960x540 iFrame, 和 1280x720 iFrame)。</div><div class=\"line\"></div><div class=\"line\">自定义 UI</div><div class=\"line\">就像上面提到的，`UIImagePickerController` 自带一套相机 UI，可以直接使用。然而，你也可以自定义相机的控件，通过隐藏默认控件，然后创建带有控件的自定义视图，并覆盖在相机预览图层上面：</div></pre></td></tr></table></figure>\n<p>UIView *cameraOverlay = …<br>picker.showsCameraControls = NO;<br>picker.cameraOverlayView = cameraOverlay;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&gt;然后你需要将你覆盖层上的控件关联上 `UIImagePickerController` 的控制方法 (比如，`startVideoCapture` 和 `stopVideoCapture`)。</div><div class=\"line\"></div><div class=\"line\">&lt;!--more--&gt;</div><div class=\"line\"></div><div class=\"line\">### 二:AVFoundation</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&gt;如果你想要更多关于处理捕获视频的方法，而这些方法是 `UIImagePickerController` 所不能提供的，那么你需要使用 `AVFoundation`。</div><div class=\"line\"></div><div class=\"line\">&gt; `AVFoundation` 中关于视频捕获的主要的类是 `AVCaptureSession`。它负责调配影音输入与输出之间的数据流：</div><div class=\"line\"></div><div class=\"line\">#### AVCaptureSession setup</div><div class=\"line\"></div><div class=\"line\">&gt;使用一个 `capture session`，你需要先实例化，添加输入与输出，接着启动从输入到输出之间的数据流：</div></pre></td></tr></table></figure>\n<p>AVCaptureSession <em>captureSession = [AVCaptureSession new];<br>AVCaptureDeviceInput </em>cameraDeviceInput = …<br>AVCaptureDeviceInput <em>micDeviceInput = …<br>AVCaptureMovieFileOutput </em>movieFileOutput = …<br>if ([captureSession canAddInput:cameraDeviceInput]) {<br>    [captureSession addInput:cameraDeviceInput];<br>}<br>if ([captureSession canAddInput:micDeviceInput]) {<br>    [captureSession addInput:micDeviceInput];<br>}<br>if ([captureSession canAddOutput:movieFileOutput]) {<br>    [captureSession addOutput:movieFileOutput];<br>}</p>\n<p>[captureSession startRunning];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">(为了简单起见，调度队列 (dispatch queue) 的相关代码已经从上面那段代码中省略了。所有对 `capture session` 的调用都是阻塞的，因此建议将它们分配到后台串行队列中。)</div><div class=\"line\"></div><div class=\"line\">`capture session` 可以通过一个 `sessionPreset` </div><div class=\"line\">来进一步配置，这可以用来指定输出质量的等级。有 11 种不同的预设模式：</div></pre></td></tr></table></figure></p>\n<p>NSString <em>const  AVCaptureSessionPresetPhoto;<br>NSString </em>const  AVCaptureSessionPresetHigh;<br>NSString <em>const  AVCaptureSessionPresetMedium;<br>NSString </em>const  AVCaptureSessionPresetLow;<br>NSString <em>const  AVCaptureSessionPreset352x288;<br>NSString </em>const  AVCaptureSessionPreset640x480;<br>NSString <em>const  AVCaptureSessionPreset1280x720;<br>NSString </em>const  AVCaptureSessionPreset1920x1080;<br>NSString <em>const  AVCaptureSessionPresetiFrame960x540;<br>NSString </em>const  AVCaptureSessionPresetiFrame1280x720;<br>NSString *const  AVCaptureSessionPresetInputPriority;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">第一个代表高像素图片输出。 接下来的九个和之前我们在设置 `UIImagePickerController` 的 `videoQuality` 时看到过的 `UIImagePickerControllerQualityType` 选项非常相似，不同的是，这里有一些额外可用于 `capture session` 的预设。 最后一个 (AVCaptureSessionPresetInputPriority) 代表 `capture session` 不去控制音频与视频输出设置。而是通过已连接的捕获设备的 `activeFormat` 来反过来控制 `capture session` 的输出质量等级。在下一节，我们将会看到更多关于设备和设备格式的细节。</div><div class=\"line\"></div><div class=\"line\">#### 输入</div><div class=\"line\"></div><div class=\"line\">`AVCaptureSession` 的输入其实就是一个或多个的 `AVCaptureDevice` 对象，这些对象通过 `AVCaptureDeviceInput` 连接上 `capture session`。</div><div class=\"line\"></div><div class=\"line\">我们可以使用 `[AVCaptureDevice devices]` 来寻找可用的捕获设备。以 iPhone 6 为例：</div></pre></td></tr></table></figure></p>\n<p>(<br>    “<avcapturefigvideodevice: 0x136514db0=\"\" [back=\"\" camera][com.apple.avfoundation.avcapturedevice.built-in_video:0]=\"\">”,<br>    “<avcapturefigvideodevice: 0x13660be80=\"\" [front=\"\" camera][com.apple.avfoundation.avcapturedevice.built-in_video:1]=\"\">”,<br>    “<avcapturefigaudiodevice: 0x174265e80=\"\" [iphone=\"\" microphone][com.apple.avfoundation.avcapturedevice.built-in_audio:0]=\"\">”<br>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 视频输入</div><div class=\"line\"></div><div class=\"line\">- 配置相机输入，需要实例化一个 `AVCaptureDeviceInput` 对象，参数是你期望的相机设备，然后把它添加到 `capture session`：</div></pre></td></tr></table></figure></avcapturefigaudiodevice:></avcapturefigvideodevice:></avcapturefigvideodevice:></p>\n<p>AVCaptureSession <em>captureSession = …<br>AVCaptureDevice </em>cameraDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];<br>NSError <em>error;<br>AVCaptureDeviceInput </em>cameraDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:cameraDevice error:&amp;error];<br>if ([captureSession canAddInput:input]) {<br>    [captureSession addInput:cameraDeviceInput];<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">如果上面提到的 `capture session` 预设列表里能满足你的需求，那你就不需要做更多的事情了。如果不够，比如你想要高的帧率，你将需要配置具体的设备格式。一个视频捕获设备有许多设备格式，每个都带有特定的属性和功能。下面是对于 iPhone6 的后置摄像头的一些例子 (一共有 22 种可用格式)：</div></pre></td></tr></table></figure></p>\n<p>格式    分辨率    FPS    HRSI    FOV    VIS    最大放大比例    Upscales    AF    ISO    SS    HDR<br>420v    1280x720    5 - 240    1280x720    54.626    YES    49.12    1.09    1    29.0 - 928    0.000003-0.200000    NO<br>420f    1280x720    5 - 240    1280x720    54.626    YES    49.12    1.09    1    29.0 - 928    0.000003-0.200000    NO<br>420v    1920x1080    2 - 30    3264x1836    58.040    YES    95.62    1.55    2    29.0 - 464    0.000013-0.500000    YES<br>420f    1920x1080    2 - 30    3264x1836    58.040    YES    95.62    1.55    2    29.0 - 464    0.000013-0.500000    YES<br>420v    1920x1080    2 - 60    3264x1836    58.040    YES    95.62    1.55    2    29.0 - 464    0.000008-0.500000    YES<br>420f    1920x1080    2 - 60    3264x1836    58.040    YES    95.62    1.55    2    29.0 - 464    0.000008-0.500000    YES<br>格式 = 像素格式<br>FPS = 支持帧数范围<br>HRSI = 高像素静态图片尺寸<br>FOV = 视角<br>VIS = 该格式支持视频防抖<br>Upscales = 加入数字 upscaling 时的放大比例<br>AF = 自动对焦系统（1 是反差对焦，2 是相位对焦）<br>ISO = 支持感光度范围<br>SS = 支持曝光时间范围<br>HDR = 支持高动态范围图像<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">通过上面的那些格式，你会发现如果要录制 240 帧每秒的视频的话，可以根据想要的像素格式选用第一个或第二个格式。另外若是要捕获 1920x1080 的分辨率的视频的话，是不支持 240 帧每秒的。</div><div class=\"line\"></div><div class=\"line\">配置一个具体设备格式，你首先需要调用 `lockForConfiguration`: 来获取设备的配置属性的独占访问权限。接着你简单地使用 `setActiveFormat`: 来设置设备的捕获格式。这将会自动把 `capture session` 的预设设置为 `AVCaptureSessionPresetInputPriority`。</div><div class=\"line\"></div><div class=\"line\">一旦你设置了预想的设备格式，你就可以在这种设备格式的约束参数范围内进行进一步的配置了。</div><div class=\"line\"></div><div class=\"line\">对于视频捕获的对焦，曝光和白平衡的设置，与图像捕获时一样，具体可参考第 21 期“iOS 上的相机捕捉”。除了那些，这里还有一些视频特有的配置选项。</div><div class=\"line\"></div><div class=\"line\">你可以用捕获设备的 `activeVideoMinFrameDuration` 和 `activeVideoMaxFrameDuration` 属性设置帧速率，一帧的时长是帧速率的倒数。设置帧速率之前，要先确认它是否在设备格式所支持的范围内，然后锁住捕获设备来进行配置。为了确保帧速率恒定，可以将最小与最大的帧时长设置成一样的值：</div></pre></td></tr></table></figure></p>\n<p>NSError <em>error;<br>CMTime frameDuration = CMTimeMake(1, 60);<br>NSArray </em>supportedFrameRateRanges = [device.activeFormat videoSupportedFrameRateRanges];<br>BOOL frameRateSupported = NO;<br>for (AVFrameRateRange *range in supportedFrameRateRanges) {<br>    if (CMTIME_COMPARE_INLINE(frameDuration, &gt;=, range.minFrameDuration) &amp;&amp;<br>        CMTIME_COMPARE_INLINE(frameDuration, &lt;=, range.maxFrameDuration)) {<br>        frameRateSupported = YES;<br>    }<br>}</p>\n<p>if (frameRateSupported &amp;&amp; [device lockForConfiguration:&amp;error]) {<br>    [device setActiveVideoMaxFrameDuration:frameDuration];<br>    [device setActiveVideoMinFrameDuration:frameDuration];<br>    [device unlockForConfiguration];<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 `AVCaptureConnection` 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持：</div></pre></td></tr></table></figure></p>\n<p>AVCaptureDevice <em>device = …;<br>AVCaptureConnection </em>connection = …;</p>\n<p>AVCaptureVideoStabilizationMode stabilizationMode = AVCaptureVideoStabilizationModeCinematic;<br>if ([device.activeFormat isVideoStabilizationModeSupported:stabilizationMode]) {<br>    [connection setPreferredVideoStabilizationMode:stabilizationMode];<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">iPhone 6 的另一个新特性就是视频 HDR (高动态范围图像)，它是“高动态范围的视频流，与传统的将不同曝光度的静态图像合成成一张高动态范围图像的方法完全不同”，它是内建在传感器中的。有两种方法可以配置视频 HDR：直接将 `capture device` 的 `videoHDREnabled` 设置为启用或禁用，或者使用 `automaticallyAdjustsVideoHDREnabled` 属性来留给系统处理。</div><div class=\"line\"></div><div class=\"line\">技术参考：iPhone 6 和 iPhone Plus 的新 AV Foundation 相机特性</div><div class=\"line\"></div><div class=\"line\">#### 音频输入</div><div class=\"line\"></div><div class=\"line\">之前展示的捕获设备列表里面只有一个音频设备，你可能觉得奇怪，毕竟 iPhone 6 有 3 个麦克风。然而因为有时会放在一起使用，便于优化性能，因此可能被当做一个设备来使用。例如在 iPhone 5 及以上的手机录制视频时，会同时使用前置和后置麦克风，用于定向降噪。</div><div class=\"line\"></div><div class=\"line\">Technical Q&amp;A: AVAudioSession - Microphone Selection</div><div class=\"line\"></div><div class=\"line\">大多数情况下，设置成默认的麦克风配置即可。后置麦克风会自动搭配后置摄像头使用 (前置麦克风则用于降噪)，前置麦克风和前置摄像头也是一样。</div><div class=\"line\"></div><div class=\"line\">然而想要访问和配置单独的麦克风也是可行的。例如，当用户正在使用后置摄像头捕获场景的时候，使用前置麦克风来录制解说也应是可能的。这就要依赖于 `AVAudioSession`。 为了变更要访问的音频，`audio session` 首先需要设置为支持这样做的类别。然后我们需要遍历 `audio session` 的输入端口和端口数据来源，来找到我们想要的麦克风：</div></pre></td></tr></table></figure></p>\n<p>// 配置 audio session<br>AVAudioSession *audioSession = [AVAudioSession sharedInstance];<br>[audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];<br>[audioSession setActive:YES error:nil];</p>\n<p>// 寻找期望的输入端口<br>NSArray<em> inputs = [audioSession availableInputs];<br>AVAudioSessionPortDescription </em>builtInMic = nil;<br>for (AVAudioSessionPortDescription* port in inputs) {<br>    if ([port.portType isEqualToString:AVAudioSessionPortBuiltInMic]) {<br>        builtInMic = port;<br>        break;<br>    }<br>}</p>\n<p>// 寻找期望的麦克风<br>for (AVAudioSessionDataSourceDescription* source in builtInMic.dataSources) {<br>    if ([source.orientation isEqual:AVAudioSessionOrientationFront]) {<br>        [builtInMic setPreferredDataSource:source error:nil];<br>        [audioSession setPreferredInput:builtInMic error:&amp;error];<br>        break;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">除了设置非默认的麦克风配置，你也可以使用 `AVAudioSession` 来配置其他音频设置，比如音频增益和采样率等。</div><div class=\"line\"></div><div class=\"line\">#### 访问权限</div><div class=\"line\"></div><div class=\"line\">有件事你需要记住，访问相机和麦克风需要先获得用户授权。当你给视频或音频创建第一个 AVCaptureDeviceInput 对象时，iOS 会自动弹出一次对话框，请求用户授权，但你最好还是自己实现下。之后你就可以在还没有被授权的时候，使用相同的代码来提示用户进行授权。当用户未授权时，对于录制视频或音频的尝试，得到的将是黑色画面和无声。</div><div class=\"line\"></div><div class=\"line\">#### 输出</div><div class=\"line\"></div><div class=\"line\">输入配置完了，现在把我们的注意力转向 `capture session` 的输出。</div><div class=\"line\"></div><div class=\"line\">`AVCaptureMovieFileOutput`</div><div class=\"line\">将视频写入文件，最简单的选择就是使用 `AVCaptureMovieFileOutput` 对象。把它作为输出添加到 `capture session` 中，就可以将视频和音频写入 `QuickTime` 文件，这只需很少的配置。</div></pre></td></tr></table></figure></p>\n<p>AVCaptureMovieFileOutput *movieFileOutput = [AVCaptureMovieFileOutput new];<br>if([captureSession canAddOutput:movieFileOutput]){<br>    [captureSession addOutput:movieFileOutput];<br>}</p>\n<p>// 开始录制<br>NSURL *outputURL = …<br>[movieFileOutput startRecordingToOutputFileURL:outputURL recordingDelegate:self];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">当实际的录制开始或停止时，想要接收回调的话就必须要一个录制代理。当录制停止时，输出通常还在写入数据，等它完成之后会调用代理方法。</div><div class=\"line\"></div><div class=\"line\">`AVCaptureMovieFileOutput` 有一些其他的配置选项，比如在某段时间后，在达到某个指定的文件尺寸时，或者当设备的最小磁盘剩余空间达到某个阈值时停止录制。如果你还需要更多设置，比如自定义视频音频的压缩率，或者你想要在写入文件之前，处理视频音频的样本，那么你需要一些更复杂的操作。</div><div class=\"line\"></div><div class=\"line\">`AVCaptureDataOutput` 和 `AVAssetWriter`</div><div class=\"line\">如果你想要对影音输出有更多的操作，你可以使用 `AVCaptureVideoDataOutput` 和 `AVCaptureAudioDataOutput` 而不是我们上节讨论的 `AVCaptureMovieFileOutput`。</div><div class=\"line\"></div><div class=\"line\">这些输出将会各自捕获视频和音频的样本缓存，接着发送到它们的代理。代理要么对采样缓冲进行处理 (比如给视频加滤镜)，要么保持原样传送。使用 `AVAssetWriter` 对象可以将样本缓存写入文件：</div><div class=\"line\"></div><div class=\"line\">Using an AVAssetWriter</div><div class=\"line\"></div><div class=\"line\">配置一个 asset writer 需要定义一个输出 URL 和文件格式，并添加一个或多个输入来接收采样的缓冲。我们还需要将输入的 `expectsMediaInRealTime`属性设置为 YES，因为它们需要从 `capture session` 实时获得数据。</div></pre></td></tr></table></figure></p>\n<p>NSURL <em>url = …;<br>AVAssetWriter </em>assetWriter = [AVAssetWriter assetWriterWithURL:url fileType:AVFileTypeMPEG4 error:nil];<br>AVAssetWriterInput <em>videoInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:nil];<br>videoInput.expectsMediaDataInRealTime = YES;<br>AVAssetWriterInput </em>audioInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeAudio outputSettings:nil];<br>audioInput.expectsMediaDataInRealTime = YES;<br>if ([assetWriter canAddInput:videoInput]) {<br>    [assetWriter addInput:videoInput];<br>}<br>if ([assetWriter canAddInput:audioInput]) {<br>    [assetWriter addInput:audioInput];<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">(这里推荐将 asset writer 派送到后台串行队列中调用。)</div><div class=\"line\"></div><div class=\"line\">在上面的示例代码中，我们将 `asset writer` 的 `outputSettings` 设置为 nil。这就意味着附加上来的样本不会再被重新编码。如果你确实想要重新编码这些样本，那么需要提供一个包含具体输出参数的字典。关于音频输出设置的键值被定义在这里, 关于视频输出设置的键值定义在这里。</div><div class=\"line\"></div><div class=\"line\">为了更简单点，`AVCaptureVideoDataOutput` 和 `AVCaptureAudioDataOutput` 分别带有 `recommendedVideoSettingsForAssetWriterWithOutputFileType`: 和 `recommendedAudioSettingsForAssetWriterWithOutputFileType`: 方法，可以生成与 `asset writer` 兼容的带有全部键值对的字典。所以你可以通过在这个字典里调整你想要重写的属性，来简单地定义你自己的输出设置。比如，增加视频比特率来提高视频质量等。</div><div class=\"line\"></div><div class=\"line\">或者，你也可以使用 `AVOutputSettingsAssistant` 来配置输出设置的字典，但是从我的经验来看，使用上面的方法会更好，它们会提供更实用的输出设置，比如视频比特率。另外，`AVOutputSettingsAssistant` 似乎存在一些缺点，例如，当你改变希望的视频的帧速率时，视频的比特率并不会改变。</div><div class=\"line\"></div><div class=\"line\">实时预览</div><div class=\"line\">当使用 AVFoundation 来做图像捕获时，我们必须提供一套自定义的用户界面。其中一个关键的相机交互组件是实时预览图。最简单的实现方式是通过把 `AVCaptureVideoPreviewLayer` 对象作为一个 `sublayer` 加到相机图层上去：</div></pre></td></tr></table></figure></p>\n<p>AVCaptureSession <em>captureSession = …;<br>AVCaptureVideoPreviewLayer </em>previewLayer = [AVCaptureVideoPreviewLayer layerWithSession:captureSession];<br>UIView *cameraView = …;<br>previewLayer.frame = cameraView.bounds;<br>[cameraView.layer addSublayer:previewLayer];<br>```</p>\n<p>如果你想要更进一步操作，比如，在实时预览图加滤镜，你需要将 <code>AVCaptureVideoDataOutput</code> 对象加到 <code>capture session</code>，并且使用 OpenGL 展示画面，具体可查看该文“iOS 上的相机捕捉”</p>\n<p>总结<br>有许多不同的方法可以给 iOS 上的视频捕获配置管线，从最直接的 <code>UIImagePickerController</code>，到精密配合的 <code>AVCaptureSession</code> 与 <code>AVAssetWriter</code>。如何抉择取决于你的项目要求，比如期望的视频质量和压缩率，或者是你想要展示给用户的相机控件。</p>\n<p><a href=\"https://github.com/suifengqjn/VideoCaptureDemo\" target=\"_blank\" rel=\"external\">demo下载</a></p>\n","excerpt":"<blockquote>\n<p>A sample project demonstrating different video capture pipelines on iOS</p>\n</blockquote>\n<h3 id=\"一-相机相关知识\"><a href=\"#一-相机相关知识\" class=\"headerlink\" title=\"一:相机相关知识\"></a>一:相机相关知识</h3><p>UIImagePickerController<br>AVCaptureSession + AVMovieFileOutput<br>AVCaptureSession + AVAssetWriter</p>\n<p>随着每一代 iPhone 处理能力和相机硬件配置的提高，使用它来捕获视频也变得更加有意思。它们小巧，轻便，低调，而且与专业摄像机之间的差距已经变得非常小，小到在某些情况下，iPhone 可以真正替代它们。</p>\n<p>这篇文章讨论了关于如何配置视频捕获管线 (pipeline) 和最大限度地利用硬件性能的一些不同选择。 这里有个使用了不同管线的样例 app，可以在 <a href=\"https://github.com/suifengqjn/VideoCaptureDemo\">GitHub</a> 查看。</p>\n<p><code>UIImagePickerController</code><br>目前，将视频捕获集成到你的应用中的最简单的方法是使用 <code>UIImagePickerController</code>。这是一个封装了完整视频捕获管线和相机 UI 的 <code>view controller</code>。</p>\n<p>在实例化相机之前，首先要检查设备是否支持相机录制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">if ([UIImagePickerController  </div><div class=\"line\">       isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) &#123;</div><div class=\"line\">    NSArray *availableMediaTypes = [UIImagePickerController</div><div class=\"line\">      availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];</div><div class=\"line\">    if ([availableMediaTypes containsObject:(NSString *)kUTTypeMovie]) &#123;</div><div class=\"line\">        // 支持视频录制</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后创建一个 UIImagePickerController 对象，设置好代理便于进一步处理录制好的视频 (比如存到相册) 以及对于用户关闭相机作出响应：</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIImagePickerController *camera = [UIImagePickerController new];  </div><div class=\"line\">camera.sourceType = UIImagePickerControllerSourceTypeCamera;  </div><div class=\"line\">camera.mediaTypes = @[(NSString *)kUTTypeMovie];  </div><div class=\"line\">camera.delegate = self;</div></pre></td></tr></table></figure>\n<p>这是你实现一个功能完善的摄像机所需要写的所有代码。</p>\n<p>相机配置<br><code>UIImagePickerController</code> 提供了额外的配置选项。</p>\n<p>通过设置 <code>cameraDevice</code> 属性可以选择一个特定的相机。这是一个 <code>UIImagePickerControllerCameraDevice</code> 枚举，默认情况下是 <code>UIImagePickerControllerCameraDeviceRear</code>，你也可以把它设置为 <code>UIImagePickerControllerCameraDeviceFront</code>。每次都应事先确认你想要设置的相机是可用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIImagePickerController *camera = …  </div><div class=\"line\">if ([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront]) &#123;  </div><div class=\"line\">    [camera setCameraDevice:UIImagePickerControllerCameraDeviceFront];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>videoQuality</code> 属性用于控制录制视频的质量。它允许你设置一个特定的编码预设，从而改变视频的比特率和分辨率。以下是六种预设：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum &#123;  </div><div class=\"line\">   UIImagePickerControllerQualityTypeHigh             = 0,</div><div class=\"line\">   UIImagePickerControllerQualityTypeMedium           = 1,  // default  value</div><div class=\"line\">   UIImagePickerControllerQualityTypeLow              = 2,</div><div class=\"line\">   UIImagePickerControllerQualityType640x480          = 3,</div><div class=\"line\">   UIImagePickerControllerQualityTypeIFrame1280x720   = 4,</div><div class=\"line\">   UIImagePickerControllerQualityTypeIFrame960x540    = 5</div><div class=\"line\">&#125;;</div><div class=\"line\">typedef NSUInteger  UIImagePickerControllerQualityType; </div><div class=\"line\">``` </div><div class=\"line\">前三种为相对预设 (low, medium, high)。这些预设的编码配置会因设备不同而不同。如果选择 high，那么你选定的相机会提供给你该设备所能支持的最高画质。后面三种是特定分辨率的预设 (640x480 VGA, 960x540 iFrame, 和 1280x720 iFrame)。</div><div class=\"line\"></div><div class=\"line\">自定义 UI</div><div class=\"line\">就像上面提到的，`UIImagePickerController` 自带一套相机 UI，可以直接使用。然而，你也可以自定义相机的控件，通过隐藏默认控件，然后创建带有控件的自定义视图，并覆盖在相机预览图层上面：</div></pre></td></tr></table></figure>\n<p>UIView *cameraOverlay = …<br>picker.showsCameraControls = NO;<br>picker.cameraOverlayView = cameraOverlay;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&gt;然后你需要将你覆盖层上的控件关联上 `UIImagePickerController` 的控制方法 (比如，`startVideoCapture` 和 `stopVideoCapture`)。</div><div class=\"line\"></div><div class=\"line\">&lt;!--more--&gt;</div><div class=\"line\"></div><div class=\"line\">### 二:AVFoundation</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&gt;如果你想要更多关于处理捕获视频的方法，而这些方法是 `UIImagePickerController` 所不能提供的，那么你需要使用 `AVFoundation`。</div><div class=\"line\"></div><div class=\"line\">&gt; `AVFoundation` 中关于视频捕获的主要的类是 `AVCaptureSession`。它负责调配影音输入与输出之间的数据流：</div><div class=\"line\"></div><div class=\"line\">#### AVCaptureSession setup</div><div class=\"line\"></div><div class=\"line\">&gt;使用一个 `capture session`，你需要先实例化，添加输入与输出，接着启动从输入到输出之间的数据流：</div></pre></td></tr></table></figure>\n<p>AVCaptureSession <em>captureSession = [AVCaptureSession new];<br>AVCaptureDeviceInput </em>cameraDeviceInput = …<br>AVCaptureDeviceInput <em>micDeviceInput = …<br>AVCaptureMovieFileOutput </em>movieFileOutput = …<br>if ([captureSession canAddInput:cameraDeviceInput]) {<br>    [captureSession addInput:cameraDeviceInput];<br>}<br>if ([captureSession canAddInput:micDeviceInput]) {<br>    [captureSession addInput:micDeviceInput];<br>}<br>if ([captureSession canAddOutput:movieFileOutput]) {<br>    [captureSession addOutput:movieFileOutput];<br>}</p>\n<p>[captureSession startRunning];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">(为了简单起见，调度队列 (dispatch queue) 的相关代码已经从上面那段代码中省略了。所有对 `capture session` 的调用都是阻塞的，因此建议将它们分配到后台串行队列中。)</div><div class=\"line\"></div><div class=\"line\">`capture session` 可以通过一个 `sessionPreset` </div><div class=\"line\">来进一步配置，这可以用来指定输出质量的等级。有 11 种不同的预设模式：</div></pre></td></tr></table></figure></p>\n<p>NSString <em>const  AVCaptureSessionPresetPhoto;<br>NSString </em>const  AVCaptureSessionPresetHigh;<br>NSString <em>const  AVCaptureSessionPresetMedium;<br>NSString </em>const  AVCaptureSessionPresetLow;<br>NSString <em>const  AVCaptureSessionPreset352x288;<br>NSString </em>const  AVCaptureSessionPreset640x480;<br>NSString <em>const  AVCaptureSessionPreset1280x720;<br>NSString </em>const  AVCaptureSessionPreset1920x1080;<br>NSString <em>const  AVCaptureSessionPresetiFrame960x540;<br>NSString </em>const  AVCaptureSessionPresetiFrame1280x720;<br>NSString *const  AVCaptureSessionPresetInputPriority;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">第一个代表高像素图片输出。 接下来的九个和之前我们在设置 `UIImagePickerController` 的 `videoQuality` 时看到过的 `UIImagePickerControllerQualityType` 选项非常相似，不同的是，这里有一些额外可用于 `capture session` 的预设。 最后一个 (AVCaptureSessionPresetInputPriority) 代表 `capture session` 不去控制音频与视频输出设置。而是通过已连接的捕获设备的 `activeFormat` 来反过来控制 `capture session` 的输出质量等级。在下一节，我们将会看到更多关于设备和设备格式的细节。</div><div class=\"line\"></div><div class=\"line\">#### 输入</div><div class=\"line\"></div><div class=\"line\">`AVCaptureSession` 的输入其实就是一个或多个的 `AVCaptureDevice` 对象，这些对象通过 `AVCaptureDeviceInput` 连接上 `capture session`。</div><div class=\"line\"></div><div class=\"line\">我们可以使用 `[AVCaptureDevice devices]` 来寻找可用的捕获设备。以 iPhone 6 为例：</div></pre></td></tr></table></figure></p>\n<p>(<br>    “<AVCaptureFigVideoDevice: 0x136514db0 [Back Camera][com.apple.avfoundation.avcapturedevice.built-in_video:0]>”,<br>    “<AVCaptureFigVideoDevice: 0x13660be80 [Front Camera][com.apple.avfoundation.avcapturedevice.built-in_video:1]>”,<br>    “<AVCaptureFigAudioDevice: 0x174265e80 [iPhone Microphone][com.apple.avfoundation.avcapturedevice.built-in_audio:0]>”<br>)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 视频输入</div><div class=\"line\"></div><div class=\"line\">- 配置相机输入，需要实例化一个 `AVCaptureDeviceInput` 对象，参数是你期望的相机设备，然后把它添加到 `capture session`：</div></pre></td></tr></table></figure></p>\n<p>AVCaptureSession <em>captureSession = …<br>AVCaptureDevice </em>cameraDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];<br>NSError <em>error;<br>AVCaptureDeviceInput </em>cameraDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:cameraDevice error:&amp;error];<br>if ([captureSession canAddInput:input]) {<br>    [captureSession addInput:cameraDeviceInput];<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">如果上面提到的 `capture session` 预设列表里能满足你的需求，那你就不需要做更多的事情了。如果不够，比如你想要高的帧率，你将需要配置具体的设备格式。一个视频捕获设备有许多设备格式，每个都带有特定的属性和功能。下面是对于 iPhone6 的后置摄像头的一些例子 (一共有 22 种可用格式)：</div></pre></td></tr></table></figure></p>\n<p>格式    分辨率    FPS    HRSI    FOV    VIS    最大放大比例    Upscales    AF    ISO    SS    HDR<br>420v    1280x720    5 - 240    1280x720    54.626    YES    49.12    1.09    1    29.0 - 928    0.000003-0.200000    NO<br>420f    1280x720    5 - 240    1280x720    54.626    YES    49.12    1.09    1    29.0 - 928    0.000003-0.200000    NO<br>420v    1920x1080    2 - 30    3264x1836    58.040    YES    95.62    1.55    2    29.0 - 464    0.000013-0.500000    YES<br>420f    1920x1080    2 - 30    3264x1836    58.040    YES    95.62    1.55    2    29.0 - 464    0.000013-0.500000    YES<br>420v    1920x1080    2 - 60    3264x1836    58.040    YES    95.62    1.55    2    29.0 - 464    0.000008-0.500000    YES<br>420f    1920x1080    2 - 60    3264x1836    58.040    YES    95.62    1.55    2    29.0 - 464    0.000008-0.500000    YES<br>格式 = 像素格式<br>FPS = 支持帧数范围<br>HRSI = 高像素静态图片尺寸<br>FOV = 视角<br>VIS = 该格式支持视频防抖<br>Upscales = 加入数字 upscaling 时的放大比例<br>AF = 自动对焦系统（1 是反差对焦，2 是相位对焦）<br>ISO = 支持感光度范围<br>SS = 支持曝光时间范围<br>HDR = 支持高动态范围图像<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">通过上面的那些格式，你会发现如果要录制 240 帧每秒的视频的话，可以根据想要的像素格式选用第一个或第二个格式。另外若是要捕获 1920x1080 的分辨率的视频的话，是不支持 240 帧每秒的。</div><div class=\"line\"></div><div class=\"line\">配置一个具体设备格式，你首先需要调用 `lockForConfiguration`: 来获取设备的配置属性的独占访问权限。接着你简单地使用 `setActiveFormat`: 来设置设备的捕获格式。这将会自动把 `capture session` 的预设设置为 `AVCaptureSessionPresetInputPriority`。</div><div class=\"line\"></div><div class=\"line\">一旦你设置了预想的设备格式，你就可以在这种设备格式的约束参数范围内进行进一步的配置了。</div><div class=\"line\"></div><div class=\"line\">对于视频捕获的对焦，曝光和白平衡的设置，与图像捕获时一样，具体可参考第 21 期“iOS 上的相机捕捉”。除了那些，这里还有一些视频特有的配置选项。</div><div class=\"line\"></div><div class=\"line\">你可以用捕获设备的 `activeVideoMinFrameDuration` 和 `activeVideoMaxFrameDuration` 属性设置帧速率，一帧的时长是帧速率的倒数。设置帧速率之前，要先确认它是否在设备格式所支持的范围内，然后锁住捕获设备来进行配置。为了确保帧速率恒定，可以将最小与最大的帧时长设置成一样的值：</div></pre></td></tr></table></figure></p>\n<p>NSError <em>error;<br>CMTime frameDuration = CMTimeMake(1, 60);<br>NSArray </em>supportedFrameRateRanges = [device.activeFormat videoSupportedFrameRateRanges];<br>BOOL frameRateSupported = NO;<br>for (AVFrameRateRange *range in supportedFrameRateRanges) {<br>    if (CMTIME_COMPARE_INLINE(frameDuration, &gt;=, range.minFrameDuration) &amp;&amp;<br>        CMTIME_COMPARE_INLINE(frameDuration, &lt;=, range.maxFrameDuration)) {<br>        frameRateSupported = YES;<br>    }<br>}</p>\n<p>if (frameRateSupported &amp;&amp; [device lockForConfiguration:&amp;error]) {<br>    [device setActiveVideoMaxFrameDuration:frameDuration];<br>    [device setActiveVideoMinFrameDuration:frameDuration];<br>    [device unlockForConfiguration];<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 `AVCaptureConnection` 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持：</div></pre></td></tr></table></figure></p>\n<p>AVCaptureDevice <em>device = …;<br>AVCaptureConnection </em>connection = …;</p>\n<p>AVCaptureVideoStabilizationMode stabilizationMode = AVCaptureVideoStabilizationModeCinematic;<br>if ([device.activeFormat isVideoStabilizationModeSupported:stabilizationMode]) {<br>    [connection setPreferredVideoStabilizationMode:stabilizationMode];<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">iPhone 6 的另一个新特性就是视频 HDR (高动态范围图像)，它是“高动态范围的视频流，与传统的将不同曝光度的静态图像合成成一张高动态范围图像的方法完全不同”，它是内建在传感器中的。有两种方法可以配置视频 HDR：直接将 `capture device` 的 `videoHDREnabled` 设置为启用或禁用，或者使用 `automaticallyAdjustsVideoHDREnabled` 属性来留给系统处理。</div><div class=\"line\"></div><div class=\"line\">技术参考：iPhone 6 和 iPhone Plus 的新 AV Foundation 相机特性</div><div class=\"line\"></div><div class=\"line\">#### 音频输入</div><div class=\"line\"></div><div class=\"line\">之前展示的捕获设备列表里面只有一个音频设备，你可能觉得奇怪，毕竟 iPhone 6 有 3 个麦克风。然而因为有时会放在一起使用，便于优化性能，因此可能被当做一个设备来使用。例如在 iPhone 5 及以上的手机录制视频时，会同时使用前置和后置麦克风，用于定向降噪。</div><div class=\"line\"></div><div class=\"line\">Technical Q&amp;A: AVAudioSession - Microphone Selection</div><div class=\"line\"></div><div class=\"line\">大多数情况下，设置成默认的麦克风配置即可。后置麦克风会自动搭配后置摄像头使用 (前置麦克风则用于降噪)，前置麦克风和前置摄像头也是一样。</div><div class=\"line\"></div><div class=\"line\">然而想要访问和配置单独的麦克风也是可行的。例如，当用户正在使用后置摄像头捕获场景的时候，使用前置麦克风来录制解说也应是可能的。这就要依赖于 `AVAudioSession`。 为了变更要访问的音频，`audio session` 首先需要设置为支持这样做的类别。然后我们需要遍历 `audio session` 的输入端口和端口数据来源，来找到我们想要的麦克风：</div></pre></td></tr></table></figure></p>\n<p>// 配置 audio session<br>AVAudioSession *audioSession = [AVAudioSession sharedInstance];<br>[audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];<br>[audioSession setActive:YES error:nil];</p>\n<p>// 寻找期望的输入端口<br>NSArray<em> inputs = [audioSession availableInputs];<br>AVAudioSessionPortDescription </em>builtInMic = nil;<br>for (AVAudioSessionPortDescription* port in inputs) {<br>    if ([port.portType isEqualToString:AVAudioSessionPortBuiltInMic]) {<br>        builtInMic = port;<br>        break;<br>    }<br>}</p>\n<p>// 寻找期望的麦克风<br>for (AVAudioSessionDataSourceDescription* source in builtInMic.dataSources) {<br>    if ([source.orientation isEqual:AVAudioSessionOrientationFront]) {<br>        [builtInMic setPreferredDataSource:source error:nil];<br>        [audioSession setPreferredInput:builtInMic error:&amp;error];<br>        break;<br>    }<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">除了设置非默认的麦克风配置，你也可以使用 `AVAudioSession` 来配置其他音频设置，比如音频增益和采样率等。</div><div class=\"line\"></div><div class=\"line\">#### 访问权限</div><div class=\"line\"></div><div class=\"line\">有件事你需要记住，访问相机和麦克风需要先获得用户授权。当你给视频或音频创建第一个 AVCaptureDeviceInput 对象时，iOS 会自动弹出一次对话框，请求用户授权，但你最好还是自己实现下。之后你就可以在还没有被授权的时候，使用相同的代码来提示用户进行授权。当用户未授权时，对于录制视频或音频的尝试，得到的将是黑色画面和无声。</div><div class=\"line\"></div><div class=\"line\">#### 输出</div><div class=\"line\"></div><div class=\"line\">输入配置完了，现在把我们的注意力转向 `capture session` 的输出。</div><div class=\"line\"></div><div class=\"line\">`AVCaptureMovieFileOutput`</div><div class=\"line\">将视频写入文件，最简单的选择就是使用 `AVCaptureMovieFileOutput` 对象。把它作为输出添加到 `capture session` 中，就可以将视频和音频写入 `QuickTime` 文件，这只需很少的配置。</div></pre></td></tr></table></figure></p>\n<p>AVCaptureMovieFileOutput *movieFileOutput = [AVCaptureMovieFileOutput new];<br>if([captureSession canAddOutput:movieFileOutput]){<br>    [captureSession addOutput:movieFileOutput];<br>}</p>\n<p>// 开始录制<br>NSURL *outputURL = …<br>[movieFileOutput startRecordingToOutputFileURL:outputURL recordingDelegate:self];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">当实际的录制开始或停止时，想要接收回调的话就必须要一个录制代理。当录制停止时，输出通常还在写入数据，等它完成之后会调用代理方法。</div><div class=\"line\"></div><div class=\"line\">`AVCaptureMovieFileOutput` 有一些其他的配置选项，比如在某段时间后，在达到某个指定的文件尺寸时，或者当设备的最小磁盘剩余空间达到某个阈值时停止录制。如果你还需要更多设置，比如自定义视频音频的压缩率，或者你想要在写入文件之前，处理视频音频的样本，那么你需要一些更复杂的操作。</div><div class=\"line\"></div><div class=\"line\">`AVCaptureDataOutput` 和 `AVAssetWriter`</div><div class=\"line\">如果你想要对影音输出有更多的操作，你可以使用 `AVCaptureVideoDataOutput` 和 `AVCaptureAudioDataOutput` 而不是我们上节讨论的 `AVCaptureMovieFileOutput`。</div><div class=\"line\"></div><div class=\"line\">这些输出将会各自捕获视频和音频的样本缓存，接着发送到它们的代理。代理要么对采样缓冲进行处理 (比如给视频加滤镜)，要么保持原样传送。使用 `AVAssetWriter` 对象可以将样本缓存写入文件：</div><div class=\"line\"></div><div class=\"line\">Using an AVAssetWriter</div><div class=\"line\"></div><div class=\"line\">配置一个 asset writer 需要定义一个输出 URL 和文件格式，并添加一个或多个输入来接收采样的缓冲。我们还需要将输入的 `expectsMediaInRealTime`属性设置为 YES，因为它们需要从 `capture session` 实时获得数据。</div></pre></td></tr></table></figure></p>\n<p>NSURL <em>url = …;<br>AVAssetWriter </em>assetWriter = [AVAssetWriter assetWriterWithURL:url fileType:AVFileTypeMPEG4 error:nil];<br>AVAssetWriterInput <em>videoInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:nil];<br>videoInput.expectsMediaDataInRealTime = YES;<br>AVAssetWriterInput </em>audioInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeAudio outputSettings:nil];<br>audioInput.expectsMediaDataInRealTime = YES;<br>if ([assetWriter canAddInput:videoInput]) {<br>    [assetWriter addInput:videoInput];<br>}<br>if ([assetWriter canAddInput:audioInput]) {<br>    [assetWriter addInput:audioInput];<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">(这里推荐将 asset writer 派送到后台串行队列中调用。)</div><div class=\"line\"></div><div class=\"line\">在上面的示例代码中，我们将 `asset writer` 的 `outputSettings` 设置为 nil。这就意味着附加上来的样本不会再被重新编码。如果你确实想要重新编码这些样本，那么需要提供一个包含具体输出参数的字典。关于音频输出设置的键值被定义在这里, 关于视频输出设置的键值定义在这里。</div><div class=\"line\"></div><div class=\"line\">为了更简单点，`AVCaptureVideoDataOutput` 和 `AVCaptureAudioDataOutput` 分别带有 `recommendedVideoSettingsForAssetWriterWithOutputFileType`: 和 `recommendedAudioSettingsForAssetWriterWithOutputFileType`: 方法，可以生成与 `asset writer` 兼容的带有全部键值对的字典。所以你可以通过在这个字典里调整你想要重写的属性，来简单地定义你自己的输出设置。比如，增加视频比特率来提高视频质量等。</div><div class=\"line\"></div><div class=\"line\">或者，你也可以使用 `AVOutputSettingsAssistant` 来配置输出设置的字典，但是从我的经验来看，使用上面的方法会更好，它们会提供更实用的输出设置，比如视频比特率。另外，`AVOutputSettingsAssistant` 似乎存在一些缺点，例如，当你改变希望的视频的帧速率时，视频的比特率并不会改变。</div><div class=\"line\"></div><div class=\"line\">实时预览</div><div class=\"line\">当使用 AVFoundation 来做图像捕获时，我们必须提供一套自定义的用户界面。其中一个关键的相机交互组件是实时预览图。最简单的实现方式是通过把 `AVCaptureVideoPreviewLayer` 对象作为一个 `sublayer` 加到相机图层上去：</div></pre></td></tr></table></figure></p>\n<p>AVCaptureSession <em>captureSession = …;<br>AVCaptureVideoPreviewLayer </em>previewLayer = [AVCaptureVideoPreviewLayer layerWithSession:captureSession];<br>UIView *cameraView = …;<br>previewLayer.frame = cameraView.bounds;<br>[cameraView.layer addSublayer:previewLayer];<br>```</p>\n<p>如果你想要更进一步操作，比如，在实时预览图加滤镜，你需要将 <code>AVCaptureVideoDataOutput</code> 对象加到 <code>capture session</code>，并且使用 OpenGL 展示画面，具体可查看该文“iOS 上的相机捕捉”</p>\n<p>总结<br>有许多不同的方法可以给 iOS 上的视频捕获配置管线，从最直接的 <code>UIImagePickerController</code>，到精密配合的 <code>AVCaptureSession</code> 与 <code>AVAssetWriter</code>。如何抉择取决于你的项目要求，比如期望的视频质量和压缩率，或者是你想要展示给用户的相机控件。</p>\n<p><a href=\"https://github.com/suifengqjn/VideoCaptureDemo\">demo下载</a></p>"},{"title":"iOS缓存机制-非结构化存储","date":"2016-03-12T11:43:33.000Z","_content":"\n对于一个优秀的app来说，缓存机制必不可少。图片，视频，音频等等各种类型的文件，怎么样去更好的管理这些数据，这对于我们开发者以及用户都是息息相关的。闲话不多说，先来看看几个github开源中牛逼的几个缓存框架。\n\n它们的使用方式都很类似，都是通过键值对(key-value)的形式进行存取，跟`NSUserDefaults`用法类似。\n\n以下排名按照性能由低到高：\n### 1.EGOCache\n \n 只提供磁盘缓存，没有内存缓存，一个比较简易的缓存框架。\n\n### 2.TMCache\n \n 最初由 Tumblr 开发，但现在已经不再维护了。TMMemoryCache 实现有很多 NSCache 并没有提供的功能，比如数量限制、总容量限制、存活时间限制、内存警告或应用退到后台时清空缓存等。TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行。它错误的用了大量异步 block 回调来实现存取功能，以至于产生了很大的性能和死锁问题。它有磁盘缓存和内存缓存两部分组成，个人感觉一般好点的缓存库都会由磁盘缓存和内存缓存两部分组成，在我们第一次存储一个文件到磁盘的时候，缓存库会帮我们复制一份到内存缓存中，可以让我们在下次使用该文件的时候可以更快的找到。我上家公司就是用的这个缓存框架，挺好用的，也没出什么问题。\n \n### 3.PINCache \n \n 是 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的一个内存缓存。它的功能和接口基本和 TMCache 一样，但修复了性能和死锁的问题。它同样也用 dispatch_semaphore 来保证线程安全，但去掉了dispatch_barrier_async，避免了线程切换带来的巨大开销，也避免了可能的死锁。相当于是TMCache的优化版，而且一直有更新。\n \n<!-- more -->\n \n### 4.YYCache\n \n YYMemoryCache相对于 PINMemoryCache 来说，去掉了异步访问的接口，尽量优化了同步访问的性能，用 OSSpinLock 来保证线程安全。另外，缓存内部用双向链表和 NSDictionary 实现了 LRU 淘汰算法,性能好一点。TMDiskCache, PINDiskCache, SDWebImage 等缓存，都是基于文件系统的，即一个 Value 对应一个文件，通过文件读写来缓存数据。他们的实现都比较简单，性能也都相近，缺点也是同样的：不方便扩展、没有元数据、难以实现较好的淘汰算法、数据统计缓慢。YYDiskCache 也是采用的 SQLite 配合文件的存储方式，在 iPhone 6 64G 上的性能基准测试结果见下图。在存取小数据 (NSNumber) 时，YYDiskCache 的性能远远高出基于文件存储的库；而较大数据的存取性能则比较接近了。但得益于 SQLite 存储的元数据，YYDiskCache 实现了 LRU 淘汰算法、更快的数据统计，更多的容量控制选项。\n \n ![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/KVCahce/1.png)\n \n YYCache相比较与前面几个，性能是最好的一个，但是差距也不是太大，而且他的使用需要依赖库，个人感觉用PinCache就可以了。\n 下面是我通过PinCache改进的KVCache，在PinCahce的基础上增加了以下几个功能。\n \n ```\n 1. 可以设置缓存上限，设置一定时间内定时清理缓存\n 2. 增加缓存类型，jpg，MP4，MP3，gif，等自动保存相应类型\n 3. 增加缓存区块，不同模块的文件可以缓存到各自对应的区域\n 4. 以上所有参数都可以根据自己的需求自行设置\n ```\n [demo地址](https://github.com/suifengqjn/KVCache)\n \n [github Blog同步更新](http://gcblog.gtihub.io)\n \n\n\n","source":"_posts/iOS缓存机制-非结构化存储.md","raw":"---\ntitle: iOS缓存机制-非结构化存储\ndate: 2016-03-12 19:43:33\ntags: [iOS, 缓存, 性能]\ncategories: \n- iOS技术\n---\n\n对于一个优秀的app来说，缓存机制必不可少。图片，视频，音频等等各种类型的文件，怎么样去更好的管理这些数据，这对于我们开发者以及用户都是息息相关的。闲话不多说，先来看看几个github开源中牛逼的几个缓存框架。\n\n它们的使用方式都很类似，都是通过键值对(key-value)的形式进行存取，跟`NSUserDefaults`用法类似。\n\n以下排名按照性能由低到高：\n### 1.EGOCache\n \n 只提供磁盘缓存，没有内存缓存，一个比较简易的缓存框架。\n\n### 2.TMCache\n \n 最初由 Tumblr 开发，但现在已经不再维护了。TMMemoryCache 实现有很多 NSCache 并没有提供的功能，比如数量限制、总容量限制、存活时间限制、内存警告或应用退到后台时清空缓存等。TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行。它错误的用了大量异步 block 回调来实现存取功能，以至于产生了很大的性能和死锁问题。它有磁盘缓存和内存缓存两部分组成，个人感觉一般好点的缓存库都会由磁盘缓存和内存缓存两部分组成，在我们第一次存储一个文件到磁盘的时候，缓存库会帮我们复制一份到内存缓存中，可以让我们在下次使用该文件的时候可以更快的找到。我上家公司就是用的这个缓存框架，挺好用的，也没出什么问题。\n \n### 3.PINCache \n \n 是 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的一个内存缓存。它的功能和接口基本和 TMCache 一样，但修复了性能和死锁的问题。它同样也用 dispatch_semaphore 来保证线程安全，但去掉了dispatch_barrier_async，避免了线程切换带来的巨大开销，也避免了可能的死锁。相当于是TMCache的优化版，而且一直有更新。\n \n<!-- more -->\n \n### 4.YYCache\n \n YYMemoryCache相对于 PINMemoryCache 来说，去掉了异步访问的接口，尽量优化了同步访问的性能，用 OSSpinLock 来保证线程安全。另外，缓存内部用双向链表和 NSDictionary 实现了 LRU 淘汰算法,性能好一点。TMDiskCache, PINDiskCache, SDWebImage 等缓存，都是基于文件系统的，即一个 Value 对应一个文件，通过文件读写来缓存数据。他们的实现都比较简单，性能也都相近，缺点也是同样的：不方便扩展、没有元数据、难以实现较好的淘汰算法、数据统计缓慢。YYDiskCache 也是采用的 SQLite 配合文件的存储方式，在 iPhone 6 64G 上的性能基准测试结果见下图。在存取小数据 (NSNumber) 时，YYDiskCache 的性能远远高出基于文件存储的库；而较大数据的存取性能则比较接近了。但得益于 SQLite 存储的元数据，YYDiskCache 实现了 LRU 淘汰算法、更快的数据统计，更多的容量控制选项。\n \n ![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/KVCahce/1.png)\n \n YYCache相比较与前面几个，性能是最好的一个，但是差距也不是太大，而且他的使用需要依赖库，个人感觉用PinCache就可以了。\n 下面是我通过PinCache改进的KVCache，在PinCahce的基础上增加了以下几个功能。\n \n ```\n 1. 可以设置缓存上限，设置一定时间内定时清理缓存\n 2. 增加缓存类型，jpg，MP4，MP3，gif，等自动保存相应类型\n 3. 增加缓存区块，不同模块的文件可以缓存到各自对应的区域\n 4. 以上所有参数都可以根据自己的需求自行设置\n ```\n [demo地址](https://github.com/suifengqjn/KVCache)\n \n [github Blog同步更新](http://gcblog.gtihub.io)\n \n\n\n","slug":"iOS缓存机制-非结构化存储","published":1,"updated":"2016-11-17T15:00:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmfo000bco60iwpma648","content":"<p>对于一个优秀的app来说，缓存机制必不可少。图片，视频，音频等等各种类型的文件，怎么样去更好的管理这些数据，这对于我们开发者以及用户都是息息相关的。闲话不多说，先来看看几个github开源中牛逼的几个缓存框架。</p>\n<p>它们的使用方式都很类似，都是通过键值对(key-value)的形式进行存取，跟<code>NSUserDefaults</code>用法类似。</p>\n<p>以下排名按照性能由低到高：</p>\n<h3 id=\"1-EGOCache\"><a href=\"#1-EGOCache\" class=\"headerlink\" title=\"1.EGOCache\"></a>1.EGOCache</h3><p> 只提供磁盘缓存，没有内存缓存，一个比较简易的缓存框架。</p>\n<h3 id=\"2-TMCache\"><a href=\"#2-TMCache\" class=\"headerlink\" title=\"2.TMCache\"></a>2.TMCache</h3><p> 最初由 Tumblr 开发，但现在已经不再维护了。TMMemoryCache 实现有很多 NSCache 并没有提供的功能，比如数量限制、总容量限制、存活时间限制、内存警告或应用退到后台时清空缓存等。TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行。它错误的用了大量异步 block 回调来实现存取功能，以至于产生了很大的性能和死锁问题。它有磁盘缓存和内存缓存两部分组成，个人感觉一般好点的缓存库都会由磁盘缓存和内存缓存两部分组成，在我们第一次存储一个文件到磁盘的时候，缓存库会帮我们复制一份到内存缓存中，可以让我们在下次使用该文件的时候可以更快的找到。我上家公司就是用的这个缓存框架，挺好用的，也没出什么问题。</p>\n<h3 id=\"3-PINCache\"><a href=\"#3-PINCache\" class=\"headerlink\" title=\"3.PINCache\"></a>3.PINCache</h3><p> 是 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的一个内存缓存。它的功能和接口基本和 TMCache 一样，但修复了性能和死锁的问题。它同样也用 dispatch_semaphore 来保证线程安全，但去掉了dispatch_barrier_async，避免了线程切换带来的巨大开销，也避免了可能的死锁。相当于是TMCache的优化版，而且一直有更新。</p>\n<a id=\"more\"></a>\n<h3 id=\"4-YYCache\"><a href=\"#4-YYCache\" class=\"headerlink\" title=\"4.YYCache\"></a>4.YYCache</h3><p> YYMemoryCache相对于 PINMemoryCache 来说，去掉了异步访问的接口，尽量优化了同步访问的性能，用 OSSpinLock 来保证线程安全。另外，缓存内部用双向链表和 NSDictionary 实现了 LRU 淘汰算法,性能好一点。TMDiskCache, PINDiskCache, SDWebImage 等缓存，都是基于文件系统的，即一个 Value 对应一个文件，通过文件读写来缓存数据。他们的实现都比较简单，性能也都相近，缺点也是同样的：不方便扩展、没有元数据、难以实现较好的淘汰算法、数据统计缓慢。YYDiskCache 也是采用的 SQLite 配合文件的存储方式，在 iPhone 6 64G 上的性能基准测试结果见下图。在存取小数据 (NSNumber) 时，YYDiskCache 的性能远远高出基于文件存储的库；而较大数据的存取性能则比较接近了。但得益于 SQLite 存储的元数据，YYDiskCache 实现了 LRU 淘汰算法、更快的数据统计，更多的容量控制选项。</p>\n<p> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/KVCahce/1.png\" alt=\"image\"></p>\n<p> YYCache相比较与前面几个，性能是最好的一个，但是差距也不是太大，而且他的使用需要依赖库，个人感觉用PinCache就可以了。<br> 下面是我通过PinCache改进的KVCache，在PinCahce的基础上增加了以下几个功能。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 可以设置缓存上限，设置一定时间内定时清理缓存</div><div class=\"line\">2. 增加缓存类型，jpg，MP4，MP3，gif，等自动保存相应类型</div><div class=\"line\">3. 增加缓存区块，不同模块的文件可以缓存到各自对应的区域</div><div class=\"line\">4. 以上所有参数都可以根据自己的需求自行设置</div></pre></td></tr></table></figure>\n<p> <a href=\"https://github.com/suifengqjn/KVCache\" target=\"_blank\" rel=\"external\">demo地址</a></p>\n<p> <a href=\"http://gcblog.gtihub.io\" target=\"_blank\" rel=\"external\">github Blog同步更新</a></p>\n","excerpt":"<p>对于一个优秀的app来说，缓存机制必不可少。图片，视频，音频等等各种类型的文件，怎么样去更好的管理这些数据，这对于我们开发者以及用户都是息息相关的。闲话不多说，先来看看几个github开源中牛逼的几个缓存框架。</p>\n<p>它们的使用方式都很类似，都是通过键值对(key-value)的形式进行存取，跟<code>NSUserDefaults</code>用法类似。</p>\n<p>以下排名按照性能由低到高：</p>\n<h3 id=\"1-EGOCache\"><a href=\"#1-EGOCache\" class=\"headerlink\" title=\"1.EGOCache\"></a>1.EGOCache</h3><p> 只提供磁盘缓存，没有内存缓存，一个比较简易的缓存框架。</p>\n<h3 id=\"2-TMCache\"><a href=\"#2-TMCache\" class=\"headerlink\" title=\"2.TMCache\"></a>2.TMCache</h3><p> 最初由 Tumblr 开发，但现在已经不再维护了。TMMemoryCache 实现有很多 NSCache 并没有提供的功能，比如数量限制、总容量限制、存活时间限制、内存警告或应用退到后台时清空缓存等。TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行。它错误的用了大量异步 block 回调来实现存取功能，以至于产生了很大的性能和死锁问题。它有磁盘缓存和内存缓存两部分组成，个人感觉一般好点的缓存库都会由磁盘缓存和内存缓存两部分组成，在我们第一次存储一个文件到磁盘的时候，缓存库会帮我们复制一份到内存缓存中，可以让我们在下次使用该文件的时候可以更快的找到。我上家公司就是用的这个缓存框架，挺好用的，也没出什么问题。</p>\n<h3 id=\"3-PINCache\"><a href=\"#3-PINCache\" class=\"headerlink\" title=\"3.PINCache\"></a>3.PINCache</h3><p> 是 Tumblr 宣布不在维护 TMCache 后，由 Pinterest 维护和改进的一个内存缓存。它的功能和接口基本和 TMCache 一样，但修复了性能和死锁的问题。它同样也用 dispatch_semaphore 来保证线程安全，但去掉了dispatch_barrier_async，避免了线程切换带来的巨大开销，也避免了可能的死锁。相当于是TMCache的优化版，而且一直有更新。</p>","more":"<h3 id=\"4-YYCache\"><a href=\"#4-YYCache\" class=\"headerlink\" title=\"4.YYCache\"></a>4.YYCache</h3><p> YYMemoryCache相对于 PINMemoryCache 来说，去掉了异步访问的接口，尽量优化了同步访问的性能，用 OSSpinLock 来保证线程安全。另外，缓存内部用双向链表和 NSDictionary 实现了 LRU 淘汰算法,性能好一点。TMDiskCache, PINDiskCache, SDWebImage 等缓存，都是基于文件系统的，即一个 Value 对应一个文件，通过文件读写来缓存数据。他们的实现都比较简单，性能也都相近，缺点也是同样的：不方便扩展、没有元数据、难以实现较好的淘汰算法、数据统计缓慢。YYDiskCache 也是采用的 SQLite 配合文件的存储方式，在 iPhone 6 64G 上的性能基准测试结果见下图。在存取小数据 (NSNumber) 时，YYDiskCache 的性能远远高出基于文件存储的库；而较大数据的存取性能则比较接近了。但得益于 SQLite 存储的元数据，YYDiskCache 实现了 LRU 淘汰算法、更快的数据统计，更多的容量控制选项。</p>\n<p> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/KVCahce/1.png\" alt=\"image\"></p>\n<p> YYCache相比较与前面几个，性能是最好的一个，但是差距也不是太大，而且他的使用需要依赖库，个人感觉用PinCache就可以了。<br> 下面是我通过PinCache改进的KVCache，在PinCahce的基础上增加了以下几个功能。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 可以设置缓存上限，设置一定时间内定时清理缓存</div><div class=\"line\">2. 增加缓存类型，jpg，MP4，MP3，gif，等自动保存相应类型</div><div class=\"line\">3. 增加缓存区块，不同模块的文件可以缓存到各自对应的区域</div><div class=\"line\">4. 以上所有参数都可以根据自己的需求自行设置</div></pre></td></tr></table></figure>\n<p> <a href=\"https://github.com/suifengqjn/KVCache\">demo地址</a></p>\n<p> <a href=\"http://gcblog.gtihub.io\">github Blog同步更新</a></p>"},{"title":"iOS开发小技巧","date":"2016-03-15T13:12:38.000Z","_content":"\niOS开发的一些奇巧淫技,\n\"奇巧淫技\"并非是一些稀奇古怪的技术要点，也不是什么所谓的黑科学，只是一些平时可能会用到但有些又并不是很容易查询得到的小tips.\n\n### 如何查看真机沙盒文件\n\n#### 一：安装iFunBox或IExployer\n\n#### 二：设置\n\n在xcode的上部导航栏里，选择window -> Devices,找到目标app![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/1.png),双击选中项目![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/2.png),\n\n<!-- more -->\n\n这样我们只能看到沙盒的目录结构,看不到实体文件。然后点击Download Container![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/3.png),下载后保存到桌面，右键显示包内容即可。\n\n\n\n###如何使用命令行进行打包?\n\n一： 使用原生xcodebuild、xcrun 打开终端 cd到当前项目,使用如下两条命令即可。\n#### 如果项目没有使用cocoapods:\nxcodebuild -project 项目名.xcodeproj -target 项目名 -configuration Release(生成项目名.app文件)\n<br>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/项目名.app -o ~/Desktop/项目名.ipa(-o前为.app文件路径，-o后为生成的.ipa路径)\n\n#### 如果使用cocoapods:\nxcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release\n<br>xcrun -sdk iphoneos -v PackageApplication 项目名.app路径 -o ~/Desktop/Demo.ipa\n\n\n二：使用xctool进行自动打包，是FaceBook开源的一个命令行工具，可使用brew安装（安装命令：sudo brew install xctool）\n#### 如果项目没有使用cocoapods:\nxctool -scheme Demo archive -archivePath \"Demo/“(会生成.xcarchive文件)\n<br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa\n#### 如果使用cocoapods:\nxctool -workspace Demo.xcworkspace -scheme Demo archive -archivePath \"Demo” \n<br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa\n\n### Xcode历史版本下载地址\n[https://developer.apple.com/downloads/](https://developer.apple.com/downloads/)\n\n\n### 加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)\nhttps://developer.apple.com/appstore/contact/appreviewteam/index.html\n也可以直接从ITunes右下角contact us也可以  但是无法填写相关文字描述\n\n\n### Autolayout及SizeClass示意图\n![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/4.png) ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/5.png) ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/6.png)\n\n\n### 窗口中有多个responder,如何快速释放键盘\n\n#### 一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];\n\n#### 二：[self.view endEditing:YES];\n\n\n### 如何去除UITableView中Group样式cell的边框\n\n#### 一： UIView *tempView = [[UIView alloc] init];\n  <br> [cell setBackgroundView:tempView];\n   <br>[cell setBackgroundColor:[UIColor clearColor]]; \n   \n#### 二：tableView.separatorColor=[UIColor clearColor];\n\n\n### 如何解决colorWithPatternImage设置view背景色太占内存问题\n\n  self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@\"main_landscape.jpg\"]];\n  <br>切换成self.view.layer.contents =[UIImage imageNamed:@\"name.png\"].CGImage;\n  \n### App升级后如何删除NSUserDefaults全部数据\n\nAPP升级后，UserDefaults中原有的plist是不会删除的，除非用户卸载APP<br>\nNSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];  \n[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];  \n\n### 如何修改图片颜色\n\n先设置图片的渲染模式为UIImageRenderingModeAlwaysTemplate，再设置tintcolor<br>\nself.imageView.image = [[UIImage imageNamed:@\"back\"] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\nself.imageView.tintColor = [UIColor redColor];\n<br>也可以在Asset catelog中设置render as<br> ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/7.png)\n\n### 如何放大图片使之不失真且不产生锯齿\n\n在Asset Catalog的Attribtues Pane中设置Single(前提是图片必须是矢量图) Vector为SingleVector<br>![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/8.png)\n\n\n### 如何在拉伸图片的时候使之不变形\n\n一：stretchableImageWithLeftCapWidth: topCapHeight:<br>\n二：在Xcode中选中图片，然后点击右下角的Show Slicing：<br>![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/9.gif)\n\n### Storyboard中如何正确设置控件透明度\n在直接设置alpha的情况下，如果上面有文字的话会随着透明度的变大而变得越来越不清楚。\n<br>此时应该这样设置 Background →0ther →0pacity\n\n### [UIScreen mainScreen].bounds获取屏幕大小不对的问题\n\\#define SCREEN_WIDTH  [UIScreen mainScreen].bounds.size.width<br>\n\\#define iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242,2208),[[UIScreen mainScreen] currentMode].size) : NO)<br>\n在标准模式下<br>\n6+：<br>\n[[UIScreen mainScreen] currentMode].size为{1242，2208}<br>\n[UIScreen mainScreen].bounds.size为{414，736}<br>\n6:<br>\n[[UIScreen mainScreen] currentMode].size为{750，1334}<br>\n[UIScreen mainScreen].bounds.size为{375，667}<br>\n\n放大模式下(设置->显示与亮度->显示模式) <br>\n6+:<br>\n[[UIScreen mainScreen] currentMode].size为{1125,2001}<br>\n[UIScreen mainScreen].bounds.size为{375,667}<br>\n6:<br>\n[[UIScreen mainScreen] currentMode].size为{640,1136}<br>\n[UIScreen mainScreen].bounds.size为{320,568}\n\n### Mac模式下如何将视频生成Gif文件\n#### 一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)\n\n#### 二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片<br>\n（ ffmpeg -i  news.mov -r 10 -f image2 文件夹名/%05d.png）\n<br>然后使用PicGIF (将多张图片生成gif文件)\n\n\n\n\n\n","source":"_posts/iOS开发小技巧.md","raw":"---\ntitle: iOS开发小技巧\ntags:\n  - iOS\n  - 缓存\ncategories:\n  - iOS技术\ndate: 2016-03-15 21:12:38\n---\n\niOS开发的一些奇巧淫技,\n\"奇巧淫技\"并非是一些稀奇古怪的技术要点，也不是什么所谓的黑科学，只是一些平时可能会用到但有些又并不是很容易查询得到的小tips.\n\n### 如何查看真机沙盒文件\n\n#### 一：安装iFunBox或IExployer\n\n#### 二：设置\n\n在xcode的上部导航栏里，选择window -> Devices,找到目标app![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/1.png),双击选中项目![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/2.png),\n\n<!-- more -->\n\n这样我们只能看到沙盒的目录结构,看不到实体文件。然后点击Download Container![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/3.png),下载后保存到桌面，右键显示包内容即可。\n\n\n\n###如何使用命令行进行打包?\n\n一： 使用原生xcodebuild、xcrun 打开终端 cd到当前项目,使用如下两条命令即可。\n#### 如果项目没有使用cocoapods:\nxcodebuild -project 项目名.xcodeproj -target 项目名 -configuration Release(生成项目名.app文件)\n<br>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/项目名.app -o ~/Desktop/项目名.ipa(-o前为.app文件路径，-o后为生成的.ipa路径)\n\n#### 如果使用cocoapods:\nxcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release\n<br>xcrun -sdk iphoneos -v PackageApplication 项目名.app路径 -o ~/Desktop/Demo.ipa\n\n\n二：使用xctool进行自动打包，是FaceBook开源的一个命令行工具，可使用brew安装（安装命令：sudo brew install xctool）\n#### 如果项目没有使用cocoapods:\nxctool -scheme Demo archive -archivePath \"Demo/“(会生成.xcarchive文件)\n<br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa\n#### 如果使用cocoapods:\nxctool -workspace Demo.xcworkspace -scheme Demo archive -archivePath \"Demo” \n<br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa\n\n### Xcode历史版本下载地址\n[https://developer.apple.com/downloads/](https://developer.apple.com/downloads/)\n\n\n### 加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)\nhttps://developer.apple.com/appstore/contact/appreviewteam/index.html\n也可以直接从ITunes右下角contact us也可以  但是无法填写相关文字描述\n\n\n### Autolayout及SizeClass示意图\n![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/4.png) ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/5.png) ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/6.png)\n\n\n### 窗口中有多个responder,如何快速释放键盘\n\n#### 一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];\n\n#### 二：[self.view endEditing:YES];\n\n\n### 如何去除UITableView中Group样式cell的边框\n\n#### 一： UIView *tempView = [[UIView alloc] init];\n  <br> [cell setBackgroundView:tempView];\n   <br>[cell setBackgroundColor:[UIColor clearColor]]; \n   \n#### 二：tableView.separatorColor=[UIColor clearColor];\n\n\n### 如何解决colorWithPatternImage设置view背景色太占内存问题\n\n  self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@\"main_landscape.jpg\"]];\n  <br>切换成self.view.layer.contents =[UIImage imageNamed:@\"name.png\"].CGImage;\n  \n### App升级后如何删除NSUserDefaults全部数据\n\nAPP升级后，UserDefaults中原有的plist是不会删除的，除非用户卸载APP<br>\nNSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];  \n[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];  \n\n### 如何修改图片颜色\n\n先设置图片的渲染模式为UIImageRenderingModeAlwaysTemplate，再设置tintcolor<br>\nself.imageView.image = [[UIImage imageNamed:@\"back\"] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\nself.imageView.tintColor = [UIColor redColor];\n<br>也可以在Asset catelog中设置render as<br> ![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/7.png)\n\n### 如何放大图片使之不失真且不产生锯齿\n\n在Asset Catalog的Attribtues Pane中设置Single(前提是图片必须是矢量图) Vector为SingleVector<br>![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/8.png)\n\n\n### 如何在拉伸图片的时候使之不变形\n\n一：stretchableImageWithLeftCapWidth: topCapHeight:<br>\n二：在Xcode中选中图片，然后点击右下角的Show Slicing：<br>![](https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/9.gif)\n\n### Storyboard中如何正确设置控件透明度\n在直接设置alpha的情况下，如果上面有文字的话会随着透明度的变大而变得越来越不清楚。\n<br>此时应该这样设置 Background →0ther →0pacity\n\n### [UIScreen mainScreen].bounds获取屏幕大小不对的问题\n\\#define SCREEN_WIDTH  [UIScreen mainScreen].bounds.size.width<br>\n\\#define iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242,2208),[[UIScreen mainScreen] currentMode].size) : NO)<br>\n在标准模式下<br>\n6+：<br>\n[[UIScreen mainScreen] currentMode].size为{1242，2208}<br>\n[UIScreen mainScreen].bounds.size为{414，736}<br>\n6:<br>\n[[UIScreen mainScreen] currentMode].size为{750，1334}<br>\n[UIScreen mainScreen].bounds.size为{375，667}<br>\n\n放大模式下(设置->显示与亮度->显示模式) <br>\n6+:<br>\n[[UIScreen mainScreen] currentMode].size为{1125,2001}<br>\n[UIScreen mainScreen].bounds.size为{375,667}<br>\n6:<br>\n[[UIScreen mainScreen] currentMode].size为{640,1136}<br>\n[UIScreen mainScreen].bounds.size为{320,568}\n\n### Mac模式下如何将视频生成Gif文件\n#### 一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)\n\n#### 二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片<br>\n（ ffmpeg -i  news.mov -r 10 -f image2 文件夹名/%05d.png）\n<br>然后使用PicGIF (将多张图片生成gif文件)\n\n\n\n\n\n","slug":"iOS开发小技巧","published":1,"updated":"2016-11-17T15:03:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmgz000fco60kd0cl0pz","content":"<p>iOS开发的一些奇巧淫技,<br>“奇巧淫技”并非是一些稀奇古怪的技术要点，也不是什么所谓的黑科学，只是一些平时可能会用到但有些又并不是很容易查询得到的小tips.</p>\n<h3 id=\"如何查看真机沙盒文件\"><a href=\"#如何查看真机沙盒文件\" class=\"headerlink\" title=\"如何查看真机沙盒文件\"></a>如何查看真机沙盒文件</h3><h4 id=\"一：安装iFunBox或IExployer\"><a href=\"#一：安装iFunBox或IExployer\" class=\"headerlink\" title=\"一：安装iFunBox或IExployer\"></a>一：安装iFunBox或IExployer</h4><h4 id=\"二：设置\"><a href=\"#二：设置\" class=\"headerlink\" title=\"二：设置\"></a>二：设置</h4><p>在xcode的上部导航栏里，选择window -&gt; Devices,找到目标app<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/1.png\" alt=\"\">,双击选中项目<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/2.png\" alt=\"\">,</p>\n<a id=\"more\"></a>\n<p>这样我们只能看到沙盒的目录结构,看不到实体文件。然后点击Download Container<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/3.png\" alt=\"\">,下载后保存到桌面，右键显示包内容即可。</p>\n<p>###如何使用命令行进行打包?</p>\n<p>一： 使用原生xcodebuild、xcrun 打开终端 cd到当前项目,使用如下两条命令即可。</p>\n<h4 id=\"如果项目没有使用cocoapods\"><a href=\"#如果项目没有使用cocoapods\" class=\"headerlink\" title=\"如果项目没有使用cocoapods:\"></a>如果项目没有使用cocoapods:</h4><p>xcodebuild -project 项目名.xcodeproj -target 项目名 -configuration Release(生成项目名.app文件)<br><br>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/项目名.app -o ~/Desktop/项目名.ipa(-o前为.app文件路径，-o后为生成的.ipa路径)</p>\n<h4 id=\"如果使用cocoapods\"><a href=\"#如果使用cocoapods\" class=\"headerlink\" title=\"如果使用cocoapods:\"></a>如果使用cocoapods:</h4><p>xcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release<br><br>xcrun -sdk iphoneos -v PackageApplication 项目名.app路径 -o ~/Desktop/Demo.ipa</p>\n<p>二：使用xctool进行自动打包，是FaceBook开源的一个命令行工具，可使用brew安装（安装命令：sudo brew install xctool）</p>\n<h4 id=\"如果项目没有使用cocoapods-1\"><a href=\"#如果项目没有使用cocoapods-1\" class=\"headerlink\" title=\"如果项目没有使用cocoapods:\"></a>如果项目没有使用cocoapods:</h4><p>xctool -scheme Demo archive -archivePath “Demo/“(会生成.xcarchive文件)<br><br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa</p>\n<h4 id=\"如果使用cocoapods-1\"><a href=\"#如果使用cocoapods-1\" class=\"headerlink\" title=\"如果使用cocoapods:\"></a>如果使用cocoapods:</h4><p>xctool -workspace Demo.xcworkspace -scheme Demo archive -archivePath “Demo”<br><br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa</p>\n<h3 id=\"Xcode历史版本下载地址\"><a href=\"#Xcode历史版本下载地址\" class=\"headerlink\" title=\"Xcode历史版本下载地址\"></a>Xcode历史版本下载地址</h3><p><a href=\"https://developer.apple.com/downloads/\" target=\"_blank\" rel=\"external\">https://developer.apple.com/downloads/</a></p>\n<h3 id=\"加急审核渠道链接-并非只是加急，包括向苹果申诉、修改appstore上相关信息等\"><a href=\"#加急审核渠道链接-并非只是加急，包括向苹果申诉、修改appstore上相关信息等\" class=\"headerlink\" title=\"加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)\"></a>加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)</h3><p><a href=\"https://developer.apple.com/appstore/contact/appreviewteam/index.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/appstore/contact/appreviewteam/index.html</a><br>也可以直接从ITunes右下角contact us也可以  但是无法填写相关文字描述</p>\n<h3 id=\"Autolayout及SizeClass示意图\"><a href=\"#Autolayout及SizeClass示意图\" class=\"headerlink\" title=\"Autolayout及SizeClass示意图\"></a>Autolayout及SizeClass示意图</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/4.png\" alt=\"\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/5.png\" alt=\"\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/6.png\" alt=\"\"></p>\n<h3 id=\"窗口中有多个responder-如何快速释放键盘\"><a href=\"#窗口中有多个responder-如何快速释放键盘\" class=\"headerlink\" title=\"窗口中有多个responder,如何快速释放键盘\"></a>窗口中有多个responder,如何快速释放键盘</h3><h4 id=\"一：-UIApplication-sharedApplication-sendAction-selector-resignFirstResponder-to-nil-from-nil-forEvent-nil\"><a href=\"#一：-UIApplication-sharedApplication-sendAction-selector-resignFirstResponder-to-nil-from-nil-forEvent-nil\" class=\"headerlink\" title=\"一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];\"></a>一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</h4><h4 id=\"二：-self-view-endEditing-YES\"><a href=\"#二：-self-view-endEditing-YES\" class=\"headerlink\" title=\"二：[self.view endEditing:YES];\"></a>二：[self.view endEditing:YES];</h4><h3 id=\"如何去除UITableView中Group样式cell的边框\"><a href=\"#如何去除UITableView中Group样式cell的边框\" class=\"headerlink\" title=\"如何去除UITableView中Group样式cell的边框\"></a>如何去除UITableView中Group样式cell的边框</h3><h4 id=\"一：-UIView-tempView-UIView-alloc-init\"><a href=\"#一：-UIView-tempView-UIView-alloc-init\" class=\"headerlink\" title=\"一： UIView *tempView = [[UIView alloc] init];\"></a>一： UIView *tempView = [[UIView alloc] init];</h4><p>  <br> [cell setBackgroundView:tempView];<br>   <br>[cell setBackgroundColor:[UIColor clearColor]]; </p>\n<h4 id=\"二：tableView-separatorColor-UIColor-clearColor\"><a href=\"#二：tableView-separatorColor-UIColor-clearColor\" class=\"headerlink\" title=\"二：tableView.separatorColor=[UIColor clearColor];\"></a>二：tableView.separatorColor=[UIColor clearColor];</h4><h3 id=\"如何解决colorWithPatternImage设置view背景色太占内存问题\"><a href=\"#如何解决colorWithPatternImage设置view背景色太占内存问题\" class=\"headerlink\" title=\"如何解决colorWithPatternImage设置view背景色太占内存问题\"></a>如何解决colorWithPatternImage设置view背景色太占内存问题</h3><p>  self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@”main_landscape.jpg”]];<br>  <br>切换成self.view.layer.contents =[UIImage imageNamed:@”name.png”].CGImage;</p>\n<h3 id=\"App升级后如何删除NSUserDefaults全部数据\"><a href=\"#App升级后如何删除NSUserDefaults全部数据\" class=\"headerlink\" title=\"App升级后如何删除NSUserDefaults全部数据\"></a>App升级后如何删除NSUserDefaults全部数据</h3><p>APP升级后，UserDefaults中原有的plist是不会删除的，除非用户卸载APP<br><br>NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];<br>[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];  </p>\n<h3 id=\"如何修改图片颜色\"><a href=\"#如何修改图片颜色\" class=\"headerlink\" title=\"如何修改图片颜色\"></a>如何修改图片颜色</h3><p>先设置图片的渲染模式为UIImageRenderingModeAlwaysTemplate，再设置tintcolor<br><br>self.imageView.image = [[UIImage imageNamed:@”back”] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];<br>self.imageView.tintColor = [UIColor redColor];<br><br>也可以在Asset catelog中设置render as<br> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/7.png\" alt=\"\"></p>\n<h3 id=\"如何放大图片使之不失真且不产生锯齿\"><a href=\"#如何放大图片使之不失真且不产生锯齿\" class=\"headerlink\" title=\"如何放大图片使之不失真且不产生锯齿\"></a>如何放大图片使之不失真且不产生锯齿</h3><p>在Asset Catalog的Attribtues Pane中设置Single(前提是图片必须是矢量图) Vector为SingleVector<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/8.png\" alt=\"\"></p>\n<h3 id=\"如何在拉伸图片的时候使之不变形\"><a href=\"#如何在拉伸图片的时候使之不变形\" class=\"headerlink\" title=\"如何在拉伸图片的时候使之不变形\"></a>如何在拉伸图片的时候使之不变形</h3><p>一：stretchableImageWithLeftCapWidth: topCapHeight:<br><br>二：在Xcode中选中图片，然后点击右下角的Show Slicing：<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/9.gif\" alt=\"\"></p>\n<h3 id=\"Storyboard中如何正确设置控件透明度\"><a href=\"#Storyboard中如何正确设置控件透明度\" class=\"headerlink\" title=\"Storyboard中如何正确设置控件透明度\"></a>Storyboard中如何正确设置控件透明度</h3><p>在直接设置alpha的情况下，如果上面有文字的话会随着透明度的变大而变得越来越不清楚。<br><br>此时应该这样设置 Background →0ther →0pacity</p>\n<h3 id=\"UIScreen-mainScreen-bounds获取屏幕大小不对的问题\"><a href=\"#UIScreen-mainScreen-bounds获取屏幕大小不对的问题\" class=\"headerlink\" title=\"[UIScreen mainScreen].bounds获取屏幕大小不对的问题\"></a>[UIScreen mainScreen].bounds获取屏幕大小不对的问题</h3><p>#define SCREEN_WIDTH  [UIScreen mainScreen].bounds.size.width<br><br>#define iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242,2208),[[UIScreen mainScreen] currentMode].size) : NO)<br><br>在标准模式下<br><br>6+：<br><br>[[UIScreen mainScreen] currentMode].size为{1242，2208}<br><br>[UIScreen mainScreen].bounds.size为{414，736}<br><br>6:<br><br>[[UIScreen mainScreen] currentMode].size为{750，1334}<br><br>[UIScreen mainScreen].bounds.size为{375，667}<br></p>\n<p>放大模式下(设置-&gt;显示与亮度-&gt;显示模式) <br><br>6+:<br><br>[[UIScreen mainScreen] currentMode].size为{1125,2001}<br><br>[UIScreen mainScreen].bounds.size为{375,667}<br><br>6:<br><br>[[UIScreen mainScreen] currentMode].size为{640,1136}<br><br>[UIScreen mainScreen].bounds.size为{320,568}</p>\n<h3 id=\"Mac模式下如何将视频生成Gif文件\"><a href=\"#Mac模式下如何将视频生成Gif文件\" class=\"headerlink\" title=\"Mac模式下如何将视频生成Gif文件\"></a>Mac模式下如何将视频生成Gif文件</h3><h4 id=\"一：使用GifBrewery直接将视频转为gif文件-安装GifBreweryw密码-www-macx-cn\"><a href=\"#一：使用GifBrewery直接将视频转为gif文件-安装GifBreweryw密码-www-macx-cn\" class=\"headerlink\" title=\"一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)\"></a>一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)</h4><h4 id=\"二：安装ffmpeg-brew-install-ffmpeg-使用ffmpeg使视频转为多张图片\"><a href=\"#二：安装ffmpeg-brew-install-ffmpeg-使用ffmpeg使视频转为多张图片\" class=\"headerlink\" title=\"二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片\"></a>二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片<br></h4><p>（ ffmpeg -i  news.mov -r 10 -f image2 文件夹名/%05d.png）<br><br>然后使用PicGIF (将多张图片生成gif文件)</p>\n","excerpt":"<p>iOS开发的一些奇巧淫技,<br>“奇巧淫技”并非是一些稀奇古怪的技术要点，也不是什么所谓的黑科学，只是一些平时可能会用到但有些又并不是很容易查询得到的小tips.</p>\n<h3 id=\"如何查看真机沙盒文件\"><a href=\"#如何查看真机沙盒文件\" class=\"headerlink\" title=\"如何查看真机沙盒文件\"></a>如何查看真机沙盒文件</h3><h4 id=\"一：安装iFunBox或IExployer\"><a href=\"#一：安装iFunBox或IExployer\" class=\"headerlink\" title=\"一：安装iFunBox或IExployer\"></a>一：安装iFunBox或IExployer</h4><h4 id=\"二：设置\"><a href=\"#二：设置\" class=\"headerlink\" title=\"二：设置\"></a>二：设置</h4><p>在xcode的上部导航栏里，选择window -&gt; Devices,找到目标app<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/1.png\" alt=\"\">,双击选中项目<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/2.png\" alt=\"\">,</p>","more":"<p>这样我们只能看到沙盒的目录结构,看不到实体文件。然后点击Download Container<img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/3.png\" alt=\"\">,下载后保存到桌面，右键显示包内容即可。</p>\n<p>###如何使用命令行进行打包?</p>\n<p>一： 使用原生xcodebuild、xcrun 打开终端 cd到当前项目,使用如下两条命令即可。</p>\n<h4 id=\"如果项目没有使用cocoapods\"><a href=\"#如果项目没有使用cocoapods\" class=\"headerlink\" title=\"如果项目没有使用cocoapods:\"></a>如果项目没有使用cocoapods:</h4><p>xcodebuild -project 项目名.xcodeproj -target 项目名 -configuration Release(生成项目名.app文件)<br><br>xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/项目名.app -o ~/Desktop/项目名.ipa(-o前为.app文件路径，-o后为生成的.ipa路径)</p>\n<h4 id=\"如果使用cocoapods\"><a href=\"#如果使用cocoapods\" class=\"headerlink\" title=\"如果使用cocoapods:\"></a>如果使用cocoapods:</h4><p>xcodebuild -workspace Test.xcworkspace -scheme Test -configuration Release<br><br>xcrun -sdk iphoneos -v PackageApplication 项目名.app路径 -o ~/Desktop/Demo.ipa</p>\n<p>二：使用xctool进行自动打包，是FaceBook开源的一个命令行工具，可使用brew安装（安装命令：sudo brew install xctool）</p>\n<h4 id=\"如果项目没有使用cocoapods-1\"><a href=\"#如果项目没有使用cocoapods-1\" class=\"headerlink\" title=\"如果项目没有使用cocoapods:\"></a>如果项目没有使用cocoapods:</h4><p>xctool -scheme Demo archive -archivePath “Demo/“(会生成.xcarchive文件)<br><br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa</p>\n<h4 id=\"如果使用cocoapods-1\"><a href=\"#如果使用cocoapods-1\" class=\"headerlink\" title=\"如果使用cocoapods:\"></a>如果使用cocoapods:</h4><p>xctool -workspace Demo.xcworkspace -scheme Demo archive -archivePath “Demo”<br><br>xcrun -sdk iphoneos -v PackageApplication ./Demo.xcarchive/Products/Applications/Demo.app -o ~/Desktop/Demo.ipa</p>\n<h3 id=\"Xcode历史版本下载地址\"><a href=\"#Xcode历史版本下载地址\" class=\"headerlink\" title=\"Xcode历史版本下载地址\"></a>Xcode历史版本下载地址</h3><p><a href=\"https://developer.apple.com/downloads/\">https://developer.apple.com/downloads/</a></p>\n<h3 id=\"加急审核渠道链接-并非只是加急，包括向苹果申诉、修改appstore上相关信息等\"><a href=\"#加急审核渠道链接-并非只是加急，包括向苹果申诉、修改appstore上相关信息等\" class=\"headerlink\" title=\"加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)\"></a>加急审核渠道链接(并非只是加急，包括向苹果申诉、修改appstore上相关信息等)</h3><p><a href=\"https://developer.apple.com/appstore/contact/appreviewteam/index.html\">https://developer.apple.com/appstore/contact/appreviewteam/index.html</a><br>也可以直接从ITunes右下角contact us也可以  但是无法填写相关文字描述</p>\n<h3 id=\"Autolayout及SizeClass示意图\"><a href=\"#Autolayout及SizeClass示意图\" class=\"headerlink\" title=\"Autolayout及SizeClass示意图\"></a>Autolayout及SizeClass示意图</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/4.png\" alt=\"\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/5.png\" alt=\"\"> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/6.png\" alt=\"\"></p>\n<h3 id=\"窗口中有多个responder-如何快速释放键盘\"><a href=\"#窗口中有多个responder-如何快速释放键盘\" class=\"headerlink\" title=\"窗口中有多个responder,如何快速释放键盘\"></a>窗口中有多个responder,如何快速释放键盘</h3><h4 id=\"一：-UIApplication-sharedApplication-sendAction-selector-resignFirstResponder-to-nil-from-nil-forEvent-nil\"><a href=\"#一：-UIApplication-sharedApplication-sendAction-selector-resignFirstResponder-to-nil-from-nil-forEvent-nil\" class=\"headerlink\" title=\"一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];\"></a>一：[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</h4><h4 id=\"二：-self-view-endEditing-YES\"><a href=\"#二：-self-view-endEditing-YES\" class=\"headerlink\" title=\"二：[self.view endEditing:YES];\"></a>二：[self.view endEditing:YES];</h4><h3 id=\"如何去除UITableView中Group样式cell的边框\"><a href=\"#如何去除UITableView中Group样式cell的边框\" class=\"headerlink\" title=\"如何去除UITableView中Group样式cell的边框\"></a>如何去除UITableView中Group样式cell的边框</h3><h4 id=\"一：-UIView-tempView-UIView-alloc-init\"><a href=\"#一：-UIView-tempView-UIView-alloc-init\" class=\"headerlink\" title=\"一： UIView *tempView = [[UIView alloc] init];\"></a>一： UIView *tempView = [[UIView alloc] init];</h4><p>  <br> [cell setBackgroundView:tempView];<br>   <br>[cell setBackgroundColor:[UIColor clearColor]]; </p>\n<h4 id=\"二：tableView-separatorColor-UIColor-clearColor\"><a href=\"#二：tableView-separatorColor-UIColor-clearColor\" class=\"headerlink\" title=\"二：tableView.separatorColor=[UIColor clearColor];\"></a>二：tableView.separatorColor=[UIColor clearColor];</h4><h3 id=\"如何解决colorWithPatternImage设置view背景色太占内存问题\"><a href=\"#如何解决colorWithPatternImage设置view背景色太占内存问题\" class=\"headerlink\" title=\"如何解决colorWithPatternImage设置view背景色太占内存问题\"></a>如何解决colorWithPatternImage设置view背景色太占内存问题</h3><p>  self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@”main_landscape.jpg”]];<br>  <br>切换成self.view.layer.contents =[UIImage imageNamed:@”name.png”].CGImage;</p>\n<h3 id=\"App升级后如何删除NSUserDefaults全部数据\"><a href=\"#App升级后如何删除NSUserDefaults全部数据\" class=\"headerlink\" title=\"App升级后如何删除NSUserDefaults全部数据\"></a>App升级后如何删除NSUserDefaults全部数据</h3><p>APP升级后，UserDefaults中原有的plist是不会删除的，除非用户卸载APP<br><br>NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];<br>[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];  </p>\n<h3 id=\"如何修改图片颜色\"><a href=\"#如何修改图片颜色\" class=\"headerlink\" title=\"如何修改图片颜色\"></a>如何修改图片颜色</h3><p>先设置图片的渲染模式为UIImageRenderingModeAlwaysTemplate，再设置tintcolor<br><br>self.imageView.image = [[UIImage imageNamed:@”back”] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];<br>self.imageView.tintColor = [UIColor redColor];<br><br>也可以在Asset catelog中设置render as<br> <img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/7.png\" alt=\"\"></p>\n<h3 id=\"如何放大图片使之不失真且不产生锯齿\"><a href=\"#如何放大图片使之不失真且不产生锯齿\" class=\"headerlink\" title=\"如何放大图片使之不失真且不产生锯齿\"></a>如何放大图片使之不失真且不产生锯齿</h3><p>在Asset Catalog的Attribtues Pane中设置Single(前提是图片必须是矢量图) Vector为SingleVector<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/8.png\" alt=\"\"></p>\n<h3 id=\"如何在拉伸图片的时候使之不变形\"><a href=\"#如何在拉伸图片的时候使之不变形\" class=\"headerlink\" title=\"如何在拉伸图片的时候使之不变形\"></a>如何在拉伸图片的时候使之不变形</h3><p>一：stretchableImageWithLeftCapWidth: topCapHeight:<br><br>二：在Xcode中选中图片，然后点击右下角的Show Slicing：<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/iOS小技巧/9.gif\" alt=\"\"></p>\n<h3 id=\"Storyboard中如何正确设置控件透明度\"><a href=\"#Storyboard中如何正确设置控件透明度\" class=\"headerlink\" title=\"Storyboard中如何正确设置控件透明度\"></a>Storyboard中如何正确设置控件透明度</h3><p>在直接设置alpha的情况下，如果上面有文字的话会随着透明度的变大而变得越来越不清楚。<br><br>此时应该这样设置 Background →0ther →0pacity</p>\n<h3 id=\"UIScreen-mainScreen-bounds获取屏幕大小不对的问题\"><a href=\"#UIScreen-mainScreen-bounds获取屏幕大小不对的问题\" class=\"headerlink\" title=\"[UIScreen mainScreen].bounds获取屏幕大小不对的问题\"></a>[UIScreen mainScreen].bounds获取屏幕大小不对的问题</h3><p>#define SCREEN_WIDTH  [UIScreen mainScreen].bounds.size.width<br><br>#define iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242,2208),[[UIScreen mainScreen] currentMode].size) : NO)<br><br>在标准模式下<br><br>6+：<br><br>[[UIScreen mainScreen] currentMode].size为{1242，2208}<br><br>[UIScreen mainScreen].bounds.size为{414，736}<br><br>6:<br><br>[[UIScreen mainScreen] currentMode].size为{750，1334}<br><br>[UIScreen mainScreen].bounds.size为{375，667}<br></p>\n<p>放大模式下(设置-&gt;显示与亮度-&gt;显示模式) <br><br>6+:<br><br>[[UIScreen mainScreen] currentMode].size为{1125,2001}<br><br>[UIScreen mainScreen].bounds.size为{375,667}<br><br>6:<br><br>[[UIScreen mainScreen] currentMode].size为{640,1136}<br><br>[UIScreen mainScreen].bounds.size为{320,568}</p>\n<h3 id=\"Mac模式下如何将视频生成Gif文件\"><a href=\"#Mac模式下如何将视频生成Gif文件\" class=\"headerlink\" title=\"Mac模式下如何将视频生成Gif文件\"></a>Mac模式下如何将视频生成Gif文件</h3><h4 id=\"一：使用GifBrewery直接将视频转为gif文件-安装GifBreweryw密码-www-macx-cn\"><a href=\"#一：使用GifBrewery直接将视频转为gif文件-安装GifBreweryw密码-www-macx-cn\" class=\"headerlink\" title=\"一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)\"></a>一：使用GifBrewery直接将视频转为gif文件(安装GifBreweryw密码:www.macx.cn)</h4><h4 id=\"二：安装ffmpeg-brew-install-ffmpeg-使用ffmpeg使视频转为多张图片\"><a href=\"#二：安装ffmpeg-brew-install-ffmpeg-使用ffmpeg使视频转为多张图片\" class=\"headerlink\" title=\"二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片\"></a>二：安装ffmpeg ( brew install ffmpeg)使用ffmpeg使视频转为多张图片<br></h4><p>（ ffmpeg -i  news.mov -r 10 -f image2 文件夹名/%05d.png）<br><br>然后使用PicGIF (将多张图片生成gif文件)</p>"},{"title":"iOS卡顿监控","date":"2016-02-25T07:46:16.000Z","_content":"\n>在移动设备上开发软件,性能一直是我们最为关心的话题之一,我们作为程序员除了需要努力提高代码质量之外,及时发现和监控软件中那些造成性能低下的”罪魁祸首”也是我们神圣的职责.\n\n众所周知,iOS平台因为UIKit本身的特性,需要将所有的UI操作都放在主线程执行,所以也造成不少程序员都习惯将一些线程安全性不确定的逻辑,以及其它线程结束后的汇总工作等等放到了主线,所以主线程中包含的这些大量计算、IO、绘制都有可能造成卡顿.\n\n在Xcode中已经集成了非常方便的调试工具Instruments,它可以帮助我们在开发测试阶段分析软件运行的性能消耗,但一款软件经过测试流程和实验室分析肯定是不够的,在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.\n\n\n### 寻找卡顿的切入点\n>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在此处查阅到源代码http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的:\n<br />\n\n<!-- more -->\n\n```\nint32_t __CFRunLoopRun()\n{\n    //通知即将进入runloop\n    __CFRunLoopDoObservers(KCFRunLoopEntry);\n    \n    do\n    {\n        // 通知将要处理timer和source\n        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);\n        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);\n        \n        __CFRunLoopDoBlocks();  //处理非延迟的主线程调用\n        __CFRunLoopDoSource0(); //处理UIEvent事件\n        \n        //GCD dispatch main queue\n        CheckIfExistMessagesInMainDispatchQueue();\n        \n        // 即将进入休眠\n        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);\n        \n        // 等待内核mach_msg事件\n        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();\n        \n        // Zzz...\n        \n        // 从等待中醒来\n        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);\n        \n        // 处理因timer的唤醒\n        if (wakeUpPort == timerPort)\n            __CFRunLoopDoTimers();\n        \n        // 处理异步方法唤醒,如dispatch_async\n        else if (wakeUpPort == mainDispatchQueuePort)\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()\n            \n        // UI刷新,动画显示\n        else\n            __CFRunLoopDoSource1();\n        \n        // 再次确保是否有同步的方法需要调用\n        __CFRunLoopDoBlocks();\n        \n    } while (!stop && !timeout);\n    \n    //通知即将退出runloop\n    __CFRunLoopDoObservers(CFRunLoopExit);\n}\n```\n<br />\n\n>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.\n\n<br />\n\n### 量化卡顿的程度\n\n>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:\n>\n\n<br />\n\n```\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    MyClass *object = (__bridge MyClass*)info;\n    object->activity = activity;\n}\n\n- (void)registerObserver\n{\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                                            kCFRunLoopAllActivities,\n                                                            YES,\n                                                            0,\n                                                            &runLoopObserverCallBack,\n                                                            &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n}\n```\n<br />\n\n>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.\n为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:\n\n<br />\n\n```\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    MyClass *object = (__bridge MyClass*)info;\n    \n    // 记录状态值\n    object->activity = activity;\n    \n    // 发送信号\n    dispatch_semaphore_t semaphore = moniotr->semaphore;\n    dispatch_semaphore_signal(semaphore);\n}\n\n- (void)registerObserver\n{\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                                            kCFRunLoopAllActivities,\n                                                            YES,\n                                                            0,\n                                                            &runLoopObserverCallBack,\n                                                            &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n    \n    // 创建信号\n    semaphore = dispatch_semaphore_create(0);\n    \n    // 在子线程监控时长\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        while (YES)\n        {\n            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)\n            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));\n            if (st != 0)\n            {\n                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)\n                {\n                    if (++timeoutCount < 5)\n                        continue;\n                    \n                    NSLog(@\"好像有点儿卡哦\");\n                }\n            }\n            timeoutCount = 0;\n        }\n    });\n}\n```\n### 记录卡顿的函数调用\n\n<br />\n\n>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:\n\n<br />\n\n```\nPLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD\n                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];\nPLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];\n\nNSData *data = [crashReporter generateLiveReport];\nPLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];\nNSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter\n                                                          withTextFormat:PLCrashReportTextFormatiOS];\n\nNSLog(@\"------------\\n%@\\n------------\", report);\n```\n当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至此这个实时卡顿监控就大功告成了!\n\n[demo地址](https://github.com/suifengqjn/PerformanceMonitor)\n","source":"_posts/iOS卡顿监控.md","raw":"---\ntitle: iOS卡顿监控\ndate: 2016-02-25 15:46:16\ntags: [iOS, 性能]\ncategories: \n- iOS技术\n---\n\n>在移动设备上开发软件,性能一直是我们最为关心的话题之一,我们作为程序员除了需要努力提高代码质量之外,及时发现和监控软件中那些造成性能低下的”罪魁祸首”也是我们神圣的职责.\n\n众所周知,iOS平台因为UIKit本身的特性,需要将所有的UI操作都放在主线程执行,所以也造成不少程序员都习惯将一些线程安全性不确定的逻辑,以及其它线程结束后的汇总工作等等放到了主线,所以主线程中包含的这些大量计算、IO、绘制都有可能造成卡顿.\n\n在Xcode中已经集成了非常方便的调试工具Instruments,它可以帮助我们在开发测试阶段分析软件运行的性能消耗,但一款软件经过测试流程和实验室分析肯定是不够的,在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.\n\n\n### 寻找卡顿的切入点\n>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在此处查阅到源代码http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的:\n<br />\n\n<!-- more -->\n\n```\nint32_t __CFRunLoopRun()\n{\n    //通知即将进入runloop\n    __CFRunLoopDoObservers(KCFRunLoopEntry);\n    \n    do\n    {\n        // 通知将要处理timer和source\n        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);\n        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);\n        \n        __CFRunLoopDoBlocks();  //处理非延迟的主线程调用\n        __CFRunLoopDoSource0(); //处理UIEvent事件\n        \n        //GCD dispatch main queue\n        CheckIfExistMessagesInMainDispatchQueue();\n        \n        // 即将进入休眠\n        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);\n        \n        // 等待内核mach_msg事件\n        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();\n        \n        // Zzz...\n        \n        // 从等待中醒来\n        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);\n        \n        // 处理因timer的唤醒\n        if (wakeUpPort == timerPort)\n            __CFRunLoopDoTimers();\n        \n        // 处理异步方法唤醒,如dispatch_async\n        else if (wakeUpPort == mainDispatchQueuePort)\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()\n            \n        // UI刷新,动画显示\n        else\n            __CFRunLoopDoSource1();\n        \n        // 再次确保是否有同步的方法需要调用\n        __CFRunLoopDoBlocks();\n        \n    } while (!stop && !timeout);\n    \n    //通知即将退出runloop\n    __CFRunLoopDoObservers(CFRunLoopExit);\n}\n```\n<br />\n\n>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.\n\n<br />\n\n### 量化卡顿的程度\n\n>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:\n>\n\n<br />\n\n```\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    MyClass *object = (__bridge MyClass*)info;\n    object->activity = activity;\n}\n\n- (void)registerObserver\n{\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                                            kCFRunLoopAllActivities,\n                                                            YES,\n                                                            0,\n                                                            &runLoopObserverCallBack,\n                                                            &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n}\n```\n<br />\n\n>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.\n为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:\n\n<br />\n\n```\nstatic void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)\n{\n    MyClass *object = (__bridge MyClass*)info;\n    \n    // 记录状态值\n    object->activity = activity;\n    \n    // 发送信号\n    dispatch_semaphore_t semaphore = moniotr->semaphore;\n    dispatch_semaphore_signal(semaphore);\n}\n\n- (void)registerObserver\n{\n    CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL};\n    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                                            kCFRunLoopAllActivities,\n                                                            YES,\n                                                            0,\n                                                            &runLoopObserverCallBack,\n                                                            &context);\n    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n    \n    // 创建信号\n    semaphore = dispatch_semaphore_create(0);\n    \n    // 在子线程监控时长\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        while (YES)\n        {\n            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)\n            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));\n            if (st != 0)\n            {\n                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)\n                {\n                    if (++timeoutCount < 5)\n                        continue;\n                    \n                    NSLog(@\"好像有点儿卡哦\");\n                }\n            }\n            timeoutCount = 0;\n        }\n    });\n}\n```\n### 记录卡顿的函数调用\n\n<br />\n\n>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:\n\n<br />\n\n```\nPLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD\n                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];\nPLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];\n\nNSData *data = [crashReporter generateLiveReport];\nPLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];\nNSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter\n                                                          withTextFormat:PLCrashReportTextFormatiOS];\n\nNSLog(@\"------------\\n%@\\n------------\", report);\n```\n当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至此这个实时卡顿监控就大功告成了!\n\n[demo地址](https://github.com/suifengqjn/PerformanceMonitor)\n","slug":"iOS卡顿监控","published":1,"updated":"2016-11-17T15:00:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmh9000ico609t19xh8j","content":"<blockquote>\n<p>在移动设备上开发软件,性能一直是我们最为关心的话题之一,我们作为程序员除了需要努力提高代码质量之外,及时发现和监控软件中那些造成性能低下的”罪魁祸首”也是我们神圣的职责.</p>\n</blockquote>\n<p>众所周知,iOS平台因为UIKit本身的特性,需要将所有的UI操作都放在主线程执行,所以也造成不少程序员都习惯将一些线程安全性不确定的逻辑,以及其它线程结束后的汇总工作等等放到了主线,所以主线程中包含的这些大量计算、IO、绘制都有可能造成卡顿.</p>\n<p>在Xcode中已经集成了非常方便的调试工具Instruments,它可以帮助我们在开发测试阶段分析软件运行的性能消耗,但一款软件经过测试流程和实验室分析肯定是不够的,在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.</p>\n<h3 id=\"寻找卡顿的切入点\"><a href=\"#寻找卡顿的切入点\" class=\"headerlink\" title=\"寻找卡顿的切入点\"></a>寻找卡顿的切入点</h3><blockquote>\n<p>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在此处查阅到源代码<a href=\"http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的\" target=\"_blank\" rel=\"external\">http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的</a>:<br><br></p>\n</blockquote>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">int32_t __CFRunLoopRun()</div><div class=\"line\">&#123;</div><div class=\"line\">    //通知即将进入runloop</div><div class=\"line\">    __CFRunLoopDoObservers(KCFRunLoopEntry);</div><div class=\"line\">    </div><div class=\"line\">    do</div><div class=\"line\">    &#123;</div><div class=\"line\">        // 通知将要处理timer和source</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopDoBlocks();  //处理非延迟的主线程调用</div><div class=\"line\">        __CFRunLoopDoSource0(); //处理UIEvent事件</div><div class=\"line\">        </div><div class=\"line\">        //GCD dispatch main queue</div><div class=\"line\">        CheckIfExistMessagesInMainDispatchQueue();</div><div class=\"line\">        </div><div class=\"line\">        // 即将进入休眠</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);</div><div class=\"line\">        </div><div class=\"line\">        // 等待内核mach_msg事件</div><div class=\"line\">        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();</div><div class=\"line\">        </div><div class=\"line\">        // Zzz...</div><div class=\"line\">        </div><div class=\"line\">        // 从等待中醒来</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);</div><div class=\"line\">        </div><div class=\"line\">        // 处理因timer的唤醒</div><div class=\"line\">        if (wakeUpPort == timerPort)</div><div class=\"line\">            __CFRunLoopDoTimers();</div><div class=\"line\">        </div><div class=\"line\">        // 处理异步方法唤醒,如dispatch_async</div><div class=\"line\">        else if (wakeUpPort == mainDispatchQueuePort)</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</div><div class=\"line\">            </div><div class=\"line\">        // UI刷新,动画显示</div><div class=\"line\">        else</div><div class=\"line\">            __CFRunLoopDoSource1();</div><div class=\"line\">        </div><div class=\"line\">        // 再次确保是否有同步的方法需要调用</div><div class=\"line\">        __CFRunLoopDoBlocks();</div><div class=\"line\">        </div><div class=\"line\">    &#125; while (!stop &amp;&amp; !timeout);</div><div class=\"line\">    </div><div class=\"line\">    //通知即将退出runloop</div><div class=\"line\">    __CFRunLoopDoObservers(CFRunLoopExit);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<blockquote>\n<p>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"量化卡顿的程度\"><a href=\"#量化卡顿的程度\" class=\"headerlink\" title=\"量化卡顿的程度\"></a>量化卡顿的程度</h3><blockquote>\n<p>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:</p>\n</blockquote>\n<p><br></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    MyClass *object = (__bridge MyClass*)info;</div><div class=\"line\">    object-&gt;activity = activity;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)registerObserver</div><div class=\"line\">&#123;</div><div class=\"line\">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</div><div class=\"line\">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</div><div class=\"line\">                                                            kCFRunLoopAllActivities,</div><div class=\"line\">                                                            YES,</div><div class=\"line\">                                                            0,</div><div class=\"line\">                                                            &amp;runLoopObserverCallBack,</div><div class=\"line\">                                                            &amp;context);</div><div class=\"line\">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br></p>\n<blockquote>\n<p>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.<br>为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:</p>\n</blockquote>\n<p><br></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    MyClass *object = (__bridge MyClass*)info;</div><div class=\"line\">    </div><div class=\"line\">    // 记录状态值</div><div class=\"line\">    object-&gt;activity = activity;</div><div class=\"line\">    </div><div class=\"line\">    // 发送信号</div><div class=\"line\">    dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</div><div class=\"line\">    dispatch_semaphore_signal(semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)registerObserver</div><div class=\"line\">&#123;</div><div class=\"line\">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</div><div class=\"line\">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</div><div class=\"line\">                                                            kCFRunLoopAllActivities,</div><div class=\"line\">                                                            YES,</div><div class=\"line\">                                                            0,</div><div class=\"line\">                                                            &amp;runLoopObserverCallBack,</div><div class=\"line\">                                                            &amp;context);</div><div class=\"line\">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">    </div><div class=\"line\">    // 创建信号</div><div class=\"line\">    semaphore = dispatch_semaphore_create(0);</div><div class=\"line\">    </div><div class=\"line\">    // 在子线程监控时长</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        while (YES)</div><div class=\"line\">        &#123;</div><div class=\"line\">            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</div><div class=\"line\">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</div><div class=\"line\">            if (st != 0)</div><div class=\"line\">            &#123;</div><div class=\"line\">                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    if (++timeoutCount &lt; 5)</div><div class=\"line\">                        continue;</div><div class=\"line\">                    </div><div class=\"line\">                    NSLog(@&quot;好像有点儿卡哦&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            timeoutCount = 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"记录卡顿的函数调用\"><a href=\"#记录卡顿的函数调用\" class=\"headerlink\" title=\"记录卡顿的函数调用\"></a>记录卡顿的函数调用</h3><p><br></p>\n<blockquote>\n<p>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:</p>\n</blockquote>\n<p><br></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD</div><div class=\"line\">                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</div><div class=\"line\">PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];</div><div class=\"line\"></div><div class=\"line\">NSData *data = [crashReporter generateLiveReport];</div><div class=\"line\">PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];</div><div class=\"line\">NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter</div><div class=\"line\">                                                          withTextFormat:PLCrashReportTextFormatiOS];</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;------------\\n%@\\n------------&quot;, report);</div></pre></td></tr></table></figure>\n<p>当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至此这个实时卡顿监控就大功告成了!</p>\n<p><a href=\"https://github.com/suifengqjn/PerformanceMonitor\" target=\"_blank\" rel=\"external\">demo地址</a></p>\n","excerpt":"<blockquote>\n<p>在移动设备上开发软件,性能一直是我们最为关心的话题之一,我们作为程序员除了需要努力提高代码质量之外,及时发现和监控软件中那些造成性能低下的”罪魁祸首”也是我们神圣的职责.</p>\n</blockquote>\n<p>众所周知,iOS平台因为UIKit本身的特性,需要将所有的UI操作都放在主线程执行,所以也造成不少程序员都习惯将一些线程安全性不确定的逻辑,以及其它线程结束后的汇总工作等等放到了主线,所以主线程中包含的这些大量计算、IO、绘制都有可能造成卡顿.</p>\n<p>在Xcode中已经集成了非常方便的调试工具Instruments,它可以帮助我们在开发测试阶段分析软件运行的性能消耗,但一款软件经过测试流程和实验室分析肯定是不够的,在正式环境中由大量用户在使用过程中监控、分析到的数据更能解决一些隐藏的问题.</p>\n<h3 id=\"寻找卡顿的切入点\"><a href=\"#寻找卡顿的切入点\" class=\"headerlink\" title=\"寻找卡顿的切入点\"></a>寻找卡顿的切入点</h3><blockquote>\n<p>监控卡顿,最直接就是找到主线程都在干些啥玩意儿.我们知道一个线程的消息事件处理都是依赖于NSRunLoop来驱动,所以要知道线程正在调用什么方法,就需要从NSRunLoop来入手.CFRunLoop的代码是开源,可以在此处查阅到源代码<a href=\"http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的\">http://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c,其中核心方法CFRunLoopRun简化后的主要逻辑大概是这样的</a>:<br><br /></p>\n</blockquote>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">int32_t __CFRunLoopRun()</div><div class=\"line\">&#123;</div><div class=\"line\">    //通知即将进入runloop</div><div class=\"line\">    __CFRunLoopDoObservers(KCFRunLoopEntry);</div><div class=\"line\">    </div><div class=\"line\">    do</div><div class=\"line\">    &#123;</div><div class=\"line\">        // 通知将要处理timer和source</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeSources);</div><div class=\"line\">        </div><div class=\"line\">        __CFRunLoopDoBlocks();  //处理非延迟的主线程调用</div><div class=\"line\">        __CFRunLoopDoSource0(); //处理UIEvent事件</div><div class=\"line\">        </div><div class=\"line\">        //GCD dispatch main queue</div><div class=\"line\">        CheckIfExistMessagesInMainDispatchQueue();</div><div class=\"line\">        </div><div class=\"line\">        // 即将进入休眠</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);</div><div class=\"line\">        </div><div class=\"line\">        // 等待内核mach_msg事件</div><div class=\"line\">        mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts();</div><div class=\"line\">        </div><div class=\"line\">        // Zzz...</div><div class=\"line\">        </div><div class=\"line\">        // 从等待中醒来</div><div class=\"line\">        __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);</div><div class=\"line\">        </div><div class=\"line\">        // 处理因timer的唤醒</div><div class=\"line\">        if (wakeUpPort == timerPort)</div><div class=\"line\">            __CFRunLoopDoTimers();</div><div class=\"line\">        </div><div class=\"line\">        // 处理异步方法唤醒,如dispatch_async</div><div class=\"line\">        else if (wakeUpPort == mainDispatchQueuePort)</div><div class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</div><div class=\"line\">            </div><div class=\"line\">        // UI刷新,动画显示</div><div class=\"line\">        else</div><div class=\"line\">            __CFRunLoopDoSource1();</div><div class=\"line\">        </div><div class=\"line\">        // 再次确保是否有同步的方法需要调用</div><div class=\"line\">        __CFRunLoopDoBlocks();</div><div class=\"line\">        </div><div class=\"line\">    &#125; while (!stop &amp;&amp; !timeout);</div><div class=\"line\">    </div><div class=\"line\">    //通知即将退出runloop</div><div class=\"line\">    __CFRunLoopDoObservers(CFRunLoopExit);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br /></p>\n<blockquote>\n<p>不难发现NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.</p>\n</blockquote>\n<p><br /></p>\n<h3 id=\"量化卡顿的程度\"><a href=\"#量化卡顿的程度\" class=\"headerlink\" title=\"量化卡顿的程度\"></a>量化卡顿的程度</h3><blockquote>\n<p>要监控NSRunLoop的状态,我们需要使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化,具体的使用如下:</p>\n</blockquote>\n<p><br /></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    MyClass *object = (__bridge MyClass*)info;</div><div class=\"line\">    object-&gt;activity = activity;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)registerObserver</div><div class=\"line\">&#123;</div><div class=\"line\">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</div><div class=\"line\">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</div><div class=\"line\">                                                            kCFRunLoopAllActivities,</div><div class=\"line\">                                                            YES,</div><div class=\"line\">                                                            0,</div><div class=\"line\">                                                            &amp;runLoopObserverCallBack,</div><div class=\"line\">                                                            &amp;context);</div><div class=\"line\">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><br /></p>\n<blockquote>\n<p>只需要另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.<br>为了让计算更精确,需要让子线程更及时的获知主线程NSRunLoop状态变化,所以dispatch_semaphore_t是个不错的选择,另外卡顿需要覆盖到多次连续小卡顿和单次长时间卡顿两种情景,所以判定条件也需要做适当优化.将上面两个方法添加计算的逻辑如下:</p>\n</blockquote>\n<p><br /></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</div><div class=\"line\">&#123;</div><div class=\"line\">    MyClass *object = (__bridge MyClass*)info;</div><div class=\"line\">    </div><div class=\"line\">    // 记录状态值</div><div class=\"line\">    object-&gt;activity = activity;</div><div class=\"line\">    </div><div class=\"line\">    // 发送信号</div><div class=\"line\">    dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</div><div class=\"line\">    dispatch_semaphore_signal(semaphore);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)registerObserver</div><div class=\"line\">&#123;</div><div class=\"line\">    CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</div><div class=\"line\">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</div><div class=\"line\">                                                            kCFRunLoopAllActivities,</div><div class=\"line\">                                                            YES,</div><div class=\"line\">                                                            0,</div><div class=\"line\">                                                            &amp;runLoopObserverCallBack,</div><div class=\"line\">                                                            &amp;context);</div><div class=\"line\">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</div><div class=\"line\">    </div><div class=\"line\">    // 创建信号</div><div class=\"line\">    semaphore = dispatch_semaphore_create(0);</div><div class=\"line\">    </div><div class=\"line\">    // 在子线程监控时长</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        while (YES)</div><div class=\"line\">        &#123;</div><div class=\"line\">            // 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</div><div class=\"line\">            long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</div><div class=\"line\">            if (st != 0)</div><div class=\"line\">            &#123;</div><div class=\"line\">                if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)</div><div class=\"line\">                &#123;</div><div class=\"line\">                    if (++timeoutCount &lt; 5)</div><div class=\"line\">                        continue;</div><div class=\"line\">                    </div><div class=\"line\">                    NSLog(@&quot;好像有点儿卡哦&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            timeoutCount = 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"记录卡顿的函数调用\"><a href=\"#记录卡顿的函数调用\" class=\"headerlink\" title=\"记录卡顿的函数调用\"></a>记录卡顿的函数调用</h3><p><br /></p>\n<blockquote>\n<p>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈,使用示例如下:</p>\n</blockquote>\n<p><br /></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">PLCrashReporterConfig *config = [[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD</div><div class=\"line\">                                                                   symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll];</div><div class=\"line\">PLCrashReporter *crashReporter = [[PLCrashReporter alloc] initWithConfiguration:config];</div><div class=\"line\"></div><div class=\"line\">NSData *data = [crashReporter generateLiveReport];</div><div class=\"line\">PLCrashReport *reporter = [[PLCrashReport alloc] initWithData:data error:NULL];</div><div class=\"line\">NSString *report = [PLCrashReportTextFormatter stringValueForCrashReport:reporter</div><div class=\"line\">                                                          withTextFormat:PLCrashReportTextFormatiOS];</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;------------\\n%@\\n------------&quot;, report);</div></pre></td></tr></table></figure>\n<p>当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑,至此这个实时卡顿监控就大功告成了!</p>\n<p><a href=\"https://github.com/suifengqjn/PerformanceMonitor\">demo地址</a></p>"},{"title":"iOS构建自动化打包脚本","date":"2016-11-20T16:00:59.000Z","_content":"\n虽然Xcode打包很方便，但是每次也得花费好几分钟，一次次重复相同的事情，日积月累也会浪费不少的时间。而且大多数情况下，一个app会有多个target,这样的话打包花费的时间更加是成倍的增加。在生成自动化构建脚本之前得先了解几个概念。\n\n### 1.xcodebuild\n\n使用 xcodebuild -h 来看看 xcodebuild 到底是干啥的\n>Usage: xcodebuild [-project ] [[-target ]...|-alltargets] [-configuration ] [-arch ]... [-sdk [|]] [-showBuildSettings] [=]... []...\n       xcodebuild [-project ] -scheme  [-destination ]... [-configuration ] [-arch ]... [-sdk [|]] [-showBuildSettings] [=]... []...\n       xcodebuild -workspace  -scheme  [-destination ]... [-configuration ] [-arch ]... [-sdk [|]] [-showBuildSettings] [=]... []...\n       xcodebuild -version [-sdk [|] [] ]\n       xcodebuild -list [[-project ]|[-workspace ]] [-json]\n       xcodebuild -showsdks\n       xcodebuild -exportArchive -archivePath  -exportPath  -exportOptionsPlist \n       xcodebuild -exportLocalizations -localizationPath  -project  [-exportLanguage ...]\n       xcodebuild -importLocalizations -localizationPath  -project\n       \n\n这里我只截取了 usage 部分，option 部分太多没有截取。\n这里介绍几条毕竟常用的命令：\n<!--more-->\n### 2.xcodebuild -list …\n\n>xcodebuild -list [[-project ]|[-workspace ]] [-json] \n\n\n>usage: 输出 project 中的 targets 和 configurations，或者 workspace 中 schemes。\n-project 和 -workspace 是输出指定内容，不输入默认输出当前目录下。-json 是以 json 格式输出。\n\nexample:\n\n```\n$ xcodebuild -list\nInformation about project \"XX\":\n    Targets:\n        XX\n        XXTests\n \n    Build Configurations:\n        Debug\n        Release\n \n    If no build configuration is specified and -scheme is not passed then \"Release\" is used.\n \n    Schemes:\n        XX\n\n```\n\n### 3. xcodebuild -project …\n\n>xcodebuild [-project ] [[-target ]...|-alltargets] [-configuration ] [-arch ]... [-sdk [|]] [-showBuildSettings] [=]... []...\n\n\nusage:\n-project: 指定 project 名字，默认首个 project。\n-target: 指定对应的 target ，默认首个 target。\n-configuration: 选择Debug 或 Release，默认 Release，当然如果你有自定义的配置的，就应该选你配置的，上面 -list 中有输出。\n-showBuildSettings: 显示工程的配置。\n=: 修改工程的配置文件。\nbuildaction ... : 如下，默认为 build\n```\n    Specify a build action (or actions) to perform on the target.\n    Available build actions are:\n \n    build       Build the target in the build root (SYMROOT).  This is\n                the default build action.\n \n   installsrc  Copy the source of the project to the source root\n               (SRCROOT).\n \n   install     Build the target and install it into the target's\n               installation directory in the distribution root\n               (DSTROOT).\n \n  clean       Remove build products and intermediate files from the\n              build root (SYMROOT).\n\n```\n\nexample:\n\n>$ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release\n这行命令表示编译 xx.xcodeproj 的 xx target。在 terminal 中会看到编译过程，如果成功最后会输出 ** BUILD SUCCEEDED **。最后会在当前目录下生成 build/Release-iphoneos/xx.app\n\n> $ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release -showBuildSettings\n这行命令使用 -showBuildSettings 是不会 build 项目的，只是输出工程的配置。这里输出的的内容有(内容过多，只截取部分)\n\n```\nBuild settings for action build and target XX:\n    ACTION = build\n    AD_HOC_CODE_SIGNING_ALLOWED = NO\n    ALTERNATE_GROUP = staff\n    ALTERNATE_MODE = u+w,go-w,a+rX\n    ALTERNATE_OWNER = TsuiYuenHong\n    ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO\n    ALWAYS_SEARCH_USER_PATHS = NO\n    ALWAYS_USE_SEPARATE_HEADERMAPS = NO\n    APPLE_INTERNAL_DEVELOPER_DIR = /AppleInternal/Developer\n    APPLE_INTERNAL_DIR = /AppleInternal\n    APPLE_INTERNAL_DOCUMENTATION_DIR = /AppleInternal/Documentation\n    APPLE_INTERNAL_LIBRARY_DIR = /AppleInternal/Library\n    APPLE_INTERNAL_TOOLS = /AppleInternal/Developer/Tools\n    APPLICATION_EXTENSION_API_ONLY = NO\n    APPLY_RULES_IN_COPY_FILES = NO\n    ARCHS = armv7 arm64\n```\n\n如果要修改配置文件，就直接最命令最后加上你要修改的内容。\n例如在这行命令最后加上指定证书\n\n>$ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release PROVISIONING_PROFILE=\"你证书的id\"\n其中的字段是上面 -showBuildSettings 显示的字段，也可以看官网介绍\n\n### 4. xcodebuild -workspace …\n\nxcodebuild -workspace -scheme [-destination ]... [-configuration ] [-arch ]... [-sdk [|]] [-showBuildSettings] [=]... []...\n\n除了 workspace 和 scheme 之外其余选项都和上条命令相同。\n\n-workspace: 指定 workspace 名字，默认首个 workspace\n\n-scheme: 指定对应的 scheme ，默认首个 scheme\n\n### 5.xcodebuild -exportArchive …\n\n这里顺便介绍一下 archive 命令，因为在下面使用 PackageApplication 会出一个警告说推荐使用 -exportArchive。所以我们就来尝试一下使用 archive 来生成 app。\n\n首先使用一下命令来生成 .xcarchive 文件\nxcodebuild archive -workspace xx.xcworkspace -scheme xx -archivePath xx.xcarchive\n可以看出添加上 archive 命令和最后加入 -archivePath 生成archivePath的路径即可。\n然后该路径下会生成一个 xx.archivePath，里面包括三个文件，xx.app.dsym文件(可用于bugly等监控bug的平台)，info.plist(保存打包的一些信息)，还有我们的 xx.app 文件。\n\n其次使用 -exportArchive 生成 ipa 包\n\nxcodebuild -exportArchive -archivePath xx.xcarchive -exportPath xx -exportFormat ipa\n\n-archivePath: xx.archivePath 的路径\n\n-exportPath: 输出路径\n\n-exportFormat: 生成类型，这里选择我们需要的 ipa\n\n这样就利用我们的 xcodebuild 命令来生成 ipa 包\n\n### 6.xcrun\n\n这里也使用 xcrun 来生成 ipa 包即可\n\n`xcrun -sdk iphoneos PackageApplication build/Release-iphoneos/xx.app -o ~/Desktop/xx.ipa`\n\n但是，在 macos10.12 和 Xcode8 的环境下会出现一个警告\n\nwarning: PackageApplication is deprecated, use xcodebuild -exportArchive instead.\n\n说明 PackageApplication 已经被弃用了。\n\n不过其实这一步可以几乎等价于将 `xx.app` 放入一个 payload 的文件夹下然后压缩文件夹为 `xx.ipa`，当然这样做缺失一些信息，不过并不影响程序的运行。\n\n初步小结:\n\n综上，我们有两种方法来生成我们需要的 ipa 包。\n1.我们用xcodebuild 命令来编译我们的项目生成app, 然后再用xcrun将app转ipa\n2.\t使用`xcodebuild archive`命令来直接生成我们需要的ipa。\n\n虽然现在网上几乎都是使用`xcodebuild + xcrun`来来生成ipa包，不过既然官方说 PackageApplication is deprecated，那还是推荐使用第二种方法，一步到位。\n\n### 7.自动化打包\n\n这里从我工作室的一个项目切入，这个项目需要最终生成18个ipa包，但是他们几乎是共用一套代码的，不同的地方在于bundleName/bundleDisplayName/bundleid等，以及一些资源文件的不同，例如icon等。所以可想而知如果选择手动打包的痛苦，并且当你打包到一半发现某个地方错了要重新打包\n\n这里说一下自动化打包1.0解决思路:\n\n\n\t1.\t使用命令defaults write来修改项目中的plist文件，来达到修改 bundleName/bundleDisplayName/bundleid…的目的。\n\t2.\t使用命令 cp 来替换资源文件。\n\t3.\t使用xcodebuild -workspace ..编译出app包。\n\t4.\t使用xcrun ...生成 ipa 。 \n这是我最开始想到的思路，最终运行时间大概为每个包2.5m(时间主要浪费在编译)，然后一套下来也要半个多小时。虽然比起手动打快了不少，但还是太慢了。毕竟自动化的目的不仅仅是自动，还要速度。\n\n既然问题出在编译上，那我的思路就往编译一次多次使用这个方向上面思考。然后想到了既然只是资源文件和plist的不同，没有涉及到代码的更换(不过这个项目后期不同 app 会执行不同一套代码，不过也有解决办法)，这里就出现了自动化打包2.0的版本。\n\n\t1.\t使用xcodebuild -workspace..编译出app包。 \n\t2.\t使用命令defaults write来修改项目中的plist文件，来达到修改bundleName/bundleDisplayName/bundleid…的目的。 \n\t3.\t使用命cp来替换资源文件。 \n\t4.\t重签名codesign -f -s \"iPhone Distribution: xx co., LTD\" --entitlements $Entitlements $ipaPath/Payload/YouXiaoYun.app \n\t5.\t使用xcrun ... 生成ipa 。\n\n和1.0大致相似，不过并不是每次生成ipa都需要编译一次。而是编译一次，然后直接修改app下内容，不过这里会出现签名错误的问题，因为在编译的最后会用证书帮app签名，如果你直接替换资源然后就生成ipa的话会导致ipa无法安装。\n\n那这时候神奇的重签名技术就出来(重签名用在正途上的真少见…hhhh，关于重签名的文章google一下就会很多)，使用codesign命令就可以帮修改过资源的app重签名。\n最终使用2.0的时间基本是在5-6分钟左右。\n\n### 8.最终代码\n\n以下是完整的脚本文件，部分信息需要自己替换。\n以下脚本适用于一次打 N 个包，适用情况：\n\n\t1.\t可以替换 bundle 信息 \n\t2.\t替换音频图片资源 \n\t3.\t可以执行不同代码 \n\t4.\t生成相应的plist文件 \n\t5.\t上传到蒲公英分发平台 \n\n当然也可以打一个包，适当删除某些代码即可。\n```\n# 1.Configuration Info\n \n# 项目路径 需修改\nprojectDir=\"你的项目路径\"\n \n# 打包生成路径 需修改\nipaPath=\"ipa生成路径\"\n \n# 图标路径 需修改\niconPath=\"~/Desktop/icon\"\n \n# Provisioning Profile 需修改 查看本地配置文件\nPROVISIONING_PROFILE=\"xxxxxxx-xxxx-4bfa-a696-0ec7391b24d8\"\n \n############# 重签名需要文件\n# 以下文件需放在 ipaPath 路径下\nEntitlements=$ipaPath/entitlements.plist\n#############\n \n# 版本号\nbundleVersion=\"2.0.0\"\n \n# 选择打包序号 多选则以空格隔开 如(\"1\" \"2\" \"3\")\nappPackNum=(\"1 2\")\n \n# 蒲公英分发参数 不分发可忽略 默认不分发 下面的两个KEY是默认测试的网址对应KEY\nISUPLOAD=0\nUSERKEY=\"xxx\"\nAPIKEY=\"xxx\"\n \n# ---------------------------可选 如果需要替换 app 的 icon --------------------------------- #\n \n# 配置App信息数组 格式:\"AppName(和工程中appInfo.Plist对应)\" \"icon\"\n#Schemes:\n#        1.app1 app1Icon\n#        2.app2 app2Icon\n#        3.app3 app3Icon\n \n# --------------------------------------------------------------------------------------- #\n \n# 打包个数\nappPackNumLength=${#appPackNum[*]}\n \nappInfos=(\n          \"app1\" \"app1Icon\" \"xxxx\"\n          \"app2\" \"app2Icon\" \"xxxx\"\n          \"app3\" \"app3Icon\" \"xxxx\"\n          )\n \nappInfosLength=${#appInfos[*]}\n \n# Scheme Name\nschemeName=\"xx\"\n \n# Code Sign ID\nCODE_SIGN_IDENTITY=\"xx co., LTD\"\n \n# 生成 APP 路径\nbuildDir=\"build/Release-iphoneos\"\n \n# 开始时间\nbeginTime=`date +%s`\n \n# 创建打包目录\nmkdir ${ipaPath}/AllPack\n \n# 本地存放全部 IPA 的路径\nallIPAPackPath=\"${ipaPath}/allPack\"\n \n# 清除缓存\nrm -rf $projectDir/$buildDir\n \n# Build 生成 APP\nxcodebuild -workspace ${projectDir}/xx.xcworkspace -scheme ${schemeName} -configuration Release clean -sdk iphoneos build CODE_SIGN_IDENTITY=\"${CODE_SIGN_IDENTITY}\" PROVISIONING_PROFILE=\"${PROVISIONING_PROFILE}\" SYMROOT=\"${projectDir}/build\"\nif [[ $? = 0 ]]; then\n  echo \"\\033[31m 编译成功\\n \\033[0m\"\nelse\n  echo \"\\033[31m 编译失败\\n \\033[0m\"\nfi\n \n# 先创建 payload 文件夹\nmkdir ~/Desktop/Payload\n# 移动编译生成的 app 到桌面的 Payload 文件夹下\ncp -Rf ${projectDir}/${buildDir}/${schemeName}.app $ipaPath/Payload\n \n# 以下二选一\n# 1.----全部打包----\n#for (( i=0; i $plist_path\nitemsassetskindsoftware-packageurlhttps://xxxxxxxxxxxx/$appDownloadName.ipakinddisplay-imageurlhttps://xxxxxxxxxxxx/${appIconName}.pngkindfull-size-imageurlhttps://xxxxxxxxxxxx/${appIconName}.pngmetadatabundle-identifier你的bundidbundle-version$bundleVersionkindsoftwaretitle$appDownloadName\nEOF\n \n# 移动\nmv ${ipaPath}/$appDownloadName.ipa ${allIPAPackPath}/$appName\n \n# 6.上传蒲公英分发平台\n \nif [[ $ISUPLOAD = 1 ]]; then\n  echo \"正在上传蒲公英...\"\n  curl -F \"file=@$allIPAPackPath/$appName/$appDownloadName.ipa\" -F \"uKey=$USERKEY\" -F \"_api_key=$APIKEY\" http://www.pgyer.com/apiv1/app/upload\n \nfi\n \ndone\n \n# 清除无关文件\nrm -rf $ipaPath/Payload\n \n# 结束时间\nendTime=`date +%s`\necho -e \"打包时间$[ endTime - beginTime ]秒\"\n\n```\n编辑完后保存成.sh后缀的可执行文件\n\n","source":"_posts/iOS构建自动化打包脚本.md","raw":"---\ntitle: iOS构建自动化打包脚本\ndate: 2016-11-21 00:00:59\ntags:\n  - iOS\n  - Archive\n  - targit\ncategories:\n  - iOS配置\n---\n\n虽然Xcode打包很方便，但是每次也得花费好几分钟，一次次重复相同的事情，日积月累也会浪费不少的时间。而且大多数情况下，一个app会有多个target,这样的话打包花费的时间更加是成倍的增加。在生成自动化构建脚本之前得先了解几个概念。\n\n### 1.xcodebuild\n\n使用 xcodebuild -h 来看看 xcodebuild 到底是干啥的\n>Usage: xcodebuild [-project ] [[-target ]...|-alltargets] [-configuration ] [-arch ]... [-sdk [|]] [-showBuildSettings] [=]... []...\n       xcodebuild [-project ] -scheme  [-destination ]... [-configuration ] [-arch ]... [-sdk [|]] [-showBuildSettings] [=]... []...\n       xcodebuild -workspace  -scheme  [-destination ]... [-configuration ] [-arch ]... [-sdk [|]] [-showBuildSettings] [=]... []...\n       xcodebuild -version [-sdk [|] [] ]\n       xcodebuild -list [[-project ]|[-workspace ]] [-json]\n       xcodebuild -showsdks\n       xcodebuild -exportArchive -archivePath  -exportPath  -exportOptionsPlist \n       xcodebuild -exportLocalizations -localizationPath  -project  [-exportLanguage ...]\n       xcodebuild -importLocalizations -localizationPath  -project\n       \n\n这里我只截取了 usage 部分，option 部分太多没有截取。\n这里介绍几条毕竟常用的命令：\n<!--more-->\n### 2.xcodebuild -list …\n\n>xcodebuild -list [[-project ]|[-workspace ]] [-json] \n\n\n>usage: 输出 project 中的 targets 和 configurations，或者 workspace 中 schemes。\n-project 和 -workspace 是输出指定内容，不输入默认输出当前目录下。-json 是以 json 格式输出。\n\nexample:\n\n```\n$ xcodebuild -list\nInformation about project \"XX\":\n    Targets:\n        XX\n        XXTests\n \n    Build Configurations:\n        Debug\n        Release\n \n    If no build configuration is specified and -scheme is not passed then \"Release\" is used.\n \n    Schemes:\n        XX\n\n```\n\n### 3. xcodebuild -project …\n\n>xcodebuild [-project ] [[-target ]...|-alltargets] [-configuration ] [-arch ]... [-sdk [|]] [-showBuildSettings] [=]... []...\n\n\nusage:\n-project: 指定 project 名字，默认首个 project。\n-target: 指定对应的 target ，默认首个 target。\n-configuration: 选择Debug 或 Release，默认 Release，当然如果你有自定义的配置的，就应该选你配置的，上面 -list 中有输出。\n-showBuildSettings: 显示工程的配置。\n=: 修改工程的配置文件。\nbuildaction ... : 如下，默认为 build\n```\n    Specify a build action (or actions) to perform on the target.\n    Available build actions are:\n \n    build       Build the target in the build root (SYMROOT).  This is\n                the default build action.\n \n   installsrc  Copy the source of the project to the source root\n               (SRCROOT).\n \n   install     Build the target and install it into the target's\n               installation directory in the distribution root\n               (DSTROOT).\n \n  clean       Remove build products and intermediate files from the\n              build root (SYMROOT).\n\n```\n\nexample:\n\n>$ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release\n这行命令表示编译 xx.xcodeproj 的 xx target。在 terminal 中会看到编译过程，如果成功最后会输出 ** BUILD SUCCEEDED **。最后会在当前目录下生成 build/Release-iphoneos/xx.app\n\n> $ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release -showBuildSettings\n这行命令使用 -showBuildSettings 是不会 build 项目的，只是输出工程的配置。这里输出的的内容有(内容过多，只截取部分)\n\n```\nBuild settings for action build and target XX:\n    ACTION = build\n    AD_HOC_CODE_SIGNING_ALLOWED = NO\n    ALTERNATE_GROUP = staff\n    ALTERNATE_MODE = u+w,go-w,a+rX\n    ALTERNATE_OWNER = TsuiYuenHong\n    ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO\n    ALWAYS_SEARCH_USER_PATHS = NO\n    ALWAYS_USE_SEPARATE_HEADERMAPS = NO\n    APPLE_INTERNAL_DEVELOPER_DIR = /AppleInternal/Developer\n    APPLE_INTERNAL_DIR = /AppleInternal\n    APPLE_INTERNAL_DOCUMENTATION_DIR = /AppleInternal/Documentation\n    APPLE_INTERNAL_LIBRARY_DIR = /AppleInternal/Library\n    APPLE_INTERNAL_TOOLS = /AppleInternal/Developer/Tools\n    APPLICATION_EXTENSION_API_ONLY = NO\n    APPLY_RULES_IN_COPY_FILES = NO\n    ARCHS = armv7 arm64\n```\n\n如果要修改配置文件，就直接最命令最后加上你要修改的内容。\n例如在这行命令最后加上指定证书\n\n>$ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release PROVISIONING_PROFILE=\"你证书的id\"\n其中的字段是上面 -showBuildSettings 显示的字段，也可以看官网介绍\n\n### 4. xcodebuild -workspace …\n\nxcodebuild -workspace -scheme [-destination ]... [-configuration ] [-arch ]... [-sdk [|]] [-showBuildSettings] [=]... []...\n\n除了 workspace 和 scheme 之外其余选项都和上条命令相同。\n\n-workspace: 指定 workspace 名字，默认首个 workspace\n\n-scheme: 指定对应的 scheme ，默认首个 scheme\n\n### 5.xcodebuild -exportArchive …\n\n这里顺便介绍一下 archive 命令，因为在下面使用 PackageApplication 会出一个警告说推荐使用 -exportArchive。所以我们就来尝试一下使用 archive 来生成 app。\n\n首先使用一下命令来生成 .xcarchive 文件\nxcodebuild archive -workspace xx.xcworkspace -scheme xx -archivePath xx.xcarchive\n可以看出添加上 archive 命令和最后加入 -archivePath 生成archivePath的路径即可。\n然后该路径下会生成一个 xx.archivePath，里面包括三个文件，xx.app.dsym文件(可用于bugly等监控bug的平台)，info.plist(保存打包的一些信息)，还有我们的 xx.app 文件。\n\n其次使用 -exportArchive 生成 ipa 包\n\nxcodebuild -exportArchive -archivePath xx.xcarchive -exportPath xx -exportFormat ipa\n\n-archivePath: xx.archivePath 的路径\n\n-exportPath: 输出路径\n\n-exportFormat: 生成类型，这里选择我们需要的 ipa\n\n这样就利用我们的 xcodebuild 命令来生成 ipa 包\n\n### 6.xcrun\n\n这里也使用 xcrun 来生成 ipa 包即可\n\n`xcrun -sdk iphoneos PackageApplication build/Release-iphoneos/xx.app -o ~/Desktop/xx.ipa`\n\n但是，在 macos10.12 和 Xcode8 的环境下会出现一个警告\n\nwarning: PackageApplication is deprecated, use xcodebuild -exportArchive instead.\n\n说明 PackageApplication 已经被弃用了。\n\n不过其实这一步可以几乎等价于将 `xx.app` 放入一个 payload 的文件夹下然后压缩文件夹为 `xx.ipa`，当然这样做缺失一些信息，不过并不影响程序的运行。\n\n初步小结:\n\n综上，我们有两种方法来生成我们需要的 ipa 包。\n1.我们用xcodebuild 命令来编译我们的项目生成app, 然后再用xcrun将app转ipa\n2.\t使用`xcodebuild archive`命令来直接生成我们需要的ipa。\n\n虽然现在网上几乎都是使用`xcodebuild + xcrun`来来生成ipa包，不过既然官方说 PackageApplication is deprecated，那还是推荐使用第二种方法，一步到位。\n\n### 7.自动化打包\n\n这里从我工作室的一个项目切入，这个项目需要最终生成18个ipa包，但是他们几乎是共用一套代码的，不同的地方在于bundleName/bundleDisplayName/bundleid等，以及一些资源文件的不同，例如icon等。所以可想而知如果选择手动打包的痛苦，并且当你打包到一半发现某个地方错了要重新打包\n\n这里说一下自动化打包1.0解决思路:\n\n\n\t1.\t使用命令defaults write来修改项目中的plist文件，来达到修改 bundleName/bundleDisplayName/bundleid…的目的。\n\t2.\t使用命令 cp 来替换资源文件。\n\t3.\t使用xcodebuild -workspace ..编译出app包。\n\t4.\t使用xcrun ...生成 ipa 。 \n这是我最开始想到的思路，最终运行时间大概为每个包2.5m(时间主要浪费在编译)，然后一套下来也要半个多小时。虽然比起手动打快了不少，但还是太慢了。毕竟自动化的目的不仅仅是自动，还要速度。\n\n既然问题出在编译上，那我的思路就往编译一次多次使用这个方向上面思考。然后想到了既然只是资源文件和plist的不同，没有涉及到代码的更换(不过这个项目后期不同 app 会执行不同一套代码，不过也有解决办法)，这里就出现了自动化打包2.0的版本。\n\n\t1.\t使用xcodebuild -workspace..编译出app包。 \n\t2.\t使用命令defaults write来修改项目中的plist文件，来达到修改bundleName/bundleDisplayName/bundleid…的目的。 \n\t3.\t使用命cp来替换资源文件。 \n\t4.\t重签名codesign -f -s \"iPhone Distribution: xx co., LTD\" --entitlements $Entitlements $ipaPath/Payload/YouXiaoYun.app \n\t5.\t使用xcrun ... 生成ipa 。\n\n和1.0大致相似，不过并不是每次生成ipa都需要编译一次。而是编译一次，然后直接修改app下内容，不过这里会出现签名错误的问题，因为在编译的最后会用证书帮app签名，如果你直接替换资源然后就生成ipa的话会导致ipa无法安装。\n\n那这时候神奇的重签名技术就出来(重签名用在正途上的真少见…hhhh，关于重签名的文章google一下就会很多)，使用codesign命令就可以帮修改过资源的app重签名。\n最终使用2.0的时间基本是在5-6分钟左右。\n\n### 8.最终代码\n\n以下是完整的脚本文件，部分信息需要自己替换。\n以下脚本适用于一次打 N 个包，适用情况：\n\n\t1.\t可以替换 bundle 信息 \n\t2.\t替换音频图片资源 \n\t3.\t可以执行不同代码 \n\t4.\t生成相应的plist文件 \n\t5.\t上传到蒲公英分发平台 \n\n当然也可以打一个包，适当删除某些代码即可。\n```\n# 1.Configuration Info\n \n# 项目路径 需修改\nprojectDir=\"你的项目路径\"\n \n# 打包生成路径 需修改\nipaPath=\"ipa生成路径\"\n \n# 图标路径 需修改\niconPath=\"~/Desktop/icon\"\n \n# Provisioning Profile 需修改 查看本地配置文件\nPROVISIONING_PROFILE=\"xxxxxxx-xxxx-4bfa-a696-0ec7391b24d8\"\n \n############# 重签名需要文件\n# 以下文件需放在 ipaPath 路径下\nEntitlements=$ipaPath/entitlements.plist\n#############\n \n# 版本号\nbundleVersion=\"2.0.0\"\n \n# 选择打包序号 多选则以空格隔开 如(\"1\" \"2\" \"3\")\nappPackNum=(\"1 2\")\n \n# 蒲公英分发参数 不分发可忽略 默认不分发 下面的两个KEY是默认测试的网址对应KEY\nISUPLOAD=0\nUSERKEY=\"xxx\"\nAPIKEY=\"xxx\"\n \n# ---------------------------可选 如果需要替换 app 的 icon --------------------------------- #\n \n# 配置App信息数组 格式:\"AppName(和工程中appInfo.Plist对应)\" \"icon\"\n#Schemes:\n#        1.app1 app1Icon\n#        2.app2 app2Icon\n#        3.app3 app3Icon\n \n# --------------------------------------------------------------------------------------- #\n \n# 打包个数\nappPackNumLength=${#appPackNum[*]}\n \nappInfos=(\n          \"app1\" \"app1Icon\" \"xxxx\"\n          \"app2\" \"app2Icon\" \"xxxx\"\n          \"app3\" \"app3Icon\" \"xxxx\"\n          )\n \nappInfosLength=${#appInfos[*]}\n \n# Scheme Name\nschemeName=\"xx\"\n \n# Code Sign ID\nCODE_SIGN_IDENTITY=\"xx co., LTD\"\n \n# 生成 APP 路径\nbuildDir=\"build/Release-iphoneos\"\n \n# 开始时间\nbeginTime=`date +%s`\n \n# 创建打包目录\nmkdir ${ipaPath}/AllPack\n \n# 本地存放全部 IPA 的路径\nallIPAPackPath=\"${ipaPath}/allPack\"\n \n# 清除缓存\nrm -rf $projectDir/$buildDir\n \n# Build 生成 APP\nxcodebuild -workspace ${projectDir}/xx.xcworkspace -scheme ${schemeName} -configuration Release clean -sdk iphoneos build CODE_SIGN_IDENTITY=\"${CODE_SIGN_IDENTITY}\" PROVISIONING_PROFILE=\"${PROVISIONING_PROFILE}\" SYMROOT=\"${projectDir}/build\"\nif [[ $? = 0 ]]; then\n  echo \"\\033[31m 编译成功\\n \\033[0m\"\nelse\n  echo \"\\033[31m 编译失败\\n \\033[0m\"\nfi\n \n# 先创建 payload 文件夹\nmkdir ~/Desktop/Payload\n# 移动编译生成的 app 到桌面的 Payload 文件夹下\ncp -Rf ${projectDir}/${buildDir}/${schemeName}.app $ipaPath/Payload\n \n# 以下二选一\n# 1.----全部打包----\n#for (( i=0; i $plist_path\nitemsassetskindsoftware-packageurlhttps://xxxxxxxxxxxx/$appDownloadName.ipakinddisplay-imageurlhttps://xxxxxxxxxxxx/${appIconName}.pngkindfull-size-imageurlhttps://xxxxxxxxxxxx/${appIconName}.pngmetadatabundle-identifier你的bundidbundle-version$bundleVersionkindsoftwaretitle$appDownloadName\nEOF\n \n# 移动\nmv ${ipaPath}/$appDownloadName.ipa ${allIPAPackPath}/$appName\n \n# 6.上传蒲公英分发平台\n \nif [[ $ISUPLOAD = 1 ]]; then\n  echo \"正在上传蒲公英...\"\n  curl -F \"file=@$allIPAPackPath/$appName/$appDownloadName.ipa\" -F \"uKey=$USERKEY\" -F \"_api_key=$APIKEY\" http://www.pgyer.com/apiv1/app/upload\n \nfi\n \ndone\n \n# 清除无关文件\nrm -rf $ipaPath/Payload\n \n# 结束时间\nendTime=`date +%s`\necho -e \"打包时间$[ endTime - beginTime ]秒\"\n\n```\n编辑完后保存成.sh后缀的可执行文件\n\n","slug":"iOS构建自动化打包脚本","published":1,"updated":"2016-11-21T07:13:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmhl000nco60jg38yn2e","content":"<p>虽然Xcode打包很方便，但是每次也得花费好几分钟，一次次重复相同的事情，日积月累也会浪费不少的时间。而且大多数情况下，一个app会有多个target,这样的话打包花费的时间更加是成倍的增加。在生成自动化构建脚本之前得先了解几个概念。</p>\n<h3 id=\"1-xcodebuild\"><a href=\"#1-xcodebuild\" class=\"headerlink\" title=\"1.xcodebuild\"></a>1.xcodebuild</h3><p>使用 xcodebuild -h 来看看 xcodebuild 到底是干啥的</p>\n<blockquote>\n<p>Usage: xcodebuild [-project ] [[-target ]…|-alltargets] [-configuration ] [-arch ]… [-sdk [|]] [-showBuildSettings] [=]… []…<br>       xcodebuild [-project ] -scheme  [-destination ]… [-configuration ] [-arch ]… [-sdk [|]] [-showBuildSettings] [=]… []…<br>       xcodebuild -workspace  -scheme  [-destination ]… [-configuration ] [-arch ]… [-sdk [|]] [-showBuildSettings] [=]… []…<br>       xcodebuild -version [-sdk [|] [] ]<br>       xcodebuild -list [[-project ]|[-workspace ]] [-json]<br>       xcodebuild -showsdks<br>       xcodebuild -exportArchive -archivePath  -exportPath  -exportOptionsPlist<br>       xcodebuild -exportLocalizations -localizationPath  -project  [-exportLanguage …]<br>       xcodebuild -importLocalizations -localizationPath  -project</p>\n</blockquote>\n<p>这里我只截取了 usage 部分，option 部分太多没有截取。<br>这里介绍几条毕竟常用的命令：<br><a id=\"more\"></a></p>\n<h3 id=\"2-xcodebuild-list-…\"><a href=\"#2-xcodebuild-list-…\" class=\"headerlink\" title=\"2.xcodebuild -list …\"></a>2.xcodebuild -list …</h3><blockquote>\n<p>xcodebuild -list [[-project ]|[-workspace ]] [-json] </p>\n<p>usage: 输出 project 中的 targets 和 configurations，或者 workspace 中 schemes。<br>-project 和 -workspace 是输出指定内容，不输入默认输出当前目录下。-json 是以 json 格式输出。</p>\n</blockquote>\n<p>example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ xcodebuild -list</div><div class=\"line\">Information about project &quot;XX&quot;:</div><div class=\"line\">    Targets:</div><div class=\"line\">        XX</div><div class=\"line\">        XXTests</div><div class=\"line\"> </div><div class=\"line\">    Build Configurations:</div><div class=\"line\">        Debug</div><div class=\"line\">        Release</div><div class=\"line\"> </div><div class=\"line\">    If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used.</div><div class=\"line\"> </div><div class=\"line\">    Schemes:</div><div class=\"line\">        XX</div></pre></td></tr></table></figure>\n<h3 id=\"3-xcodebuild-project-…\"><a href=\"#3-xcodebuild-project-…\" class=\"headerlink\" title=\"3. xcodebuild -project …\"></a>3. xcodebuild -project …</h3><blockquote>\n<p>xcodebuild [-project ] [[-target ]…|-alltargets] [-configuration ] [-arch ]… [-sdk [|]] [-showBuildSettings] [=]… []…</p>\n</blockquote>\n<p>usage:<br>-project: 指定 project 名字，默认首个 project。<br>-target: 指定对应的 target ，默认首个 target。<br>-configuration: 选择Debug 或 Release，默认 Release，当然如果你有自定义的配置的，就应该选你配置的，上面 -list 中有输出。<br>-showBuildSettings: 显示工程的配置。<br>=: 修改工程的配置文件。<br>buildaction … : 如下，默认为 build<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">    Specify a build action (or actions) to perform on the target.</div><div class=\"line\">    Available build actions are:</div><div class=\"line\"> </div><div class=\"line\">    build       Build the target in the build root (SYMROOT).  This is</div><div class=\"line\">                the default build action.</div><div class=\"line\"> </div><div class=\"line\">   installsrc  Copy the source of the project to the source root</div><div class=\"line\">               (SRCROOT).</div><div class=\"line\"> </div><div class=\"line\">install     Build the target and install it into the target&apos;s</div><div class=\"line\">               installation directory in the distribution root</div><div class=\"line\">               (DSTROOT).</div><div class=\"line\"> </div><div class=\"line\">  clean       Remove build products and intermediate files from the</div><div class=\"line\">              build root (SYMROOT).</div></pre></td></tr></table></figure></p>\n<p>example:</p>\n<blockquote>\n<p>$ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release<br>这行命令表示编译 xx.xcodeproj 的 xx target。在 terminal 中会看到编译过程，如果成功最后会输出 <strong> BUILD SUCCEEDED </strong>。最后会在当前目录下生成 build/Release-iphoneos/xx.app</p>\n<p>$ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release -showBuildSettings<br>这行命令使用 -showBuildSettings 是不会 build 项目的，只是输出工程的配置。这里输出的的内容有(内容过多，只截取部分)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">Build settings for action build and target XX:</div><div class=\"line\">    ACTION = build</div><div class=\"line\">    AD_HOC_CODE_SIGNING_ALLOWED = NO</div><div class=\"line\">    ALTERNATE_GROUP = staff</div><div class=\"line\">    ALTERNATE_MODE = u+w,go-w,a+rX</div><div class=\"line\">    ALTERNATE_OWNER = TsuiYuenHong</div><div class=\"line\">    ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO</div><div class=\"line\">    ALWAYS_SEARCH_USER_PATHS = NO</div><div class=\"line\">    ALWAYS_USE_SEPARATE_HEADERMAPS = NO</div><div class=\"line\">    APPLE_INTERNAL_DEVELOPER_DIR = /AppleInternal/Developer</div><div class=\"line\">    APPLE_INTERNAL_DIR = /AppleInternal</div><div class=\"line\">    APPLE_INTERNAL_DOCUMENTATION_DIR = /AppleInternal/Documentation</div><div class=\"line\">    APPLE_INTERNAL_LIBRARY_DIR = /AppleInternal/Library</div><div class=\"line\">    APPLE_INTERNAL_TOOLS = /AppleInternal/Developer/Tools</div><div class=\"line\">    APPLICATION_EXTENSION_API_ONLY = NO</div><div class=\"line\">    APPLY_RULES_IN_COPY_FILES = NO</div><div class=\"line\">    ARCHS = armv7 arm64</div></pre></td></tr></table></figure>\n<p>如果要修改配置文件，就直接最命令最后加上你要修改的内容。<br>例如在这行命令最后加上指定证书</p>\n<blockquote>\n<p>$ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release PROVISIONING_PROFILE=”你证书的id”<br>其中的字段是上面 -showBuildSettings 显示的字段，也可以看官网介绍</p>\n</blockquote>\n<h3 id=\"4-xcodebuild-workspace-…\"><a href=\"#4-xcodebuild-workspace-…\" class=\"headerlink\" title=\"4. xcodebuild -workspace …\"></a>4. xcodebuild -workspace …</h3><p>xcodebuild -workspace -scheme [-destination ]… [-configuration ] [-arch ]… [-sdk [|]] [-showBuildSettings] [=]… []…</p>\n<p>除了 workspace 和 scheme 之外其余选项都和上条命令相同。</p>\n<p>-workspace: 指定 workspace 名字，默认首个 workspace</p>\n<p>-scheme: 指定对应的 scheme ，默认首个 scheme</p>\n<h3 id=\"5-xcodebuild-exportArchive-…\"><a href=\"#5-xcodebuild-exportArchive-…\" class=\"headerlink\" title=\"5.xcodebuild -exportArchive …\"></a>5.xcodebuild -exportArchive …</h3><p>这里顺便介绍一下 archive 命令，因为在下面使用 PackageApplication 会出一个警告说推荐使用 -exportArchive。所以我们就来尝试一下使用 archive 来生成 app。</p>\n<p>首先使用一下命令来生成 .xcarchive 文件<br>xcodebuild archive -workspace xx.xcworkspace -scheme xx -archivePath xx.xcarchive<br>可以看出添加上 archive 命令和最后加入 -archivePath 生成archivePath的路径即可。<br>然后该路径下会生成一个 xx.archivePath，里面包括三个文件，xx.app.dsym文件(可用于bugly等监控bug的平台)，info.plist(保存打包的一些信息)，还有我们的 xx.app 文件。</p>\n<p>其次使用 -exportArchive 生成 ipa 包</p>\n<p>xcodebuild -exportArchive -archivePath xx.xcarchive -exportPath xx -exportFormat ipa</p>\n<p>-archivePath: xx.archivePath 的路径</p>\n<p>-exportPath: 输出路径</p>\n<p>-exportFormat: 生成类型，这里选择我们需要的 ipa</p>\n<p>这样就利用我们的 xcodebuild 命令来生成 ipa 包</p>\n<h3 id=\"6-xcrun\"><a href=\"#6-xcrun\" class=\"headerlink\" title=\"6.xcrun\"></a>6.xcrun</h3><p>这里也使用 xcrun 来生成 ipa 包即可</p>\n<p><code>xcrun -sdk iphoneos PackageApplication build/Release-iphoneos/xx.app -o ~/Desktop/xx.ipa</code></p>\n<p>但是，在 macos10.12 和 Xcode8 的环境下会出现一个警告</p>\n<p>warning: PackageApplication is deprecated, use xcodebuild -exportArchive instead.</p>\n<p>说明 PackageApplication 已经被弃用了。</p>\n<p>不过其实这一步可以几乎等价于将 <code>xx.app</code> 放入一个 payload 的文件夹下然后压缩文件夹为 <code>xx.ipa</code>，当然这样做缺失一些信息，不过并不影响程序的运行。</p>\n<p>初步小结:</p>\n<p>综上，我们有两种方法来生成我们需要的 ipa 包。<br>1.我们用xcodebuild 命令来编译我们的项目生成app, 然后再用xcrun将app转ipa</p>\n<ol>\n<li>使用<code>xcodebuild archive</code>命令来直接生成我们需要的ipa。</li>\n</ol>\n<p>虽然现在网上几乎都是使用<code>xcodebuild + xcrun</code>来来生成ipa包，不过既然官方说 PackageApplication is deprecated，那还是推荐使用第二种方法，一步到位。</p>\n<h3 id=\"7-自动化打包\"><a href=\"#7-自动化打包\" class=\"headerlink\" title=\"7.自动化打包\"></a>7.自动化打包</h3><p>这里从我工作室的一个项目切入，这个项目需要最终生成18个ipa包，但是他们几乎是共用一套代码的，不同的地方在于bundleName/bundleDisplayName/bundleid等，以及一些资源文件的不同，例如icon等。所以可想而知如果选择手动打包的痛苦，并且当你打包到一半发现某个地方错了要重新打包</p>\n<p>这里说一下自动化打包1.0解决思路:</p>\n<pre><code>1.    使用命令defaults write来修改项目中的plist文件，来达到修改 bundleName/bundleDisplayName/bundleid…的目的。\n2.    使用命令 cp 来替换资源文件。\n3.    使用xcodebuild -workspace ..编译出app包。\n4.    使用xcrun ...生成 ipa 。 \n</code></pre><p>这是我最开始想到的思路，最终运行时间大概为每个包2.5m(时间主要浪费在编译)，然后一套下来也要半个多小时。虽然比起手动打快了不少，但还是太慢了。毕竟自动化的目的不仅仅是自动，还要速度。</p>\n<p>既然问题出在编译上，那我的思路就往编译一次多次使用这个方向上面思考。然后想到了既然只是资源文件和plist的不同，没有涉及到代码的更换(不过这个项目后期不同 app 会执行不同一套代码，不过也有解决办法)，这里就出现了自动化打包2.0的版本。</p>\n<pre><code>1.    使用xcodebuild -workspace..编译出app包。 \n2.    使用命令defaults write来修改项目中的plist文件，来达到修改bundleName/bundleDisplayName/bundleid…的目的。 \n3.    使用命cp来替换资源文件。 \n4.    重签名codesign -f -s &quot;iPhone Distribution: xx co., LTD&quot; --entitlements $Entitlements $ipaPath/Payload/YouXiaoYun.app \n5.    使用xcrun ... 生成ipa 。\n</code></pre><p>和1.0大致相似，不过并不是每次生成ipa都需要编译一次。而是编译一次，然后直接修改app下内容，不过这里会出现签名错误的问题，因为在编译的最后会用证书帮app签名，如果你直接替换资源然后就生成ipa的话会导致ipa无法安装。</p>\n<p>那这时候神奇的重签名技术就出来(重签名用在正途上的真少见…hhhh，关于重签名的文章google一下就会很多)，使用codesign命令就可以帮修改过资源的app重签名。<br>最终使用2.0的时间基本是在5-6分钟左右。</p>\n<h3 id=\"8-最终代码\"><a href=\"#8-最终代码\" class=\"headerlink\" title=\"8.最终代码\"></a>8.最终代码</h3><p>以下是完整的脚本文件，部分信息需要自己替换。<br>以下脚本适用于一次打 N 个包，适用情况：</p>\n<pre><code>1.    可以替换 bundle 信息 \n2.    替换音频图片资源 \n3.    可以执行不同代码 \n4.    生成相应的plist文件 \n5.    上传到蒲公英分发平台 \n</code></pre><p>当然也可以打一个包，适当删除某些代码即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 1.Configuration Info</div><div class=\"line\"> </div><div class=\"line\"># 项目路径 需修改</div><div class=\"line\">projectDir=&quot;你的项目路径&quot;</div><div class=\"line\"> </div><div class=\"line\"># 打包生成路径 需修改</div><div class=\"line\">ipaPath=&quot;ipa生成路径&quot;</div><div class=\"line\"> </div><div class=\"line\"># 图标路径 需修改</div><div class=\"line\">iconPath=&quot;~/Desktop/icon&quot;</div><div class=\"line\"> </div><div class=\"line\"># Provisioning Profile 需修改 查看本地配置文件</div><div class=\"line\">PROVISIONING_PROFILE=&quot;xxxxxxx-xxxx-4bfa-a696-0ec7391b24d8&quot;</div><div class=\"line\"> </div><div class=\"line\">############# 重签名需要文件</div><div class=\"line\"># 以下文件需放在 ipaPath 路径下</div><div class=\"line\">Entitlements=$ipaPath/entitlements.plist</div><div class=\"line\">#############</div><div class=\"line\"> </div><div class=\"line\"># 版本号</div><div class=\"line\">bundleVersion=&quot;2.0.0&quot;</div><div class=\"line\"> </div><div class=\"line\"># 选择打包序号 多选则以空格隔开 如(&quot;1&quot; &quot;2&quot; &quot;3&quot;)</div><div class=\"line\">appPackNum=(&quot;1 2&quot;)</div><div class=\"line\"> </div><div class=\"line\"># 蒲公英分发参数 不分发可忽略 默认不分发 下面的两个KEY是默认测试的网址对应KEY</div><div class=\"line\">ISUPLOAD=0</div><div class=\"line\">USERKEY=&quot;xxx&quot;</div><div class=\"line\">APIKEY=&quot;xxx&quot;</div><div class=\"line\"> </div><div class=\"line\"># ---------------------------可选 如果需要替换 app 的 icon --------------------------------- #</div><div class=\"line\"> </div><div class=\"line\"># 配置App信息数组 格式:&quot;AppName(和工程中appInfo.Plist对应)&quot; &quot;icon&quot;</div><div class=\"line\">#Schemes:</div><div class=\"line\">#        1.app1 app1Icon</div><div class=\"line\">#        2.app2 app2Icon</div><div class=\"line\">#        3.app3 app3Icon</div><div class=\"line\"> </div><div class=\"line\"># --------------------------------------------------------------------------------------- #</div><div class=\"line\"> </div><div class=\"line\"># 打包个数</div><div class=\"line\">appPackNumLength=$&#123;#appPackNum[*]&#125;</div><div class=\"line\"> </div><div class=\"line\">appInfos=(</div><div class=\"line\">          &quot;app1&quot; &quot;app1Icon&quot; &quot;xxxx&quot;</div><div class=\"line\">          &quot;app2&quot; &quot;app2Icon&quot; &quot;xxxx&quot;</div><div class=\"line\">          &quot;app3&quot; &quot;app3Icon&quot; &quot;xxxx&quot;</div><div class=\"line\">          )</div><div class=\"line\"> </div><div class=\"line\">appInfosLength=$&#123;#appInfos[*]&#125;</div><div class=\"line\"> </div><div class=\"line\"># Scheme Name</div><div class=\"line\">schemeName=&quot;xx&quot;</div><div class=\"line\"> </div><div class=\"line\"># Code Sign ID</div><div class=\"line\">CODE_SIGN_IDENTITY=&quot;xx co., LTD&quot;</div><div class=\"line\"> </div><div class=\"line\"># 生成 APP 路径</div><div class=\"line\">buildDir=&quot;build/Release-iphoneos&quot;</div><div class=\"line\"> </div><div class=\"line\"># 开始时间</div><div class=\"line\">beginTime=`date +%s`</div><div class=\"line\"> </div><div class=\"line\"># 创建打包目录</div><div class=\"line\">mkdir $&#123;ipaPath&#125;/AllPack</div><div class=\"line\"> </div><div class=\"line\"># 本地存放全部 IPA 的路径</div><div class=\"line\">allIPAPackPath=&quot;$&#123;ipaPath&#125;/allPack&quot;</div><div class=\"line\"> </div><div class=\"line\"># 清除缓存</div><div class=\"line\">rm -rf $projectDir/$buildDir</div><div class=\"line\"> </div><div class=\"line\"># Build 生成 APP</div><div class=\"line\">xcodebuild -workspace $&#123;projectDir&#125;/xx.xcworkspace -scheme $&#123;schemeName&#125; -configuration Release clean -sdk iphoneos build CODE_SIGN_IDENTITY=&quot;$&#123;CODE_SIGN_IDENTITY&#125;&quot; PROVISIONING_PROFILE=&quot;$&#123;PROVISIONING_PROFILE&#125;&quot; SYMROOT=&quot;$&#123;projectDir&#125;/build&quot;</div><div class=\"line\">if [[ $? = 0 ]]; then</div><div class=\"line\">  echo &quot;\\033[31m 编译成功\\n \\033[0m&quot;</div><div class=\"line\">else</div><div class=\"line\">  echo &quot;\\033[31m 编译失败\\n \\033[0m&quot;</div><div class=\"line\">fi</div><div class=\"line\"> </div><div class=\"line\"># 先创建 payload 文件夹</div><div class=\"line\">mkdir ~/Desktop/Payload</div><div class=\"line\"># 移动编译生成的 app 到桌面的 Payload 文件夹下</div><div class=\"line\">cp -Rf $&#123;projectDir&#125;/$&#123;buildDir&#125;/$&#123;schemeName&#125;.app $ipaPath/Payload</div><div class=\"line\"> </div><div class=\"line\"># 以下二选一</div><div class=\"line\"># 1.----全部打包----</div><div class=\"line\">#for (( i=0; i $plist_path</div><div class=\"line\">itemsassetskindsoftware-packageurlhttps://xxxxxxxxxxxx/$appDownloadName.ipakinddisplay-imageurlhttps://xxxxxxxxxxxx/$&#123;appIconName&#125;.pngkindfull-size-imageurlhttps://xxxxxxxxxxxx/$&#123;appIconName&#125;.pngmetadatabundle-identifier你的bundidbundle-version$bundleVersionkindsoftwaretitle$appDownloadName</div><div class=\"line\">EOF</div><div class=\"line\"> </div><div class=\"line\"># 移动</div><div class=\"line\">mv $&#123;ipaPath&#125;/$appDownloadName.ipa $&#123;allIPAPackPath&#125;/$appName</div><div class=\"line\"> </div><div class=\"line\"># 6.上传蒲公英分发平台</div><div class=\"line\"> </div><div class=\"line\">if [[ $ISUPLOAD = 1 ]]; then</div><div class=\"line\">  echo &quot;正在上传蒲公英...&quot;</div><div class=\"line\">  curl -F &quot;file=@$allIPAPackPath/$appName/$appDownloadName.ipa&quot; -F &quot;uKey=$USERKEY&quot; -F &quot;_api_key=$APIKEY&quot; http://www.pgyer.com/apiv1/app/upload</div><div class=\"line\"> </div><div class=\"line\">fi</div><div class=\"line\"> </div><div class=\"line\">done</div><div class=\"line\"> </div><div class=\"line\"># 清除无关文件</div><div class=\"line\">rm -rf $ipaPath/Payload</div><div class=\"line\"> </div><div class=\"line\"># 结束时间</div><div class=\"line\">endTime=`date +%s`</div><div class=\"line\">echo -e &quot;打包时间$[ endTime - beginTime ]秒&quot;</div></pre></td></tr></table></figure></p>\n<p>编辑完后保存成.sh后缀的可执行文件</p>\n","excerpt":"<p>虽然Xcode打包很方便，但是每次也得花费好几分钟，一次次重复相同的事情，日积月累也会浪费不少的时间。而且大多数情况下，一个app会有多个target,这样的话打包花费的时间更加是成倍的增加。在生成自动化构建脚本之前得先了解几个概念。</p>\n<h3 id=\"1-xcodebuild\"><a href=\"#1-xcodebuild\" class=\"headerlink\" title=\"1.xcodebuild\"></a>1.xcodebuild</h3><p>使用 xcodebuild -h 来看看 xcodebuild 到底是干啥的</p>\n<blockquote>\n<p>Usage: xcodebuild [-project ] [[-target ]…|-alltargets] [-configuration ] [-arch ]… [-sdk [|]] [-showBuildSettings] [=]… []…<br>       xcodebuild [-project ] -scheme  [-destination ]… [-configuration ] [-arch ]… [-sdk [|]] [-showBuildSettings] [=]… []…<br>       xcodebuild -workspace  -scheme  [-destination ]… [-configuration ] [-arch ]… [-sdk [|]] [-showBuildSettings] [=]… []…<br>       xcodebuild -version [-sdk [|] [] ]<br>       xcodebuild -list [[-project ]|[-workspace ]] [-json]<br>       xcodebuild -showsdks<br>       xcodebuild -exportArchive -archivePath  -exportPath  -exportOptionsPlist<br>       xcodebuild -exportLocalizations -localizationPath  -project  [-exportLanguage …]<br>       xcodebuild -importLocalizations -localizationPath  -project</p>\n</blockquote>\n<p>这里我只截取了 usage 部分，option 部分太多没有截取。<br>这里介绍几条毕竟常用的命令：<br>","more":"</p>\n<h3 id=\"2-xcodebuild-list-…\"><a href=\"#2-xcodebuild-list-…\" class=\"headerlink\" title=\"2.xcodebuild -list …\"></a>2.xcodebuild -list …</h3><blockquote>\n<p>xcodebuild -list [[-project ]|[-workspace ]] [-json] </p>\n<p>usage: 输出 project 中的 targets 和 configurations，或者 workspace 中 schemes。<br>-project 和 -workspace 是输出指定内容，不输入默认输出当前目录下。-json 是以 json 格式输出。</p>\n</blockquote>\n<p>example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ xcodebuild -list</div><div class=\"line\">Information about project &quot;XX&quot;:</div><div class=\"line\">    Targets:</div><div class=\"line\">        XX</div><div class=\"line\">        XXTests</div><div class=\"line\"> </div><div class=\"line\">    Build Configurations:</div><div class=\"line\">        Debug</div><div class=\"line\">        Release</div><div class=\"line\"> </div><div class=\"line\">    If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used.</div><div class=\"line\"> </div><div class=\"line\">    Schemes:</div><div class=\"line\">        XX</div></pre></td></tr></table></figure>\n<h3 id=\"3-xcodebuild-project-…\"><a href=\"#3-xcodebuild-project-…\" class=\"headerlink\" title=\"3. xcodebuild -project …\"></a>3. xcodebuild -project …</h3><blockquote>\n<p>xcodebuild [-project ] [[-target ]…|-alltargets] [-configuration ] [-arch ]… [-sdk [|]] [-showBuildSettings] [=]… []…</p>\n</blockquote>\n<p>usage:<br>-project: 指定 project 名字，默认首个 project。<br>-target: 指定对应的 target ，默认首个 target。<br>-configuration: 选择Debug 或 Release，默认 Release，当然如果你有自定义的配置的，就应该选你配置的，上面 -list 中有输出。<br>-showBuildSettings: 显示工程的配置。<br>=: 修改工程的配置文件。<br>buildaction … : 如下，默认为 build<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">    Specify a build action (or actions) to perform on the target.</div><div class=\"line\">    Available build actions are:</div><div class=\"line\"> </div><div class=\"line\">    build       Build the target in the build root (SYMROOT).  This is</div><div class=\"line\">                the default build action.</div><div class=\"line\"> </div><div class=\"line\">   installsrc  Copy the source of the project to the source root</div><div class=\"line\">               (SRCROOT).</div><div class=\"line\"> </div><div class=\"line\">install     Build the target and install it into the target&apos;s</div><div class=\"line\">               installation directory in the distribution root</div><div class=\"line\">               (DSTROOT).</div><div class=\"line\"> </div><div class=\"line\">  clean       Remove build products and intermediate files from the</div><div class=\"line\">              build root (SYMROOT).</div></pre></td></tr></table></figure></p>\n<p>example:</p>\n<blockquote>\n<p>$ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release<br>这行命令表示编译 xx.xcodeproj 的 xx target。在 terminal 中会看到编译过程，如果成功最后会输出 <strong> BUILD SUCCEEDED </strong>。最后会在当前目录下生成 build/Release-iphoneos/xx.app</p>\n<p>$ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release -showBuildSettings<br>这行命令使用 -showBuildSettings 是不会 build 项目的，只是输出工程的配置。这里输出的的内容有(内容过多，只截取部分)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">Build settings for action build and target XX:</div><div class=\"line\">    ACTION = build</div><div class=\"line\">    AD_HOC_CODE_SIGNING_ALLOWED = NO</div><div class=\"line\">    ALTERNATE_GROUP = staff</div><div class=\"line\">    ALTERNATE_MODE = u+w,go-w,a+rX</div><div class=\"line\">    ALTERNATE_OWNER = TsuiYuenHong</div><div class=\"line\">    ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = NO</div><div class=\"line\">    ALWAYS_SEARCH_USER_PATHS = NO</div><div class=\"line\">    ALWAYS_USE_SEPARATE_HEADERMAPS = NO</div><div class=\"line\">    APPLE_INTERNAL_DEVELOPER_DIR = /AppleInternal/Developer</div><div class=\"line\">    APPLE_INTERNAL_DIR = /AppleInternal</div><div class=\"line\">    APPLE_INTERNAL_DOCUMENTATION_DIR = /AppleInternal/Documentation</div><div class=\"line\">    APPLE_INTERNAL_LIBRARY_DIR = /AppleInternal/Library</div><div class=\"line\">    APPLE_INTERNAL_TOOLS = /AppleInternal/Developer/Tools</div><div class=\"line\">    APPLICATION_EXTENSION_API_ONLY = NO</div><div class=\"line\">    APPLY_RULES_IN_COPY_FILES = NO</div><div class=\"line\">    ARCHS = armv7 arm64</div></pre></td></tr></table></figure>\n<p>如果要修改配置文件，就直接最命令最后加上你要修改的内容。<br>例如在这行命令最后加上指定证书</p>\n<blockquote>\n<p>$ xcodebuild -project 你的项目名字.xcodeproj -target 你的 target 名字 -configuration release PROVISIONING_PROFILE=”你证书的id”<br>其中的字段是上面 -showBuildSettings 显示的字段，也可以看官网介绍</p>\n</blockquote>\n<h3 id=\"4-xcodebuild-workspace-…\"><a href=\"#4-xcodebuild-workspace-…\" class=\"headerlink\" title=\"4. xcodebuild -workspace …\"></a>4. xcodebuild -workspace …</h3><p>xcodebuild -workspace -scheme [-destination ]… [-configuration ] [-arch ]… [-sdk [|]] [-showBuildSettings] [=]… []…</p>\n<p>除了 workspace 和 scheme 之外其余选项都和上条命令相同。</p>\n<p>-workspace: 指定 workspace 名字，默认首个 workspace</p>\n<p>-scheme: 指定对应的 scheme ，默认首个 scheme</p>\n<h3 id=\"5-xcodebuild-exportArchive-…\"><a href=\"#5-xcodebuild-exportArchive-…\" class=\"headerlink\" title=\"5.xcodebuild -exportArchive …\"></a>5.xcodebuild -exportArchive …</h3><p>这里顺便介绍一下 archive 命令，因为在下面使用 PackageApplication 会出一个警告说推荐使用 -exportArchive。所以我们就来尝试一下使用 archive 来生成 app。</p>\n<p>首先使用一下命令来生成 .xcarchive 文件<br>xcodebuild archive -workspace xx.xcworkspace -scheme xx -archivePath xx.xcarchive<br>可以看出添加上 archive 命令和最后加入 -archivePath 生成archivePath的路径即可。<br>然后该路径下会生成一个 xx.archivePath，里面包括三个文件，xx.app.dsym文件(可用于bugly等监控bug的平台)，info.plist(保存打包的一些信息)，还有我们的 xx.app 文件。</p>\n<p>其次使用 -exportArchive 生成 ipa 包</p>\n<p>xcodebuild -exportArchive -archivePath xx.xcarchive -exportPath xx -exportFormat ipa</p>\n<p>-archivePath: xx.archivePath 的路径</p>\n<p>-exportPath: 输出路径</p>\n<p>-exportFormat: 生成类型，这里选择我们需要的 ipa</p>\n<p>这样就利用我们的 xcodebuild 命令来生成 ipa 包</p>\n<h3 id=\"6-xcrun\"><a href=\"#6-xcrun\" class=\"headerlink\" title=\"6.xcrun\"></a>6.xcrun</h3><p>这里也使用 xcrun 来生成 ipa 包即可</p>\n<p><code>xcrun -sdk iphoneos PackageApplication build/Release-iphoneos/xx.app -o ~/Desktop/xx.ipa</code></p>\n<p>但是，在 macos10.12 和 Xcode8 的环境下会出现一个警告</p>\n<p>warning: PackageApplication is deprecated, use xcodebuild -exportArchive instead.</p>\n<p>说明 PackageApplication 已经被弃用了。</p>\n<p>不过其实这一步可以几乎等价于将 <code>xx.app</code> 放入一个 payload 的文件夹下然后压缩文件夹为 <code>xx.ipa</code>，当然这样做缺失一些信息，不过并不影响程序的运行。</p>\n<p>初步小结:</p>\n<p>综上，我们有两种方法来生成我们需要的 ipa 包。<br>1.我们用xcodebuild 命令来编译我们的项目生成app, 然后再用xcrun将app转ipa</p>\n<ol>\n<li>使用<code>xcodebuild archive</code>命令来直接生成我们需要的ipa。</li>\n</ol>\n<p>虽然现在网上几乎都是使用<code>xcodebuild + xcrun</code>来来生成ipa包，不过既然官方说 PackageApplication is deprecated，那还是推荐使用第二种方法，一步到位。</p>\n<h3 id=\"7-自动化打包\"><a href=\"#7-自动化打包\" class=\"headerlink\" title=\"7.自动化打包\"></a>7.自动化打包</h3><p>这里从我工作室的一个项目切入，这个项目需要最终生成18个ipa包，但是他们几乎是共用一套代码的，不同的地方在于bundleName/bundleDisplayName/bundleid等，以及一些资源文件的不同，例如icon等。所以可想而知如果选择手动打包的痛苦，并且当你打包到一半发现某个地方错了要重新打包</p>\n<p>这里说一下自动化打包1.0解决思路:</p>\n<pre><code>1.    使用命令defaults write来修改项目中的plist文件，来达到修改 bundleName/bundleDisplayName/bundleid…的目的。\n2.    使用命令 cp 来替换资源文件。\n3.    使用xcodebuild -workspace ..编译出app包。\n4.    使用xcrun ...生成 ipa 。 \n</code></pre><p>这是我最开始想到的思路，最终运行时间大概为每个包2.5m(时间主要浪费在编译)，然后一套下来也要半个多小时。虽然比起手动打快了不少，但还是太慢了。毕竟自动化的目的不仅仅是自动，还要速度。</p>\n<p>既然问题出在编译上，那我的思路就往编译一次多次使用这个方向上面思考。然后想到了既然只是资源文件和plist的不同，没有涉及到代码的更换(不过这个项目后期不同 app 会执行不同一套代码，不过也有解决办法)，这里就出现了自动化打包2.0的版本。</p>\n<pre><code>1.    使用xcodebuild -workspace..编译出app包。 \n2.    使用命令defaults write来修改项目中的plist文件，来达到修改bundleName/bundleDisplayName/bundleid…的目的。 \n3.    使用命cp来替换资源文件。 \n4.    重签名codesign -f -s &quot;iPhone Distribution: xx co., LTD&quot; --entitlements $Entitlements $ipaPath/Payload/YouXiaoYun.app \n5.    使用xcrun ... 生成ipa 。\n</code></pre><p>和1.0大致相似，不过并不是每次生成ipa都需要编译一次。而是编译一次，然后直接修改app下内容，不过这里会出现签名错误的问题，因为在编译的最后会用证书帮app签名，如果你直接替换资源然后就生成ipa的话会导致ipa无法安装。</p>\n<p>那这时候神奇的重签名技术就出来(重签名用在正途上的真少见…hhhh，关于重签名的文章google一下就会很多)，使用codesign命令就可以帮修改过资源的app重签名。<br>最终使用2.0的时间基本是在5-6分钟左右。</p>\n<h3 id=\"8-最终代码\"><a href=\"#8-最终代码\" class=\"headerlink\" title=\"8.最终代码\"></a>8.最终代码</h3><p>以下是完整的脚本文件，部分信息需要自己替换。<br>以下脚本适用于一次打 N 个包，适用情况：</p>\n<pre><code>1.    可以替换 bundle 信息 \n2.    替换音频图片资源 \n3.    可以执行不同代码 \n4.    生成相应的plist文件 \n5.    上传到蒲公英分发平台 \n</code></pre><p>当然也可以打一个包，适当删除某些代码即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 1.Configuration Info</div><div class=\"line\"> </div><div class=\"line\"># 项目路径 需修改</div><div class=\"line\">projectDir=&quot;你的项目路径&quot;</div><div class=\"line\"> </div><div class=\"line\"># 打包生成路径 需修改</div><div class=\"line\">ipaPath=&quot;ipa生成路径&quot;</div><div class=\"line\"> </div><div class=\"line\"># 图标路径 需修改</div><div class=\"line\">iconPath=&quot;~/Desktop/icon&quot;</div><div class=\"line\"> </div><div class=\"line\"># Provisioning Profile 需修改 查看本地配置文件</div><div class=\"line\">PROVISIONING_PROFILE=&quot;xxxxxxx-xxxx-4bfa-a696-0ec7391b24d8&quot;</div><div class=\"line\"> </div><div class=\"line\">############# 重签名需要文件</div><div class=\"line\"># 以下文件需放在 ipaPath 路径下</div><div class=\"line\">Entitlements=$ipaPath/entitlements.plist</div><div class=\"line\">#############</div><div class=\"line\"> </div><div class=\"line\"># 版本号</div><div class=\"line\">bundleVersion=&quot;2.0.0&quot;</div><div class=\"line\"> </div><div class=\"line\"># 选择打包序号 多选则以空格隔开 如(&quot;1&quot; &quot;2&quot; &quot;3&quot;)</div><div class=\"line\">appPackNum=(&quot;1 2&quot;)</div><div class=\"line\"> </div><div class=\"line\"># 蒲公英分发参数 不分发可忽略 默认不分发 下面的两个KEY是默认测试的网址对应KEY</div><div class=\"line\">ISUPLOAD=0</div><div class=\"line\">USERKEY=&quot;xxx&quot;</div><div class=\"line\">APIKEY=&quot;xxx&quot;</div><div class=\"line\"> </div><div class=\"line\"># ---------------------------可选 如果需要替换 app 的 icon --------------------------------- #</div><div class=\"line\"> </div><div class=\"line\"># 配置App信息数组 格式:&quot;AppName(和工程中appInfo.Plist对应)&quot; &quot;icon&quot;</div><div class=\"line\">#Schemes:</div><div class=\"line\">#        1.app1 app1Icon</div><div class=\"line\">#        2.app2 app2Icon</div><div class=\"line\">#        3.app3 app3Icon</div><div class=\"line\"> </div><div class=\"line\"># --------------------------------------------------------------------------------------- #</div><div class=\"line\"> </div><div class=\"line\"># 打包个数</div><div class=\"line\">appPackNumLength=$&#123;#appPackNum[*]&#125;</div><div class=\"line\"> </div><div class=\"line\">appInfos=(</div><div class=\"line\">          &quot;app1&quot; &quot;app1Icon&quot; &quot;xxxx&quot;</div><div class=\"line\">          &quot;app2&quot; &quot;app2Icon&quot; &quot;xxxx&quot;</div><div class=\"line\">          &quot;app3&quot; &quot;app3Icon&quot; &quot;xxxx&quot;</div><div class=\"line\">          )</div><div class=\"line\"> </div><div class=\"line\">appInfosLength=$&#123;#appInfos[*]&#125;</div><div class=\"line\"> </div><div class=\"line\"># Scheme Name</div><div class=\"line\">schemeName=&quot;xx&quot;</div><div class=\"line\"> </div><div class=\"line\"># Code Sign ID</div><div class=\"line\">CODE_SIGN_IDENTITY=&quot;xx co., LTD&quot;</div><div class=\"line\"> </div><div class=\"line\"># 生成 APP 路径</div><div class=\"line\">buildDir=&quot;build/Release-iphoneos&quot;</div><div class=\"line\"> </div><div class=\"line\"># 开始时间</div><div class=\"line\">beginTime=`date +%s`</div><div class=\"line\"> </div><div class=\"line\"># 创建打包目录</div><div class=\"line\">mkdir $&#123;ipaPath&#125;/AllPack</div><div class=\"line\"> </div><div class=\"line\"># 本地存放全部 IPA 的路径</div><div class=\"line\">allIPAPackPath=&quot;$&#123;ipaPath&#125;/allPack&quot;</div><div class=\"line\"> </div><div class=\"line\"># 清除缓存</div><div class=\"line\">rm -rf $projectDir/$buildDir</div><div class=\"line\"> </div><div class=\"line\"># Build 生成 APP</div><div class=\"line\">xcodebuild -workspace $&#123;projectDir&#125;/xx.xcworkspace -scheme $&#123;schemeName&#125; -configuration Release clean -sdk iphoneos build CODE_SIGN_IDENTITY=&quot;$&#123;CODE_SIGN_IDENTITY&#125;&quot; PROVISIONING_PROFILE=&quot;$&#123;PROVISIONING_PROFILE&#125;&quot; SYMROOT=&quot;$&#123;projectDir&#125;/build&quot;</div><div class=\"line\">if [[ $? = 0 ]]; then</div><div class=\"line\">  echo &quot;\\033[31m 编译成功\\n \\033[0m&quot;</div><div class=\"line\">else</div><div class=\"line\">  echo &quot;\\033[31m 编译失败\\n \\033[0m&quot;</div><div class=\"line\">fi</div><div class=\"line\"> </div><div class=\"line\"># 先创建 payload 文件夹</div><div class=\"line\">mkdir ~/Desktop/Payload</div><div class=\"line\"># 移动编译生成的 app 到桌面的 Payload 文件夹下</div><div class=\"line\">cp -Rf $&#123;projectDir&#125;/$&#123;buildDir&#125;/$&#123;schemeName&#125;.app $ipaPath/Payload</div><div class=\"line\"> </div><div class=\"line\"># 以下二选一</div><div class=\"line\"># 1.----全部打包----</div><div class=\"line\">#for (( i=0; i $plist_path</div><div class=\"line\">itemsassetskindsoftware-packageurlhttps://xxxxxxxxxxxx/$appDownloadName.ipakinddisplay-imageurlhttps://xxxxxxxxxxxx/$&#123;appIconName&#125;.pngkindfull-size-imageurlhttps://xxxxxxxxxxxx/$&#123;appIconName&#125;.pngmetadatabundle-identifier你的bundidbundle-version$bundleVersionkindsoftwaretitle$appDownloadName</div><div class=\"line\">EOF</div><div class=\"line\"> </div><div class=\"line\"># 移动</div><div class=\"line\">mv $&#123;ipaPath&#125;/$appDownloadName.ipa $&#123;allIPAPackPath&#125;/$appName</div><div class=\"line\"> </div><div class=\"line\"># 6.上传蒲公英分发平台</div><div class=\"line\"> </div><div class=\"line\">if [[ $ISUPLOAD = 1 ]]; then</div><div class=\"line\">  echo &quot;正在上传蒲公英...&quot;</div><div class=\"line\">  curl -F &quot;file=@$allIPAPackPath/$appName/$appDownloadName.ipa&quot; -F &quot;uKey=$USERKEY&quot; -F &quot;_api_key=$APIKEY&quot; http://www.pgyer.com/apiv1/app/upload</div><div class=\"line\"> </div><div class=\"line\">fi</div><div class=\"line\"> </div><div class=\"line\">done</div><div class=\"line\"> </div><div class=\"line\"># 清除无关文件</div><div class=\"line\">rm -rf $ipaPath/Payload</div><div class=\"line\"> </div><div class=\"line\"># 结束时间</div><div class=\"line\">endTime=`date +%s`</div><div class=\"line\">echo -e &quot;打包时间$[ endTime - beginTime ]秒&quot;</div></pre></td></tr></table></figure></p>\n<p>编辑完后保存成.sh后缀的可执行文件</p>"},{"title":"iOS release,debug版设置不同的AppIcon","author":[{"name":"千寻墨","url":"http://www.jianshu.com/users/527ecf8c8753/latest_articles"}],"date":"2016-04-13T10:41:56.000Z","_content":"\n也许你也遇到过这种情况，产品经理或者测试让你给装个测试包，一会装正式环境的，一会又装测试环境的，一会又装个灰度环境的。弄来弄去的有时候自己都搞不清楚测试包是什么环境下的。\n\n通过判断debug还是release环境，我们可以用很多种方法来区分这两种环境，这里最简单而且效果非常好的一种方法。不同的环境下采用不同的图标，这样软件一安装上就可以非常明显的分辨出来。\n\n#### 第一步\n\n创建一个新的AppIcon\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/1.png)\n\n<!-- more -->\n\n#### 第二步\n\n给两个AppIcon分别加入不同的图片\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/2.png)\n\n\n#### 第三步\n\n在build Setting 里面搜索 icon，找到Asset catalog AppIcon set name\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/3.png)\n\n#### 第四步\n\n分别给debug和release设置不同的AppIcon。到这里就全部完成了，快去试试吧。\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/4.png)\n\n","source":"_posts/iOS-release-debug版设置不同的AppIcon.md","raw":"---\ntitle: iOS release,debug版设置不同的AppIcon\ntags:\n  - iOS\n  - 配置\ncategories:\n  - iOS配置\nauthor:\n  - name: 千寻墨\n    url: 'http://www.jianshu.com/users/527ecf8c8753/latest_articles'\ndate: 2016-04-13 18:41:56\n---\n\n也许你也遇到过这种情况，产品经理或者测试让你给装个测试包，一会装正式环境的，一会又装测试环境的，一会又装个灰度环境的。弄来弄去的有时候自己都搞不清楚测试包是什么环境下的。\n\n通过判断debug还是release环境，我们可以用很多种方法来区分这两种环境，这里最简单而且效果非常好的一种方法。不同的环境下采用不同的图标，这样软件一安装上就可以非常明显的分辨出来。\n\n#### 第一步\n\n创建一个新的AppIcon\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/1.png)\n\n<!-- more -->\n\n#### 第二步\n\n给两个AppIcon分别加入不同的图片\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/2.png)\n\n\n#### 第三步\n\n在build Setting 里面搜索 icon，找到Asset catalog AppIcon set name\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/3.png)\n\n#### 第四步\n\n分别给debug和release设置不同的AppIcon。到这里就全部完成了，快去试试吧。\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/4.png)\n\n","slug":"iOS-release-debug版设置不同的AppIcon","published":1,"updated":"2016-11-17T13:51:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmht000pco609zz6bjb0","content":"<p>也许你也遇到过这种情况，产品经理或者测试让你给装个测试包，一会装正式环境的，一会又装测试环境的，一会又装个灰度环境的。弄来弄去的有时候自己都搞不清楚测试包是什么环境下的。</p>\n<p>通过判断debug还是release环境，我们可以用很多种方法来区分这两种环境，这里最简单而且效果非常好的一种方法。不同的环境下采用不同的图标，这样软件一安装上就可以非常明显的分辨出来。</p>\n<h4 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h4><p>创建一个新的AppIcon</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/1.png\" alt=\"image\"></p>\n<a id=\"more\"></a>\n<h4 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h4><p>给两个AppIcon分别加入不同的图片</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/2.png\" alt=\"image\"></p>\n<h4 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h4><p>在build Setting 里面搜索 icon，找到Asset catalog AppIcon set name</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/3.png\" alt=\"image\"></p>\n<h4 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h4><p>分别给debug和release设置不同的AppIcon。到这里就全部完成了，快去试试吧。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/4.png\" alt=\"image\"></p>\n","excerpt":"<p>也许你也遇到过这种情况，产品经理或者测试让你给装个测试包，一会装正式环境的，一会又装测试环境的，一会又装个灰度环境的。弄来弄去的有时候自己都搞不清楚测试包是什么环境下的。</p>\n<p>通过判断debug还是release环境，我们可以用很多种方法来区分这两种环境，这里最简单而且效果非常好的一种方法。不同的环境下采用不同的图标，这样软件一安装上就可以非常明显的分辨出来。</p>\n<h4 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h4><p>创建一个新的AppIcon</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/1.png\" alt=\"image\"></p>","more":"<h4 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h4><p>给两个AppIcon分别加入不同的图片</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/2.png\" alt=\"image\"></p>\n<h4 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h4><p>在build Setting 里面搜索 icon，找到Asset catalog AppIcon set name</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/3.png\" alt=\"image\"></p>\n<h4 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h4><p>分别给debug和release设置不同的AppIcon。到这里就全部完成了，快去试试吧。<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/AppIcon/4.png\" alt=\"image\"></p>"},{"title":"一分钟学会环形进度条","date":"2016-02-27T10:36:20.000Z","_content":"\n有几篇博客写到了怎么实现环形进度条，大多是使用Core Graph来实现，实现比较麻烦且效率略低，只是一个小小的进度条而已，我们当然是用最简单而且效率高的方式来实现。\n先看一下这篇博客，博客地址：[http://www.brighttj.com/ios/ios-implement-loop-progress.html](http://www.brighttj.com/ios/ios-implement-loop-progress.html)\n这篇博客写的不错，不过看上去还是略微复杂了，我自己根据自己的思路整理了一下，当然目的是为了更加简洁易懂。\n\n### 一：先制作一个不带颜色渐变的进度条\n\n自定义一个cycleView，在.m 中实现drawRect方法\n\n```\n- (void)drawRect:(CGRect)rect {\n    \n    CGContextRef ctx = UIGraphicsGetCurrentContext();//获取上下文\n    \n    CGPoint center = CGPointMake(100, 100);  //设置圆心位置\n    CGFloat radius = 90;  //设置半径\n    CGFloat startA = - M_PI_2;  //圆起点位置\n    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //圆终点位置\n    \n    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];\n    \n    CGContextSetLineWidth(ctx, 10); //设置线条宽度\n    [[UIColor blueColor] setStroke]; //设置描边颜色\n    \n    CGContextAddPath(ctx, path.CGPath); //把路径添加到上下文\n    \n    CGContextStrokePath(ctx);  //渲染\n\n}\n\n```\n<!-- more -->\n\n因为drawRect方法只是在视图刚刚出现的时候执行一次，所以我们需要使用 \n\n`[self setNeedsDisplay];`\n\n这个方法来进行重新绘制，\n在控制器里面加一个slider，滑动slider来控制进度变化\n\n```\n- (void)drawProgress:(CGFloat )progress\n{\n    _progress = progress;\n    [self setNeedsDisplay];\n}\n```\n\n看一下效果\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/0.png)\n\n如果进度条不需要加渐变色，那么这儿几行代码就完成了。\n\n下面来实现一下带有渐变色的进度条，原理很简单，刚刚画的是一条默认是黑色的线条，我们把黑色替换成一条渐变色的线条就可以了。\n环形渐变色线条的制作：\n\n\n### 第一步\n\n使用CAShapeLayer绘制出渐变层，应为它只能指定两个点之间进行渐变，所以这里需要两个CAShapeLayer，左边一个和右边一个，看一下效果图\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/3.jpg)\n\n代码实现\n\n```\n//生成渐变色\n    CALayer *gradientLayer = [CALayer layer];\n    \n    //左侧渐变色\n    CAGradientLayer *leftLayer = [CAGradientLayer layer];\n    leftLayer.frame = CGRectMake(0, 0, self.bounds.size.width / 2, self.bounds.size.height);    // 分段设置渐变色\n    leftLayer.locations = @[@0.3, @0.9, @1];\n    leftLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor greenColor].CGColor];\n    [gradientLayer addSublayer:leftLayer];\n    \n    //右侧渐变色\n    CAGradientLayer *rightLayer = [CAGradientLayer layer];\n    rightLayer.frame = CGRectMake(self.bounds.size.width / 2, 0, self.bounds.size.width / 2, self.bounds.size.height);\n    rightLayer.locations = @[@0.3, @0.9, @1];\n    rightLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor redColor].CGColor];\n    [gradientLayer addSublayer:rightLayer];\n    \n```\n\n这个渐变层只是一个中间变量，是不能显示出来的，我这里只是演示一下，现在我们已经拿到了渐变层gradientLayer。\n\n### 第二步\n\n我们需要制作一个环形路径\n先看一下效果：\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/2.jpg)\n\n代码实现：\n\n```\nCGPoint center = CGPointMake(100, 100);\n    CGFloat radius = 90;\n    CGFloat startA = - M_PI_2;  //设置进度条起点位置\n    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //设置进度条终点位置\n    \n    //获取环形路径（画一个圆形，填充色透明，设置线框宽度为10，这样就获得了一个环形）\n    _progressLayer = [CAShapeLayer layer];//创建一个track shape layer\n    _progressLayer.frame = self.bounds;\n    _progressLayer.fillColor = [[UIColor clearColor] CGColor];  //填充色为无色\n    _progressLayer.strokeColor = [[UIColor redColor] CGColor]; //指定path的渲染颜色,这里可以设置任意不透明颜色\n    _progressLayer.opacity = 1; //背景颜色的透明度\n    _progressLayer.lineCap = kCALineCapRound;//指定线的边缘是圆的\n    _progressLayer.lineWidth = 10;//线的宽度\n    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];//上面说明过了用来构建圆形\n    _progressLayer.path =[path CGPath]; //把path传递給layer，然后layer会处理相应的渲染，整个逻辑和CoreGraph是一致的。\n    [self.layer addSublayer:_progressLayer];\n\n```\n\n### 第三步，也是最后一步了\n\n用我们在第二步生成的环形路径去截取第一步生成的渐变层\n\n```\n[gradientLayer setMask:_progressLayer]; //用progressLayer来截取渐变层\nself.layer addSublayer:gradientLayer];\n```\n\n截取的layer层就是我们最后需要的，看一看我们最后截取后得到的\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/4.jpg)\n\n到这里，我们已经完成了99%了，最后一步，根据自己的需要让它显示多少的比例就完成了。比例的控制在第二部的progress属性，比例在0-1之间，看一看最后的效果。\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/1.jpg)\n\n\n[demo下载地址](https://github.com/suifengqjn/TBCycleProgress)\n\n更多原创文章可以看 [我的博客](https://gcblog/github.io/)\n\n\n\n\n\n","source":"_posts/一分钟学会环形进度条.md","raw":"---\ntitle: 一分钟学会环形进度条\ndate: 2016-02-27 18:36:20\ntags: [iOS, UI]\ncategories: \n- iOS技术\n---\n\n有几篇博客写到了怎么实现环形进度条，大多是使用Core Graph来实现，实现比较麻烦且效率略低，只是一个小小的进度条而已，我们当然是用最简单而且效率高的方式来实现。\n先看一下这篇博客，博客地址：[http://www.brighttj.com/ios/ios-implement-loop-progress.html](http://www.brighttj.com/ios/ios-implement-loop-progress.html)\n这篇博客写的不错，不过看上去还是略微复杂了，我自己根据自己的思路整理了一下，当然目的是为了更加简洁易懂。\n\n### 一：先制作一个不带颜色渐变的进度条\n\n自定义一个cycleView，在.m 中实现drawRect方法\n\n```\n- (void)drawRect:(CGRect)rect {\n    \n    CGContextRef ctx = UIGraphicsGetCurrentContext();//获取上下文\n    \n    CGPoint center = CGPointMake(100, 100);  //设置圆心位置\n    CGFloat radius = 90;  //设置半径\n    CGFloat startA = - M_PI_2;  //圆起点位置\n    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //圆终点位置\n    \n    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];\n    \n    CGContextSetLineWidth(ctx, 10); //设置线条宽度\n    [[UIColor blueColor] setStroke]; //设置描边颜色\n    \n    CGContextAddPath(ctx, path.CGPath); //把路径添加到上下文\n    \n    CGContextStrokePath(ctx);  //渲染\n\n}\n\n```\n<!-- more -->\n\n因为drawRect方法只是在视图刚刚出现的时候执行一次，所以我们需要使用 \n\n`[self setNeedsDisplay];`\n\n这个方法来进行重新绘制，\n在控制器里面加一个slider，滑动slider来控制进度变化\n\n```\n- (void)drawProgress:(CGFloat )progress\n{\n    _progress = progress;\n    [self setNeedsDisplay];\n}\n```\n\n看一下效果\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/0.png)\n\n如果进度条不需要加渐变色，那么这儿几行代码就完成了。\n\n下面来实现一下带有渐变色的进度条，原理很简单，刚刚画的是一条默认是黑色的线条，我们把黑色替换成一条渐变色的线条就可以了。\n环形渐变色线条的制作：\n\n\n### 第一步\n\n使用CAShapeLayer绘制出渐变层，应为它只能指定两个点之间进行渐变，所以这里需要两个CAShapeLayer，左边一个和右边一个，看一下效果图\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/3.jpg)\n\n代码实现\n\n```\n//生成渐变色\n    CALayer *gradientLayer = [CALayer layer];\n    \n    //左侧渐变色\n    CAGradientLayer *leftLayer = [CAGradientLayer layer];\n    leftLayer.frame = CGRectMake(0, 0, self.bounds.size.width / 2, self.bounds.size.height);    // 分段设置渐变色\n    leftLayer.locations = @[@0.3, @0.9, @1];\n    leftLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor greenColor].CGColor];\n    [gradientLayer addSublayer:leftLayer];\n    \n    //右侧渐变色\n    CAGradientLayer *rightLayer = [CAGradientLayer layer];\n    rightLayer.frame = CGRectMake(self.bounds.size.width / 2, 0, self.bounds.size.width / 2, self.bounds.size.height);\n    rightLayer.locations = @[@0.3, @0.9, @1];\n    rightLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor redColor].CGColor];\n    [gradientLayer addSublayer:rightLayer];\n    \n```\n\n这个渐变层只是一个中间变量，是不能显示出来的，我这里只是演示一下，现在我们已经拿到了渐变层gradientLayer。\n\n### 第二步\n\n我们需要制作一个环形路径\n先看一下效果：\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/2.jpg)\n\n代码实现：\n\n```\nCGPoint center = CGPointMake(100, 100);\n    CGFloat radius = 90;\n    CGFloat startA = - M_PI_2;  //设置进度条起点位置\n    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //设置进度条终点位置\n    \n    //获取环形路径（画一个圆形，填充色透明，设置线框宽度为10，这样就获得了一个环形）\n    _progressLayer = [CAShapeLayer layer];//创建一个track shape layer\n    _progressLayer.frame = self.bounds;\n    _progressLayer.fillColor = [[UIColor clearColor] CGColor];  //填充色为无色\n    _progressLayer.strokeColor = [[UIColor redColor] CGColor]; //指定path的渲染颜色,这里可以设置任意不透明颜色\n    _progressLayer.opacity = 1; //背景颜色的透明度\n    _progressLayer.lineCap = kCALineCapRound;//指定线的边缘是圆的\n    _progressLayer.lineWidth = 10;//线的宽度\n    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];//上面说明过了用来构建圆形\n    _progressLayer.path =[path CGPath]; //把path传递給layer，然后layer会处理相应的渲染，整个逻辑和CoreGraph是一致的。\n    [self.layer addSublayer:_progressLayer];\n\n```\n\n### 第三步，也是最后一步了\n\n用我们在第二步生成的环形路径去截取第一步生成的渐变层\n\n```\n[gradientLayer setMask:_progressLayer]; //用progressLayer来截取渐变层\nself.layer addSublayer:gradientLayer];\n```\n\n截取的layer层就是我们最后需要的，看一看我们最后截取后得到的\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/4.jpg)\n\n到这里，我们已经完成了99%了，最后一步，根据自己的需要让它显示多少的比例就完成了。比例的控制在第二部的progress属性，比例在0-1之间，看一看最后的效果。\n\n![image](https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/1.jpg)\n\n\n[demo下载地址](https://github.com/suifengqjn/TBCycleProgress)\n\n更多原创文章可以看 [我的博客](https://gcblog/github.io/)\n\n\n\n\n\n","slug":"一分钟学会环形进度条","published":1,"updated":"2016-11-17T14:59:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmi2000sco60gjcwqf0h","content":"<p>有几篇博客写到了怎么实现环形进度条，大多是使用Core Graph来实现，实现比较麻烦且效率略低，只是一个小小的进度条而已，我们当然是用最简单而且效率高的方式来实现。<br>先看一下这篇博客，博客地址：<a href=\"http://www.brighttj.com/ios/ios-implement-loop-progress.html\" target=\"_blank\" rel=\"external\">http://www.brighttj.com/ios/ios-implement-loop-progress.html</a><br>这篇博客写的不错，不过看上去还是略微复杂了，我自己根据自己的思路整理了一下，当然目的是为了更加简洁易懂。</p>\n<h3 id=\"一：先制作一个不带颜色渐变的进度条\"><a href=\"#一：先制作一个不带颜色渐变的进度条\" class=\"headerlink\" title=\"一：先制作一个不带颜色渐变的进度条\"></a>一：先制作一个不带颜色渐变的进度条</h3><p>自定义一个cycleView，在.m 中实现drawRect方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawRect:(CGRect)rect &#123;</div><div class=\"line\">    </div><div class=\"line\">    CGContextRef ctx = UIGraphicsGetCurrentContext();//获取上下文</div><div class=\"line\">    </div><div class=\"line\">    CGPoint center = CGPointMake(100, 100);  //设置圆心位置</div><div class=\"line\">    CGFloat radius = 90;  //设置半径</div><div class=\"line\">    CGFloat startA = - M_PI_2;  //圆起点位置</div><div class=\"line\">    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //圆终点位置</div><div class=\"line\">    </div><div class=\"line\">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];</div><div class=\"line\">    </div><div class=\"line\">    CGContextSetLineWidth(ctx, 10); //设置线条宽度</div><div class=\"line\">    [[UIColor blueColor] setStroke]; //设置描边颜色</div><div class=\"line\">    </div><div class=\"line\">    CGContextAddPath(ctx, path.CGPath); //把路径添加到上下文</div><div class=\"line\">    </div><div class=\"line\">    CGContextStrokePath(ctx);  //渲染</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>因为drawRect方法只是在视图刚刚出现的时候执行一次，所以我们需要使用 </p>\n<p><code>[self setNeedsDisplay];</code></p>\n<p>这个方法来进行重新绘制，<br>在控制器里面加一个slider，滑动slider来控制进度变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawProgress:(CGFloat )progress</div><div class=\"line\">&#123;</div><div class=\"line\">    _progress = progress;</div><div class=\"line\">    [self setNeedsDisplay];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一下效果</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/0.png\" alt=\"image\"></p>\n<p>如果进度条不需要加渐变色，那么这儿几行代码就完成了。</p>\n<p>下面来实现一下带有渐变色的进度条，原理很简单，刚刚画的是一条默认是黑色的线条，我们把黑色替换成一条渐变色的线条就可以了。<br>环形渐变色线条的制作：</p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>使用CAShapeLayer绘制出渐变层，应为它只能指定两个点之间进行渐变，所以这里需要两个CAShapeLayer，左边一个和右边一个，看一下效果图</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/3.jpg\" alt=\"image\"></p>\n<p>代码实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//生成渐变色</div><div class=\"line\">    CALayer *gradientLayer = [CALayer layer];</div><div class=\"line\">    </div><div class=\"line\">    //左侧渐变色</div><div class=\"line\">    CAGradientLayer *leftLayer = [CAGradientLayer layer];</div><div class=\"line\">    leftLayer.frame = CGRectMake(0, 0, self.bounds.size.width / 2, self.bounds.size.height);    // 分段设置渐变色</div><div class=\"line\">    leftLayer.locations = @[@0.3, @0.9, @1];</div><div class=\"line\">    leftLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor greenColor].CGColor];</div><div class=\"line\">    [gradientLayer addSublayer:leftLayer];</div><div class=\"line\">    </div><div class=\"line\">    //右侧渐变色</div><div class=\"line\">    CAGradientLayer *rightLayer = [CAGradientLayer layer];</div><div class=\"line\">    rightLayer.frame = CGRectMake(self.bounds.size.width / 2, 0, self.bounds.size.width / 2, self.bounds.size.height);</div><div class=\"line\">    rightLayer.locations = @[@0.3, @0.9, @1];</div><div class=\"line\">    rightLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor redColor].CGColor];</div><div class=\"line\">    [gradientLayer addSublayer:rightLayer];</div></pre></td></tr></table></figure>\n<p>这个渐变层只是一个中间变量，是不能显示出来的，我这里只是演示一下，现在我们已经拿到了渐变层gradientLayer。</p>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>我们需要制作一个环形路径<br>先看一下效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/2.jpg\" alt=\"image\"></p>\n<p>代码实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGPoint center = CGPointMake(100, 100);</div><div class=\"line\">    CGFloat radius = 90;</div><div class=\"line\">    CGFloat startA = - M_PI_2;  //设置进度条起点位置</div><div class=\"line\">    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //设置进度条终点位置</div><div class=\"line\">    </div><div class=\"line\">    //获取环形路径（画一个圆形，填充色透明，设置线框宽度为10，这样就获得了一个环形）</div><div class=\"line\">    _progressLayer = [CAShapeLayer layer];//创建一个track shape layer</div><div class=\"line\">    _progressLayer.frame = self.bounds;</div><div class=\"line\">    _progressLayer.fillColor = [[UIColor clearColor] CGColor];  //填充色为无色</div><div class=\"line\">    _progressLayer.strokeColor = [[UIColor redColor] CGColor]; //指定path的渲染颜色,这里可以设置任意不透明颜色</div><div class=\"line\">    _progressLayer.opacity = 1; //背景颜色的透明度</div><div class=\"line\">    _progressLayer.lineCap = kCALineCapRound;//指定线的边缘是圆的</div><div class=\"line\">    _progressLayer.lineWidth = 10;//线的宽度</div><div class=\"line\">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];//上面说明过了用来构建圆形</div><div class=\"line\">    _progressLayer.path =[path CGPath]; //把path传递給layer，然后layer会处理相应的渲染，整个逻辑和CoreGraph是一致的。</div><div class=\"line\">    [self.layer addSublayer:_progressLayer];</div></pre></td></tr></table></figure>\n<h3 id=\"第三步，也是最后一步了\"><a href=\"#第三步，也是最后一步了\" class=\"headerlink\" title=\"第三步，也是最后一步了\"></a>第三步，也是最后一步了</h3><p>用我们在第二步生成的环形路径去截取第一步生成的渐变层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[gradientLayer setMask:_progressLayer]; //用progressLayer来截取渐变层</div><div class=\"line\">self.layer addSublayer:gradientLayer];</div></pre></td></tr></table></figure>\n<p>截取的layer层就是我们最后需要的，看一看我们最后截取后得到的<br><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/4.jpg\" alt=\"image\"></p>\n<p>到这里，我们已经完成了99%了，最后一步，根据自己的需要让它显示多少的比例就完成了。比例的控制在第二部的progress属性，比例在0-1之间，看一看最后的效果。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/1.jpg\" alt=\"image\"></p>\n<p><a href=\"https://github.com/suifengqjn/TBCycleProgress\" target=\"_blank\" rel=\"external\">demo下载地址</a></p>\n<p>更多原创文章可以看 <a href=\"https://gcblog/github.io/\">我的博客</a></p>\n","excerpt":"<p>有几篇博客写到了怎么实现环形进度条，大多是使用Core Graph来实现，实现比较麻烦且效率略低，只是一个小小的进度条而已，我们当然是用最简单而且效率高的方式来实现。<br>先看一下这篇博客，博客地址：<a href=\"http://www.brighttj.com/ios/ios-implement-loop-progress.html\">http://www.brighttj.com/ios/ios-implement-loop-progress.html</a><br>这篇博客写的不错，不过看上去还是略微复杂了，我自己根据自己的思路整理了一下，当然目的是为了更加简洁易懂。</p>\n<h3 id=\"一：先制作一个不带颜色渐变的进度条\"><a href=\"#一：先制作一个不带颜色渐变的进度条\" class=\"headerlink\" title=\"一：先制作一个不带颜色渐变的进度条\"></a>一：先制作一个不带颜色渐变的进度条</h3><p>自定义一个cycleView，在.m 中实现drawRect方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawRect:(CGRect)rect &#123;</div><div class=\"line\">    </div><div class=\"line\">    CGContextRef ctx = UIGraphicsGetCurrentContext();//获取上下文</div><div class=\"line\">    </div><div class=\"line\">    CGPoint center = CGPointMake(100, 100);  //设置圆心位置</div><div class=\"line\">    CGFloat radius = 90;  //设置半径</div><div class=\"line\">    CGFloat startA = - M_PI_2;  //圆起点位置</div><div class=\"line\">    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //圆终点位置</div><div class=\"line\">    </div><div class=\"line\">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];</div><div class=\"line\">    </div><div class=\"line\">    CGContextSetLineWidth(ctx, 10); //设置线条宽度</div><div class=\"line\">    [[UIColor blueColor] setStroke]; //设置描边颜色</div><div class=\"line\">    </div><div class=\"line\">    CGContextAddPath(ctx, path.CGPath); //把路径添加到上下文</div><div class=\"line\">    </div><div class=\"line\">    CGContextStrokePath(ctx);  //渲染</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>因为drawRect方法只是在视图刚刚出现的时候执行一次，所以我们需要使用 </p>\n<p><code>[self setNeedsDisplay];</code></p>\n<p>这个方法来进行重新绘制，<br>在控制器里面加一个slider，滑动slider来控制进度变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)drawProgress:(CGFloat )progress</div><div class=\"line\">&#123;</div><div class=\"line\">    _progress = progress;</div><div class=\"line\">    [self setNeedsDisplay];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看一下效果</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/0.png\" alt=\"image\"></p>\n<p>如果进度条不需要加渐变色，那么这儿几行代码就完成了。</p>\n<p>下面来实现一下带有渐变色的进度条，原理很简单，刚刚画的是一条默认是黑色的线条，我们把黑色替换成一条渐变色的线条就可以了。<br>环形渐变色线条的制作：</p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>使用CAShapeLayer绘制出渐变层，应为它只能指定两个点之间进行渐变，所以这里需要两个CAShapeLayer，左边一个和右边一个，看一下效果图</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/3.jpg\" alt=\"image\"></p>\n<p>代码实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//生成渐变色</div><div class=\"line\">    CALayer *gradientLayer = [CALayer layer];</div><div class=\"line\">    </div><div class=\"line\">    //左侧渐变色</div><div class=\"line\">    CAGradientLayer *leftLayer = [CAGradientLayer layer];</div><div class=\"line\">    leftLayer.frame = CGRectMake(0, 0, self.bounds.size.width / 2, self.bounds.size.height);    // 分段设置渐变色</div><div class=\"line\">    leftLayer.locations = @[@0.3, @0.9, @1];</div><div class=\"line\">    leftLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor greenColor].CGColor];</div><div class=\"line\">    [gradientLayer addSublayer:leftLayer];</div><div class=\"line\">    </div><div class=\"line\">    //右侧渐变色</div><div class=\"line\">    CAGradientLayer *rightLayer = [CAGradientLayer layer];</div><div class=\"line\">    rightLayer.frame = CGRectMake(self.bounds.size.width / 2, 0, self.bounds.size.width / 2, self.bounds.size.height);</div><div class=\"line\">    rightLayer.locations = @[@0.3, @0.9, @1];</div><div class=\"line\">    rightLayer.colors = @[(id)[UIColor yellowColor].CGColor, (id)[UIColor redColor].CGColor];</div><div class=\"line\">    [gradientLayer addSublayer:rightLayer];</div></pre></td></tr></table></figure>\n<p>这个渐变层只是一个中间变量，是不能显示出来的，我这里只是演示一下，现在我们已经拿到了渐变层gradientLayer。</p>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>我们需要制作一个环形路径<br>先看一下效果：</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/2.jpg\" alt=\"image\"></p>\n<p>代码实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">CGPoint center = CGPointMake(100, 100);</div><div class=\"line\">    CGFloat radius = 90;</div><div class=\"line\">    CGFloat startA = - M_PI_2;  //设置进度条起点位置</div><div class=\"line\">    CGFloat endA = -M_PI_2 + M_PI * 2 * _progress;  //设置进度条终点位置</div><div class=\"line\">    </div><div class=\"line\">    //获取环形路径（画一个圆形，填充色透明，设置线框宽度为10，这样就获得了一个环形）</div><div class=\"line\">    _progressLayer = [CAShapeLayer layer];//创建一个track shape layer</div><div class=\"line\">    _progressLayer.frame = self.bounds;</div><div class=\"line\">    _progressLayer.fillColor = [[UIColor clearColor] CGColor];  //填充色为无色</div><div class=\"line\">    _progressLayer.strokeColor = [[UIColor redColor] CGColor]; //指定path的渲染颜色,这里可以设置任意不透明颜色</div><div class=\"line\">    _progressLayer.opacity = 1; //背景颜色的透明度</div><div class=\"line\">    _progressLayer.lineCap = kCALineCapRound;//指定线的边缘是圆的</div><div class=\"line\">    _progressLayer.lineWidth = 10;//线的宽度</div><div class=\"line\">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:startA endAngle:endA clockwise:YES];//上面说明过了用来构建圆形</div><div class=\"line\">    _progressLayer.path =[path CGPath]; //把path传递給layer，然后layer会处理相应的渲染，整个逻辑和CoreGraph是一致的。</div><div class=\"line\">    [self.layer addSublayer:_progressLayer];</div></pre></td></tr></table></figure>\n<h3 id=\"第三步，也是最后一步了\"><a href=\"#第三步，也是最后一步了\" class=\"headerlink\" title=\"第三步，也是最后一步了\"></a>第三步，也是最后一步了</h3><p>用我们在第二步生成的环形路径去截取第一步生成的渐变层</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[gradientLayer setMask:_progressLayer]; //用progressLayer来截取渐变层</div><div class=\"line\">self.layer addSublayer:gradientLayer];</div></pre></td></tr></table></figure>\n<p>截取的layer层就是我们最后需要的，看一看我们最后截取后得到的<br><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/4.jpg\" alt=\"image\"></p>\n<p>到这里，我们已经完成了99%了，最后一步，根据自己的需要让它显示多少的比例就完成了。比例的控制在第二部的progress属性，比例在0-1之间，看一看最后的效果。</p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/TBCycleProgress/master/TBCycleProgress/TBCycleProgress/screenShot/1.jpg\" alt=\"image\"></p>\n<p><a href=\"https://github.com/suifengqjn/TBCycleProgress\">demo下载地址</a></p>\n<p>更多原创文章可以看 <a href=\"https://gcblog/github.io/\">我的博客</a></p>"},{"title":"swift自动布局","date":"2016-11-24T15:48:09.000Z","_content":"\n### 苹果原生自动布局\n\n- 自动布局核心公式\n\n` view1.attr1 = view2.attr2 * multiplier + constant`\n\n- 自动布局构造函数\n\n``` \nNSLayoutConstraint(item: 视图,\n\tattribute: 约束属性，\n\trelatedBy: 约束关系，\n\ttoItem: 参照视图,\n\tattribute: 参照属性,\n\tmultiplier:乘积,\n\tconstant:约束数值\n)\n\n```\n<!--more-->\n\n- 如果指定 宽 高 约束\n  - 参照视图设置为 nil\n  - 参照属性选择 .notAnAttribute\n  \n- 自动布局类函数\n\n```\nNSLayoutConstraint.constraints(withVisualFormat: VLF公式,\n options:[], \n metrics: 约束数值字典[String : 数值], \n views: 视图字典[String : 子视图]\n )\n```\n\n- VFL 可视化格式化语言\n  - H 水平方向\n  - V 垂直方向\n  - | 边界\n  - [] 包含控件的名称字符串，对应关系在`views`字典中定义\n  - () 定义控件的宽/高，可以在`metrics`中指定\n>tip：VFL 通常用于连续参照关系，如果遇到居中对齐，通常使用直接参照\n\n","source":"_posts/swift自动布局.md","raw":"---\ntitle: swift自动布局\ndate: 2016-11-24 23:48:09\ncategories:\n  - swfit\ntags:\n  - swift\n  - 自动布局\n---\n\n### 苹果原生自动布局\n\n- 自动布局核心公式\n\n` view1.attr1 = view2.attr2 * multiplier + constant`\n\n- 自动布局构造函数\n\n``` \nNSLayoutConstraint(item: 视图,\n\tattribute: 约束属性，\n\trelatedBy: 约束关系，\n\ttoItem: 参照视图,\n\tattribute: 参照属性,\n\tmultiplier:乘积,\n\tconstant:约束数值\n)\n\n```\n<!--more-->\n\n- 如果指定 宽 高 约束\n  - 参照视图设置为 nil\n  - 参照属性选择 .notAnAttribute\n  \n- 自动布局类函数\n\n```\nNSLayoutConstraint.constraints(withVisualFormat: VLF公式,\n options:[], \n metrics: 约束数值字典[String : 数值], \n views: 视图字典[String : 子视图]\n )\n```\n\n- VFL 可视化格式化语言\n  - H 水平方向\n  - V 垂直方向\n  - | 边界\n  - [] 包含控件的名称字符串，对应关系在`views`字典中定义\n  - () 定义控件的宽/高，可以在`metrics`中指定\n>tip：VFL 通常用于连续参照关系，如果遇到居中对齐，通常使用直接参照\n\n","slug":"swift自动布局","published":1,"updated":"2016-11-24T15:50:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmi5000vco60b94az7ut","content":"<h3 id=\"苹果原生自动布局\"><a href=\"#苹果原生自动布局\" class=\"headerlink\" title=\"苹果原生自动布局\"></a>苹果原生自动布局</h3><ul>\n<li>自动布局核心公式</li>\n</ul>\n<p><code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>\n<ul>\n<li>自动布局构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSLayoutConstraint(item: 视图,</div><div class=\"line\">\tattribute: 约束属性，</div><div class=\"line\">\trelatedBy: 约束关系，</div><div class=\"line\">\ttoItem: 参照视图,</div><div class=\"line\">\tattribute: 参照属性,</div><div class=\"line\">\tmultiplier:乘积,</div><div class=\"line\">\tconstant:约束数值</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<ul>\n<li><p>如果指定 宽 高 约束</p>\n<ul>\n<li>参照视图设置为 nil</li>\n<li>参照属性选择 .notAnAttribute</li>\n</ul>\n</li>\n<li><p>自动布局类函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSLayoutConstraint.constraints(withVisualFormat: VLF公式,</div><div class=\"line\"> options:[], </div><div class=\"line\"> metrics: 约束数值字典[String : 数值], </div><div class=\"line\"> views: 视图字典[String : 子视图]</div><div class=\"line\"> )</div></pre></td></tr></table></figure>\n<ul>\n<li>VFL 可视化格式化语言<ul>\n<li>H 水平方向</li>\n<li>V 垂直方向</li>\n<li>| 边界</li>\n<li>[] 包含控件的名称字符串，对应关系在<code>views</code>字典中定义</li>\n<li>() 定义控件的宽/高，可以在<code>metrics</code>中指定<blockquote>\n<p>tip：VFL 通常用于连续参照关系，如果遇到居中对齐，通常使用直接参照</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n","excerpt":"<h3 id=\"苹果原生自动布局\"><a href=\"#苹果原生自动布局\" class=\"headerlink\" title=\"苹果原生自动布局\"></a>苹果原生自动布局</h3><ul>\n<li>自动布局核心公式</li>\n</ul>\n<p><code>view1.attr1 = view2.attr2 * multiplier + constant</code></p>\n<ul>\n<li>自动布局构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSLayoutConstraint(item: 视图,</div><div class=\"line\">\tattribute: 约束属性，</div><div class=\"line\">\trelatedBy: 约束关系，</div><div class=\"line\">\ttoItem: 参照视图,</div><div class=\"line\">\tattribute: 参照属性,</div><div class=\"line\">\tmultiplier:乘积,</div><div class=\"line\">\tconstant:约束数值</div><div class=\"line\">)</div></pre></td></tr></table></figure>","more":"<ul>\n<li><p>如果指定 宽 高 约束</p>\n<ul>\n<li>参照视图设置为 nil</li>\n<li>参照属性选择 .notAnAttribute</li>\n</ul>\n</li>\n<li><p>自动布局类函数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSLayoutConstraint.constraints(withVisualFormat: VLF公式,</div><div class=\"line\"> options:[], </div><div class=\"line\"> metrics: 约束数值字典[String : 数值], </div><div class=\"line\"> views: 视图字典[String : 子视图]</div><div class=\"line\"> )</div></pre></td></tr></table></figure>\n<ul>\n<li>VFL 可视化格式化语言<ul>\n<li>H 水平方向</li>\n<li>V 垂直方向</li>\n<li>| 边界</li>\n<li>[] 包含控件的名称字符串，对应关系在<code>views</code>字典中定义</li>\n<li>() 定义控件的宽/高，可以在<code>metrics</code>中指定<blockquote>\n<p>tip：VFL 通常用于连续参照关系，如果遇到居中对齐，通常使用直接参照</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"iOS视频边下边播--缓存视频数据流","date":"2016-02-25T08:01:50.000Z","_content":"\ngoogle搜索“iOS视频变下边播”，有好几篇博客写到了实现方法，其实只有一篇，其他都是copy的，不过他们都是使用的本地代理服务器的方式，原理很简单，但是缺点也很明显，需要自己写一个本地代理服务器或者使用第三方库httpSever。如果使用httpSever作为本地代理服务器，如果只缓存一个视频是没有问题的，如果缓存多个视频互相切换，本地代理服务器提供的数据很不稳定，crash概率非常大。\n***\n\n这里我采用ios7以后系统自带的方法实现视频边下边播，这里的边下边播不是单独开一个子线程去下载，而是把视频播放的数据给保存到本地。简而言之，就是使用一遍的流量，既播放了视频，也保存了视频。\n\n```\n用到的框架：<AVFoundation/AVFoundation.h>\n\n用到的播放器：AVplayer\n```\n\n先说一下avplayer自身的播放原理，当我们给播放器设置好url等一些参数后，播放器就会向url所在的服务器发送请求(请求参数有两个值，一个是offset偏移量，另一个是length长度，其实就相当于NSRange一样)，服务器就根据range参数给播放器返回数据。这就是大致的原理，当然实际的过程还是略微比较复杂。\n***\n\n</br>\n\n### 一:下面进入主题\n#### 产品需求：\n - 1.支持正常播放器的一切功能，包括暂停、播放和拖拽\n - 2.如果视频加载完成且完整，将视频文件保存到本地cache，下一次播放本地cache中的视频，不再请求网络数据\n - 3.如果视频没有加载完（半路关闭或者拖拽）就不用保存到本地cache\n \n<!-- more -->\n\n#### 实现方案:\n\n - 需要在视频播放器和服务器之间添加一层类似代理的机制，视频播放器不再直接访问服务器，而是访问代理对象，代理对象去访问服务器获得数据，之后返回给视频播放器，同时代理对象根据一定的策略缓存数据。\n\n- 2.AVURLAsset中的resourceLoader可以实现这个机制，resourceLoader的delegate就是上述的代理对象。\n\n- 3.视频播放器在开始播放之前首先检测是本地cache中是否有此视频，如果没有才通过代理获得数据，如果有，则直接播放本地cache中的视频即可。\n\n#### 视频播放器需要实现的功能\n\n - 1.有开始暂停按钮\n\n - 2.显示播放进度及总时长\n\n - 3.可以通过拖拽从任意位置开始播放视频\n\n - 4.视频加载中的过程和加载失败需要有相应的提示\n\n#### 代理对象需要实现的功能\n\n - 1.接收视频播放器的请求，并根据请求的range向服务器请求本地没有获得的数据\n\n - 2.缓存向服务器请求回的数据到本地\n\n - 3.如果向服务器的请求出现错误，需要通知给视频播放器，以便视频播放器对用户进行提示\n\t\n\t\n### 二：具体流程\n\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/TBPlayer/1.png)\n\n\n#### 视频播放器处理流程\n\n - 1.当开始播放视频时，通过视频url判断本地cache中是否已经缓存当前视频，如果有，则直接播放本地cache中视频\n\n - 2.如果本地cache中没有视频，则视频播放器向代理请求数据\n\n - 3.加载视频时展示正在加载的提示（菊花转）\n\n - 4.如果可以正常播放视频，则去掉加载提示，播放视频，如果加载失败，去掉加载提示并显示失败提示\n\n - 5.在播放过程中如果由于网络过慢或拖拽原因导致没有播放数据时，要展示加载提示，跳转到第4步\n\n#### 代理对象处理流程\n\n - 1.当视频播放器向代理请求dataRequest时，判断代理是否已经向服务器发起了请求，如果没有，则发起下载整个视频文件的请求\n\n - 2.如果代理已经和服务器建立链接，则判断当前的dataRequest请求的offset是否大于当前已经缓存的文件的offset，如果大于则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向后拖拽，并且超过了已缓存的数据时才会出现）\n\n - 3.如果当前的dataRequest请求的offset小于已经缓存的文件的offset，同时大于代理向服务器请求的range的offset，说明有一部分已经缓存的数据可以传给播放器，则将这部分数据返回给播放器（此时应该是由于播放器向前拖拽，请求的数据已经缓存过才会出现）\n\n - 4.如果当前的dataRequest请求的offset小于代理向服务器请求的range的offset，则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向前拖拽，并且超过了已缓存的数据时才会出现）\n\n - 5.只要代理重新向服务器发起请求，就会导致缓存的数据不连续，则加载结束后不用将缓存的数据放入本地cache\n\n - 6.如果代理和服务器的链接超时，重试一次，如果还是错误则通知播放器网络错误\n\n - 7.如果服务器返回其他错误，则代理通知播放器网络错误\n\n### 三：resourceLoader的难点处理\n```\n- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest\n{\n    [self.pendingRequests addObject:loadingRequest];\n    [self dealWithLoadingRequest:loadingRequest];\n    \n    return YES;\n}\n```\n播放器发出的数据请求从这里开始，我们保存从这里发出的所有请求存放到数组，自己来处理这些请求，当一个请求完成后，对请求发出finishLoading消息，并从数组中移除。正常状态下，当播放器发出下一个请求的时候，会把上一个请求给finish。\n\n下面这个方法发出的请求说明播放器自己关闭了这个请求，我们不需要再对这个请求进行处理，系统每次结束一个旧的请求，便必然会发出一个或多个新的请求，除了播放器已经获得整个视频完整的数据，这时候就不会再发起请求。\n\n```\n- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest\n{\n    [self.pendingRequests removeObject:loadingRequest];\n    \n}\n```\n下面这个方法是对播放器发出的请求进行填充数据\n\n```\n- (BOOL)respondWithDataForRequest:(AVAssetResourceLoadingDataRequest *)dataRequest\n{\n    long long startOffset = dataRequest.requestedOffset;\n\n    if (dataRequest.currentOffset != 0) {\n        startOffset = dataRequest.currentOffset;\n    }\n    \n    if ((self.task.offset +self.task.downLoadingOffset) < startOffset)\n    {\n        //NSLog(@\"NO DATA FOR REQUEST\");\n        return NO;\n    }\n    \n    if (startOffset < self.task.offset) {\n        return NO;\n    }\n    \n    NSData *filedata = [NSData dataWithContentsOfURL:[NSURL fileURLWithPath:_videoPath] options:NSDataReadingMappedIfSafe error:nil];\n    \n    // This is the total data we have from startOffset to whatever has been downloaded so far\n    NSUInteger unreadBytes = self.task.downLoadingOffset - ((NSInteger)startOffset - self.task.offset);\n    \n    // Respond with whatever is available if we can't satisfy the request fully yet\n    NSUInteger numberOfBytesToRespondWith = MIN((NSUInteger)dataRequest.requestedLength, unreadBytes);\n    \n    \n    [dataRequest respondWithData:[filedata subdataWithRange:NSMakeRange((NSUInteger)startOffset- self.task.offset, (NSUInteger)numberOfBytesToRespondWith)]];\n    \n    \n    \n    long long endOffset = startOffset + dataRequest.requestedLength;\n    BOOL didRespondFully = (self.task.offset + self.task.downLoadingOffset) >= endOffset;\n\n    return didRespondFully;\n  \n    \n}\n```\n\n这是对存放所有的请求的数组进行处理\n\n```\n- (void)processPendingRequests\n{\n    NSMutableArray *requestsCompleted = [NSMutableArray array];  //请求完成的数组\n    //每次下载一块数据都是一次请求，把这些请求放到数组，遍历数组\n    for (AVAssetResourceLoadingRequest *loadingRequest in self.pendingRequests)\n    {\n        [self fillInContentInformation:loadingRequest.contentInformationRequest]; //对每次请求加上长度，文件类型等信息\n        \n        BOOL didRespondCompletely = [self respondWithDataForRequest:loadingRequest.dataRequest]; //判断此次请求的数据是否处理完全\n        \n        if (didRespondCompletely) {\n\n            [requestsCompleted addObject:loadingRequest];  //如果完整，把此次请求放进 请求完成的数组\n            [loadingRequest finishLoading];\n            \n        }\n    }\n\n    [self.pendingRequests removeObjectsInArray:requestsCompleted];   //在所有请求的数组中移除已经完成的\n    \n}\n```\nresourceLoader的难点基本上就是上面这点了，说到播放器，下面便顺便讲下AVPlayer的难点。\n\n### 四：难点：对播放器状态的捕获\n- 1.举个简单的例子，视频总长度60分，现在缓冲的数据才10分钟，然后拖动到20分钟的位置进行播放，在网速较慢的时候，视频从当前位置开始播放，必然会出现一段时间的卡顿，为了有一个更好的用户体验，在卡顿的时候，我们需要加一个菊花转的状态，现在问题就来了。\n\n\n- 2.在拖动到未缓冲区域内，是否需要加菊花转，如果加，要显示多久再消失，而且如果在网速很慢的时候，播放器如果等了太久，哪怕最后有数据了，播放器也已经“死”了，它自己无法恢复播放，这个时候需要我们人为的去恢复播放，如果恢复播放不成功，那么过一段时间需要再次恢复播放，是否恢复播放成功，这里也需要捕获其状态。所以，如果要有一个好的用户体验，我们需要时时知道播放器的状态。\n\n有两个状态需要捕获，一个是正在缓冲，一个是正在播放，监听播放的“playbackBufferEmpty”属性就可以捕获正在缓冲状态，播放器的时间监听器则可以捕获正在播放状态，我的demo中一共有4个状态：\n\n```\ntypedef NS_ENUM(NSInteger, TBPlayerState) {\n    TBPlayerStateBuffering = 1,\n    TBPlayerStatePlaying   = 2,\n    TBPlayerStateStopped   = 3,\n    TBPlayerStatePause     = 4\n};\n```\n这样可以对播放器更好的把握和处理了。\n然后说一说在缓冲时候的处理，以及缓冲后多久去播放，处理方法：\n进入缓冲状态后，缓冲2秒后去手动播放，如果播放不成功（缓冲的数据太少，还不足以播放），那就再缓冲2秒再次播放，如此循环，看详细代码：\n\n```\n- (void)bufferingSomeSecond\n{\n    // playbackBufferEmpty会反复进入，因此在bufferingOneSecond延时播放执行完之前再调用bufferingSomeSecond都忽略\n    static BOOL isBuffering = NO;\n    if (isBuffering) {\n        return;\n    }\n    isBuffering = YES;\n    \n    // 需要先暂停一小会之后再播放，否则网络状况不好的时候时间在走，声音播放不出来\n    [self.player pause];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        \n        // 如果此时用户已经暂停了，则不再需要开启播放了\n        if (self.isPauseByUser) {\n            isBuffering = NO;\n            return;\n        }\n        \n        [self.player play];\n        // 如果执行了play还是没有播放则说明还没有缓存好，则再次缓存一段时间\n        isBuffering = NO;\n        if (!self.currentPlayerItem.isPlaybackLikelyToKeepUp) {\n            [self bufferingSomeSecond];\n        }\n    });\n}\n```\n这个demo花了我很长的时间，实现这个demo我也遇到了很多坑最后才完成的，现在我奉献出来，也许对你会有所帮助。如果你觉得不错，还请为我Star一个，也算是对我的支持和鼓励。\n\n[demo下载地址](https://github.com/suifengqjn/TBPlayer)\n也可以去我的简书博客查看更多文章\n[博客地址](http://www.jianshu.com/users/527ecf8c8753/latest_articles)\n","source":"_posts/iOS视频边下边播-缓存视频数据流.md","raw":"---\ntitle: iOS视频边下边播--缓存视频数据流\ndate: 2016-02-25 16:01:50\ntags: [iOS, AVplayer]\ncategories: \n- iOS技术\n---\n\ngoogle搜索“iOS视频变下边播”，有好几篇博客写到了实现方法，其实只有一篇，其他都是copy的，不过他们都是使用的本地代理服务器的方式，原理很简单，但是缺点也很明显，需要自己写一个本地代理服务器或者使用第三方库httpSever。如果使用httpSever作为本地代理服务器，如果只缓存一个视频是没有问题的，如果缓存多个视频互相切换，本地代理服务器提供的数据很不稳定，crash概率非常大。\n***\n\n这里我采用ios7以后系统自带的方法实现视频边下边播，这里的边下边播不是单独开一个子线程去下载，而是把视频播放的数据给保存到本地。简而言之，就是使用一遍的流量，既播放了视频，也保存了视频。\n\n```\n用到的框架：<AVFoundation/AVFoundation.h>\n\n用到的播放器：AVplayer\n```\n\n先说一下avplayer自身的播放原理，当我们给播放器设置好url等一些参数后，播放器就会向url所在的服务器发送请求(请求参数有两个值，一个是offset偏移量，另一个是length长度，其实就相当于NSRange一样)，服务器就根据range参数给播放器返回数据。这就是大致的原理，当然实际的过程还是略微比较复杂。\n***\n\n</br>\n\n### 一:下面进入主题\n#### 产品需求：\n - 1.支持正常播放器的一切功能，包括暂停、播放和拖拽\n - 2.如果视频加载完成且完整，将视频文件保存到本地cache，下一次播放本地cache中的视频，不再请求网络数据\n - 3.如果视频没有加载完（半路关闭或者拖拽）就不用保存到本地cache\n \n<!-- more -->\n\n#### 实现方案:\n\n - 需要在视频播放器和服务器之间添加一层类似代理的机制，视频播放器不再直接访问服务器，而是访问代理对象，代理对象去访问服务器获得数据，之后返回给视频播放器，同时代理对象根据一定的策略缓存数据。\n\n- 2.AVURLAsset中的resourceLoader可以实现这个机制，resourceLoader的delegate就是上述的代理对象。\n\n- 3.视频播放器在开始播放之前首先检测是本地cache中是否有此视频，如果没有才通过代理获得数据，如果有，则直接播放本地cache中的视频即可。\n\n#### 视频播放器需要实现的功能\n\n - 1.有开始暂停按钮\n\n - 2.显示播放进度及总时长\n\n - 3.可以通过拖拽从任意位置开始播放视频\n\n - 4.视频加载中的过程和加载失败需要有相应的提示\n\n#### 代理对象需要实现的功能\n\n - 1.接收视频播放器的请求，并根据请求的range向服务器请求本地没有获得的数据\n\n - 2.缓存向服务器请求回的数据到本地\n\n - 3.如果向服务器的请求出现错误，需要通知给视频播放器，以便视频播放器对用户进行提示\n\t\n\t\n### 二：具体流程\n\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/TBPlayer/1.png)\n\n\n#### 视频播放器处理流程\n\n - 1.当开始播放视频时，通过视频url判断本地cache中是否已经缓存当前视频，如果有，则直接播放本地cache中视频\n\n - 2.如果本地cache中没有视频，则视频播放器向代理请求数据\n\n - 3.加载视频时展示正在加载的提示（菊花转）\n\n - 4.如果可以正常播放视频，则去掉加载提示，播放视频，如果加载失败，去掉加载提示并显示失败提示\n\n - 5.在播放过程中如果由于网络过慢或拖拽原因导致没有播放数据时，要展示加载提示，跳转到第4步\n\n#### 代理对象处理流程\n\n - 1.当视频播放器向代理请求dataRequest时，判断代理是否已经向服务器发起了请求，如果没有，则发起下载整个视频文件的请求\n\n - 2.如果代理已经和服务器建立链接，则判断当前的dataRequest请求的offset是否大于当前已经缓存的文件的offset，如果大于则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向后拖拽，并且超过了已缓存的数据时才会出现）\n\n - 3.如果当前的dataRequest请求的offset小于已经缓存的文件的offset，同时大于代理向服务器请求的range的offset，说明有一部分已经缓存的数据可以传给播放器，则将这部分数据返回给播放器（此时应该是由于播放器向前拖拽，请求的数据已经缓存过才会出现）\n\n - 4.如果当前的dataRequest请求的offset小于代理向服务器请求的range的offset，则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向前拖拽，并且超过了已缓存的数据时才会出现）\n\n - 5.只要代理重新向服务器发起请求，就会导致缓存的数据不连续，则加载结束后不用将缓存的数据放入本地cache\n\n - 6.如果代理和服务器的链接超时，重试一次，如果还是错误则通知播放器网络错误\n\n - 7.如果服务器返回其他错误，则代理通知播放器网络错误\n\n### 三：resourceLoader的难点处理\n```\n- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest\n{\n    [self.pendingRequests addObject:loadingRequest];\n    [self dealWithLoadingRequest:loadingRequest];\n    \n    return YES;\n}\n```\n播放器发出的数据请求从这里开始，我们保存从这里发出的所有请求存放到数组，自己来处理这些请求，当一个请求完成后，对请求发出finishLoading消息，并从数组中移除。正常状态下，当播放器发出下一个请求的时候，会把上一个请求给finish。\n\n下面这个方法发出的请求说明播放器自己关闭了这个请求，我们不需要再对这个请求进行处理，系统每次结束一个旧的请求，便必然会发出一个或多个新的请求，除了播放器已经获得整个视频完整的数据，这时候就不会再发起请求。\n\n```\n- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest\n{\n    [self.pendingRequests removeObject:loadingRequest];\n    \n}\n```\n下面这个方法是对播放器发出的请求进行填充数据\n\n```\n- (BOOL)respondWithDataForRequest:(AVAssetResourceLoadingDataRequest *)dataRequest\n{\n    long long startOffset = dataRequest.requestedOffset;\n\n    if (dataRequest.currentOffset != 0) {\n        startOffset = dataRequest.currentOffset;\n    }\n    \n    if ((self.task.offset +self.task.downLoadingOffset) < startOffset)\n    {\n        //NSLog(@\"NO DATA FOR REQUEST\");\n        return NO;\n    }\n    \n    if (startOffset < self.task.offset) {\n        return NO;\n    }\n    \n    NSData *filedata = [NSData dataWithContentsOfURL:[NSURL fileURLWithPath:_videoPath] options:NSDataReadingMappedIfSafe error:nil];\n    \n    // This is the total data we have from startOffset to whatever has been downloaded so far\n    NSUInteger unreadBytes = self.task.downLoadingOffset - ((NSInteger)startOffset - self.task.offset);\n    \n    // Respond with whatever is available if we can't satisfy the request fully yet\n    NSUInteger numberOfBytesToRespondWith = MIN((NSUInteger)dataRequest.requestedLength, unreadBytes);\n    \n    \n    [dataRequest respondWithData:[filedata subdataWithRange:NSMakeRange((NSUInteger)startOffset- self.task.offset, (NSUInteger)numberOfBytesToRespondWith)]];\n    \n    \n    \n    long long endOffset = startOffset + dataRequest.requestedLength;\n    BOOL didRespondFully = (self.task.offset + self.task.downLoadingOffset) >= endOffset;\n\n    return didRespondFully;\n  \n    \n}\n```\n\n这是对存放所有的请求的数组进行处理\n\n```\n- (void)processPendingRequests\n{\n    NSMutableArray *requestsCompleted = [NSMutableArray array];  //请求完成的数组\n    //每次下载一块数据都是一次请求，把这些请求放到数组，遍历数组\n    for (AVAssetResourceLoadingRequest *loadingRequest in self.pendingRequests)\n    {\n        [self fillInContentInformation:loadingRequest.contentInformationRequest]; //对每次请求加上长度，文件类型等信息\n        \n        BOOL didRespondCompletely = [self respondWithDataForRequest:loadingRequest.dataRequest]; //判断此次请求的数据是否处理完全\n        \n        if (didRespondCompletely) {\n\n            [requestsCompleted addObject:loadingRequest];  //如果完整，把此次请求放进 请求完成的数组\n            [loadingRequest finishLoading];\n            \n        }\n    }\n\n    [self.pendingRequests removeObjectsInArray:requestsCompleted];   //在所有请求的数组中移除已经完成的\n    \n}\n```\nresourceLoader的难点基本上就是上面这点了，说到播放器，下面便顺便讲下AVPlayer的难点。\n\n### 四：难点：对播放器状态的捕获\n- 1.举个简单的例子，视频总长度60分，现在缓冲的数据才10分钟，然后拖动到20分钟的位置进行播放，在网速较慢的时候，视频从当前位置开始播放，必然会出现一段时间的卡顿，为了有一个更好的用户体验，在卡顿的时候，我们需要加一个菊花转的状态，现在问题就来了。\n\n\n- 2.在拖动到未缓冲区域内，是否需要加菊花转，如果加，要显示多久再消失，而且如果在网速很慢的时候，播放器如果等了太久，哪怕最后有数据了，播放器也已经“死”了，它自己无法恢复播放，这个时候需要我们人为的去恢复播放，如果恢复播放不成功，那么过一段时间需要再次恢复播放，是否恢复播放成功，这里也需要捕获其状态。所以，如果要有一个好的用户体验，我们需要时时知道播放器的状态。\n\n有两个状态需要捕获，一个是正在缓冲，一个是正在播放，监听播放的“playbackBufferEmpty”属性就可以捕获正在缓冲状态，播放器的时间监听器则可以捕获正在播放状态，我的demo中一共有4个状态：\n\n```\ntypedef NS_ENUM(NSInteger, TBPlayerState) {\n    TBPlayerStateBuffering = 1,\n    TBPlayerStatePlaying   = 2,\n    TBPlayerStateStopped   = 3,\n    TBPlayerStatePause     = 4\n};\n```\n这样可以对播放器更好的把握和处理了。\n然后说一说在缓冲时候的处理，以及缓冲后多久去播放，处理方法：\n进入缓冲状态后，缓冲2秒后去手动播放，如果播放不成功（缓冲的数据太少，还不足以播放），那就再缓冲2秒再次播放，如此循环，看详细代码：\n\n```\n- (void)bufferingSomeSecond\n{\n    // playbackBufferEmpty会反复进入，因此在bufferingOneSecond延时播放执行完之前再调用bufferingSomeSecond都忽略\n    static BOOL isBuffering = NO;\n    if (isBuffering) {\n        return;\n    }\n    isBuffering = YES;\n    \n    // 需要先暂停一小会之后再播放，否则网络状况不好的时候时间在走，声音播放不出来\n    [self.player pause];\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        \n        // 如果此时用户已经暂停了，则不再需要开启播放了\n        if (self.isPauseByUser) {\n            isBuffering = NO;\n            return;\n        }\n        \n        [self.player play];\n        // 如果执行了play还是没有播放则说明还没有缓存好，则再次缓存一段时间\n        isBuffering = NO;\n        if (!self.currentPlayerItem.isPlaybackLikelyToKeepUp) {\n            [self bufferingSomeSecond];\n        }\n    });\n}\n```\n这个demo花了我很长的时间，实现这个demo我也遇到了很多坑最后才完成的，现在我奉献出来，也许对你会有所帮助。如果你觉得不错，还请为我Star一个，也算是对我的支持和鼓励。\n\n[demo下载地址](https://github.com/suifengqjn/TBPlayer)\n也可以去我的简书博客查看更多文章\n[博客地址](http://www.jianshu.com/users/527ecf8c8753/latest_articles)\n","slug":"iOS视频边下边播-缓存视频数据流","published":1,"updated":"2016-11-17T14:59:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmid000zco60jj41gn85","content":"<p>google搜索“iOS视频变下边播”，有好几篇博客写到了实现方法，其实只有一篇，其他都是copy的，不过他们都是使用的本地代理服务器的方式，原理很简单，但是缺点也很明显，需要自己写一个本地代理服务器或者使用第三方库httpSever。如果使用httpSever作为本地代理服务器，如果只缓存一个视频是没有问题的，如果缓存多个视频互相切换，本地代理服务器提供的数据很不稳定，crash概率非常大。</p>\n<hr>\n<p>这里我采用ios7以后系统自带的方法实现视频边下边播，这里的边下边播不是单独开一个子线程去下载，而是把视频播放的数据给保存到本地。简而言之，就是使用一遍的流量，既播放了视频，也保存了视频。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">用到的框架：&lt;AVFoundation/AVFoundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">用到的播放器：AVplayer</div></pre></td></tr></table></figure>\n<p>先说一下avplayer自身的播放原理，当我们给播放器设置好url等一些参数后，播放器就会向url所在的服务器发送请求(请求参数有两个值，一个是offset偏移量，另一个是length长度，其实就相当于NSRange一样)，服务器就根据range参数给播放器返回数据。这就是大致的原理，当然实际的过程还是略微比较复杂。</p>\n<hr>\n<p><br></p>\n<h3 id=\"一-下面进入主题\"><a href=\"#一-下面进入主题\" class=\"headerlink\" title=\"一:下面进入主题\"></a>一:下面进入主题</h3><h4 id=\"产品需求：\"><a href=\"#产品需求：\" class=\"headerlink\" title=\"产品需求：\"></a>产品需求：</h4><ul>\n<li>1.支持正常播放器的一切功能，包括暂停、播放和拖拽</li>\n<li>2.如果视频加载完成且完整，将视频文件保存到本地cache，下一次播放本地cache中的视频，不再请求网络数据</li>\n<li>3.如果视频没有加载完（半路关闭或者拖拽）就不用保存到本地cache</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案:\"></a>实现方案:</h4><ul>\n<li>需要在视频播放器和服务器之间添加一层类似代理的机制，视频播放器不再直接访问服务器，而是访问代理对象，代理对象去访问服务器获得数据，之后返回给视频播放器，同时代理对象根据一定的策略缓存数据。</li>\n</ul>\n<ul>\n<li><p>2.AVURLAsset中的resourceLoader可以实现这个机制，resourceLoader的delegate就是上述的代理对象。</p>\n</li>\n<li><p>3.视频播放器在开始播放之前首先检测是本地cache中是否有此视频，如果没有才通过代理获得数据，如果有，则直接播放本地cache中的视频即可。</p>\n</li>\n</ul>\n<h4 id=\"视频播放器需要实现的功能\"><a href=\"#视频播放器需要实现的功能\" class=\"headerlink\" title=\"视频播放器需要实现的功能\"></a>视频播放器需要实现的功能</h4><ul>\n<li><p>1.有开始暂停按钮</p>\n</li>\n<li><p>2.显示播放进度及总时长</p>\n</li>\n<li><p>3.可以通过拖拽从任意位置开始播放视频</p>\n</li>\n<li><p>4.视频加载中的过程和加载失败需要有相应的提示</p>\n</li>\n</ul>\n<h4 id=\"代理对象需要实现的功能\"><a href=\"#代理对象需要实现的功能\" class=\"headerlink\" title=\"代理对象需要实现的功能\"></a>代理对象需要实现的功能</h4><ul>\n<li><p>1.接收视频播放器的请求，并根据请求的range向服务器请求本地没有获得的数据</p>\n</li>\n<li><p>2.缓存向服务器请求回的数据到本地</p>\n</li>\n<li><p>3.如果向服务器的请求出现错误，需要通知给视频播放器，以便视频播放器对用户进行提示</p>\n</li>\n</ul>\n<h3 id=\"二：具体流程\"><a href=\"#二：具体流程\" class=\"headerlink\" title=\"二：具体流程\"></a>二：具体流程</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/TBPlayer/1.png\" alt=\"image\"></p>\n<h4 id=\"视频播放器处理流程\"><a href=\"#视频播放器处理流程\" class=\"headerlink\" title=\"视频播放器处理流程\"></a>视频播放器处理流程</h4><ul>\n<li><p>1.当开始播放视频时，通过视频url判断本地cache中是否已经缓存当前视频，如果有，则直接播放本地cache中视频</p>\n</li>\n<li><p>2.如果本地cache中没有视频，则视频播放器向代理请求数据</p>\n</li>\n<li><p>3.加载视频时展示正在加载的提示（菊花转）</p>\n</li>\n<li><p>4.如果可以正常播放视频，则去掉加载提示，播放视频，如果加载失败，去掉加载提示并显示失败提示</p>\n</li>\n<li><p>5.在播放过程中如果由于网络过慢或拖拽原因导致没有播放数据时，要展示加载提示，跳转到第4步</p>\n</li>\n</ul>\n<h4 id=\"代理对象处理流程\"><a href=\"#代理对象处理流程\" class=\"headerlink\" title=\"代理对象处理流程\"></a>代理对象处理流程</h4><ul>\n<li><p>1.当视频播放器向代理请求dataRequest时，判断代理是否已经向服务器发起了请求，如果没有，则发起下载整个视频文件的请求</p>\n</li>\n<li><p>2.如果代理已经和服务器建立链接，则判断当前的dataRequest请求的offset是否大于当前已经缓存的文件的offset，如果大于则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向后拖拽，并且超过了已缓存的数据时才会出现）</p>\n</li>\n<li><p>3.如果当前的dataRequest请求的offset小于已经缓存的文件的offset，同时大于代理向服务器请求的range的offset，说明有一部分已经缓存的数据可以传给播放器，则将这部分数据返回给播放器（此时应该是由于播放器向前拖拽，请求的数据已经缓存过才会出现）</p>\n</li>\n<li><p>4.如果当前的dataRequest请求的offset小于代理向服务器请求的range的offset，则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向前拖拽，并且超过了已缓存的数据时才会出现）</p>\n</li>\n<li><p>5.只要代理重新向服务器发起请求，就会导致缓存的数据不连续，则加载结束后不用将缓存的数据放入本地cache</p>\n</li>\n<li><p>6.如果代理和服务器的链接超时，重试一次，如果还是错误则通知播放器网络错误</p>\n</li>\n<li><p>7.如果服务器返回其他错误，则代理通知播放器网络错误</p>\n</li>\n</ul>\n<h3 id=\"三：resourceLoader的难点处理\"><a href=\"#三：resourceLoader的难点处理\" class=\"headerlink\" title=\"三：resourceLoader的难点处理\"></a>三：resourceLoader的难点处理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.pendingRequests addObject:loadingRequest];</div><div class=\"line\">    [self dealWithLoadingRequest:loadingRequest];</div><div class=\"line\">    </div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>播放器发出的数据请求从这里开始，我们保存从这里发出的所有请求存放到数组，自己来处理这些请求，当一个请求完成后，对请求发出finishLoading消息，并从数组中移除。正常状态下，当播放器发出下一个请求的时候，会把上一个请求给finish。</p>\n<p>下面这个方法发出的请求说明播放器自己关闭了这个请求，我们不需要再对这个请求进行处理，系统每次结束一个旧的请求，便必然会发出一个或多个新的请求，除了播放器已经获得整个视频完整的数据，这时候就不会再发起请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.pendingRequests removeObject:loadingRequest];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面这个方法是对播放器发出的请求进行填充数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)respondWithDataForRequest:(AVAssetResourceLoadingDataRequest *)dataRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    long long startOffset = dataRequest.requestedOffset;</div><div class=\"line\"></div><div class=\"line\">    if (dataRequest.currentOffset != 0) &#123;</div><div class=\"line\">        startOffset = dataRequest.currentOffset;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if ((self.task.offset +self.task.downLoadingOffset) &lt; startOffset)</div><div class=\"line\">    &#123;</div><div class=\"line\">        //NSLog(@&quot;NO DATA FOR REQUEST&quot;);</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (startOffset &lt; self.task.offset) &#123;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    NSData *filedata = [NSData dataWithContentsOfURL:[NSURL fileURLWithPath:_videoPath] options:NSDataReadingMappedIfSafe error:nil];</div><div class=\"line\">    </div><div class=\"line\">    // This is the total data we have from startOffset to whatever has been downloaded so far</div><div class=\"line\">    NSUInteger unreadBytes = self.task.downLoadingOffset - ((NSInteger)startOffset - self.task.offset);</div><div class=\"line\">    </div><div class=\"line\">    // Respond with whatever is available if we can&apos;t satisfy the request fully yet</div><div class=\"line\">    NSUInteger numberOfBytesToRespondWith = MIN((NSUInteger)dataRequest.requestedLength, unreadBytes);</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    [dataRequest respondWithData:[filedata subdataWithRange:NSMakeRange((NSUInteger)startOffset- self.task.offset, (NSUInteger)numberOfBytesToRespondWith)]];</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    long long endOffset = startOffset + dataRequest.requestedLength;</div><div class=\"line\">    BOOL didRespondFully = (self.task.offset + self.task.downLoadingOffset) &gt;= endOffset;</div><div class=\"line\"></div><div class=\"line\">    return didRespondFully;</div><div class=\"line\">  </div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是对存放所有的请求的数组进行处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)processPendingRequests</div><div class=\"line\">&#123;</div><div class=\"line\">    NSMutableArray *requestsCompleted = [NSMutableArray array];  //请求完成的数组</div><div class=\"line\">    //每次下载一块数据都是一次请求，把这些请求放到数组，遍历数组</div><div class=\"line\">    for (AVAssetResourceLoadingRequest *loadingRequest in self.pendingRequests)</div><div class=\"line\">    &#123;</div><div class=\"line\">        [self fillInContentInformation:loadingRequest.contentInformationRequest]; //对每次请求加上长度，文件类型等信息</div><div class=\"line\">        </div><div class=\"line\">        BOOL didRespondCompletely = [self respondWithDataForRequest:loadingRequest.dataRequest]; //判断此次请求的数据是否处理完全</div><div class=\"line\">        </div><div class=\"line\">        if (didRespondCompletely) &#123;</div><div class=\"line\"></div><div class=\"line\">            [requestsCompleted addObject:loadingRequest];  //如果完整，把此次请求放进 请求完成的数组</div><div class=\"line\">            [loadingRequest finishLoading];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    [self.pendingRequests removeObjectsInArray:requestsCompleted];   //在所有请求的数组中移除已经完成的</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>resourceLoader的难点基本上就是上面这点了，说到播放器，下面便顺便讲下AVPlayer的难点。</p>\n<h3 id=\"四：难点：对播放器状态的捕获\"><a href=\"#四：难点：对播放器状态的捕获\" class=\"headerlink\" title=\"四：难点：对播放器状态的捕获\"></a>四：难点：对播放器状态的捕获</h3><ul>\n<li>1.举个简单的例子，视频总长度60分，现在缓冲的数据才10分钟，然后拖动到20分钟的位置进行播放，在网速较慢的时候，视频从当前位置开始播放，必然会出现一段时间的卡顿，为了有一个更好的用户体验，在卡顿的时候，我们需要加一个菊花转的状态，现在问题就来了。</li>\n</ul>\n<ul>\n<li>2.在拖动到未缓冲区域内，是否需要加菊花转，如果加，要显示多久再消失，而且如果在网速很慢的时候，播放器如果等了太久，哪怕最后有数据了，播放器也已经“死”了，它自己无法恢复播放，这个时候需要我们人为的去恢复播放，如果恢复播放不成功，那么过一段时间需要再次恢复播放，是否恢复播放成功，这里也需要捕获其状态。所以，如果要有一个好的用户体验，我们需要时时知道播放器的状态。</li>\n</ul>\n<p>有两个状态需要捕获，一个是正在缓冲，一个是正在播放，监听播放的“playbackBufferEmpty”属性就可以捕获正在缓冲状态，播放器的时间监听器则可以捕获正在播放状态，我的demo中一共有4个状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, TBPlayerState) &#123;</div><div class=\"line\">    TBPlayerStateBuffering = 1,</div><div class=\"line\">    TBPlayerStatePlaying   = 2,</div><div class=\"line\">    TBPlayerStateStopped   = 3,</div><div class=\"line\">    TBPlayerStatePause     = 4</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样可以对播放器更好的把握和处理了。<br>然后说一说在缓冲时候的处理，以及缓冲后多久去播放，处理方法：<br>进入缓冲状态后，缓冲2秒后去手动播放，如果播放不成功（缓冲的数据太少，还不足以播放），那就再缓冲2秒再次播放，如此循环，看详细代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)bufferingSomeSecond</div><div class=\"line\">&#123;</div><div class=\"line\">    // playbackBufferEmpty会反复进入，因此在bufferingOneSecond延时播放执行完之前再调用bufferingSomeSecond都忽略</div><div class=\"line\">    static BOOL isBuffering = NO;</div><div class=\"line\">    if (isBuffering) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isBuffering = YES;</div><div class=\"line\">    </div><div class=\"line\">    // 需要先暂停一小会之后再播放，否则网络状况不好的时候时间在走，声音播放不出来</div><div class=\"line\">    [self.player pause];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        // 如果此时用户已经暂停了，则不再需要开启播放了</div><div class=\"line\">        if (self.isPauseByUser) &#123;</div><div class=\"line\">            isBuffering = NO;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        [self.player play];</div><div class=\"line\">        // 如果执行了play还是没有播放则说明还没有缓存好，则再次缓存一段时间</div><div class=\"line\">        isBuffering = NO;</div><div class=\"line\">        if (!self.currentPlayerItem.isPlaybackLikelyToKeepUp) &#123;</div><div class=\"line\">            [self bufferingSomeSecond];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个demo花了我很长的时间，实现这个demo我也遇到了很多坑最后才完成的，现在我奉献出来，也许对你会有所帮助。如果你觉得不错，还请为我Star一个，也算是对我的支持和鼓励。</p>\n<p><a href=\"https://github.com/suifengqjn/TBPlayer\" target=\"_blank\" rel=\"external\">demo下载地址</a><br>也可以去我的简书博客查看更多文章<br><a href=\"http://www.jianshu.com/users/527ecf8c8753/latest_articles\" target=\"_blank\" rel=\"external\">博客地址</a></p>\n","excerpt":"<p>google搜索“iOS视频变下边播”，有好几篇博客写到了实现方法，其实只有一篇，其他都是copy的，不过他们都是使用的本地代理服务器的方式，原理很简单，但是缺点也很明显，需要自己写一个本地代理服务器或者使用第三方库httpSever。如果使用httpSever作为本地代理服务器，如果只缓存一个视频是没有问题的，如果缓存多个视频互相切换，本地代理服务器提供的数据很不稳定，crash概率非常大。</p>\n<hr>\n<p>这里我采用ios7以后系统自带的方法实现视频边下边播，这里的边下边播不是单独开一个子线程去下载，而是把视频播放的数据给保存到本地。简而言之，就是使用一遍的流量，既播放了视频，也保存了视频。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">用到的框架：&lt;AVFoundation/AVFoundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">用到的播放器：AVplayer</div></pre></td></tr></table></figure>\n<p>先说一下avplayer自身的播放原理，当我们给播放器设置好url等一些参数后，播放器就会向url所在的服务器发送请求(请求参数有两个值，一个是offset偏移量，另一个是length长度，其实就相当于NSRange一样)，服务器就根据range参数给播放器返回数据。这就是大致的原理，当然实际的过程还是略微比较复杂。</p>\n<hr>\n<p></br></p>\n<h3 id=\"一-下面进入主题\"><a href=\"#一-下面进入主题\" class=\"headerlink\" title=\"一:下面进入主题\"></a>一:下面进入主题</h3><h4 id=\"产品需求：\"><a href=\"#产品需求：\" class=\"headerlink\" title=\"产品需求：\"></a>产品需求：</h4><ul>\n<li>1.支持正常播放器的一切功能，包括暂停、播放和拖拽</li>\n<li>2.如果视频加载完成且完整，将视频文件保存到本地cache，下一次播放本地cache中的视频，不再请求网络数据</li>\n<li>3.如果视频没有加载完（半路关闭或者拖拽）就不用保存到本地cache</li>\n</ul>","more":"<h4 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案:\"></a>实现方案:</h4><ul>\n<li>需要在视频播放器和服务器之间添加一层类似代理的机制，视频播放器不再直接访问服务器，而是访问代理对象，代理对象去访问服务器获得数据，之后返回给视频播放器，同时代理对象根据一定的策略缓存数据。</li>\n</ul>\n<ul>\n<li><p>2.AVURLAsset中的resourceLoader可以实现这个机制，resourceLoader的delegate就是上述的代理对象。</p>\n</li>\n<li><p>3.视频播放器在开始播放之前首先检测是本地cache中是否有此视频，如果没有才通过代理获得数据，如果有，则直接播放本地cache中的视频即可。</p>\n</li>\n</ul>\n<h4 id=\"视频播放器需要实现的功能\"><a href=\"#视频播放器需要实现的功能\" class=\"headerlink\" title=\"视频播放器需要实现的功能\"></a>视频播放器需要实现的功能</h4><ul>\n<li><p>1.有开始暂停按钮</p>\n</li>\n<li><p>2.显示播放进度及总时长</p>\n</li>\n<li><p>3.可以通过拖拽从任意位置开始播放视频</p>\n</li>\n<li><p>4.视频加载中的过程和加载失败需要有相应的提示</p>\n</li>\n</ul>\n<h4 id=\"代理对象需要实现的功能\"><a href=\"#代理对象需要实现的功能\" class=\"headerlink\" title=\"代理对象需要实现的功能\"></a>代理对象需要实现的功能</h4><ul>\n<li><p>1.接收视频播放器的请求，并根据请求的range向服务器请求本地没有获得的数据</p>\n</li>\n<li><p>2.缓存向服务器请求回的数据到本地</p>\n</li>\n<li><p>3.如果向服务器的请求出现错误，需要通知给视频播放器，以便视频播放器对用户进行提示</p>\n</li>\n</ul>\n<h3 id=\"二：具体流程\"><a href=\"#二：具体流程\" class=\"headerlink\" title=\"二：具体流程\"></a>二：具体流程</h3><p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/TBPlayer/1.png\" alt=\"image\"></p>\n<h4 id=\"视频播放器处理流程\"><a href=\"#视频播放器处理流程\" class=\"headerlink\" title=\"视频播放器处理流程\"></a>视频播放器处理流程</h4><ul>\n<li><p>1.当开始播放视频时，通过视频url判断本地cache中是否已经缓存当前视频，如果有，则直接播放本地cache中视频</p>\n</li>\n<li><p>2.如果本地cache中没有视频，则视频播放器向代理请求数据</p>\n</li>\n<li><p>3.加载视频时展示正在加载的提示（菊花转）</p>\n</li>\n<li><p>4.如果可以正常播放视频，则去掉加载提示，播放视频，如果加载失败，去掉加载提示并显示失败提示</p>\n</li>\n<li><p>5.在播放过程中如果由于网络过慢或拖拽原因导致没有播放数据时，要展示加载提示，跳转到第4步</p>\n</li>\n</ul>\n<h4 id=\"代理对象处理流程\"><a href=\"#代理对象处理流程\" class=\"headerlink\" title=\"代理对象处理流程\"></a>代理对象处理流程</h4><ul>\n<li><p>1.当视频播放器向代理请求dataRequest时，判断代理是否已经向服务器发起了请求，如果没有，则发起下载整个视频文件的请求</p>\n</li>\n<li><p>2.如果代理已经和服务器建立链接，则判断当前的dataRequest请求的offset是否大于当前已经缓存的文件的offset，如果大于则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向后拖拽，并且超过了已缓存的数据时才会出现）</p>\n</li>\n<li><p>3.如果当前的dataRequest请求的offset小于已经缓存的文件的offset，同时大于代理向服务器请求的range的offset，说明有一部分已经缓存的数据可以传给播放器，则将这部分数据返回给播放器（此时应该是由于播放器向前拖拽，请求的数据已经缓存过才会出现）</p>\n</li>\n<li><p>4.如果当前的dataRequest请求的offset小于代理向服务器请求的range的offset，则取消当前与服务器的请求，并从offset开始到文件尾向服务器发起请求（此时应该是由于播放器向前拖拽，并且超过了已缓存的数据时才会出现）</p>\n</li>\n<li><p>5.只要代理重新向服务器发起请求，就会导致缓存的数据不连续，则加载结束后不用将缓存的数据放入本地cache</p>\n</li>\n<li><p>6.如果代理和服务器的链接超时，重试一次，如果还是错误则通知播放器网络错误</p>\n</li>\n<li><p>7.如果服务器返回其他错误，则代理通知播放器网络错误</p>\n</li>\n</ul>\n<h3 id=\"三：resourceLoader的难点处理\"><a href=\"#三：resourceLoader的难点处理\" class=\"headerlink\" title=\"三：resourceLoader的难点处理\"></a>三：resourceLoader的难点处理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.pendingRequests addObject:loadingRequest];</div><div class=\"line\">    [self dealWithLoadingRequest:loadingRequest];</div><div class=\"line\">    </div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>播放器发出的数据请求从这里开始，我们保存从这里发出的所有请求存放到数组，自己来处理这些请求，当一个请求完成后，对请求发出finishLoading消息，并从数组中移除。正常状态下，当播放器发出下一个请求的时候，会把上一个请求给finish。</p>\n<p>下面这个方法发出的请求说明播放器自己关闭了这个请求，我们不需要再对这个请求进行处理，系统每次结束一个旧的请求，便必然会发出一个或多个新的请求，除了播放器已经获得整个视频完整的数据，这时候就不会再发起请求。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    [self.pendingRequests removeObject:loadingRequest];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面这个方法是对播放器发出的请求进行填充数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)respondWithDataForRequest:(AVAssetResourceLoadingDataRequest *)dataRequest</div><div class=\"line\">&#123;</div><div class=\"line\">    long long startOffset = dataRequest.requestedOffset;</div><div class=\"line\"></div><div class=\"line\">    if (dataRequest.currentOffset != 0) &#123;</div><div class=\"line\">        startOffset = dataRequest.currentOffset;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if ((self.task.offset +self.task.downLoadingOffset) &lt; startOffset)</div><div class=\"line\">    &#123;</div><div class=\"line\">        //NSLog(@&quot;NO DATA FOR REQUEST&quot;);</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (startOffset &lt; self.task.offset) &#123;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    NSData *filedata = [NSData dataWithContentsOfURL:[NSURL fileURLWithPath:_videoPath] options:NSDataReadingMappedIfSafe error:nil];</div><div class=\"line\">    </div><div class=\"line\">    // This is the total data we have from startOffset to whatever has been downloaded so far</div><div class=\"line\">    NSUInteger unreadBytes = self.task.downLoadingOffset - ((NSInteger)startOffset - self.task.offset);</div><div class=\"line\">    </div><div class=\"line\">    // Respond with whatever is available if we can&apos;t satisfy the request fully yet</div><div class=\"line\">    NSUInteger numberOfBytesToRespondWith = MIN((NSUInteger)dataRequest.requestedLength, unreadBytes);</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    [dataRequest respondWithData:[filedata subdataWithRange:NSMakeRange((NSUInteger)startOffset- self.task.offset, (NSUInteger)numberOfBytesToRespondWith)]];</div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    long long endOffset = startOffset + dataRequest.requestedLength;</div><div class=\"line\">    BOOL didRespondFully = (self.task.offset + self.task.downLoadingOffset) &gt;= endOffset;</div><div class=\"line\"></div><div class=\"line\">    return didRespondFully;</div><div class=\"line\">  </div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是对存放所有的请求的数组进行处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)processPendingRequests</div><div class=\"line\">&#123;</div><div class=\"line\">    NSMutableArray *requestsCompleted = [NSMutableArray array];  //请求完成的数组</div><div class=\"line\">    //每次下载一块数据都是一次请求，把这些请求放到数组，遍历数组</div><div class=\"line\">    for (AVAssetResourceLoadingRequest *loadingRequest in self.pendingRequests)</div><div class=\"line\">    &#123;</div><div class=\"line\">        [self fillInContentInformation:loadingRequest.contentInformationRequest]; //对每次请求加上长度，文件类型等信息</div><div class=\"line\">        </div><div class=\"line\">        BOOL didRespondCompletely = [self respondWithDataForRequest:loadingRequest.dataRequest]; //判断此次请求的数据是否处理完全</div><div class=\"line\">        </div><div class=\"line\">        if (didRespondCompletely) &#123;</div><div class=\"line\"></div><div class=\"line\">            [requestsCompleted addObject:loadingRequest];  //如果完整，把此次请求放进 请求完成的数组</div><div class=\"line\">            [loadingRequest finishLoading];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    [self.pendingRequests removeObjectsInArray:requestsCompleted];   //在所有请求的数组中移除已经完成的</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>resourceLoader的难点基本上就是上面这点了，说到播放器，下面便顺便讲下AVPlayer的难点。</p>\n<h3 id=\"四：难点：对播放器状态的捕获\"><a href=\"#四：难点：对播放器状态的捕获\" class=\"headerlink\" title=\"四：难点：对播放器状态的捕获\"></a>四：难点：对播放器状态的捕获</h3><ul>\n<li>1.举个简单的例子，视频总长度60分，现在缓冲的数据才10分钟，然后拖动到20分钟的位置进行播放，在网速较慢的时候，视频从当前位置开始播放，必然会出现一段时间的卡顿，为了有一个更好的用户体验，在卡顿的时候，我们需要加一个菊花转的状态，现在问题就来了。</li>\n</ul>\n<ul>\n<li>2.在拖动到未缓冲区域内，是否需要加菊花转，如果加，要显示多久再消失，而且如果在网速很慢的时候，播放器如果等了太久，哪怕最后有数据了，播放器也已经“死”了，它自己无法恢复播放，这个时候需要我们人为的去恢复播放，如果恢复播放不成功，那么过一段时间需要再次恢复播放，是否恢复播放成功，这里也需要捕获其状态。所以，如果要有一个好的用户体验，我们需要时时知道播放器的状态。</li>\n</ul>\n<p>有两个状态需要捕获，一个是正在缓冲，一个是正在播放，监听播放的“playbackBufferEmpty”属性就可以捕获正在缓冲状态，播放器的时间监听器则可以捕获正在播放状态，我的demo中一共有4个状态：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, TBPlayerState) &#123;</div><div class=\"line\">    TBPlayerStateBuffering = 1,</div><div class=\"line\">    TBPlayerStatePlaying   = 2,</div><div class=\"line\">    TBPlayerStateStopped   = 3,</div><div class=\"line\">    TBPlayerStatePause     = 4</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样可以对播放器更好的把握和处理了。<br>然后说一说在缓冲时候的处理，以及缓冲后多久去播放，处理方法：<br>进入缓冲状态后，缓冲2秒后去手动播放，如果播放不成功（缓冲的数据太少，还不足以播放），那就再缓冲2秒再次播放，如此循环，看详细代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)bufferingSomeSecond</div><div class=\"line\">&#123;</div><div class=\"line\">    // playbackBufferEmpty会反复进入，因此在bufferingOneSecond延时播放执行完之前再调用bufferingSomeSecond都忽略</div><div class=\"line\">    static BOOL isBuffering = NO;</div><div class=\"line\">    if (isBuffering) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    isBuffering = YES;</div><div class=\"line\">    </div><div class=\"line\">    // 需要先暂停一小会之后再播放，否则网络状况不好的时候时间在走，声音播放不出来</div><div class=\"line\">    [self.player pause];</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        </div><div class=\"line\">        // 如果此时用户已经暂停了，则不再需要开启播放了</div><div class=\"line\">        if (self.isPauseByUser) &#123;</div><div class=\"line\">            isBuffering = NO;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        [self.player play];</div><div class=\"line\">        // 如果执行了play还是没有播放则说明还没有缓存好，则再次缓存一段时间</div><div class=\"line\">        isBuffering = NO;</div><div class=\"line\">        if (!self.currentPlayerItem.isPlaybackLikelyToKeepUp) &#123;</div><div class=\"line\">            [self bufferingSomeSecond];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个demo花了我很长的时间，实现这个demo我也遇到了很多坑最后才完成的，现在我奉献出来，也许对你会有所帮助。如果你觉得不错，还请为我Star一个，也算是对我的支持和鼓励。</p>\n<p><a href=\"https://github.com/suifengqjn/TBPlayer\">demo下载地址</a><br>也可以去我的简书博客查看更多文章<br><a href=\"http://www.jianshu.com/users/527ecf8c8753/latest_articles\">博客地址</a></p>"},{"title":"runtime详解","author":[{"name":"千寻墨","url":"http://www.jianshu.com/users/527ecf8c8753/latest_articles"}],"date":"2016-04-16T08:59:52.000Z","_content":"\n公司项目用到一个三方开源库，里面有个bug，不能改动源码，我想来想去，只能通过runtime这个万能的手段来解决。但是runtime 并不怎么会用，怎么办，马上学习呗。说到runtime，它是Objective-c里面最核心的技术，被人们传呼的神乎其神，但是感觉有一层神秘的面纱笼罩其上，毕竟使用场景不多，相信大多数开发者都不会熟练的运用。而网络上也有无数的文章来讲解runtime，但是真的非常的乱，非常的碎片化，很少有讲解的比较全面的。\n   \n最初是在onevcat的博客上看到runtime的[runtime的博客](https://onevcat.com/2012/04/objective-c-runtime/)，说句实话，看完后我还是蒙的，这里面主要讲了一下runtime 比较核心的功能-Method Swizzling，不过看完后还是有些不知如何下手的感觉。下面是我自己对runtime的整理，从零开始，由浅入深，并且带了几个runtime实际的应用场景。看完之后，你可以再回过头来看喵神的这篇文章，应该就能看的懂了。\n\n### 一：基本概念\nRuntime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在[这里](http://opensource.apple.com//source/objc4/)下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。\n\n* RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。\n* 对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。\n* OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。\n* 只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。\n\n### 二：runtime的具体实现\n我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。\n每一个oc的方法，底层必然有一个与之对应的runtime方法。\n<!-- more -->\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/1.png)\n\n- 当我们用OC写下这样一段代码\n`[tableView cellForRowAtIndexPath:indexPath];`\n\n- 在编译时RunTime会将上述代码转化成[发送消息]\n`objc_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath);`\n\n### 三:常见方法\n\n `unsigned int count; `\n \n - 获取属性列表\n \n ```\nobjc_property_t *propertyList = class_copyPropertyList([self class], &count);\n    for (unsigned int i=0; i<count; i++) {\n        const char *propertyName = property_getName(propertyList[i]);\n        NSLog(@\"property---->%@\", [NSString stringWithUTF8String:propertyName]);\n    }\n```\n\n - 获取方法列表\n \n ```\n    Method *methodList = class_copyMethodList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Method method = methodList[i];\n        NSLog(@\"method---->%@\", NSStringFromSelector(method_getName(method)));\n    }\n```\n\n- 获取成员变量列表\n    \n  ```  \n  Ivar *ivarList = class_copyIvarList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Ivar myIvar = ivarList[i];\n        const char *ivarName = ivar_getName(myIvar);\n        NSLog(@\"Ivar---->%@\", [NSString stringWithUTF8String:ivarName]);\n    } \n  ```\n \n- 获取协议列表\n \n ```   \n __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Protocol *myProtocal = protocolList[i];\n        const char *protocolName = protocol_getName(myProtocal);\n        NSLog(@\"protocol---->%@\", [NSString stringWithUTF8String:protocolName]);\n    }\n  ``` \n  \n>现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法\n\n- 获得类方法\n\n```\nClass PersonClass = object_getClass([Person class]);\nSEL oriSEL = @selector(test1);\nMethod oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);\n```   \n\n- 获得实例方法\n  \n```\nClass PersonClass = object_getClass([xiaoming class]);\nSEL oriSEL = @selector(test2);\nMethod cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);\n```   \n- 添加方法\n\n```\nBOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n```\n\n- 替换原方法实现\n\n```\nclass_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n```\n- 交换两个方法\n\n```\nmethod_exchangeImplementations(oriMethod, cusMethod);\n```\n    \n    \n    \n### 四：常见作用\n- 动态的添加对象的成员变量和方法\n- 动态交换两个方法的实现\n- 拦截并替换方法\n- 在方法上增加额外功能\n- 实现NSCoding的自动归档和解档\n- 实现字典转模型的自动转换\n\n### 五：代码实现\n要使用runtime，要先引入头文件`#import <objc/runtime.h>`\n这些代码的实例有浅入深逐步讲解，最后附上一个我在公司项目中遇到的一个实际问题。\n\n#### 1. 动态变量控制\n   在程序中，xiaoming的age是10，后来被runtime变成了20，来看看runtime是怎么做到的。\n   \n##### 1.动态获取XiaoMing类中的所有属性[当然包括私有]  \n\n\t`Ivar *ivar = class_copyIvarList([self.xiaoming class], &count);`  \n\n##### 2.遍历属性找到对应name字段  \n\n\t`const char *varName = ivar_getName(var);`\n\n##### 3.修改对应的字段值成20 \n\t\n\t`object_setIvar(self.xiaoMing, var, @\"20\");`  \n\t\n##### 4.代码参考\n\n```\n-(void)answer{\n    \tunsigned int count = 0;\n    \tIvar *ivar = class_copyIvarList([self.xiaoMing class], &count);\n    \tfor (int i = 0; i<count; i++) {\n        \tIvar var = ivar[i];\n        \tconst char *varName = ivar_getName(var);\n        \tNSString *name = [NSString stringWithUTF8String:varName];\n        \tif ([name isEqualToString:@\"_age\"]) {\n            \tobject_setIvar(self.xiaoMing, var, @\"20\");\n            \tbreak;\n        \t}\n    \t}\n    \tNSLog(@\"XiaoMing's age is %@\",self.xiaoMing.age);\n\t}\n```\n\n#### 2.动态添加方法\n\n在程序当中，假设XiaoMing的中没有`guess`这个方法，后来被Runtime添加一个名字叫guess的方法，最终再调用guess方法做出相应。那么，Runtime是如何做到的呢？  \n  \n##### 1.动态给XiaoMing类中添加guess方法：  \n\n```\n\tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, \"v@:\");\n```\n\n这里参数地方说明一下：\n\n>(IMP)guessAnswer 意思是guessAnswer的地址指针;\n>\"v@:\" 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;\n>“v@:@@” 意思是，两个参数的没有返回值。  \n\n\n##### 2.调用guess方法响应事件：  \n\n\t[self.xiaoMing performSelector:@selector(guess)];\n\n##### 3.编写guessAnswer的实现：  \n\t\n\t\n\tvoid guessAnswer(id self,SEL _cmd){\n    \tNSLog(@\"i am from beijing\");   \n\t} \n\t\n\n这个有两个地方留意一下：\n* void的前面没有+、-号，因为只是C的代码。\n* 必须有两个指定参数(id self,SEL _cmd)  \n\n##### 4.代码参考\n\n```  \n\t-(void)answer{\n    \tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, \"v@:\");\n    \tif ([self.xiaoMing respondsToSelector:@selector(guess)]) {\n        \n        \t[self.xiaoMing performSelector:@selector(guess)];\n        \n    \t} else{\n        \tNSLog(@\"Sorry,I don't know\");\n    \t}\n\t}\n\n\tvoid guessAnswer(id self,SEL _cmd){\n   \n    \tNSLog(@\"i am from beijing\");\n    \n\t}\n```\n\n#### 3：动态交换两个方法的实现\n\n在程序当中，假设XiaoMing的中有`test1` 和 `test2`这两个方法，后来被Runtime交换方法后，每次调动`test1` 的时候就会去执行`test2`，调动`test2` 的时候就会去执行`test1`， 。那么，Runtime是如何做到的呢？\n\n##### 1. 获取这个类中的两个方法并交换\n\n```\nMethod m1 = class_getInstanceMethod([self.xiaoMing class], @selector(test1));\n    Method m2 = class_getInstanceMethod([self.xiaoMing class], @selector(test2));\n    method_exchangeImplementations(m1, m2);\n```\n交换方法之后，以后每次调用这两个方法都会交换方法的实现\n\n#### 4：拦截并替换方法\n\n在程序当中，假设XiaoMing的中有`test1`这个方法，但是由于某种原因，我们要改变这个方法的实现，但是又不能去动它的源代码(正如一些开源库出现问题的时候)，这个时候runtime就派上用场了。\n\n我们先增加一个tool类，然后写一个我们自己实现的方法-change，\n通过runtime把test1替换成change。\n\n```\nClass PersionClass = object_getClass([Person class]);\nClass toolClass = object_getClass([tool class]);\n\n    ////源方法的SEL和Method\n    \n    SEL oriSEL = @selector(test1);\n    Method oriMethod = class_getInstanceMethod(PersionClass, oriSEL);\n    \n    ////交换方法的SEL和Method\n    \n    SEL cusSEL = @selector(change);\n    Method cusMethod = class_getInstanceMethod(toolClass, cusSEL);\n    \n    ////先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况\n    \n    BOOL addSucc = class_addMethod(PersionClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n    if (addSucc) {\n          // 添加成功：将源方法的实现替换到交换方法的实现     \n        class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n               \n    }else {\n    //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即\nmethod_exchangeImplementations(oriMethod, cusMethod);  \n  }\n \n```\n\n#### 5：在方法上增加额外功能\n\n有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决：\n\n```\n@implementation UIButton (Hook)\n\n+ (void)load {\n\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n\n        Class selfClass = [self class];\n\n        SEL oriSEL = @selector(sendAction:to:forEvent:);\n        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);\n\n        SEL cusSEL = @selector(mySendAction:to:forEvent:);\n        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);\n\n        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n        if (addSucc) {\n            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n        }else {\n            method_exchangeImplementations(oriMethod, cusMethod);\n        }\n\n    });\n}\n\n- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {\n    [CountTool addClickCount];\n    [self mySendAction:action to:target forEvent:event];\n}\n\n@end\n```\n\nload方法会在类第一次加载的时候被调用,调用的时间比较靠前，适合在这个方法里做方法交换,方法交换应该被保证，在程序中只会执行一次。\n\n#### 6.实现NSCoding的自动归档和解档\n\n如果你实现过自定义模型数据持久化的过程，那么你也肯定明白，如果一个模型有许多个属性，那么我们需要对每个属性都实现一遍`encodeObject` 和 `decodeObjectForKey`方法，如果这样的模型又有很多个，这还真的是一个十分麻烦的事情。下面来看看简单的实现方式。\n假设现在有一个Movie类，有3个属性，它的`h`文件这这样的\n\n```\n#import <Foundation/Foundation.h>\n\n//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding\n@interface Movie : NSObject<NSCoding>\n\n@property (nonatomic, copy) NSString *movieId;\n@property (nonatomic, copy) NSString *movieName;\n@property (nonatomic, copy) NSString *pic_url;\n\n@end\n\n```\n\n如果是正常写法， `m`文件应该是这样的：\n\n```\n#import \"Movie.h\"\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)aCoder\n{\n    [aCoder encodeObject:_movieId forKey:@\"id\"];\n    [aCoder encodeObject:_movieName forKey:@\"name\"];\n    [aCoder encodeObject:_pic_url forKey:@\"url\"];\n    \n}\n\n- (id)initWithCoder:(NSCoder *)aDecoder\n{\n    if (self = [super init]) {\n        self.movieId = [aDecoder decodeObjectForKey:@\"id\"];\n        self.movieName = [aDecoder decodeObjectForKey:@\"name\"];\n        self.pic_url = [aDecoder decodeObjectForKey:@\"url\"];\n    }\n    return self;\n}\n@end\n```\n如果这里有100个属性，那么我们也只能把100个属性都给写一遍。\n不过你会使用runtime后，这里就有更简便的方法。\n下面看看runtime的实现方式：\n\n```\n#import \"Movie.h\"\n#import <objc/runtime.h>\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)encoder\n\n{\n    unsigned int count = 0;\n    Ivar *ivars = class_copyIvarList([Movie class], &count);\n    \n    for (int i = 0; i<count; i++) {\n        // 取出i位置对应的成员变量\n        Ivar ivar = ivars[i];\n        // 查看成员变量\n        const char *name = ivar_getName(ivar);\n        // 归档\n        NSString *key = [NSString stringWithUTF8String:name];\n        id value = [self valueForKey:key];\n        [encoder encodeObject:value forKey:key];\n    }\n    free(ivars);\n}\n\n- (id)initWithCoder:(NSCoder *)decoder\n{\n    if (self = [super init]) {\n        unsigned int count = 0;\n        Ivar *ivars = class_copyIvarList([Movie class], &count);\n        for (int i = 0; i<count; i++) {\n        // 取出i位置对应的成员变量\n        Ivar ivar = ivars[i];\n        // 查看成员变量\n        const char *name = ivar_getName(ivar);\n       // 归档\n       NSString *key = [NSString stringWithUTF8String:name];\n      id value = [decoder decodeObjectForKey:key];\n       // 设置到成员变量身上\n        [self setValue:value forKey:key];\n            \n        }\n        free(ivars);\n    } \n    return self;\n}\n@end\n```\n\n这样的方式实现，不管有多少个属性，写这几行代码就搞定了。怎么，还嫌麻烦，下面看看更加简便的方法：两句代码搞定。\n我们把`encodeWithCoder` 和 `initWithCoder`这两个方法抽成宏\n\n```\n#import \"Movie.h\"\n#import <objc/runtime.h>\n\n#define encodeRuntime(A) \\\n\\\nunsigned int count = 0;\\\nIvar *ivars = class_copyIvarList([A class], &count);\\\nfor (int i = 0; i<count; i++) {\\\nIvar ivar = ivars[i];\\\nconst char *name = ivar_getName(ivar);\\\nNSString *key = [NSString stringWithUTF8String:name];\\\nid value = [self valueForKey:key];\\\n[encoder encodeObject:value forKey:key];\\\n}\\\nfree(ivars);\\\n\\\n\n\n\n#define initCoderRuntime(A) \\\n\\\nif (self = [super init]) {\\\nunsigned int count = 0;\\\nIvar *ivars = class_copyIvarList([A class], &count);\\\nfor (int i = 0; i<count; i++) {\\\nIvar ivar = ivars[i];\\\nconst char *name = ivar_getName(ivar);\\\nNSString *key = [NSString stringWithUTF8String:name];\\\nid value = [decoder decodeObjectForKey:key];\\\n[self setValue:value forKey:key];\\\n}\\\nfree(ivars);\\\n}\\\nreturn self;\\\n\\\n\n\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)encoder\n\n{\n    encodeRuntime(Movie)\n}\n\n- (id)initWithCoder:(NSCoder *)decoder\n{\n    initCoderRuntime(Movie)\n}\n@end\n```\n我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。\n\n#### 7.实现字典转模型的自动转换\n\n字典转模型的应用可以说是每个app必然会使用的场景,虽然实现的方式略有不同，但是原理都是一致的：遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。\n像几个出名的开源库：JSONModel,MJExtension等都是通过这种方式实现的。\n\n- 先实现最外层的属性转换\n\n```\n   // 创建对应模型对象\n    id objc = [[self alloc] init];\n\n    unsigned int count = 0;\n\n    // 1.获取成员属性数组\n    Ivar *ivarList = class_copyIvarList(self, &count);\n\n    // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值\n    for (int i = 0; i < count; i++) {\n\n        // 2.1 获取成员属性\n        Ivar ivar = ivarList[i];\n\n        // 2.2 获取成员属性名 C -> OC 字符串\n       NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];\n\n        // 2.3 _成员属性名 => 字典key\n        NSString *key = [ivarName substringFromIndex:1];\n\n        // 2.4 去字典中取出对应value给模型属性赋值\n        id value = dict[key];\n\n        // 获取成员属性类型\n        NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n        }\n```\n\n如果模型比较简单，只有NSString，NSNumber等，这样就可以搞定了。但是如果模型含有NSArray，或者NSDictionary等，那么我们还需要进行第二步转换。\n\n- 内层数组，字典的转换\n\n```\nif ([value isKindOfClass:[NSDictionary class]] && ![ivarType containsString:@\"NS\"]) { \n\n             //  是字典对象,并且属性名对应类型是自定义类型\n            // 处理类型字符串 @\\\"User\\\" -> User\n            ivarType = [ivarType stringByReplacingOccurrencesOfString:@\"@\" withString:@\"\"];\n            ivarType = [ivarType stringByReplacingOccurrencesOfString:@\"\\\"\" withString:@\"\"];\n            // 自定义对象,并且值是字典\n            // value:user字典 -> User模型\n            // 获取模型(user)类对象\n            Class modalClass = NSClassFromString(ivarType);\n\n            // 字典转模型\n            if (modalClass) {\n                // 字典转模型 user\n                value = [modalClass objectWithDict:value];\n            }\n\n        }\n        \n        if ([value isKindOfClass:[NSArray class]]) {\n            // 判断对应类有没有实现字典数组转模型数组的协议\n            if ([self respondsToSelector:@selector(arrayContainModelClass)]) {\n\n                // 转换成id类型，就能调用任何对象的方法\n                id idSelf = self;\n\n                // 获取数组中字典对应的模型\n                NSString *type =  [idSelf arrayContainModelClass][key];\n\n                // 生成模型\n                Class classModel = NSClassFromString(type);\n                NSMutableArray *arrM = [NSMutableArray array];\n                // 遍历字典数组，生成模型数组\n                for (NSDictionary *dict in value) {\n                    // 字典转模型\n                    id model =  [classModel objectWithDict:dict];\n                    [arrM addObject:model];\n                }\n\n                // 把模型数组赋值给value\n                value = arrM;\n\n            }\n        }\n```\n我自己觉得系统自带的KVC模式字典转模型就挺好的，假设movie是一个模型对象，dict 是一个需要转化的 `[movie setValuesForKeysWithDictionary:dict];` 这个是系统自带的字典转模型方法，个人感觉也还是挺好用的，不过使用这个方法的时候需要在模型里面再实现一个方法才行，\n`- (void)setValue:(id)value forUndefinedKey:(NSString *)key` 重写这个方法为了实现两个目的：1. 模型中的属性和字典中的key不一致的情况，比如字典中有个`id`,我们需要把它赋值给`uid`属性；2. 字典中属性比模型的属性还多的情况。\n如果出现以上两种情况而没有实现这个方法的话，程序就会崩溃。\n这个方法的实现：\n\n```\n- (void)setValue:(id)value forUndefinedKey:(NSString *)key\n{\n    if ([key isEqualToString:@\"id\"]) {\n        self.uid = value;\n    }\n}\n```\n### 六.几个参数概念\n\n以上的几种方法应该算是runtime在实际场景中所应用的大部分的情况了，平常的编码中差不多足够用了。\n如果从头仔细看到尾，相信你基本的用法应该会了，虽然会用是主要的目的，有几个基本的参数概念还是要了解一下的。\n\n#### 1.objc_msgSend \n \n ```\n /* Basic Messaging Primitives\n *\n * On some architectures, use objc_msgSend_stret for some struct return types.\n * On some architectures, use objc_msgSend_fpret for some float return types.\n * On some architectures, use objc_msgSend_fp2ret for some float return types.\n *\n * These functions must be cast to an appropriate function pointer type \n * before being called. \n */\n ```\n\n这是官方的声明，从这个函数的注释可以看出来了，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用`objc_msgSend_stret`来发送返回值类型为结构体的消息，使用`objc_msgSend_fpret`来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用objc_msgSend_fp2ret来发送返回值类型为浮点类型的消息。\n最关键的一点：无论何时，要调用`objc_msgSend`函数，必须要将函数强制转换成合适的函数指针类型才能调用。\n从`objc_msgSend`函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。\n其实编译器会根据情况在`objc_msgSend`, `objc_msgSend_stret`, `objc_msgSendSuper`, 或 `objc_msgSendSuper_stret`四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有`”Super”`的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有`”stret”`的函数。\n\n#### 2.SEL\n\n`objc_msgSend`函数第二个参数类型为SEL，它是`selector在Objc`中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:\n`typedef struct objc_selector *SEL`;\n其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令`@selector()`或者 Runtime 系统的`sel_registerName`函数来获得一个SEL类型的方法选择器。\n不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法)，Cocoa 中有好多长长的方法哦。\n#### 3.id\n`objc_msgSend`第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：\n`typedef struct objc_object *id`;\n那objc_object又是啥呢：\n`struct objc_object { Class isa; }`;\n`objc_object`结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。\nPS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见[官方文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html).\n#### 4.Class\n之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：\n`typedef struct objc_class *Class`;\nobjc_class里面的东西多着呢：\n\n```\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n#if  !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。\n在`objc_class`结构体中：`ivars是objc_ivar_list`指针；`methodLists`是指向`objc_method_list`指针的指针。也就是说可以动态修改 `*methodLists` 的值来添加成员方法，这也是Category实现的原理.\n\n上面讲到的所有东西都在Demo里，如果你觉得不错，还请为我的Demo star一个。\n[demo下载](https://github.com/suifengqjn/runtime)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/2.png)\n\n\n\n\n\n\n","source":"_posts/runtime详解.md","raw":"\n---\ntitle: runtime详解\ntags:\n  - iOS\n  - runtime\n  - Method Swizzling\ncategories:\n  - iOS技术\nauthor:\n  - name: 千寻墨\n    url: 'http://www.jianshu.com/users/527ecf8c8753/latest_articles'\ndate: 2016-04-16 16:59:52\n---\n\n公司项目用到一个三方开源库，里面有个bug，不能改动源码，我想来想去，只能通过runtime这个万能的手段来解决。但是runtime 并不怎么会用，怎么办，马上学习呗。说到runtime，它是Objective-c里面最核心的技术，被人们传呼的神乎其神，但是感觉有一层神秘的面纱笼罩其上，毕竟使用场景不多，相信大多数开发者都不会熟练的运用。而网络上也有无数的文章来讲解runtime，但是真的非常的乱，非常的碎片化，很少有讲解的比较全面的。\n   \n最初是在onevcat的博客上看到runtime的[runtime的博客](https://onevcat.com/2012/04/objective-c-runtime/)，说句实话，看完后我还是蒙的，这里面主要讲了一下runtime 比较核心的功能-Method Swizzling，不过看完后还是有些不知如何下手的感觉。下面是我自己对runtime的整理，从零开始，由浅入深，并且带了几个runtime实际的应用场景。看完之后，你可以再回过头来看喵神的这篇文章，应该就能看的懂了。\n\n### 一：基本概念\nRuntime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在[这里](http://opensource.apple.com//source/objc4/)下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。\n\n* RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。\n* 对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。\n* OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。\n* 只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。\n\n### 二：runtime的具体实现\n我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。\n每一个oc的方法，底层必然有一个与之对应的runtime方法。\n<!-- more -->\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/1.png)\n\n- 当我们用OC写下这样一段代码\n`[tableView cellForRowAtIndexPath:indexPath];`\n\n- 在编译时RunTime会将上述代码转化成[发送消息]\n`objc_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath);`\n\n### 三:常见方法\n\n `unsigned int count; `\n \n - 获取属性列表\n \n ```\nobjc_property_t *propertyList = class_copyPropertyList([self class], &count);\n    for (unsigned int i=0; i<count; i++) {\n        const char *propertyName = property_getName(propertyList[i]);\n        NSLog(@\"property---->%@\", [NSString stringWithUTF8String:propertyName]);\n    }\n```\n\n - 获取方法列表\n \n ```\n    Method *methodList = class_copyMethodList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Method method = methodList[i];\n        NSLog(@\"method---->%@\", NSStringFromSelector(method_getName(method)));\n    }\n```\n\n- 获取成员变量列表\n    \n  ```  \n  Ivar *ivarList = class_copyIvarList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Ivar myIvar = ivarList[i];\n        const char *ivarName = ivar_getName(myIvar);\n        NSLog(@\"Ivar---->%@\", [NSString stringWithUTF8String:ivarName]);\n    } \n  ```\n \n- 获取协议列表\n \n ```   \n __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Protocol *myProtocal = protocolList[i];\n        const char *protocolName = protocol_getName(myProtocal);\n        NSLog(@\"protocol---->%@\", [NSString stringWithUTF8String:protocolName]);\n    }\n  ``` \n  \n>现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法\n\n- 获得类方法\n\n```\nClass PersonClass = object_getClass([Person class]);\nSEL oriSEL = @selector(test1);\nMethod oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);\n```   \n\n- 获得实例方法\n  \n```\nClass PersonClass = object_getClass([xiaoming class]);\nSEL oriSEL = @selector(test2);\nMethod cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);\n```   \n- 添加方法\n\n```\nBOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n```\n\n- 替换原方法实现\n\n```\nclass_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n```\n- 交换两个方法\n\n```\nmethod_exchangeImplementations(oriMethod, cusMethod);\n```\n    \n    \n    \n### 四：常见作用\n- 动态的添加对象的成员变量和方法\n- 动态交换两个方法的实现\n- 拦截并替换方法\n- 在方法上增加额外功能\n- 实现NSCoding的自动归档和解档\n- 实现字典转模型的自动转换\n\n### 五：代码实现\n要使用runtime，要先引入头文件`#import <objc/runtime.h>`\n这些代码的实例有浅入深逐步讲解，最后附上一个我在公司项目中遇到的一个实际问题。\n\n#### 1. 动态变量控制\n   在程序中，xiaoming的age是10，后来被runtime变成了20，来看看runtime是怎么做到的。\n   \n##### 1.动态获取XiaoMing类中的所有属性[当然包括私有]  \n\n\t`Ivar *ivar = class_copyIvarList([self.xiaoming class], &count);`  \n\n##### 2.遍历属性找到对应name字段  \n\n\t`const char *varName = ivar_getName(var);`\n\n##### 3.修改对应的字段值成20 \n\t\n\t`object_setIvar(self.xiaoMing, var, @\"20\");`  \n\t\n##### 4.代码参考\n\n```\n-(void)answer{\n    \tunsigned int count = 0;\n    \tIvar *ivar = class_copyIvarList([self.xiaoMing class], &count);\n    \tfor (int i = 0; i<count; i++) {\n        \tIvar var = ivar[i];\n        \tconst char *varName = ivar_getName(var);\n        \tNSString *name = [NSString stringWithUTF8String:varName];\n        \tif ([name isEqualToString:@\"_age\"]) {\n            \tobject_setIvar(self.xiaoMing, var, @\"20\");\n            \tbreak;\n        \t}\n    \t}\n    \tNSLog(@\"XiaoMing's age is %@\",self.xiaoMing.age);\n\t}\n```\n\n#### 2.动态添加方法\n\n在程序当中，假设XiaoMing的中没有`guess`这个方法，后来被Runtime添加一个名字叫guess的方法，最终再调用guess方法做出相应。那么，Runtime是如何做到的呢？  \n  \n##### 1.动态给XiaoMing类中添加guess方法：  \n\n```\n\tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, \"v@:\");\n```\n\n这里参数地方说明一下：\n\n>(IMP)guessAnswer 意思是guessAnswer的地址指针;\n>\"v@:\" 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;\n>“v@:@@” 意思是，两个参数的没有返回值。  \n\n\n##### 2.调用guess方法响应事件：  \n\n\t[self.xiaoMing performSelector:@selector(guess)];\n\n##### 3.编写guessAnswer的实现：  \n\t\n\t\n\tvoid guessAnswer(id self,SEL _cmd){\n    \tNSLog(@\"i am from beijing\");   \n\t} \n\t\n\n这个有两个地方留意一下：\n* void的前面没有+、-号，因为只是C的代码。\n* 必须有两个指定参数(id self,SEL _cmd)  \n\n##### 4.代码参考\n\n```  \n\t-(void)answer{\n    \tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, \"v@:\");\n    \tif ([self.xiaoMing respondsToSelector:@selector(guess)]) {\n        \n        \t[self.xiaoMing performSelector:@selector(guess)];\n        \n    \t} else{\n        \tNSLog(@\"Sorry,I don't know\");\n    \t}\n\t}\n\n\tvoid guessAnswer(id self,SEL _cmd){\n   \n    \tNSLog(@\"i am from beijing\");\n    \n\t}\n```\n\n#### 3：动态交换两个方法的实现\n\n在程序当中，假设XiaoMing的中有`test1` 和 `test2`这两个方法，后来被Runtime交换方法后，每次调动`test1` 的时候就会去执行`test2`，调动`test2` 的时候就会去执行`test1`， 。那么，Runtime是如何做到的呢？\n\n##### 1. 获取这个类中的两个方法并交换\n\n```\nMethod m1 = class_getInstanceMethod([self.xiaoMing class], @selector(test1));\n    Method m2 = class_getInstanceMethod([self.xiaoMing class], @selector(test2));\n    method_exchangeImplementations(m1, m2);\n```\n交换方法之后，以后每次调用这两个方法都会交换方法的实现\n\n#### 4：拦截并替换方法\n\n在程序当中，假设XiaoMing的中有`test1`这个方法，但是由于某种原因，我们要改变这个方法的实现，但是又不能去动它的源代码(正如一些开源库出现问题的时候)，这个时候runtime就派上用场了。\n\n我们先增加一个tool类，然后写一个我们自己实现的方法-change，\n通过runtime把test1替换成change。\n\n```\nClass PersionClass = object_getClass([Person class]);\nClass toolClass = object_getClass([tool class]);\n\n    ////源方法的SEL和Method\n    \n    SEL oriSEL = @selector(test1);\n    Method oriMethod = class_getInstanceMethod(PersionClass, oriSEL);\n    \n    ////交换方法的SEL和Method\n    \n    SEL cusSEL = @selector(change);\n    Method cusMethod = class_getInstanceMethod(toolClass, cusSEL);\n    \n    ////先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况\n    \n    BOOL addSucc = class_addMethod(PersionClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n    if (addSucc) {\n          // 添加成功：将源方法的实现替换到交换方法的实现     \n        class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n               \n    }else {\n    //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即\nmethod_exchangeImplementations(oriMethod, cusMethod);  \n  }\n \n```\n\n#### 5：在方法上增加额外功能\n\n有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决：\n\n```\n@implementation UIButton (Hook)\n\n+ (void)load {\n\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n\n        Class selfClass = [self class];\n\n        SEL oriSEL = @selector(sendAction:to:forEvent:);\n        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);\n\n        SEL cusSEL = @selector(mySendAction:to:forEvent:);\n        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);\n\n        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));\n        if (addSucc) {\n            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));\n        }else {\n            method_exchangeImplementations(oriMethod, cusMethod);\n        }\n\n    });\n}\n\n- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {\n    [CountTool addClickCount];\n    [self mySendAction:action to:target forEvent:event];\n}\n\n@end\n```\n\nload方法会在类第一次加载的时候被调用,调用的时间比较靠前，适合在这个方法里做方法交换,方法交换应该被保证，在程序中只会执行一次。\n\n#### 6.实现NSCoding的自动归档和解档\n\n如果你实现过自定义模型数据持久化的过程，那么你也肯定明白，如果一个模型有许多个属性，那么我们需要对每个属性都实现一遍`encodeObject` 和 `decodeObjectForKey`方法，如果这样的模型又有很多个，这还真的是一个十分麻烦的事情。下面来看看简单的实现方式。\n假设现在有一个Movie类，有3个属性，它的`h`文件这这样的\n\n```\n#import <Foundation/Foundation.h>\n\n//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding\n@interface Movie : NSObject<NSCoding>\n\n@property (nonatomic, copy) NSString *movieId;\n@property (nonatomic, copy) NSString *movieName;\n@property (nonatomic, copy) NSString *pic_url;\n\n@end\n\n```\n\n如果是正常写法， `m`文件应该是这样的：\n\n```\n#import \"Movie.h\"\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)aCoder\n{\n    [aCoder encodeObject:_movieId forKey:@\"id\"];\n    [aCoder encodeObject:_movieName forKey:@\"name\"];\n    [aCoder encodeObject:_pic_url forKey:@\"url\"];\n    \n}\n\n- (id)initWithCoder:(NSCoder *)aDecoder\n{\n    if (self = [super init]) {\n        self.movieId = [aDecoder decodeObjectForKey:@\"id\"];\n        self.movieName = [aDecoder decodeObjectForKey:@\"name\"];\n        self.pic_url = [aDecoder decodeObjectForKey:@\"url\"];\n    }\n    return self;\n}\n@end\n```\n如果这里有100个属性，那么我们也只能把100个属性都给写一遍。\n不过你会使用runtime后，这里就有更简便的方法。\n下面看看runtime的实现方式：\n\n```\n#import \"Movie.h\"\n#import <objc/runtime.h>\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)encoder\n\n{\n    unsigned int count = 0;\n    Ivar *ivars = class_copyIvarList([Movie class], &count);\n    \n    for (int i = 0; i<count; i++) {\n        // 取出i位置对应的成员变量\n        Ivar ivar = ivars[i];\n        // 查看成员变量\n        const char *name = ivar_getName(ivar);\n        // 归档\n        NSString *key = [NSString stringWithUTF8String:name];\n        id value = [self valueForKey:key];\n        [encoder encodeObject:value forKey:key];\n    }\n    free(ivars);\n}\n\n- (id)initWithCoder:(NSCoder *)decoder\n{\n    if (self = [super init]) {\n        unsigned int count = 0;\n        Ivar *ivars = class_copyIvarList([Movie class], &count);\n        for (int i = 0; i<count; i++) {\n        // 取出i位置对应的成员变量\n        Ivar ivar = ivars[i];\n        // 查看成员变量\n        const char *name = ivar_getName(ivar);\n       // 归档\n       NSString *key = [NSString stringWithUTF8String:name];\n      id value = [decoder decodeObjectForKey:key];\n       // 设置到成员变量身上\n        [self setValue:value forKey:key];\n            \n        }\n        free(ivars);\n    } \n    return self;\n}\n@end\n```\n\n这样的方式实现，不管有多少个属性，写这几行代码就搞定了。怎么，还嫌麻烦，下面看看更加简便的方法：两句代码搞定。\n我们把`encodeWithCoder` 和 `initWithCoder`这两个方法抽成宏\n\n```\n#import \"Movie.h\"\n#import <objc/runtime.h>\n\n#define encodeRuntime(A) \\\n\\\nunsigned int count = 0;\\\nIvar *ivars = class_copyIvarList([A class], &count);\\\nfor (int i = 0; i<count; i++) {\\\nIvar ivar = ivars[i];\\\nconst char *name = ivar_getName(ivar);\\\nNSString *key = [NSString stringWithUTF8String:name];\\\nid value = [self valueForKey:key];\\\n[encoder encodeObject:value forKey:key];\\\n}\\\nfree(ivars);\\\n\\\n\n\n\n#define initCoderRuntime(A) \\\n\\\nif (self = [super init]) {\\\nunsigned int count = 0;\\\nIvar *ivars = class_copyIvarList([A class], &count);\\\nfor (int i = 0; i<count; i++) {\\\nIvar ivar = ivars[i];\\\nconst char *name = ivar_getName(ivar);\\\nNSString *key = [NSString stringWithUTF8String:name];\\\nid value = [decoder decodeObjectForKey:key];\\\n[self setValue:value forKey:key];\\\n}\\\nfree(ivars);\\\n}\\\nreturn self;\\\n\\\n\n\n@implementation Movie\n\n- (void)encodeWithCoder:(NSCoder *)encoder\n\n{\n    encodeRuntime(Movie)\n}\n\n- (id)initWithCoder:(NSCoder *)decoder\n{\n    initCoderRuntime(Movie)\n}\n@end\n```\n我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。\n\n#### 7.实现字典转模型的自动转换\n\n字典转模型的应用可以说是每个app必然会使用的场景,虽然实现的方式略有不同，但是原理都是一致的：遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。\n像几个出名的开源库：JSONModel,MJExtension等都是通过这种方式实现的。\n\n- 先实现最外层的属性转换\n\n```\n   // 创建对应模型对象\n    id objc = [[self alloc] init];\n\n    unsigned int count = 0;\n\n    // 1.获取成员属性数组\n    Ivar *ivarList = class_copyIvarList(self, &count);\n\n    // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值\n    for (int i = 0; i < count; i++) {\n\n        // 2.1 获取成员属性\n        Ivar ivar = ivarList[i];\n\n        // 2.2 获取成员属性名 C -> OC 字符串\n       NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];\n\n        // 2.3 _成员属性名 => 字典key\n        NSString *key = [ivarName substringFromIndex:1];\n\n        // 2.4 去字典中取出对应value给模型属性赋值\n        id value = dict[key];\n\n        // 获取成员属性类型\n        NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];\n        }\n```\n\n如果模型比较简单，只有NSString，NSNumber等，这样就可以搞定了。但是如果模型含有NSArray，或者NSDictionary等，那么我们还需要进行第二步转换。\n\n- 内层数组，字典的转换\n\n```\nif ([value isKindOfClass:[NSDictionary class]] && ![ivarType containsString:@\"NS\"]) { \n\n             //  是字典对象,并且属性名对应类型是自定义类型\n            // 处理类型字符串 @\\\"User\\\" -> User\n            ivarType = [ivarType stringByReplacingOccurrencesOfString:@\"@\" withString:@\"\"];\n            ivarType = [ivarType stringByReplacingOccurrencesOfString:@\"\\\"\" withString:@\"\"];\n            // 自定义对象,并且值是字典\n            // value:user字典 -> User模型\n            // 获取模型(user)类对象\n            Class modalClass = NSClassFromString(ivarType);\n\n            // 字典转模型\n            if (modalClass) {\n                // 字典转模型 user\n                value = [modalClass objectWithDict:value];\n            }\n\n        }\n        \n        if ([value isKindOfClass:[NSArray class]]) {\n            // 判断对应类有没有实现字典数组转模型数组的协议\n            if ([self respondsToSelector:@selector(arrayContainModelClass)]) {\n\n                // 转换成id类型，就能调用任何对象的方法\n                id idSelf = self;\n\n                // 获取数组中字典对应的模型\n                NSString *type =  [idSelf arrayContainModelClass][key];\n\n                // 生成模型\n                Class classModel = NSClassFromString(type);\n                NSMutableArray *arrM = [NSMutableArray array];\n                // 遍历字典数组，生成模型数组\n                for (NSDictionary *dict in value) {\n                    // 字典转模型\n                    id model =  [classModel objectWithDict:dict];\n                    [arrM addObject:model];\n                }\n\n                // 把模型数组赋值给value\n                value = arrM;\n\n            }\n        }\n```\n我自己觉得系统自带的KVC模式字典转模型就挺好的，假设movie是一个模型对象，dict 是一个需要转化的 `[movie setValuesForKeysWithDictionary:dict];` 这个是系统自带的字典转模型方法，个人感觉也还是挺好用的，不过使用这个方法的时候需要在模型里面再实现一个方法才行，\n`- (void)setValue:(id)value forUndefinedKey:(NSString *)key` 重写这个方法为了实现两个目的：1. 模型中的属性和字典中的key不一致的情况，比如字典中有个`id`,我们需要把它赋值给`uid`属性；2. 字典中属性比模型的属性还多的情况。\n如果出现以上两种情况而没有实现这个方法的话，程序就会崩溃。\n这个方法的实现：\n\n```\n- (void)setValue:(id)value forUndefinedKey:(NSString *)key\n{\n    if ([key isEqualToString:@\"id\"]) {\n        self.uid = value;\n    }\n}\n```\n### 六.几个参数概念\n\n以上的几种方法应该算是runtime在实际场景中所应用的大部分的情况了，平常的编码中差不多足够用了。\n如果从头仔细看到尾，相信你基本的用法应该会了，虽然会用是主要的目的，有几个基本的参数概念还是要了解一下的。\n\n#### 1.objc_msgSend \n \n ```\n /* Basic Messaging Primitives\n *\n * On some architectures, use objc_msgSend_stret for some struct return types.\n * On some architectures, use objc_msgSend_fpret for some float return types.\n * On some architectures, use objc_msgSend_fp2ret for some float return types.\n *\n * These functions must be cast to an appropriate function pointer type \n * before being called. \n */\n ```\n\n这是官方的声明，从这个函数的注释可以看出来了，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用`objc_msgSend_stret`来发送返回值类型为结构体的消息，使用`objc_msgSend_fpret`来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用objc_msgSend_fp2ret来发送返回值类型为浮点类型的消息。\n最关键的一点：无论何时，要调用`objc_msgSend`函数，必须要将函数强制转换成合适的函数指针类型才能调用。\n从`objc_msgSend`函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。\n其实编译器会根据情况在`objc_msgSend`, `objc_msgSend_stret`, `objc_msgSendSuper`, 或 `objc_msgSendSuper_stret`四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有`”Super”`的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有`”stret”`的函数。\n\n#### 2.SEL\n\n`objc_msgSend`函数第二个参数类型为SEL，它是`selector在Objc`中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:\n`typedef struct objc_selector *SEL`;\n其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令`@selector()`或者 Runtime 系统的`sel_registerName`函数来获得一个SEL类型的方法选择器。\n不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法)，Cocoa 中有好多长长的方法哦。\n#### 3.id\n`objc_msgSend`第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：\n`typedef struct objc_object *id`;\n那objc_object又是啥呢：\n`struct objc_object { Class isa; }`;\n`objc_object`结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。\nPS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见[官方文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html).\n#### 4.Class\n之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：\n`typedef struct objc_class *Class`;\nobjc_class里面的东西多着呢：\n\n```\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n#if  !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。\n在`objc_class`结构体中：`ivars是objc_ivar_list`指针；`methodLists`是指向`objc_method_list`指针的指针。也就是说可以动态修改 `*methodLists` 的值来添加成员方法，这也是Category实现的原理.\n\n上面讲到的所有东西都在Demo里，如果你觉得不错，还请为我的Demo star一个。\n[demo下载](https://github.com/suifengqjn/runtime)\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/2.png)\n\n\n\n\n\n\n","slug":"runtime详解","published":1,"updated":"2016-11-17T13:48:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmol002eco60m53puz2k","content":"<p>公司项目用到一个三方开源库，里面有个bug，不能改动源码，我想来想去，只能通过runtime这个万能的手段来解决。但是runtime 并不怎么会用，怎么办，马上学习呗。说到runtime，它是Objective-c里面最核心的技术，被人们传呼的神乎其神，但是感觉有一层神秘的面纱笼罩其上，毕竟使用场景不多，相信大多数开发者都不会熟练的运用。而网络上也有无数的文章来讲解runtime，但是真的非常的乱，非常的碎片化，很少有讲解的比较全面的。</p>\n<p>最初是在onevcat的博客上看到runtime的<a href=\"https://onevcat.com/2012/04/objective-c-runtime/\" target=\"_blank\" rel=\"external\">runtime的博客</a>，说句实话，看完后我还是蒙的，这里面主要讲了一下runtime 比较核心的功能-Method Swizzling，不过看完后还是有些不知如何下手的感觉。下面是我自己对runtime的整理，从零开始，由浅入深，并且带了几个runtime实际的应用场景。看完之后，你可以再回过头来看喵神的这篇文章，应该就能看的懂了。</p>\n<h3 id=\"一：基本概念\"><a href=\"#一：基本概念\" class=\"headerlink\" title=\"一：基本概念\"></a>一：基本概念</h3><p>Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href=\"http://opensource.apple.com//source/objc4/\" target=\"_blank\" rel=\"external\">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。</p>\n<ul>\n<li>RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。</li>\n<li>对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。</li>\n<li>OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。</li>\n<li>只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。</li>\n</ul>\n<h3 id=\"二：runtime的具体实现\"><a href=\"#二：runtime的具体实现\" class=\"headerlink\" title=\"二：runtime的具体实现\"></a>二：runtime的具体实现</h3><p>我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。<br>每一个oc的方法，底层必然有一个与之对应的runtime方法。<br><a id=\"more\"></a><br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/1.png\" alt=\"image\"></p>\n<ul>\n<li><p>当我们用OC写下这样一段代码<br><code>[tableView cellForRowAtIndexPath:indexPath];</code></p>\n</li>\n<li><p>在编译时RunTime会将上述代码转化成[发送消息]<br><code>objc_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath);</code></p>\n</li>\n</ul>\n<h3 id=\"三-常见方法\"><a href=\"#三-常见方法\" class=\"headerlink\" title=\"三:常见方法\"></a>三:常见方法</h3><p> <code>unsigned int count;</code></p>\n<ul>\n<li><p>获取属性列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</div><div class=\"line\">    for (unsigned int i=0; i&lt;count; i++) &#123;</div><div class=\"line\">        const char *propertyName = property_getName(propertyList[i]);</div><div class=\"line\">        NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取方法列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method *methodList = class_copyMethodList([self class], &amp;count);</div><div class=\"line\">for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">    Method method = methodList[i];</div><div class=\"line\">    NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>获取成员变量列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Ivar *ivarList = class_copyIvarList([self class], &amp;count);</div><div class=\"line\">  for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">      Ivar myIvar = ivarList[i];</div><div class=\"line\">      const char *ivarName = ivar_getName(myIvar);</div><div class=\"line\">      NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>获取协议列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</div><div class=\"line\">    for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">        Protocol *myProtocal = protocolList[i];</div><div class=\"line\">        const char *protocolName = protocol_getName(myProtocal);</div><div class=\"line\">        NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</div><div class=\"line\">    &#125;</div><div class=\"line\">  ``` </div><div class=\"line\">  </div><div class=\"line\">&gt;现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法</div><div class=\"line\"></div><div class=\"line\">- 获得类方法</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Class PersonClass = object_getClass([Person class]);<br>SEL oriSEL = @selector(test1);<br>Method oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 获得实例方法</div></pre></td></tr></table></figure></p>\n<p>Class PersonClass = object_getClass([xiaoming class]);<br>SEL oriSEL = @selector(test2);<br>Method cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 添加方法</div></pre></td></tr></table></figure></p>\n<p>BOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 替换原方法实现</div></pre></td></tr></table></figure></p>\n<p>class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 交换两个方法</div></pre></td></tr></table></figure></p>\n<p>method_exchangeImplementations(oriMethod, cusMethod);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">### 四：常见作用</div><div class=\"line\">- 动态的添加对象的成员变量和方法</div><div class=\"line\">- 动态交换两个方法的实现</div><div class=\"line\">- 拦截并替换方法</div><div class=\"line\">- 在方法上增加额外功能</div><div class=\"line\">- 实现NSCoding的自动归档和解档</div><div class=\"line\">- 实现字典转模型的自动转换</div><div class=\"line\"></div><div class=\"line\">### 五：代码实现</div><div class=\"line\">要使用runtime，要先引入头文件`#import &lt;objc/runtime.h&gt;`</div><div class=\"line\">这些代码的实例有浅入深逐步讲解，最后附上一个我在公司项目中遇到的一个实际问题。</div><div class=\"line\"></div><div class=\"line\">#### 1. 动态变量控制</div><div class=\"line\">   在程序中，xiaoming的age是10，后来被runtime变成了20，来看看runtime是怎么做到的。</div><div class=\"line\">   </div><div class=\"line\">##### 1.动态获取XiaoMing类中的所有属性[当然包括私有]  </div><div class=\"line\"></div><div class=\"line\">\t`Ivar *ivar = class_copyIvarList([self.xiaoming class], &amp;count);`  </div><div class=\"line\"></div><div class=\"line\">##### 2.遍历属性找到对应name字段  </div><div class=\"line\"></div><div class=\"line\">\t`const char *varName = ivar_getName(var);`</div><div class=\"line\"></div><div class=\"line\">##### 3.修改对应的字段值成20 </div><div class=\"line\">\t</div><div class=\"line\">\t`object_setIvar(self.xiaoMing, var, @&quot;20&quot;);`  </div><div class=\"line\">\t</div><div class=\"line\">##### 4.代码参考</div></pre></td></tr></table></figure></p>\n<p>-(void)answer{<br>        unsigned int count = 0;<br>        Ivar <em>ivar = class_copyIvarList([self.xiaoMing class], &amp;count);<br>        for (int i = 0; i&lt;count; i++) {<br>            Ivar var = ivar[i];<br>            const char </em>varName = ivar_getName(var);<br>            NSString *name = [NSString stringWithUTF8String:varName];<br>            if ([name isEqualToString:@”_age”]) {<br>                object_setIvar(self.xiaoMing, var, @”20”);<br>                break;<br>            }<br>        }<br>        NSLog(@”XiaoMing’s age is %@”,self.xiaoMing.age);<br>    }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 2.动态添加方法</div><div class=\"line\"></div><div class=\"line\">在程序当中，假设XiaoMing的中没有`guess`这个方法，后来被Runtime添加一个名字叫guess的方法，最终再调用guess方法做出相应。那么，Runtime是如何做到的呢？  </div><div class=\"line\">  </div><div class=\"line\">##### 1.动态给XiaoMing类中添加guess方法：</div></pre></td></tr></table></figure></p>\n<pre><code>class_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这里参数地方说明一下：</div><div class=\"line\"></div><div class=\"line\">&gt;(IMP)guessAnswer 意思是guessAnswer的地址指针;</div><div class=\"line\">&gt;&quot;v@:&quot; 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;</div><div class=\"line\">&gt;“v@:@@” 意思是，两个参数的没有返回值。  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">##### 2.调用guess方法响应事件：  </div><div class=\"line\"></div><div class=\"line\">\t[self.xiaoMing performSelector:@selector(guess)];</div><div class=\"line\"></div><div class=\"line\">##### 3.编写guessAnswer的实现：  </div><div class=\"line\">\t</div><div class=\"line\">\t</div><div class=\"line\">\tvoid guessAnswer(id self,SEL _cmd)&#123;</div><div class=\"line\">    \tNSLog(@&quot;i am from beijing&quot;);   </div><div class=\"line\">\t&#125; </div><div class=\"line\">\t</div><div class=\"line\"></div><div class=\"line\">这个有两个地方留意一下：</div><div class=\"line\">* void的前面没有+、-号，因为只是C的代码。</div><div class=\"line\">* 必须有两个指定参数(id self,SEL _cmd)  </div><div class=\"line\"></div><div class=\"line\">##### 4.代码参考</div><div class=\"line\"></div><div class=\"line\">```  </div><div class=\"line\">\t-(void)answer&#123;</div><div class=\"line\">    \tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;);</div><div class=\"line\">    \tif ([self.xiaoMing respondsToSelector:@selector(guess)]) &#123;</div><div class=\"line\">        </div><div class=\"line\">        \t[self.xiaoMing performSelector:@selector(guess)];</div><div class=\"line\">        </div><div class=\"line\">    \t&#125; else&#123;</div><div class=\"line\">        \tNSLog(@&quot;Sorry,I don&apos;t know&quot;);</div><div class=\"line\">    \t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tvoid guessAnswer(id self,SEL _cmd)&#123;</div><div class=\"line\">   </div><div class=\"line\">    \tNSLog(@&quot;i am from beijing&quot;);</div><div class=\"line\">    </div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3：动态交换两个方法的实现\"><a href=\"#3：动态交换两个方法的实现\" class=\"headerlink\" title=\"3：动态交换两个方法的实现\"></a>3：动态交换两个方法的实现</h4><p>在程序当中，假设XiaoMing的中有<code>test1</code> 和 <code>test2</code>这两个方法，后来被Runtime交换方法后，每次调动<code>test1</code> 的时候就会去执行<code>test2</code>，调动<code>test2</code> 的时候就会去执行<code>test1</code>， 。那么，Runtime是如何做到的呢？</p>\n<h5 id=\"1-获取这个类中的两个方法并交换\"><a href=\"#1-获取这个类中的两个方法并交换\" class=\"headerlink\" title=\"1. 获取这个类中的两个方法并交换\"></a>1. 获取这个类中的两个方法并交换</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method m1 = class_getInstanceMethod([self.xiaoMing class], @selector(test1));</div><div class=\"line\">    Method m2 = class_getInstanceMethod([self.xiaoMing class], @selector(test2));</div><div class=\"line\">    method_exchangeImplementations(m1, m2);</div></pre></td></tr></table></figure>\n<p>交换方法之后，以后每次调用这两个方法都会交换方法的实现</p>\n<h4 id=\"4：拦截并替换方法\"><a href=\"#4：拦截并替换方法\" class=\"headerlink\" title=\"4：拦截并替换方法\"></a>4：拦截并替换方法</h4><p>在程序当中，假设XiaoMing的中有<code>test1</code>这个方法，但是由于某种原因，我们要改变这个方法的实现，但是又不能去动它的源代码(正如一些开源库出现问题的时候)，这个时候runtime就派上用场了。</p>\n<p>我们先增加一个tool类，然后写一个我们自己实现的方法-change，<br>通过runtime把test1替换成change。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class PersionClass = object_getClass([Person class]);</div><div class=\"line\">Class toolClass = object_getClass([tool class]);</div><div class=\"line\"></div><div class=\"line\">    ////源方法的SEL和Method</div><div class=\"line\">    </div><div class=\"line\">    SEL oriSEL = @selector(test1);</div><div class=\"line\">    Method oriMethod = class_getInstanceMethod(PersionClass, oriSEL);</div><div class=\"line\">    </div><div class=\"line\">    ////交换方法的SEL和Method</div><div class=\"line\">    </div><div class=\"line\">    SEL cusSEL = @selector(change);</div><div class=\"line\">    Method cusMethod = class_getInstanceMethod(toolClass, cusSEL);</div><div class=\"line\">    </div><div class=\"line\">    ////先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况</div><div class=\"line\">    </div><div class=\"line\">    BOOL addSucc = class_addMethod(PersionClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class=\"line\">    if (addSucc) &#123;</div><div class=\"line\">          // 添加成功：将源方法的实现替换到交换方法的实现     </div><div class=\"line\">        class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class=\"line\">               </div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">    //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即</div><div class=\"line\">method_exchangeImplementations(oriMethod, cusMethod);  </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5：在方法上增加额外功能\"><a href=\"#5：在方法上增加额外功能\" class=\"headerlink\" title=\"5：在方法上增加额外功能\"></a>5：在方法上增加额外功能</h4><p>有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation UIButton (Hook)</div><div class=\"line\"></div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\"></div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\"></div><div class=\"line\">        Class selfClass = [self class];</div><div class=\"line\"></div><div class=\"line\">        SEL oriSEL = @selector(sendAction:to:forEvent:);</div><div class=\"line\">        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</div><div class=\"line\"></div><div class=\"line\">        SEL cusSEL = @selector(mySendAction:to:forEvent:);</div><div class=\"line\">        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</div><div class=\"line\"></div><div class=\"line\">        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class=\"line\">        if (addSucc) &#123;</div><div class=\"line\">            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class=\"line\">        &#125;else &#123;</div><div class=\"line\">            method_exchangeImplementations(oriMethod, cusMethod);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</div><div class=\"line\">    [CountTool addClickCount];</div><div class=\"line\">    [self mySendAction:action to:target forEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>load方法会在类第一次加载的时候被调用,调用的时间比较靠前，适合在这个方法里做方法交换,方法交换应该被保证，在程序中只会执行一次。</p>\n<h4 id=\"6-实现NSCoding的自动归档和解档\"><a href=\"#6-实现NSCoding的自动归档和解档\" class=\"headerlink\" title=\"6.实现NSCoding的自动归档和解档\"></a>6.实现NSCoding的自动归档和解档</h4><p>如果你实现过自定义模型数据持久化的过程，那么你也肯定明白，如果一个模型有许多个属性，那么我们需要对每个属性都实现一遍<code>encodeObject</code> 和 <code>decodeObjectForKey</code>方法，如果这样的模型又有很多个，这还真的是一个十分麻烦的事情。下面来看看简单的实现方式。<br>假设现在有一个Movie类，有3个属性，它的<code>h</code>文件这这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding</div><div class=\"line\">@interface Movie : NSObject&lt;NSCoding&gt;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, copy) NSString *movieId;</div><div class=\"line\">@property (nonatomic, copy) NSString *movieName;</div><div class=\"line\">@property (nonatomic, copy) NSString *pic_url;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>如果是正常写法， <code>m</code>文件应该是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)aCoder</div><div class=\"line\">&#123;</div><div class=\"line\">    [aCoder encodeObject:_movieId forKey:@&quot;id&quot;];</div><div class=\"line\">    [aCoder encodeObject:_movieName forKey:@&quot;name&quot;];</div><div class=\"line\">    [aCoder encodeObject:_pic_url forKey:@&quot;url&quot;];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)aDecoder</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init]) &#123;</div><div class=\"line\">        self.movieId = [aDecoder decodeObjectForKey:@&quot;id&quot;];</div><div class=\"line\">        self.movieName = [aDecoder decodeObjectForKey:@&quot;name&quot;];</div><div class=\"line\">        self.pic_url = [aDecoder decodeObjectForKey:@&quot;url&quot;];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>如果这里有100个属性，那么我们也只能把100个属性都给写一遍。<br>不过你会使用runtime后，这里就有更简便的方法。<br>下面看看runtime的实现方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)encoder</div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    unsigned int count = 0;</div><div class=\"line\">    Ivar *ivars = class_copyIvarList([Movie class], &amp;count);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i&lt;count; i++) &#123;</div><div class=\"line\">        // 取出i位置对应的成员变量</div><div class=\"line\">        Ivar ivar = ivars[i];</div><div class=\"line\">        // 查看成员变量</div><div class=\"line\">        const char *name = ivar_getName(ivar);</div><div class=\"line\">        // 归档</div><div class=\"line\">        NSString *key = [NSString stringWithUTF8String:name];</div><div class=\"line\">        id value = [self valueForKey:key];</div><div class=\"line\">        [encoder encodeObject:value forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(ivars);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)decoder</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init]) &#123;</div><div class=\"line\">        unsigned int count = 0;</div><div class=\"line\">        Ivar *ivars = class_copyIvarList([Movie class], &amp;count);</div><div class=\"line\">        for (int i = 0; i&lt;count; i++) &#123;</div><div class=\"line\">        // 取出i位置对应的成员变量</div><div class=\"line\">        Ivar ivar = ivars[i];</div><div class=\"line\">        // 查看成员变量</div><div class=\"line\">        const char *name = ivar_getName(ivar);</div><div class=\"line\">       // 归档</div><div class=\"line\">       NSString *key = [NSString stringWithUTF8String:name];</div><div class=\"line\">      id value = [decoder decodeObjectForKey:key];</div><div class=\"line\">       // 设置到成员变量身上</div><div class=\"line\">        [self setValue:value forKey:key];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        free(ivars);</div><div class=\"line\">    &#125; </div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这样的方式实现，不管有多少个属性，写这几行代码就搞定了。怎么，还嫌麻烦，下面看看更加简便的方法：两句代码搞定。<br>我们把<code>encodeWithCoder</code> 和 <code>initWithCoder</code>这两个方法抽成宏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">#define encodeRuntime(A) \\</div><div class=\"line\">\\</div><div class=\"line\">unsigned int count = 0;\\</div><div class=\"line\">Ivar *ivars = class_copyIvarList([A class], &amp;count);\\</div><div class=\"line\">for (int i = 0; i&lt;count; i++) &#123;\\</div><div class=\"line\">Ivar ivar = ivars[i];\\</div><div class=\"line\">const char *name = ivar_getName(ivar);\\</div><div class=\"line\">NSString *key = [NSString stringWithUTF8String:name];\\</div><div class=\"line\">id value = [self valueForKey:key];\\</div><div class=\"line\">[encoder encodeObject:value forKey:key];\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">free(ivars);\\</div><div class=\"line\">\\</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#define initCoderRuntime(A) \\</div><div class=\"line\">\\</div><div class=\"line\">if (self = [super init]) &#123;\\</div><div class=\"line\">unsigned int count = 0;\\</div><div class=\"line\">Ivar *ivars = class_copyIvarList([A class], &amp;count);\\</div><div class=\"line\">for (int i = 0; i&lt;count; i++) &#123;\\</div><div class=\"line\">Ivar ivar = ivars[i];\\</div><div class=\"line\">const char *name = ivar_getName(ivar);\\</div><div class=\"line\">NSString *key = [NSString stringWithUTF8String:name];\\</div><div class=\"line\">id value = [decoder decodeObjectForKey:key];\\</div><div class=\"line\">[self setValue:value forKey:key];\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">free(ivars);\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">return self;\\</div><div class=\"line\">\\</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)encoder</div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    encodeRuntime(Movie)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)decoder</div><div class=\"line\">&#123;</div><div class=\"line\">    initCoderRuntime(Movie)</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。</p>\n<h4 id=\"7-实现字典转模型的自动转换\"><a href=\"#7-实现字典转模型的自动转换\" class=\"headerlink\" title=\"7.实现字典转模型的自动转换\"></a>7.实现字典转模型的自动转换</h4><p>字典转模型的应用可以说是每个app必然会使用的场景,虽然实现的方式略有不同，但是原理都是一致的：遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。<br>像几个出名的开源库：JSONModel,MJExtension等都是通过这种方式实现的。</p>\n<ul>\n<li>先实现最外层的属性转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建对应模型对象</div><div class=\"line\"> id objc = [[self alloc] init];</div><div class=\"line\"></div><div class=\"line\"> unsigned int count = 0;</div><div class=\"line\"></div><div class=\"line\"> // 1.获取成员属性数组</div><div class=\"line\"> Ivar *ivarList = class_copyIvarList(self, &amp;count);</div><div class=\"line\"></div><div class=\"line\"> // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值</div><div class=\"line\"> for (int i = 0; i &lt; count; i++) &#123;</div><div class=\"line\"></div><div class=\"line\">     // 2.1 获取成员属性</div><div class=\"line\">     Ivar ivar = ivarList[i];</div><div class=\"line\"></div><div class=\"line\">     // 2.2 获取成员属性名 C -&gt; OC 字符串</div><div class=\"line\">    NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class=\"line\"></div><div class=\"line\">     // 2.3 _成员属性名 =&gt; 字典key</div><div class=\"line\">     NSString *key = [ivarName substringFromIndex:1];</div><div class=\"line\"></div><div class=\"line\">     // 2.4 去字典中取出对应value给模型属性赋值</div><div class=\"line\">     id value = dict[key];</div><div class=\"line\"></div><div class=\"line\">     // 获取成员属性类型</div><div class=\"line\">     NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure>\n<p>如果模型比较简单，只有NSString，NSNumber等，这样就可以搞定了。但是如果模型含有NSArray，或者NSDictionary等，那么我们还需要进行第二步转换。</p>\n<ul>\n<li>内层数组，字典的转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType containsString:@&quot;NS&quot;]) &#123; </div><div class=\"line\"></div><div class=\"line\">             //  是字典对象,并且属性名对应类型是自定义类型</div><div class=\"line\">            // 处理类型字符串 @\\&quot;User\\&quot; -&gt; User</div><div class=\"line\">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;];</div><div class=\"line\">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\\&quot;&quot; withString:@&quot;&quot;];</div><div class=\"line\">            // 自定义对象,并且值是字典</div><div class=\"line\">            // value:user字典 -&gt; User模型</div><div class=\"line\">            // 获取模型(user)类对象</div><div class=\"line\">            Class modalClass = NSClassFromString(ivarType);</div><div class=\"line\"></div><div class=\"line\">            // 字典转模型</div><div class=\"line\">            if (modalClass) &#123;</div><div class=\"line\">                // 字典转模型 user</div><div class=\"line\">                value = [modalClass objectWithDict:value];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if ([value isKindOfClass:[NSArray class]]) &#123;</div><div class=\"line\">            // 判断对应类有没有实现字典数组转模型数组的协议</div><div class=\"line\">            if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;</div><div class=\"line\"></div><div class=\"line\">                // 转换成id类型，就能调用任何对象的方法</div><div class=\"line\">                id idSelf = self;</div><div class=\"line\"></div><div class=\"line\">                // 获取数组中字典对应的模型</div><div class=\"line\">                NSString *type =  [idSelf arrayContainModelClass][key];</div><div class=\"line\"></div><div class=\"line\">                // 生成模型</div><div class=\"line\">                Class classModel = NSClassFromString(type);</div><div class=\"line\">                NSMutableArray *arrM = [NSMutableArray array];</div><div class=\"line\">                // 遍历字典数组，生成模型数组</div><div class=\"line\">                for (NSDictionary *dict in value) &#123;</div><div class=\"line\">                    // 字典转模型</div><div class=\"line\">                    id model =  [classModel objectWithDict:dict];</div><div class=\"line\">                    [arrM addObject:model];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // 把模型数组赋值给value</div><div class=\"line\">                value = arrM;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>我自己觉得系统自带的KVC模式字典转模型就挺好的，假设movie是一个模型对象，dict 是一个需要转化的 <code>[movie setValuesForKeysWithDictionary:dict];</code> 这个是系统自带的字典转模型方法，个人感觉也还是挺好用的，不过使用这个方法的时候需要在模型里面再实现一个方法才行，<br><code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code> 重写这个方法为了实现两个目的：1. 模型中的属性和字典中的key不一致的情况，比如字典中有个<code>id</code>,我们需要把它赋值给<code>uid</code>属性；2. 字典中属性比模型的属性还多的情况。<br>如果出现以上两种情况而没有实现这个方法的话，程序就会崩溃。<br>这个方法的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setValue:(id)value forUndefinedKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    if ([key isEqualToString:@&quot;id&quot;]) &#123;</div><div class=\"line\">        self.uid = value;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"六-几个参数概念\"><a href=\"#六-几个参数概念\" class=\"headerlink\" title=\"六.几个参数概念\"></a>六.几个参数概念</h3><p>以上的几种方法应该算是runtime在实际场景中所应用的大部分的情况了，平常的编码中差不多足够用了。<br>如果从头仔细看到尾，相信你基本的用法应该会了，虽然会用是主要的目的，有几个基本的参数概念还是要了解一下的。</p>\n<h4 id=\"1-objc-msgSend\"><a href=\"#1-objc-msgSend\" class=\"headerlink\" title=\"1.objc_msgSend\"></a>1.objc_msgSend</h4> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* Basic Messaging Primitives</div><div class=\"line\">*</div><div class=\"line\">* On some architectures, use objc_msgSend_stret for some struct return types.</div><div class=\"line\">* On some architectures, use objc_msgSend_fpret for some float return types.</div><div class=\"line\">* On some architectures, use objc_msgSend_fp2ret for some float return types.</div><div class=\"line\">*</div><div class=\"line\">* These functions must be cast to an appropriate function pointer type </div><div class=\"line\">* before being called. </div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<p>这是官方的声明，从这个函数的注释可以看出来了，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用<code>objc_msgSend_stret</code>来发送返回值类型为结构体的消息，使用<code>objc_msgSend_fpret</code>来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用objc_msgSend_fp2ret来发送返回值类型为浮点类型的消息。<br>最关键的一点：无论何时，要调用<code>objc_msgSend</code>函数，必须要将函数强制转换成合适的函数指针类型才能调用。<br>从<code>objc_msgSend</code>函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。<br>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>”Super”</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>”stret”</code>的函数。</p>\n<h4 id=\"2-SEL\"><a href=\"#2-SEL\" class=\"headerlink\" title=\"2.SEL\"></a>2.SEL</h4><p><code>objc_msgSend</code>函数第二个参数类型为SEL，它是<code>selector在Objc</code>中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:<br><code>typedef struct objc_selector *SEL</code>;<br>其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令<code>@selector()</code>或者 Runtime 系统的<code>sel_registerName</code>函数来获得一个SEL类型的方法选择器。<br>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法)，Cocoa 中有好多长长的方法哦。</p>\n<h4 id=\"3-id\"><a href=\"#3-id\" class=\"headerlink\" title=\"3.id\"></a>3.id</h4><p><code>objc_msgSend</code>第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：<br><code>typedef struct objc_object *id</code>;<br>那objc_object又是啥呢：<br><code>struct objc_object { Class isa; }</code>;<br><code>objc_object</code>结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。<br>PS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html\" target=\"_blank\" rel=\"external\">官方文档</a>.</p>\n<h4 id=\"4-Class\"><a href=\"#4-Class\" class=\"headerlink\" title=\"4.Class\"></a>4.Class</h4><p>之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：<br><code>typedef struct objc_class *Class</code>;<br>objc_class里面的东西多着呢：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">#if  !__OBJC2__</div><div class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class=\"line\">    const char *name                                         OBJC2_UNAVAILABLE;</div><div class=\"line\">    long version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    long info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>\n<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。<br>在<code>objc_class</code>结构体中：<code>ivars是objc_ivar_list</code>指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。也就是说可以动态修改 <code>*methodLists</code> 的值来添加成员方法，这也是Category实现的原理.</p>\n<p>上面讲到的所有东西都在Demo里，如果你觉得不错，还请为我的Demo star一个。<br><a href=\"https://github.com/suifengqjn/runtime\" target=\"_blank\" rel=\"external\">demo下载</a></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/2.png\" alt=\"image\"></p>\n","excerpt":"<p>公司项目用到一个三方开源库，里面有个bug，不能改动源码，我想来想去，只能通过runtime这个万能的手段来解决。但是runtime 并不怎么会用，怎么办，马上学习呗。说到runtime，它是Objective-c里面最核心的技术，被人们传呼的神乎其神，但是感觉有一层神秘的面纱笼罩其上，毕竟使用场景不多，相信大多数开发者都不会熟练的运用。而网络上也有无数的文章来讲解runtime，但是真的非常的乱，非常的碎片化，很少有讲解的比较全面的。</p>\n<p>最初是在onevcat的博客上看到runtime的<a href=\"https://onevcat.com/2012/04/objective-c-runtime/\">runtime的博客</a>，说句实话，看完后我还是蒙的，这里面主要讲了一下runtime 比较核心的功能-Method Swizzling，不过看完后还是有些不知如何下手的感觉。下面是我自己对runtime的整理，从零开始，由浅入深，并且带了几个runtime实际的应用场景。看完之后，你可以再回过头来看喵神的这篇文章，应该就能看的懂了。</p>\n<h3 id=\"一：基本概念\"><a href=\"#一：基本概念\" class=\"headerlink\" title=\"一：基本概念\"></a>一：基本概念</h3><p>Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href=\"http://opensource.apple.com//source/objc4/\">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。Objective-C 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的NSObject类定义的方法，通过对 runtime 函数的直接调用。大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。</p>\n<ul>\n<li>RunTime简称运行时,就是系统在运行的时候的一些机制，其中最主要的是消息机制。</li>\n<li>对于C语言，函数的调用在编译的时候会决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。</li>\n<li>OC的函数调用成为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（事实证明，在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要申明过就不会报错。而C语言在编译阶段就会报错）。</li>\n<li>只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。</li>\n</ul>\n<h3 id=\"二：runtime的具体实现\"><a href=\"#二：runtime的具体实现\" class=\"headerlink\" title=\"二：runtime的具体实现\"></a>二：runtime的具体实现</h3><p>我们写的oc代码，它在运行的时候也是转换成了runtime方式运行的，更好的理解runtime，也能帮我们更深的掌握oc语言。<br>每一个oc的方法，底层必然有一个与之对应的runtime方法。<br>","more":"<br><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/1.png\" alt=\"image\"></p>\n<ul>\n<li><p>当我们用OC写下这样一段代码<br><code>[tableView cellForRowAtIndexPath:indexPath];</code></p>\n</li>\n<li><p>在编译时RunTime会将上述代码转化成[发送消息]<br><code>objc_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath);</code></p>\n</li>\n</ul>\n<h3 id=\"三-常见方法\"><a href=\"#三-常见方法\" class=\"headerlink\" title=\"三:常见方法\"></a>三:常见方法</h3><p> <code>unsigned int count;</code></p>\n<ul>\n<li><p>获取属性列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</div><div class=\"line\">    for (unsigned int i=0; i&lt;count; i++) &#123;</div><div class=\"line\">        const char *propertyName = property_getName(propertyList[i]);</div><div class=\"line\">        NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>获取方法列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method *methodList = class_copyMethodList([self class], &amp;count);</div><div class=\"line\">for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">    Method method = methodList[i];</div><div class=\"line\">    NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>获取成员变量列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Ivar *ivarList = class_copyIvarList([self class], &amp;count);</div><div class=\"line\">  for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">      Ivar myIvar = ivarList[i];</div><div class=\"line\">      const char *ivarName = ivar_getName(myIvar);</div><div class=\"line\">      NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>获取协议列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</div><div class=\"line\">    for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">        Protocol *myProtocal = protocolList[i];</div><div class=\"line\">        const char *protocolName = protocol_getName(myProtocal);</div><div class=\"line\">        NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</div><div class=\"line\">    &#125;</div><div class=\"line\">  ``` </div><div class=\"line\">  </div><div class=\"line\">&gt;现在有一个Person类，和person创建的xiaoming对象,有test1和test2两个方法</div><div class=\"line\"></div><div class=\"line\">- 获得类方法</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Class PersonClass = object_getClass([Person class]);<br>SEL oriSEL = @selector(test1);<br>Method oriMethod = class_getInstanceMethod(xiaomingClass, oriSEL);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 获得实例方法</div></pre></td></tr></table></figure></p>\n<p>Class PersonClass = object_getClass([xiaoming class]);<br>SEL oriSEL = @selector(test2);<br>Method cusMethod = class_getInstanceMethod(xiaomingClass, oriSEL);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 添加方法</div></pre></td></tr></table></figure></p>\n<p>BOOL addSucc = class_addMethod(xiaomingClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">- 替换原方法实现</div></pre></td></tr></table></figure></p>\n<p>class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- 交换两个方法</div></pre></td></tr></table></figure></p>\n<p>method_exchangeImplementations(oriMethod, cusMethod);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">    </div><div class=\"line\">### 四：常见作用</div><div class=\"line\">- 动态的添加对象的成员变量和方法</div><div class=\"line\">- 动态交换两个方法的实现</div><div class=\"line\">- 拦截并替换方法</div><div class=\"line\">- 在方法上增加额外功能</div><div class=\"line\">- 实现NSCoding的自动归档和解档</div><div class=\"line\">- 实现字典转模型的自动转换</div><div class=\"line\"></div><div class=\"line\">### 五：代码实现</div><div class=\"line\">要使用runtime，要先引入头文件`#import &lt;objc/runtime.h&gt;`</div><div class=\"line\">这些代码的实例有浅入深逐步讲解，最后附上一个我在公司项目中遇到的一个实际问题。</div><div class=\"line\"></div><div class=\"line\">#### 1. 动态变量控制</div><div class=\"line\">   在程序中，xiaoming的age是10，后来被runtime变成了20，来看看runtime是怎么做到的。</div><div class=\"line\">   </div><div class=\"line\">##### 1.动态获取XiaoMing类中的所有属性[当然包括私有]  </div><div class=\"line\"></div><div class=\"line\">\t`Ivar *ivar = class_copyIvarList([self.xiaoming class], &amp;count);`  </div><div class=\"line\"></div><div class=\"line\">##### 2.遍历属性找到对应name字段  </div><div class=\"line\"></div><div class=\"line\">\t`const char *varName = ivar_getName(var);`</div><div class=\"line\"></div><div class=\"line\">##### 3.修改对应的字段值成20 </div><div class=\"line\">\t</div><div class=\"line\">\t`object_setIvar(self.xiaoMing, var, @&quot;20&quot;);`  </div><div class=\"line\">\t</div><div class=\"line\">##### 4.代码参考</div></pre></td></tr></table></figure></p>\n<p>-(void)answer{<br>        unsigned int count = 0;<br>        Ivar <em>ivar = class_copyIvarList([self.xiaoMing class], &amp;count);<br>        for (int i = 0; i&lt;count; i++) {<br>            Ivar var = ivar[i];<br>            const char </em>varName = ivar_getName(var);<br>            NSString *name = [NSString stringWithUTF8String:varName];<br>            if ([name isEqualToString:@”_age”]) {<br>                object_setIvar(self.xiaoMing, var, @”20”);<br>                break;<br>            }<br>        }<br>        NSLog(@”XiaoMing’s age is %@”,self.xiaoMing.age);<br>    }<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#### 2.动态添加方法</div><div class=\"line\"></div><div class=\"line\">在程序当中，假设XiaoMing的中没有`guess`这个方法，后来被Runtime添加一个名字叫guess的方法，最终再调用guess方法做出相应。那么，Runtime是如何做到的呢？  </div><div class=\"line\">  </div><div class=\"line\">##### 1.动态给XiaoMing类中添加guess方法：</div></pre></td></tr></table></figure></p>\n<pre><code>class_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;);\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这里参数地方说明一下：</div><div class=\"line\"></div><div class=\"line\">&gt;(IMP)guessAnswer 意思是guessAnswer的地址指针;</div><div class=\"line\">&gt;&quot;v@:&quot; 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;</div><div class=\"line\">&gt;“v@:@@” 意思是，两个参数的没有返回值。  </div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">##### 2.调用guess方法响应事件：  </div><div class=\"line\"></div><div class=\"line\">\t[self.xiaoMing performSelector:@selector(guess)];</div><div class=\"line\"></div><div class=\"line\">##### 3.编写guessAnswer的实现：  </div><div class=\"line\">\t</div><div class=\"line\">\t</div><div class=\"line\">\tvoid guessAnswer(id self,SEL _cmd)&#123;</div><div class=\"line\">    \tNSLog(@&quot;i am from beijing&quot;);   </div><div class=\"line\">\t&#125; </div><div class=\"line\">\t</div><div class=\"line\"></div><div class=\"line\">这个有两个地方留意一下：</div><div class=\"line\">* void的前面没有+、-号，因为只是C的代码。</div><div class=\"line\">* 必须有两个指定参数(id self,SEL _cmd)  </div><div class=\"line\"></div><div class=\"line\">##### 4.代码参考</div><div class=\"line\"></div><div class=\"line\">```  </div><div class=\"line\">\t-(void)answer&#123;</div><div class=\"line\">    \tclass_addMethod([self.xiaoMing class], @selector(guess), (IMP)guessAnswer, &quot;v@:&quot;);</div><div class=\"line\">    \tif ([self.xiaoMing respondsToSelector:@selector(guess)]) &#123;</div><div class=\"line\">        </div><div class=\"line\">        \t[self.xiaoMing performSelector:@selector(guess)];</div><div class=\"line\">        </div><div class=\"line\">    \t&#125; else&#123;</div><div class=\"line\">        \tNSLog(@&quot;Sorry,I don&apos;t know&quot;);</div><div class=\"line\">    \t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tvoid guessAnswer(id self,SEL _cmd)&#123;</div><div class=\"line\">   </div><div class=\"line\">    \tNSLog(@&quot;i am from beijing&quot;);</div><div class=\"line\">    </div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3：动态交换两个方法的实现\"><a href=\"#3：动态交换两个方法的实现\" class=\"headerlink\" title=\"3：动态交换两个方法的实现\"></a>3：动态交换两个方法的实现</h4><p>在程序当中，假设XiaoMing的中有<code>test1</code> 和 <code>test2</code>这两个方法，后来被Runtime交换方法后，每次调动<code>test1</code> 的时候就会去执行<code>test2</code>，调动<code>test2</code> 的时候就会去执行<code>test1</code>， 。那么，Runtime是如何做到的呢？</p>\n<h5 id=\"1-获取这个类中的两个方法并交换\"><a href=\"#1-获取这个类中的两个方法并交换\" class=\"headerlink\" title=\"1. 获取这个类中的两个方法并交换\"></a>1. 获取这个类中的两个方法并交换</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Method m1 = class_getInstanceMethod([self.xiaoMing class], @selector(test1));</div><div class=\"line\">    Method m2 = class_getInstanceMethod([self.xiaoMing class], @selector(test2));</div><div class=\"line\">    method_exchangeImplementations(m1, m2);</div></pre></td></tr></table></figure>\n<p>交换方法之后，以后每次调用这两个方法都会交换方法的实现</p>\n<h4 id=\"4：拦截并替换方法\"><a href=\"#4：拦截并替换方法\" class=\"headerlink\" title=\"4：拦截并替换方法\"></a>4：拦截并替换方法</h4><p>在程序当中，假设XiaoMing的中有<code>test1</code>这个方法，但是由于某种原因，我们要改变这个方法的实现，但是又不能去动它的源代码(正如一些开源库出现问题的时候)，这个时候runtime就派上用场了。</p>\n<p>我们先增加一个tool类，然后写一个我们自己实现的方法-change，<br>通过runtime把test1替换成change。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class PersionClass = object_getClass([Person class]);</div><div class=\"line\">Class toolClass = object_getClass([tool class]);</div><div class=\"line\"></div><div class=\"line\">    ////源方法的SEL和Method</div><div class=\"line\">    </div><div class=\"line\">    SEL oriSEL = @selector(test1);</div><div class=\"line\">    Method oriMethod = class_getInstanceMethod(PersionClass, oriSEL);</div><div class=\"line\">    </div><div class=\"line\">    ////交换方法的SEL和Method</div><div class=\"line\">    </div><div class=\"line\">    SEL cusSEL = @selector(change);</div><div class=\"line\">    Method cusMethod = class_getInstanceMethod(toolClass, cusSEL);</div><div class=\"line\">    </div><div class=\"line\">    ////先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况</div><div class=\"line\">    </div><div class=\"line\">    BOOL addSucc = class_addMethod(PersionClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class=\"line\">    if (addSucc) &#123;</div><div class=\"line\">          // 添加成功：将源方法的实现替换到交换方法的实现     </div><div class=\"line\">        class_replaceMethod(toolClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class=\"line\">               </div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">    //添加失败：说明源方法已经有实现，直接将两个方法的实现交换即</div><div class=\"line\">method_exchangeImplementations(oriMethod, cusMethod);  </div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h4 id=\"5：在方法上增加额外功能\"><a href=\"#5：在方法上增加额外功能\" class=\"headerlink\" title=\"5：在方法上增加额外功能\"></a>5：在方法上增加额外功能</h4><p>有这样一个场景，出于某些需求，我们需要跟踪记录APP中按钮的点击次数和频率等数据，怎么解决？当然通过继承按钮类或者通过类别实现是一个办法，但是带来其他问题比如别人不一定会去实例化你写的子类，或者其他类别也实现了点击方法导致不确定会调用哪一个，runtime可以这样解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation UIButton (Hook)</div><div class=\"line\"></div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\"></div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\"></div><div class=\"line\">        Class selfClass = [self class];</div><div class=\"line\"></div><div class=\"line\">        SEL oriSEL = @selector(sendAction:to:forEvent:);</div><div class=\"line\">        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</div><div class=\"line\"></div><div class=\"line\">        SEL cusSEL = @selector(mySendAction:to:forEvent:);</div><div class=\"line\">        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</div><div class=\"line\"></div><div class=\"line\">        BOOL addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</div><div class=\"line\">        if (addSucc) &#123;</div><div class=\"line\">            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</div><div class=\"line\">        &#125;else &#123;</div><div class=\"line\">            method_exchangeImplementations(oriMethod, cusMethod);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)mySendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123;</div><div class=\"line\">    [CountTool addClickCount];</div><div class=\"line\">    [self mySendAction:action to:target forEvent:event];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>load方法会在类第一次加载的时候被调用,调用的时间比较靠前，适合在这个方法里做方法交换,方法交换应该被保证，在程序中只会执行一次。</p>\n<h4 id=\"6-实现NSCoding的自动归档和解档\"><a href=\"#6-实现NSCoding的自动归档和解档\" class=\"headerlink\" title=\"6.实现NSCoding的自动归档和解档\"></a>6.实现NSCoding的自动归档和解档</h4><p>如果你实现过自定义模型数据持久化的过程，那么你也肯定明白，如果一个模型有许多个属性，那么我们需要对每个属性都实现一遍<code>encodeObject</code> 和 <code>decodeObjectForKey</code>方法，如果这样的模型又有很多个，这还真的是一个十分麻烦的事情。下面来看看简单的实现方式。<br>假设现在有一个Movie类，有3个属性，它的<code>h</code>文件这这样的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">//1. 如果想要当前类可以实现归档与反归档，需要遵守一个协议NSCoding</div><div class=\"line\">@interface Movie : NSObject&lt;NSCoding&gt;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, copy) NSString *movieId;</div><div class=\"line\">@property (nonatomic, copy) NSString *movieName;</div><div class=\"line\">@property (nonatomic, copy) NSString *pic_url;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>如果是正常写法， <code>m</code>文件应该是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)aCoder</div><div class=\"line\">&#123;</div><div class=\"line\">    [aCoder encodeObject:_movieId forKey:@&quot;id&quot;];</div><div class=\"line\">    [aCoder encodeObject:_movieName forKey:@&quot;name&quot;];</div><div class=\"line\">    [aCoder encodeObject:_pic_url forKey:@&quot;url&quot;];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)aDecoder</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init]) &#123;</div><div class=\"line\">        self.movieId = [aDecoder decodeObjectForKey:@&quot;id&quot;];</div><div class=\"line\">        self.movieName = [aDecoder decodeObjectForKey:@&quot;name&quot;];</div><div class=\"line\">        self.pic_url = [aDecoder decodeObjectForKey:@&quot;url&quot;];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>如果这里有100个属性，那么我们也只能把100个属性都给写一遍。<br>不过你会使用runtime后，这里就有更简便的方法。<br>下面看看runtime的实现方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)encoder</div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    unsigned int count = 0;</div><div class=\"line\">    Ivar *ivars = class_copyIvarList([Movie class], &amp;count);</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i&lt;count; i++) &#123;</div><div class=\"line\">        // 取出i位置对应的成员变量</div><div class=\"line\">        Ivar ivar = ivars[i];</div><div class=\"line\">        // 查看成员变量</div><div class=\"line\">        const char *name = ivar_getName(ivar);</div><div class=\"line\">        // 归档</div><div class=\"line\">        NSString *key = [NSString stringWithUTF8String:name];</div><div class=\"line\">        id value = [self valueForKey:key];</div><div class=\"line\">        [encoder encodeObject:value forKey:key];</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(ivars);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)decoder</div><div class=\"line\">&#123;</div><div class=\"line\">    if (self = [super init]) &#123;</div><div class=\"line\">        unsigned int count = 0;</div><div class=\"line\">        Ivar *ivars = class_copyIvarList([Movie class], &amp;count);</div><div class=\"line\">        for (int i = 0; i&lt;count; i++) &#123;</div><div class=\"line\">        // 取出i位置对应的成员变量</div><div class=\"line\">        Ivar ivar = ivars[i];</div><div class=\"line\">        // 查看成员变量</div><div class=\"line\">        const char *name = ivar_getName(ivar);</div><div class=\"line\">       // 归档</div><div class=\"line\">       NSString *key = [NSString stringWithUTF8String:name];</div><div class=\"line\">      id value = [decoder decodeObjectForKey:key];</div><div class=\"line\">       // 设置到成员变量身上</div><div class=\"line\">        [self setValue:value forKey:key];</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        free(ivars);</div><div class=\"line\">    &#125; </div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>这样的方式实现，不管有多少个属性，写这几行代码就搞定了。怎么，还嫌麻烦，下面看看更加简便的方法：两句代码搞定。<br>我们把<code>encodeWithCoder</code> 和 <code>initWithCoder</code>这两个方法抽成宏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;Movie.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">#define encodeRuntime(A) \\</div><div class=\"line\">\\</div><div class=\"line\">unsigned int count = 0;\\</div><div class=\"line\">Ivar *ivars = class_copyIvarList([A class], &amp;count);\\</div><div class=\"line\">for (int i = 0; i&lt;count; i++) &#123;\\</div><div class=\"line\">Ivar ivar = ivars[i];\\</div><div class=\"line\">const char *name = ivar_getName(ivar);\\</div><div class=\"line\">NSString *key = [NSString stringWithUTF8String:name];\\</div><div class=\"line\">id value = [self valueForKey:key];\\</div><div class=\"line\">[encoder encodeObject:value forKey:key];\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">free(ivars);\\</div><div class=\"line\">\\</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#define initCoderRuntime(A) \\</div><div class=\"line\">\\</div><div class=\"line\">if (self = [super init]) &#123;\\</div><div class=\"line\">unsigned int count = 0;\\</div><div class=\"line\">Ivar *ivars = class_copyIvarList([A class], &amp;count);\\</div><div class=\"line\">for (int i = 0; i&lt;count; i++) &#123;\\</div><div class=\"line\">Ivar ivar = ivars[i];\\</div><div class=\"line\">const char *name = ivar_getName(ivar);\\</div><div class=\"line\">NSString *key = [NSString stringWithUTF8String:name];\\</div><div class=\"line\">id value = [decoder decodeObjectForKey:key];\\</div><div class=\"line\">[self setValue:value forKey:key];\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">free(ivars);\\</div><div class=\"line\">&#125;\\</div><div class=\"line\">return self;\\</div><div class=\"line\">\\</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">@implementation Movie</div><div class=\"line\"></div><div class=\"line\">- (void)encodeWithCoder:(NSCoder *)encoder</div><div class=\"line\"></div><div class=\"line\">&#123;</div><div class=\"line\">    encodeRuntime(Movie)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (id)initWithCoder:(NSCoder *)decoder</div><div class=\"line\">&#123;</div><div class=\"line\">    initCoderRuntime(Movie)</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>我们可以把这两个宏单独放到一个文件里面，这里以后需要进行数据持久化的模型都可以直接使用这两个宏。</p>\n<h4 id=\"7-实现字典转模型的自动转换\"><a href=\"#7-实现字典转模型的自动转换\" class=\"headerlink\" title=\"7.实现字典转模型的自动转换\"></a>7.实现字典转模型的自动转换</h4><p>字典转模型的应用可以说是每个app必然会使用的场景,虽然实现的方式略有不同，但是原理都是一致的：遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。<br>像几个出名的开源库：JSONModel,MJExtension等都是通过这种方式实现的。</p>\n<ul>\n<li>先实现最外层的属性转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 创建对应模型对象</div><div class=\"line\"> id objc = [[self alloc] init];</div><div class=\"line\"></div><div class=\"line\"> unsigned int count = 0;</div><div class=\"line\"></div><div class=\"line\"> // 1.获取成员属性数组</div><div class=\"line\"> Ivar *ivarList = class_copyIvarList(self, &amp;count);</div><div class=\"line\"></div><div class=\"line\"> // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值</div><div class=\"line\"> for (int i = 0; i &lt; count; i++) &#123;</div><div class=\"line\"></div><div class=\"line\">     // 2.1 获取成员属性</div><div class=\"line\">     Ivar ivar = ivarList[i];</div><div class=\"line\"></div><div class=\"line\">     // 2.2 获取成员属性名 C -&gt; OC 字符串</div><div class=\"line\">    NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class=\"line\"></div><div class=\"line\">     // 2.3 _成员属性名 =&gt; 字典key</div><div class=\"line\">     NSString *key = [ivarName substringFromIndex:1];</div><div class=\"line\"></div><div class=\"line\">     // 2.4 去字典中取出对应value给模型属性赋值</div><div class=\"line\">     id value = dict[key];</div><div class=\"line\"></div><div class=\"line\">     // 获取成员属性类型</div><div class=\"line\">     NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure>\n<p>如果模型比较简单，只有NSString，NSNumber等，这样就可以搞定了。但是如果模型含有NSArray，或者NSDictionary等，那么我们还需要进行第二步转换。</p>\n<ul>\n<li>内层数组，字典的转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType containsString:@&quot;NS&quot;]) &#123; </div><div class=\"line\"></div><div class=\"line\">             //  是字典对象,并且属性名对应类型是自定义类型</div><div class=\"line\">            // 处理类型字符串 @\\&quot;User\\&quot; -&gt; User</div><div class=\"line\">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;];</div><div class=\"line\">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\\&quot;&quot; withString:@&quot;&quot;];</div><div class=\"line\">            // 自定义对象,并且值是字典</div><div class=\"line\">            // value:user字典 -&gt; User模型</div><div class=\"line\">            // 获取模型(user)类对象</div><div class=\"line\">            Class modalClass = NSClassFromString(ivarType);</div><div class=\"line\"></div><div class=\"line\">            // 字典转模型</div><div class=\"line\">            if (modalClass) &#123;</div><div class=\"line\">                // 字典转模型 user</div><div class=\"line\">                value = [modalClass objectWithDict:value];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if ([value isKindOfClass:[NSArray class]]) &#123;</div><div class=\"line\">            // 判断对应类有没有实现字典数组转模型数组的协议</div><div class=\"line\">            if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123;</div><div class=\"line\"></div><div class=\"line\">                // 转换成id类型，就能调用任何对象的方法</div><div class=\"line\">                id idSelf = self;</div><div class=\"line\"></div><div class=\"line\">                // 获取数组中字典对应的模型</div><div class=\"line\">                NSString *type =  [idSelf arrayContainModelClass][key];</div><div class=\"line\"></div><div class=\"line\">                // 生成模型</div><div class=\"line\">                Class classModel = NSClassFromString(type);</div><div class=\"line\">                NSMutableArray *arrM = [NSMutableArray array];</div><div class=\"line\">                // 遍历字典数组，生成模型数组</div><div class=\"line\">                for (NSDictionary *dict in value) &#123;</div><div class=\"line\">                    // 字典转模型</div><div class=\"line\">                    id model =  [classModel objectWithDict:dict];</div><div class=\"line\">                    [arrM addObject:model];</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // 把模型数组赋值给value</div><div class=\"line\">                value = arrM;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n<p>我自己觉得系统自带的KVC模式字典转模型就挺好的，假设movie是一个模型对象，dict 是一个需要转化的 <code>[movie setValuesForKeysWithDictionary:dict];</code> 这个是系统自带的字典转模型方法，个人感觉也还是挺好用的，不过使用这个方法的时候需要在模型里面再实现一个方法才行，<br><code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code> 重写这个方法为了实现两个目的：1. 模型中的属性和字典中的key不一致的情况，比如字典中有个<code>id</code>,我们需要把它赋值给<code>uid</code>属性；2. 字典中属性比模型的属性还多的情况。<br>如果出现以上两种情况而没有实现这个方法的话，程序就会崩溃。<br>这个方法的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setValue:(id)value forUndefinedKey:(NSString *)key</div><div class=\"line\">&#123;</div><div class=\"line\">    if ([key isEqualToString:@&quot;id&quot;]) &#123;</div><div class=\"line\">        self.uid = value;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"六-几个参数概念\"><a href=\"#六-几个参数概念\" class=\"headerlink\" title=\"六.几个参数概念\"></a>六.几个参数概念</h3><p>以上的几种方法应该算是runtime在实际场景中所应用的大部分的情况了，平常的编码中差不多足够用了。<br>如果从头仔细看到尾，相信你基本的用法应该会了，虽然会用是主要的目的，有几个基本的参数概念还是要了解一下的。</p>\n<h4 id=\"1-objc-msgSend\"><a href=\"#1-objc-msgSend\" class=\"headerlink\" title=\"1.objc_msgSend\"></a>1.objc_msgSend</h4> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* Basic Messaging Primitives</div><div class=\"line\">*</div><div class=\"line\">* On some architectures, use objc_msgSend_stret for some struct return types.</div><div class=\"line\">* On some architectures, use objc_msgSend_fpret for some float return types.</div><div class=\"line\">* On some architectures, use objc_msgSend_fp2ret for some float return types.</div><div class=\"line\">*</div><div class=\"line\">* These functions must be cast to an appropriate function pointer type </div><div class=\"line\">* before being called. </div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<p>这是官方的声明，从这个函数的注释可以看出来了，这是个最基本的用于发送消息的函数。另外，这个函数并不能发送所有类型的消息，只能发送基本的消息。比如，在一些处理器上，我们必须使用<code>objc_msgSend_stret</code>来发送返回值类型为结构体的消息，使用<code>objc_msgSend_fpret</code>来发送返回值类型为浮点类型的消息，而又在一些处理器上，还得使用objc_msgSend_fp2ret来发送返回值类型为浮点类型的消息。<br>最关键的一点：无论何时，要调用<code>objc_msgSend</code>函数，必须要将函数强制转换成合适的函数指针类型才能调用。<br>从<code>objc_msgSend</code>函数的声明来看，它应该是不带返回值的，但是我们在使用中却可以强制转换类型，以便接收返回值。另外，它的参数列表是可以任意多个的，前提也是要强制函数指针类型。<br>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有<code>”Super”</code>的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>”stret”</code>的函数。</p>\n<h4 id=\"2-SEL\"><a href=\"#2-SEL\" class=\"headerlink\" title=\"2.SEL\"></a>2.SEL</h4><p><code>objc_msgSend</code>函数第二个参数类型为SEL，它是<code>selector在Objc</code>中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:<br><code>typedef struct objc_selector *SEL</code>;<br>其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令<code>@selector()</code>或者 Runtime 系统的<code>sel_registerName</code>函数来获得一个SEL类型的方法选择器。<br>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法)，Cocoa 中有好多长长的方法哦。</p>\n<h4 id=\"3-id\"><a href=\"#3-id\" class=\"headerlink\" title=\"3.id\"></a>3.id</h4><p><code>objc_msgSend</code>第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：<br><code>typedef struct objc_object *id</code>;<br>那objc_object又是啥呢：<br><code>struct objc_object { Class isa; }</code>;<br><code>objc_object</code>结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。<br>PS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html\">官方文档</a>.</p>\n<h4 id=\"4-Class\"><a href=\"#4-Class\" class=\"headerlink\" title=\"4.Class\"></a>4.Class</h4><p>之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：<br><code>typedef struct objc_class *Class</code>;<br>objc_class里面的东西多着呢：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">#if  !__OBJC2__</div><div class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class=\"line\">    const char *name                                         OBJC2_UNAVAILABLE;</div><div class=\"line\">    long version                                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    long info                                                OBJC2_UNAVAILABLE;</div><div class=\"line\">    long instance_size                                       OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class=\"line\">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>\n<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。<br>在<code>objc_class</code>结构体中：<code>ivars是objc_ivar_list</code>指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。也就是说可以动态修改 <code>*methodLists</code> 的值来添加成员方法，这也是Category实现的原理.</p>\n<p>上面讲到的所有东西都在Demo里，如果你觉得不错，还请为我的Demo star一个。<br><a href=\"https://github.com/suifengqjn/runtime\">demo下载</a></p>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/runtime/2.png\" alt=\"image\"></p>"},{"title":"自定义刷新控件","_content":"\n### 一：前言\n记得工作中第一次用的刷新控件是`svpulltorefresh`，用法稍微有点麻烦，而且bug颇多，后来果断放弃，现在用的是`MJRefresh`,不管是用法还是bug，都比前一个好多了，但是不久前也遇到了一个致命的bug，有好些情况下会导致`MJRefresh`陷入一个死循环，导致不断的刷新，只能重启软件才行。`MJRefresh`工程比较庞大，找到了bug也很难修改，然后还是决定自己写一个，系统提供的`UIRefreshControl`我认为是最好的，缺点是不提供自定义UI的方法，那么我就自己基于它来自定义UI。我不是一开始就决定继承于`UIRefreshControl`，我同时也写了一个继承与`UIView`的control，两个进行对比，发现使用`UIview`会有很多弊端，这种弊端在一些复杂特殊的情况下一下子就暴露出来了，而且很难解决，当然，正常状态下是没什么问题的，有兴趣的同学倒是可以去试一试。本demo供大家学习和参考，如有发现bug，还请issues 我。\n\n### 二: 了解 UIRefreshControl\n* 基本使用方法\n\n```\n//初始化一个control\nUIRefreshControl *control = [[UIRefreshControl alloc] init];\n//给control 添加一个刷新方法\n[control addTarget:self action:@selector(refreshAction) forControlEvents:UIControlEventValueChanged];\n//把control 添加到 tableView\n[self.tableView addSubview:control];\n```\n\n* 存在的问题\n\t* 1. 刷新时的动画是一个灰色小菊花，很多情况下不符合app的刷新动画效果\n\t* 2. 经过多次反复测试，下拉的偏移量达到130以上才会触发刷新方法，很显然这个也不符合，一般的刷新控件的高度60左右，所以下拉的偏移量达到60就可以触发刷新的方法了。\n\n* 自定义控件的思路\n\t* 1. 去掉默认的动画效果\n\t* 2. 自定义自己的动画效果\n\t* 3. 改变满足刷新时的条件\n\t<!-- more -->\n### 三：FMRefreshControl\n\n* 先看一下我写完的这个控件的使用方法\n\n``` \nFMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];\n\n[self.tableView addSubview:control];\n```\n两行代码，用法比系统的还要稍微简单一点。\n\n* 再看一下效果\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/FMRefresh/1.gif)\n\n### 四：思路与代码\n#### 1. 关于 `UIRefreshControl` 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 `superViwe`,再执行 \n`[[_control.subviews objectAtIndex:0] setFrame:CGRectMake(0, 0, _control.bounds.size.width, 30)];`\n一开始我是想改变它的高度是否就能改变它的触发刷新的偏移量，然后我找到了这个方法可以修改它的高度，但实际上改变了高度还是无法改变触发下拉刷新的偏移量，所以我们需要自定义去触发刷新这个动作的时机。\n\n#### 2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。\n\n#### 3. 进入代码阶段\n```\nFMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];\n[self.tableView addSubview:control];\n```\n初始化的时候赋一个 target 和 一个 action，当满足条件的时候，我们需要知道让谁去执行刷新方法，有这两个参数足够，当执行到第二行 addSubView的时候，我们需要在control内部实现这个方法：\n```\n- (void)willMoveToSuperview:(UIView *)newSuperview {\n    [super willMoveToSuperview:newSuperview];\n    \n    if ([newSuperview isKindOfClass:[UIScrollView class]]) {\n        self.superScrollView = (UIScrollView *)newSuperview;\n        \n        [self.superScrollView addObserver:self forKeyPath:@\"contentOffset\" options:NSKeyValueObservingOptionNew context:nil];\n    }\n}\n```\n这样，我们就知道当前这个control被添加到哪个父视图上了，为了安全及代码的严谨，先判断父视图是否属于\n`UIScrollView`，如果是，就用KVO监听`contentOffset`属性，这样便能知道用户滑动的偏移量。\n\n这里我定义了3种状态：\n```\ntypedef NS_ENUM(NSInteger, FMRefreshState) {\n    FMRefreshStateNormal = 0,     /** 普通状态 */\n    FMRefreshStatePulling,        /** 释放刷新状态 */\n    FMRefreshStateRefreshing,     /** 正在刷新 */\n};\n```\n以及切换状态后UI的切换和方法的触发：\n```\n- (void)setCurrentStatus:(FMRefreshState)currentStatus {\n    _currentStatus = currentStatus;\n    switch (_currentStatus) {\n        case FMRefreshStateNormal:\n            NSLog(@\"切换到Normal\");\n            [self.imageView stopAnimating];\n            self.label.text = FM_Refresh_normal_title;\n            [self.label sizeToFit];\n            self.imageView.image = [UIImage imageNamed:@\"refresh_1\"];\n            \n            break;\n        case FMRefreshStatePulling:\n            NSLog(@\"切换到Pulling\");\n            self.label.text = FM_Refresh_pulling_title;\n            [self.label sizeToFit];\n            self.imageView.animationImages = self.refreshingImages;\n            self.imageView.animationDuration = 1.5;\n            [self.imageView startAnimating];\n            \n            break;\n        case FMRefreshStateRefreshing:\n            NSLog(@\"切换到Refreshing\");\n            self.label.text = FM_Refresh_Refreshing_title;\n            [self.label sizeToFit];\n            [self beginRefreshing];\n            self.imageView.animationImages = self.refreshingImages;\n            self.imageView.animationDuration = 1.5;\n            [self.imageView startAnimating];\n            [self doRefreshAction];\n            \n            break;\n    }\n}\n```\n切换到`FMRefreshStateNormal` 停止动画，切换到`FMRefreshStatePulling` 开始动画，达到这个状态，说明用户已经达到了刷新的偏移量，此时松手便可刷新，切换到`FMRefreshStateRefreshing`，如果此时往回滑动，小于临界值，那么状态重新切回`FMRefreshStateNormal`。\n满足刷新条件，则便可执行以下方法：\n```\n- (void)doRefreshAction\n{\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n    if (self.refreshTarget && [self.refreshTarget respondsToSelector:self.refreshAction])\n        [self.refreshTarget performSelector:self.refreshAction];\n#pragma clang diagnostic pop\n    \n}\n```\n下面看最关键的KVO方法，也是这里面最复杂的逻辑处理代码：\n```\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {\n    \n    //isDragging 属性是指用户手指是否在拖动\n    if (self.superScrollView.isDragging && !self.isRefreshing) {\n        if (!self.originalOffsetY) {\n            self.originalOffsetY = -self.superScrollView.contentInset.top;\n        }\n        CGFloat normalPullingOffset =  self.originalOffsetY - k_FMRefresh_Height;\n        if (self.currentStatus == FMRefreshStatePulling && self.superScrollView.contentOffset.y > normalPullingOffset) {\n            \n            self.currentStatus = FMRefreshStateNormal;\n        } else if (self.currentStatus == FMRefreshStateNormal && self.superScrollView.contentOffset.y < normalPullingOffset) {\n            self.currentStatus = FMRefreshStatePulling;\n        }\n    } else if(!self.superScrollView.isDragging){\n        \n        if (self.currentStatus == FMRefreshStatePulling) {\n            \n            self.currentStatus = FMRefreshStateRefreshing;\n        }\n    }\n\t//拖动的偏移量，转换成正数\n    CGFloat pullDistance = -self.frame.origin.y;\n    self.backgroundView.frame = CGRectMake(0, 0, k_FMRefresh_Width, pullDistance);\n    CGFloat totalWidth = 35 + 20 + self.label.bounds.size.width;\n    CGFloat imageViewX = (k_FMRefresh_Width - totalWidth)/2;\n    \n    self.imageView.frame = CGRectMake(imageViewX,  -k_FMRefresh_Height+pullDistance+(k_FMRefresh_Height - self.imageView.bounds.size.height)/2, self.imageView.frame.size.width, self.imageView.frame.size.height);\n    self.label.frame = CGRectMake(imageViewX + 35 + 20, -k_FMRefresh_Height + pullDistance + (k_FMRefresh_Height - self.label.bounds.size.height)/2, self.label.frame.size.width, self.label.frame.size.height);   \n}\n```\n这里最重要的就是处理两点：1. 根据偏移量和用户手指的拖动来切换状态，2. control上面的子视图需要我们根据偏移量来实时更新。\n\n还有一种情况，上面也提到过，用户先滑动到`FMRefreshStatePulling`状态，然后又往回滑动，此时的偏移量在0-`FMRefreshStatePulling`状态的偏移量之间，此时调用自身的 `endRefreshing`偏移量不会复原，还需要我们自己处理，看了几个老外写的自定义刷新控件，他们都没修复这个bug。他们也没封装，全部代码写在了控制器里，什么都没有改变，只是实现了一个动画效果，还多了个bug,动画效果倒是不错的。有兴趣的可以参考一番：\n[https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/](https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/)\n[https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/](https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/)\n\n\n```\n- (void)endRefreshing {\n    if (self.currentStatus != FMRefreshStateRefreshing) {\n        return;\n    }\n    self.currentStatus = FMRefreshStateNormal;\n    [super endRefreshing];\n    \n    //在执行刷新的状态中，用户手动拖动到 nornal 状态的 offset，[super endRefreshing] 无法回到初始位置，所以手动设置\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        if(self.superScrollView.contentOffset.y >= self.originalOffsetY - k_FMRefresh_Height && self.superScrollView.contentOffset.y <= self.originalOffsetY) {\n            CGPoint offset = self.superScrollView.contentOffset;\n            offset.y = self.originalOffsetY;\n            [self.superScrollView setContentOffset:offset animated:YES];\n        }\n    });\n\n}\n```\n最后还有一点不要忘记 `dealloc`移除监听：\n```\n- (void)dealloc {\n    [self.superScrollView removeObserver:self forKeyPath:@\"contentOffset\"];\n}\n```\n整篇文章从上至下是按照整个完整的思路写下来的，先是提出遇到的问题以及难点，然后最后的代码和思路也是由外至内一路写下来，希望方便大家阅读。这是上篇，下拉刷新的，还有下篇，上拉加载，过两天写，demo中已经有了，不过就是还没优化。\n\n[domo地址：https://github.com/suifengqjn/FMRefreshControl](https://github.com/suifengqjn/FMRefreshControl)\n\n\n\n\n\n\n\n","source":"_posts/自定义刷新控件.md","raw":"---\ntitle: 自定义刷新控件\ntags:\n  - iOS\n  - UIRefreshControl\ncategories:\n  - iOS技术\n---\n\n### 一：前言\n记得工作中第一次用的刷新控件是`svpulltorefresh`，用法稍微有点麻烦，而且bug颇多，后来果断放弃，现在用的是`MJRefresh`,不管是用法还是bug，都比前一个好多了，但是不久前也遇到了一个致命的bug，有好些情况下会导致`MJRefresh`陷入一个死循环，导致不断的刷新，只能重启软件才行。`MJRefresh`工程比较庞大，找到了bug也很难修改，然后还是决定自己写一个，系统提供的`UIRefreshControl`我认为是最好的，缺点是不提供自定义UI的方法，那么我就自己基于它来自定义UI。我不是一开始就决定继承于`UIRefreshControl`，我同时也写了一个继承与`UIView`的control，两个进行对比，发现使用`UIview`会有很多弊端，这种弊端在一些复杂特殊的情况下一下子就暴露出来了，而且很难解决，当然，正常状态下是没什么问题的，有兴趣的同学倒是可以去试一试。本demo供大家学习和参考，如有发现bug，还请issues 我。\n\n### 二: 了解 UIRefreshControl\n* 基本使用方法\n\n```\n//初始化一个control\nUIRefreshControl *control = [[UIRefreshControl alloc] init];\n//给control 添加一个刷新方法\n[control addTarget:self action:@selector(refreshAction) forControlEvents:UIControlEventValueChanged];\n//把control 添加到 tableView\n[self.tableView addSubview:control];\n```\n\n* 存在的问题\n\t* 1. 刷新时的动画是一个灰色小菊花，很多情况下不符合app的刷新动画效果\n\t* 2. 经过多次反复测试，下拉的偏移量达到130以上才会触发刷新方法，很显然这个也不符合，一般的刷新控件的高度60左右，所以下拉的偏移量达到60就可以触发刷新的方法了。\n\n* 自定义控件的思路\n\t* 1. 去掉默认的动画效果\n\t* 2. 自定义自己的动画效果\n\t* 3. 改变满足刷新时的条件\n\t<!-- more -->\n### 三：FMRefreshControl\n\n* 先看一下我写完的这个控件的使用方法\n\n``` \nFMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];\n\n[self.tableView addSubview:control];\n```\n两行代码，用法比系统的还要稍微简单一点。\n\n* 再看一下效果\n\n![image](https://raw.githubusercontent.com/suifengqjn/demoimages/master/FMRefresh/1.gif)\n\n### 四：思路与代码\n#### 1. 关于 `UIRefreshControl` 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 `superViwe`,再执行 \n`[[_control.subviews objectAtIndex:0] setFrame:CGRectMake(0, 0, _control.bounds.size.width, 30)];`\n一开始我是想改变它的高度是否就能改变它的触发刷新的偏移量，然后我找到了这个方法可以修改它的高度，但实际上改变了高度还是无法改变触发下拉刷新的偏移量，所以我们需要自定义去触发刷新这个动作的时机。\n\n#### 2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。\n\n#### 3. 进入代码阶段\n```\nFMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];\n[self.tableView addSubview:control];\n```\n初始化的时候赋一个 target 和 一个 action，当满足条件的时候，我们需要知道让谁去执行刷新方法，有这两个参数足够，当执行到第二行 addSubView的时候，我们需要在control内部实现这个方法：\n```\n- (void)willMoveToSuperview:(UIView *)newSuperview {\n    [super willMoveToSuperview:newSuperview];\n    \n    if ([newSuperview isKindOfClass:[UIScrollView class]]) {\n        self.superScrollView = (UIScrollView *)newSuperview;\n        \n        [self.superScrollView addObserver:self forKeyPath:@\"contentOffset\" options:NSKeyValueObservingOptionNew context:nil];\n    }\n}\n```\n这样，我们就知道当前这个control被添加到哪个父视图上了，为了安全及代码的严谨，先判断父视图是否属于\n`UIScrollView`，如果是，就用KVO监听`contentOffset`属性，这样便能知道用户滑动的偏移量。\n\n这里我定义了3种状态：\n```\ntypedef NS_ENUM(NSInteger, FMRefreshState) {\n    FMRefreshStateNormal = 0,     /** 普通状态 */\n    FMRefreshStatePulling,        /** 释放刷新状态 */\n    FMRefreshStateRefreshing,     /** 正在刷新 */\n};\n```\n以及切换状态后UI的切换和方法的触发：\n```\n- (void)setCurrentStatus:(FMRefreshState)currentStatus {\n    _currentStatus = currentStatus;\n    switch (_currentStatus) {\n        case FMRefreshStateNormal:\n            NSLog(@\"切换到Normal\");\n            [self.imageView stopAnimating];\n            self.label.text = FM_Refresh_normal_title;\n            [self.label sizeToFit];\n            self.imageView.image = [UIImage imageNamed:@\"refresh_1\"];\n            \n            break;\n        case FMRefreshStatePulling:\n            NSLog(@\"切换到Pulling\");\n            self.label.text = FM_Refresh_pulling_title;\n            [self.label sizeToFit];\n            self.imageView.animationImages = self.refreshingImages;\n            self.imageView.animationDuration = 1.5;\n            [self.imageView startAnimating];\n            \n            break;\n        case FMRefreshStateRefreshing:\n            NSLog(@\"切换到Refreshing\");\n            self.label.text = FM_Refresh_Refreshing_title;\n            [self.label sizeToFit];\n            [self beginRefreshing];\n            self.imageView.animationImages = self.refreshingImages;\n            self.imageView.animationDuration = 1.5;\n            [self.imageView startAnimating];\n            [self doRefreshAction];\n            \n            break;\n    }\n}\n```\n切换到`FMRefreshStateNormal` 停止动画，切换到`FMRefreshStatePulling` 开始动画，达到这个状态，说明用户已经达到了刷新的偏移量，此时松手便可刷新，切换到`FMRefreshStateRefreshing`，如果此时往回滑动，小于临界值，那么状态重新切回`FMRefreshStateNormal`。\n满足刷新条件，则便可执行以下方法：\n```\n- (void)doRefreshAction\n{\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n    if (self.refreshTarget && [self.refreshTarget respondsToSelector:self.refreshAction])\n        [self.refreshTarget performSelector:self.refreshAction];\n#pragma clang diagnostic pop\n    \n}\n```\n下面看最关键的KVO方法，也是这里面最复杂的逻辑处理代码：\n```\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {\n    \n    //isDragging 属性是指用户手指是否在拖动\n    if (self.superScrollView.isDragging && !self.isRefreshing) {\n        if (!self.originalOffsetY) {\n            self.originalOffsetY = -self.superScrollView.contentInset.top;\n        }\n        CGFloat normalPullingOffset =  self.originalOffsetY - k_FMRefresh_Height;\n        if (self.currentStatus == FMRefreshStatePulling && self.superScrollView.contentOffset.y > normalPullingOffset) {\n            \n            self.currentStatus = FMRefreshStateNormal;\n        } else if (self.currentStatus == FMRefreshStateNormal && self.superScrollView.contentOffset.y < normalPullingOffset) {\n            self.currentStatus = FMRefreshStatePulling;\n        }\n    } else if(!self.superScrollView.isDragging){\n        \n        if (self.currentStatus == FMRefreshStatePulling) {\n            \n            self.currentStatus = FMRefreshStateRefreshing;\n        }\n    }\n\t//拖动的偏移量，转换成正数\n    CGFloat pullDistance = -self.frame.origin.y;\n    self.backgroundView.frame = CGRectMake(0, 0, k_FMRefresh_Width, pullDistance);\n    CGFloat totalWidth = 35 + 20 + self.label.bounds.size.width;\n    CGFloat imageViewX = (k_FMRefresh_Width - totalWidth)/2;\n    \n    self.imageView.frame = CGRectMake(imageViewX,  -k_FMRefresh_Height+pullDistance+(k_FMRefresh_Height - self.imageView.bounds.size.height)/2, self.imageView.frame.size.width, self.imageView.frame.size.height);\n    self.label.frame = CGRectMake(imageViewX + 35 + 20, -k_FMRefresh_Height + pullDistance + (k_FMRefresh_Height - self.label.bounds.size.height)/2, self.label.frame.size.width, self.label.frame.size.height);   \n}\n```\n这里最重要的就是处理两点：1. 根据偏移量和用户手指的拖动来切换状态，2. control上面的子视图需要我们根据偏移量来实时更新。\n\n还有一种情况，上面也提到过，用户先滑动到`FMRefreshStatePulling`状态，然后又往回滑动，此时的偏移量在0-`FMRefreshStatePulling`状态的偏移量之间，此时调用自身的 `endRefreshing`偏移量不会复原，还需要我们自己处理，看了几个老外写的自定义刷新控件，他们都没修复这个bug。他们也没封装，全部代码写在了控制器里，什么都没有改变，只是实现了一个动画效果，还多了个bug,动画效果倒是不错的。有兴趣的可以参考一番：\n[https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/](https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/)\n[https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/](https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/)\n\n\n```\n- (void)endRefreshing {\n    if (self.currentStatus != FMRefreshStateRefreshing) {\n        return;\n    }\n    self.currentStatus = FMRefreshStateNormal;\n    [super endRefreshing];\n    \n    //在执行刷新的状态中，用户手动拖动到 nornal 状态的 offset，[super endRefreshing] 无法回到初始位置，所以手动设置\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        if(self.superScrollView.contentOffset.y >= self.originalOffsetY - k_FMRefresh_Height && self.superScrollView.contentOffset.y <= self.originalOffsetY) {\n            CGPoint offset = self.superScrollView.contentOffset;\n            offset.y = self.originalOffsetY;\n            [self.superScrollView setContentOffset:offset animated:YES];\n        }\n    });\n\n}\n```\n最后还有一点不要忘记 `dealloc`移除监听：\n```\n- (void)dealloc {\n    [self.superScrollView removeObserver:self forKeyPath:@\"contentOffset\"];\n}\n```\n整篇文章从上至下是按照整个完整的思路写下来的，先是提出遇到的问题以及难点，然后最后的代码和思路也是由外至内一路写下来，希望方便大家阅读。这是上篇，下拉刷新的，还有下篇，上拉加载，过两天写，demo中已经有了，不过就是还没优化。\n\n[domo地址：https://github.com/suifengqjn/FMRefreshControl](https://github.com/suifengqjn/FMRefreshControl)\n\n\n\n\n\n\n\n","slug":"自定义刷新控件","published":1,"date":"2016-11-16T15:05:20.000Z","updated":"2016-11-16T15:05:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civyshmop002gco60b3goi04x","content":"<h3 id=\"一：前言\"><a href=\"#一：前言\" class=\"headerlink\" title=\"一：前言\"></a>一：前言</h3><p>记得工作中第一次用的刷新控件是<code>svpulltorefresh</code>，用法稍微有点麻烦，而且bug颇多，后来果断放弃，现在用的是<code>MJRefresh</code>,不管是用法还是bug，都比前一个好多了，但是不久前也遇到了一个致命的bug，有好些情况下会导致<code>MJRefresh</code>陷入一个死循环，导致不断的刷新，只能重启软件才行。<code>MJRefresh</code>工程比较庞大，找到了bug也很难修改，然后还是决定自己写一个，系统提供的<code>UIRefreshControl</code>我认为是最好的，缺点是不提供自定义UI的方法，那么我就自己基于它来自定义UI。我不是一开始就决定继承于<code>UIRefreshControl</code>，我同时也写了一个继承与<code>UIView</code>的control，两个进行对比，发现使用<code>UIview</code>会有很多弊端，这种弊端在一些复杂特殊的情况下一下子就暴露出来了，而且很难解决，当然，正常状态下是没什么问题的，有兴趣的同学倒是可以去试一试。本demo供大家学习和参考，如有发现bug，还请issues 我。</p>\n<h3 id=\"二-了解-UIRefreshControl\"><a href=\"#二-了解-UIRefreshControl\" class=\"headerlink\" title=\"二: 了解 UIRefreshControl\"></a>二: 了解 UIRefreshControl</h3><ul>\n<li>基本使用方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化一个control</div><div class=\"line\">UIRefreshControl *control = [[UIRefreshControl alloc] init];</div><div class=\"line\">//给control 添加一个刷新方法</div><div class=\"line\">[control addTarget:self action:@selector(refreshAction) forControlEvents:UIControlEventValueChanged];</div><div class=\"line\">//把control 添加到 tableView</div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<ul>\n<li><p>存在的问题</p>\n<ul>\n<li><ol>\n<li>刷新时的动画是一个灰色小菊花，很多情况下不符合app的刷新动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>经过多次反复测试，下拉的偏移量达到130以上才会触发刷新方法，很显然这个也不符合，一般的刷新控件的高度60左右，所以下拉的偏移量达到60就可以触发刷新的方法了。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>自定义控件的思路</p>\n<ul>\n<li><ol>\n<li>去掉默认的动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>自定义自己的动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>改变满足刷新时的条件<a id=\"more\"></a>\n<h3 id=\"三：FMRefreshControl\"><a href=\"#三：FMRefreshControl\" class=\"headerlink\" title=\"三：FMRefreshControl\"></a>三：FMRefreshControl</h3></li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>先看一下我写完的这个控件的使用方法</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];</div><div class=\"line\"></div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<p>两行代码，用法比系统的还要稍微简单一点。</p>\n<ul>\n<li>再看一下效果</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/FMRefresh/1.gif\" alt=\"image\"></p>\n<h3 id=\"四：思路与代码\"><a href=\"#四：思路与代码\" class=\"headerlink\" title=\"四：思路与代码\"></a>四：思路与代码</h3><h4 id=\"1-关于-UIRefreshControl-的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到-superViwe-再执行\"><a href=\"#1-关于-UIRefreshControl-的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到-superViwe-再执行\" class=\"headerlink\" title=\"1. 关于 UIRefreshControl 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 superViwe,再执行\"></a>1. 关于 <code>UIRefreshControl</code> 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 <code>superViwe</code>,再执行</h4><p><code>[[_control.subviews objectAtIndex:0] setFrame:CGRectMake(0, 0, _control.bounds.size.width, 30)];</code><br>一开始我是想改变它的高度是否就能改变它的触发刷新的偏移量，然后我找到了这个方法可以修改它的高度，但实际上改变了高度还是无法改变触发下拉刷新的偏移量，所以我们需要自定义去触发刷新这个动作的时机。</p>\n<h4 id=\"2-手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow-因偏移量变动而导致非人为的刷新。\"><a href=\"#2-手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow-因偏移量变动而导致非人为的刷新。\" class=\"headerlink\" title=\"2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。\"></a>2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。</h4><h4 id=\"3-进入代码阶段\"><a href=\"#3-进入代码阶段\" class=\"headerlink\" title=\"3. 进入代码阶段\"></a>3. 进入代码阶段</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];</div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<p>初始化的时候赋一个 target 和 一个 action，当满足条件的时候，我们需要知道让谁去执行刷新方法，有这两个参数足够，当执行到第二行 addSubView的时候，我们需要在control内部实现这个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)willMoveToSuperview:(UIView *)newSuperview &#123;</div><div class=\"line\">    [super willMoveToSuperview:newSuperview];</div><div class=\"line\">    </div><div class=\"line\">    if ([newSuperview isKindOfClass:[UIScrollView class]]) &#123;</div><div class=\"line\">        self.superScrollView = (UIScrollView *)newSuperview;</div><div class=\"line\">        </div><div class=\"line\">        [self.superScrollView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样，我们就知道当前这个control被添加到哪个父视图上了，为了安全及代码的严谨，先判断父视图是否属于<br><code>UIScrollView</code>，如果是，就用KVO监听<code>contentOffset</code>属性，这样便能知道用户滑动的偏移量。</p>\n<p>这里我定义了3种状态：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, FMRefreshState) &#123;</div><div class=\"line\">    FMRefreshStateNormal = 0,     /** 普通状态 */</div><div class=\"line\">    FMRefreshStatePulling,        /** 释放刷新状态 */</div><div class=\"line\">    FMRefreshStateRefreshing,     /** 正在刷新 */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>以及切换状态后UI的切换和方法的触发：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setCurrentStatus:(FMRefreshState)currentStatus &#123;</div><div class=\"line\">    _currentStatus = currentStatus;</div><div class=\"line\">    switch (_currentStatus) &#123;</div><div class=\"line\">        case FMRefreshStateNormal:</div><div class=\"line\">            NSLog(@&quot;切换到Normal&quot;);</div><div class=\"line\">            [self.imageView stopAnimating];</div><div class=\"line\">            self.label.text = FM_Refresh_normal_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            self.imageView.image = [UIImage imageNamed:@&quot;refresh_1&quot;];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">        case FMRefreshStatePulling:</div><div class=\"line\">            NSLog(@&quot;切换到Pulling&quot;);</div><div class=\"line\">            self.label.text = FM_Refresh_pulling_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            self.imageView.animationImages = self.refreshingImages;</div><div class=\"line\">            self.imageView.animationDuration = 1.5;</div><div class=\"line\">            [self.imageView startAnimating];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">        case FMRefreshStateRefreshing:</div><div class=\"line\">            NSLog(@&quot;切换到Refreshing&quot;);</div><div class=\"line\">            self.label.text = FM_Refresh_Refreshing_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            [self beginRefreshing];</div><div class=\"line\">            self.imageView.animationImages = self.refreshingImages;</div><div class=\"line\">            self.imageView.animationDuration = 1.5;</div><div class=\"line\">            [self.imageView startAnimating];</div><div class=\"line\">            [self doRefreshAction];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>切换到<code>FMRefreshStateNormal</code> 停止动画，切换到<code>FMRefreshStatePulling</code> 开始动画，达到这个状态，说明用户已经达到了刷新的偏移量，此时松手便可刷新，切换到<code>FMRefreshStateRefreshing</code>，如果此时往回滑动，小于临界值，那么状态重新切回<code>FMRefreshStateNormal</code>。<br>满足刷新条件，则便可执行以下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)doRefreshAction</div><div class=\"line\">&#123;</div><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</div><div class=\"line\">    if (self.refreshTarget &amp;&amp; [self.refreshTarget respondsToSelector:self.refreshAction])</div><div class=\"line\">        [self.refreshTarget performSelector:self.refreshAction];</div><div class=\"line\">#pragma clang diagnostic pop</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面看最关键的KVO方法，也是这里面最复杂的逻辑处理代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</div><div class=\"line\">    </div><div class=\"line\">    //isDragging 属性是指用户手指是否在拖动</div><div class=\"line\">    if (self.superScrollView.isDragging &amp;&amp; !self.isRefreshing) &#123;</div><div class=\"line\">        if (!self.originalOffsetY) &#123;</div><div class=\"line\">            self.originalOffsetY = -self.superScrollView.contentInset.top;</div><div class=\"line\">        &#125;</div><div class=\"line\">        CGFloat normalPullingOffset =  self.originalOffsetY - k_FMRefresh_Height;</div><div class=\"line\">        if (self.currentStatus == FMRefreshStatePulling &amp;&amp; self.superScrollView.contentOffset.y &gt; normalPullingOffset) &#123;</div><div class=\"line\">            </div><div class=\"line\">            self.currentStatus = FMRefreshStateNormal;</div><div class=\"line\">        &#125; else if (self.currentStatus == FMRefreshStateNormal &amp;&amp; self.superScrollView.contentOffset.y &lt; normalPullingOffset) &#123;</div><div class=\"line\">            self.currentStatus = FMRefreshStatePulling;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else if(!self.superScrollView.isDragging)&#123;</div><div class=\"line\">        </div><div class=\"line\">        if (self.currentStatus == FMRefreshStatePulling) &#123;</div><div class=\"line\">            </div><div class=\"line\">            self.currentStatus = FMRefreshStateRefreshing;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t//拖动的偏移量，转换成正数</div><div class=\"line\">    CGFloat pullDistance = -self.frame.origin.y;</div><div class=\"line\">    self.backgroundView.frame = CGRectMake(0, 0, k_FMRefresh_Width, pullDistance);</div><div class=\"line\">    CGFloat totalWidth = 35 + 20 + self.label.bounds.size.width;</div><div class=\"line\">    CGFloat imageViewX = (k_FMRefresh_Width - totalWidth)/2;</div><div class=\"line\">    </div><div class=\"line\">    self.imageView.frame = CGRectMake(imageViewX,  -k_FMRefresh_Height+pullDistance+(k_FMRefresh_Height - self.imageView.bounds.size.height)/2, self.imageView.frame.size.width, self.imageView.frame.size.height);</div><div class=\"line\">    self.label.frame = CGRectMake(imageViewX + 35 + 20, -k_FMRefresh_Height + pullDistance + (k_FMRefresh_Height - self.label.bounds.size.height)/2, self.label.frame.size.width, self.label.frame.size.height);   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里最重要的就是处理两点：1. 根据偏移量和用户手指的拖动来切换状态，2. control上面的子视图需要我们根据偏移量来实时更新。</p>\n<p>还有一种情况，上面也提到过，用户先滑动到<code>FMRefreshStatePulling</code>状态，然后又往回滑动，此时的偏移量在0-<code>FMRefreshStatePulling</code>状态的偏移量之间，此时调用自身的 <code>endRefreshing</code>偏移量不会复原，还需要我们自己处理，看了几个老外写的自定义刷新控件，他们都没修复这个bug。他们也没封装，全部代码写在了控制器里，什么都没有改变，只是实现了一个动画效果，还多了个bug,动画效果倒是不错的。有兴趣的可以参考一番：<br><a href=\"https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/\" target=\"_blank\" rel=\"external\">https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/</a><br><a href=\"https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/\" target=\"_blank\" rel=\"external\">https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)endRefreshing &#123;</div><div class=\"line\">    if (self.currentStatus != FMRefreshStateRefreshing) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.currentStatus = FMRefreshStateNormal;</div><div class=\"line\">    [super endRefreshing];</div><div class=\"line\">    </div><div class=\"line\">    //在执行刷新的状态中，用户手动拖动到 nornal 状态的 offset，[super endRefreshing] 无法回到初始位置，所以手动设置</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        if(self.superScrollView.contentOffset.y &gt;= self.originalOffsetY - k_FMRefresh_Height &amp;&amp; self.superScrollView.contentOffset.y &lt;= self.originalOffsetY) &#123;</div><div class=\"line\">            CGPoint offset = self.superScrollView.contentOffset;</div><div class=\"line\">            offset.y = self.originalOffsetY;</div><div class=\"line\">            [self.superScrollView setContentOffset:offset animated:YES];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后还有一点不要忘记 <code>dealloc</code>移除监听：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)dealloc &#123;</div><div class=\"line\">    [self.superScrollView removeObserver:self forKeyPath:@&quot;contentOffset&quot;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>整篇文章从上至下是按照整个完整的思路写下来的，先是提出遇到的问题以及难点，然后最后的代码和思路也是由外至内一路写下来，希望方便大家阅读。这是上篇，下拉刷新的，还有下篇，上拉加载，过两天写，demo中已经有了，不过就是还没优化。</p>\n<p><a href=\"https://github.com/suifengqjn/FMRefreshControl\" target=\"_blank\" rel=\"external\">domo地址：https://github.com/suifengqjn/FMRefreshControl</a></p>\n","excerpt":"<h3 id=\"一：前言\"><a href=\"#一：前言\" class=\"headerlink\" title=\"一：前言\"></a>一：前言</h3><p>记得工作中第一次用的刷新控件是<code>svpulltorefresh</code>，用法稍微有点麻烦，而且bug颇多，后来果断放弃，现在用的是<code>MJRefresh</code>,不管是用法还是bug，都比前一个好多了，但是不久前也遇到了一个致命的bug，有好些情况下会导致<code>MJRefresh</code>陷入一个死循环，导致不断的刷新，只能重启软件才行。<code>MJRefresh</code>工程比较庞大，找到了bug也很难修改，然后还是决定自己写一个，系统提供的<code>UIRefreshControl</code>我认为是最好的，缺点是不提供自定义UI的方法，那么我就自己基于它来自定义UI。我不是一开始就决定继承于<code>UIRefreshControl</code>，我同时也写了一个继承与<code>UIView</code>的control，两个进行对比，发现使用<code>UIview</code>会有很多弊端，这种弊端在一些复杂特殊的情况下一下子就暴露出来了，而且很难解决，当然，正常状态下是没什么问题的，有兴趣的同学倒是可以去试一试。本demo供大家学习和参考，如有发现bug，还请issues 我。</p>\n<h3 id=\"二-了解-UIRefreshControl\"><a href=\"#二-了解-UIRefreshControl\" class=\"headerlink\" title=\"二: 了解 UIRefreshControl\"></a>二: 了解 UIRefreshControl</h3><ul>\n<li>基本使用方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//初始化一个control</div><div class=\"line\">UIRefreshControl *control = [[UIRefreshControl alloc] init];</div><div class=\"line\">//给control 添加一个刷新方法</div><div class=\"line\">[control addTarget:self action:@selector(refreshAction) forControlEvents:UIControlEventValueChanged];</div><div class=\"line\">//把control 添加到 tableView</div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<ul>\n<li><p>存在的问题</p>\n<ul>\n<li><ol>\n<li>刷新时的动画是一个灰色小菊花，很多情况下不符合app的刷新动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>经过多次反复测试，下拉的偏移量达到130以上才会触发刷新方法，很显然这个也不符合，一般的刷新控件的高度60左右，所以下拉的偏移量达到60就可以触发刷新的方法了。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>自定义控件的思路</p>\n<ul>\n<li><ol>\n<li>去掉默认的动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>自定义自己的动画效果</li>\n</ol>\n</li>\n<li><ol>\n<li>改变满足刷新时的条件","more":"<h3 id=\"三：FMRefreshControl\"><a href=\"#三：FMRefreshControl\" class=\"headerlink\" title=\"三：FMRefreshControl\"></a>三：FMRefreshControl</h3></li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>先看一下我写完的这个控件的使用方法</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];</div><div class=\"line\"></div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<p>两行代码，用法比系统的还要稍微简单一点。</p>\n<ul>\n<li>再看一下效果</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/suifengqjn/demoimages/master/FMRefresh/1.gif\" alt=\"image\"></p>\n<h3 id=\"四：思路与代码\"><a href=\"#四：思路与代码\" class=\"headerlink\" title=\"四：思路与代码\"></a>四：思路与代码</h3><h4 id=\"1-关于-UIRefreshControl-的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到-superViwe-再执行\"><a href=\"#1-关于-UIRefreshControl-的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到-superViwe-再执行\" class=\"headerlink\" title=\"1. 关于 UIRefreshControl 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 superViwe,再执行\"></a>1. 关于 <code>UIRefreshControl</code> 的几个注意点，通过frame无法修改它的高度，修改高度目前只找到一种方法，先添加到 <code>superViwe</code>,再执行</h4><p><code>[[_control.subviews objectAtIndex:0] setFrame:CGRectMake(0, 0, _control.bounds.size.width, 30)];</code><br>一开始我是想改变它的高度是否就能改变它的触发刷新的偏移量，然后我找到了这个方法可以修改它的高度，但实际上改变了高度还是无法改变触发下拉刷新的偏移量，所以我们需要自定义去触发刷新这个动作的时机。</p>\n<h4 id=\"2-手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow-因偏移量变动而导致非人为的刷新。\"><a href=\"#2-手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow-因偏移量变动而导致非人为的刷新。\" class=\"headerlink\" title=\"2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。\"></a>2.手动去触发刷新动作也有几个注意点，我们是根据偏移量去触发刷新，但是仅仅靠这一个动作是不够的，还需要一个条件，那就是用户手指响应过屏幕，简单地说，先定义一个变量，如果用户触摸过屏幕，就把变量置为YES，然后再判断用户手指离开时是否达到了触发刷新的偏移量，如果两个条件都满足，就触发刷新，刷新完把变量置为NO，如果不满足，就不触发，也把变量置为NO。这样就避免了UIScrollow 因偏移量变动而导致非人为的刷新。</h4><h4 id=\"3-进入代码阶段\"><a href=\"#3-进入代码阶段\" class=\"headerlink\" title=\"3. 进入代码阶段\"></a>3. 进入代码阶段</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">FMRefreshControl *control = [[FMRefreshControl alloc] initWithTargrt:self refreshAction:@selector(refreshAction)];</div><div class=\"line\">[self.tableView addSubview:control];</div></pre></td></tr></table></figure>\n<p>初始化的时候赋一个 target 和 一个 action，当满足条件的时候，我们需要知道让谁去执行刷新方法，有这两个参数足够，当执行到第二行 addSubView的时候，我们需要在control内部实现这个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)willMoveToSuperview:(UIView *)newSuperview &#123;</div><div class=\"line\">    [super willMoveToSuperview:newSuperview];</div><div class=\"line\">    </div><div class=\"line\">    if ([newSuperview isKindOfClass:[UIScrollView class]]) &#123;</div><div class=\"line\">        self.superScrollView = (UIScrollView *)newSuperview;</div><div class=\"line\">        </div><div class=\"line\">        [self.superScrollView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样，我们就知道当前这个control被添加到哪个父视图上了，为了安全及代码的严谨，先判断父视图是否属于<br><code>UIScrollView</code>，如果是，就用KVO监听<code>contentOffset</code>属性，这样便能知道用户滑动的偏移量。</p>\n<p>这里我定义了3种状态：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_ENUM(NSInteger, FMRefreshState) &#123;</div><div class=\"line\">    FMRefreshStateNormal = 0,     /** 普通状态 */</div><div class=\"line\">    FMRefreshStatePulling,        /** 释放刷新状态 */</div><div class=\"line\">    FMRefreshStateRefreshing,     /** 正在刷新 */</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>以及切换状态后UI的切换和方法的触发：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setCurrentStatus:(FMRefreshState)currentStatus &#123;</div><div class=\"line\">    _currentStatus = currentStatus;</div><div class=\"line\">    switch (_currentStatus) &#123;</div><div class=\"line\">        case FMRefreshStateNormal:</div><div class=\"line\">            NSLog(@&quot;切换到Normal&quot;);</div><div class=\"line\">            [self.imageView stopAnimating];</div><div class=\"line\">            self.label.text = FM_Refresh_normal_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            self.imageView.image = [UIImage imageNamed:@&quot;refresh_1&quot;];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">        case FMRefreshStatePulling:</div><div class=\"line\">            NSLog(@&quot;切换到Pulling&quot;);</div><div class=\"line\">            self.label.text = FM_Refresh_pulling_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            self.imageView.animationImages = self.refreshingImages;</div><div class=\"line\">            self.imageView.animationDuration = 1.5;</div><div class=\"line\">            [self.imageView startAnimating];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">        case FMRefreshStateRefreshing:</div><div class=\"line\">            NSLog(@&quot;切换到Refreshing&quot;);</div><div class=\"line\">            self.label.text = FM_Refresh_Refreshing_title;</div><div class=\"line\">            [self.label sizeToFit];</div><div class=\"line\">            [self beginRefreshing];</div><div class=\"line\">            self.imageView.animationImages = self.refreshingImages;</div><div class=\"line\">            self.imageView.animationDuration = 1.5;</div><div class=\"line\">            [self.imageView startAnimating];</div><div class=\"line\">            [self doRefreshAction];</div><div class=\"line\">            </div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>切换到<code>FMRefreshStateNormal</code> 停止动画，切换到<code>FMRefreshStatePulling</code> 开始动画，达到这个状态，说明用户已经达到了刷新的偏移量，此时松手便可刷新，切换到<code>FMRefreshStateRefreshing</code>，如果此时往回滑动，小于临界值，那么状态重新切回<code>FMRefreshStateNormal</code>。<br>满足刷新条件，则便可执行以下方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)doRefreshAction</div><div class=\"line\">&#123;</div><div class=\"line\">#pragma clang diagnostic push</div><div class=\"line\">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</div><div class=\"line\">    if (self.refreshTarget &amp;&amp; [self.refreshTarget respondsToSelector:self.refreshAction])</div><div class=\"line\">        [self.refreshTarget performSelector:self.refreshAction];</div><div class=\"line\">#pragma clang diagnostic pop</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面看最关键的KVO方法，也是这里面最复杂的逻辑处理代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</div><div class=\"line\">    </div><div class=\"line\">    //isDragging 属性是指用户手指是否在拖动</div><div class=\"line\">    if (self.superScrollView.isDragging &amp;&amp; !self.isRefreshing) &#123;</div><div class=\"line\">        if (!self.originalOffsetY) &#123;</div><div class=\"line\">            self.originalOffsetY = -self.superScrollView.contentInset.top;</div><div class=\"line\">        &#125;</div><div class=\"line\">        CGFloat normalPullingOffset =  self.originalOffsetY - k_FMRefresh_Height;</div><div class=\"line\">        if (self.currentStatus == FMRefreshStatePulling &amp;&amp; self.superScrollView.contentOffset.y &gt; normalPullingOffset) &#123;</div><div class=\"line\">            </div><div class=\"line\">            self.currentStatus = FMRefreshStateNormal;</div><div class=\"line\">        &#125; else if (self.currentStatus == FMRefreshStateNormal &amp;&amp; self.superScrollView.contentOffset.y &lt; normalPullingOffset) &#123;</div><div class=\"line\">            self.currentStatus = FMRefreshStatePulling;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else if(!self.superScrollView.isDragging)&#123;</div><div class=\"line\">        </div><div class=\"line\">        if (self.currentStatus == FMRefreshStatePulling) &#123;</div><div class=\"line\">            </div><div class=\"line\">            self.currentStatus = FMRefreshStateRefreshing;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t//拖动的偏移量，转换成正数</div><div class=\"line\">    CGFloat pullDistance = -self.frame.origin.y;</div><div class=\"line\">    self.backgroundView.frame = CGRectMake(0, 0, k_FMRefresh_Width, pullDistance);</div><div class=\"line\">    CGFloat totalWidth = 35 + 20 + self.label.bounds.size.width;</div><div class=\"line\">    CGFloat imageViewX = (k_FMRefresh_Width - totalWidth)/2;</div><div class=\"line\">    </div><div class=\"line\">    self.imageView.frame = CGRectMake(imageViewX,  -k_FMRefresh_Height+pullDistance+(k_FMRefresh_Height - self.imageView.bounds.size.height)/2, self.imageView.frame.size.width, self.imageView.frame.size.height);</div><div class=\"line\">    self.label.frame = CGRectMake(imageViewX + 35 + 20, -k_FMRefresh_Height + pullDistance + (k_FMRefresh_Height - self.label.bounds.size.height)/2, self.label.frame.size.width, self.label.frame.size.height);   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里最重要的就是处理两点：1. 根据偏移量和用户手指的拖动来切换状态，2. control上面的子视图需要我们根据偏移量来实时更新。</p>\n<p>还有一种情况，上面也提到过，用户先滑动到<code>FMRefreshStatePulling</code>状态，然后又往回滑动，此时的偏移量在0-<code>FMRefreshStatePulling</code>状态的偏移量之间，此时调用自身的 <code>endRefreshing</code>偏移量不会复原，还需要我们自己处理，看了几个老外写的自定义刷新控件，他们都没修复这个bug。他们也没封装，全部代码写在了控制器里，什么都没有改变，只是实现了一个动画效果，还多了个bug,动画效果倒是不错的。有兴趣的可以参考一番：<br><a href=\"https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/\">https://www.jackrabbitmobile.com/app-development/ios-custom-pull-to-refresh-contro/</a><br><a href=\"https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/\">https://possiblemobile.com/2014/05/ios-custom-pull-to-refresh/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)endRefreshing &#123;</div><div class=\"line\">    if (self.currentStatus != FMRefreshStateRefreshing) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.currentStatus = FMRefreshStateNormal;</div><div class=\"line\">    [super endRefreshing];</div><div class=\"line\">    </div><div class=\"line\">    //在执行刷新的状态中，用户手动拖动到 nornal 状态的 offset，[super endRefreshing] 无法回到初始位置，所以手动设置</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        if(self.superScrollView.contentOffset.y &gt;= self.originalOffsetY - k_FMRefresh_Height &amp;&amp; self.superScrollView.contentOffset.y &lt;= self.originalOffsetY) &#123;</div><div class=\"line\">            CGPoint offset = self.superScrollView.contentOffset;</div><div class=\"line\">            offset.y = self.originalOffsetY;</div><div class=\"line\">            [self.superScrollView setContentOffset:offset animated:YES];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后还有一点不要忘记 <code>dealloc</code>移除监听：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)dealloc &#123;</div><div class=\"line\">    [self.superScrollView removeObserver:self forKeyPath:@&quot;contentOffset&quot;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>整篇文章从上至下是按照整个完整的思路写下来的，先是提出遇到的问题以及难点，然后最后的代码和思路也是由外至内一路写下来，希望方便大家阅读。这是上篇，下拉刷新的，还有下篇，上拉加载，过两天写，demo中已经有了，不过就是还没优化。</p>\n<p><a href=\"https://github.com/suifengqjn/FMRefreshControl\">domo地址：https://github.com/suifengqjn/FMRefreshControl</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"civyshmev0005co60q6ig7xx3","category_id":"civyshmem0002co60qm2lbiyk","_id":"civyshmfn000aco600e8qn8go"},{"post_id":"civyshme80000co60hc5z5z7w","category_id":"civyshmem0002co60qm2lbiyk","_id":"civyshmgv000eco600tfvilj8"},{"post_id":"civyshmfb0009co606fi25hfy","category_id":"civyshmem0002co60qm2lbiyk","_id":"civyshmh8000hco603w5i6xsw"},{"post_id":"civyshmeg0001co604hq2f6sa","category_id":"civyshmf80007co60miipwxdj","_id":"civyshmhl000mco6089ujv3cf"},{"post_id":"civyshmfo000bco60iwpma648","category_id":"civyshmem0002co60qm2lbiyk","_id":"civyshmhr000oco60sefzfumr"},{"post_id":"civyshmgz000fco60kd0cl0pz","category_id":"civyshmem0002co60qm2lbiyk","_id":"civyshmi1000rco60axfl1ln4"},{"post_id":"civyshmes0004co60nzt3rahs","category_id":"civyshmgk000cco60uvl8e8xl","_id":"civyshmi5000uco60fpcfphts"},{"post_id":"civyshmh9000ico609t19xh8j","category_id":"civyshmem0002co60qm2lbiyk","_id":"civyshmib000xco605d3vh602"},{"post_id":"civyshmhl000nco60jg38yn2e","category_id":"civyshmf80007co60miipwxdj","_id":"civyshmif0011co604v5stzmw"},{"post_id":"civyshmf70006co60eh0sa00l","category_id":"civyshmgk000cco60uvl8e8xl","_id":"civyshmig0012co608nmf76eo"},{"post_id":"civyshmht000pco609zz6bjb0","category_id":"civyshmf80007co60miipwxdj","_id":"civyshmig0014co60987tgq8h"},{"post_id":"civyshmi2000sco60gjcwqf0h","category_id":"civyshmem0002co60qm2lbiyk","_id":"civyshmih0016co60nx4834i8"},{"post_id":"civyshmid000zco60jj41gn85","category_id":"civyshmem0002co60qm2lbiyk","_id":"civyshmih0019co6055dwswt4"},{"post_id":"civyshmi5000vco60b94az7ut","category_id":"civyshmif0010co60ei373e3y","_id":"civyshmih001aco605kgujxuw"},{"post_id":"civyshmol002eco60m53puz2k","category_id":"civyshmem0002co60qm2lbiyk","_id":"civyshmox002kco60vn2pxboz"},{"post_id":"civyshmop002gco60b3goi04x","category_id":"civyshmem0002co60qm2lbiyk","_id":"civyshmoy002mco60s7lcqt43"}],"PostTag":[{"post_id":"civyshme80000co60hc5z5z7w","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmh3000gco60zl7lpkmt"},{"post_id":"civyshme80000co60hc5z5z7w","tag_id":"civyshmf90008co60dank2nhg","_id":"civyshmhe000jco60gr5uv2e0"},{"post_id":"civyshmeg0001co604hq2f6sa","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmi4000tco60m417vvyp"},{"post_id":"civyshmeg0001co604hq2f6sa","tag_id":"civyshmhi000kco60xsghrhmo","_id":"civyshmib000wco60gznc5kgn"},{"post_id":"civyshmes0004co60nzt3rahs","tag_id":"civyshmi0000qco60faqjzzxb","_id":"civyshmih0015co60s4io7888"},{"post_id":"civyshmes0004co60nzt3rahs","tag_id":"civyshmid000yco60o2xtnh2y","_id":"civyshmih0017co60v3g0i7en"},{"post_id":"civyshmev0005co60q6ig7xx3","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmii001cco604okpbeqr"},{"post_id":"civyshmev0005co60q6ig7xx3","tag_id":"civyshmig0013co606q5x2o66","_id":"civyshmii001dco60nv3b678b"},{"post_id":"civyshmev0005co60q6ig7xx3","tag_id":"civyshmhi000kco60xsghrhmo","_id":"civyshmij001fco60jpc8k6j9"},{"post_id":"civyshmf70006co60eh0sa00l","tag_id":"civyshmi0000qco60faqjzzxb","_id":"civyshmij001hco60o7rdjnu5"},{"post_id":"civyshmf70006co60eh0sa00l","tag_id":"civyshmii001eco608wi28o7h","_id":"civyshmik001ico6024dcoud2"},{"post_id":"civyshmfb0009co606fi25hfy","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmik001kco604n7wbmlc"},{"post_id":"civyshmfb0009co606fi25hfy","tag_id":"civyshmij001gco60zgunw4p9","_id":"civyshmik001lco607x8d35ja"},{"post_id":"civyshmfo000bco60iwpma648","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmir001oco60or7xj9id"},{"post_id":"civyshmfo000bco60iwpma648","tag_id":"civyshmik001jco60du4pl4kf","_id":"civyshmir001pco60mfix0t27"},{"post_id":"civyshmfo000bco60iwpma648","tag_id":"civyshmil001mco60jb0k3eqs","_id":"civyshmiu001rco60hvuwc0mm"},{"post_id":"civyshmgz000fco60kd0cl0pz","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmiv001sco60sl75j85t"},{"post_id":"civyshmgz000fco60kd0cl0pz","tag_id":"civyshmik001jco60du4pl4kf","_id":"civyshmiw001uco60cqx0998w"},{"post_id":"civyshmh9000ico609t19xh8j","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmiw001vco60b4sgdlx6"},{"post_id":"civyshmh9000ico609t19xh8j","tag_id":"civyshmil001mco60jb0k3eqs","_id":"civyshmiw001xco60pf9k3zew"},{"post_id":"civyshmhl000nco60jg38yn2e","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmix001zco603xdhxyum"},{"post_id":"civyshmhl000nco60jg38yn2e","tag_id":"civyshmiv001tco600g9agaub","_id":"civyshmiy0020co60npr49j6k"},{"post_id":"civyshmhl000nco60jg38yn2e","tag_id":"civyshmiw001wco60vpqx8ett","_id":"civyshmiz0022co607o7tn5lx"},{"post_id":"civyshmht000pco609zz6bjb0","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmiz0023co60t5s362hg"},{"post_id":"civyshmht000pco609zz6bjb0","tag_id":"civyshmiw001yco60m4krnfe8","_id":"civyshmj00025co6081aiz3z7"},{"post_id":"civyshmi2000sco60gjcwqf0h","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmj00026co601srry4y3"},{"post_id":"civyshmi2000sco60gjcwqf0h","tag_id":"civyshmiy0021co608mbdjmm6","_id":"civyshmj10028co60jaqx83he"},{"post_id":"civyshmi5000vco60b94az7ut","tag_id":"civyshmiz0024co600vnscxtw","_id":"civyshmj5002aco60chf3zq6g"},{"post_id":"civyshmi5000vco60b94az7ut","tag_id":"civyshmj00027co60hfix8isa","_id":"civyshmj5002bco60tutwls4n"},{"post_id":"civyshmid000zco60jj41gn85","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmj5002cco60bm2cljym"},{"post_id":"civyshmid000zco60jj41gn85","tag_id":"civyshmj40029co608rua6r9m","_id":"civyshmj6002dco6022io2enw"},{"post_id":"civyshmol002eco60m53puz2k","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmp0002pco60n3wz8wkz"},{"post_id":"civyshmol002eco60m53puz2k","tag_id":"civyshmot002ico6096mauz3c","_id":"civyshmp1002qco60nfenerav"},{"post_id":"civyshmol002eco60m53puz2k","tag_id":"civyshmoy002nco60katv91k2","_id":"civyshmp2002rco60dcjnb5io"},{"post_id":"civyshmop002gco60b3goi04x","tag_id":"civyshmer0003co60glwzqqj7","_id":"civyshmp2002sco60ybh9e6af"},{"post_id":"civyshmop002gco60b3goi04x","tag_id":"civyshmoz002oco606xe5qomd","_id":"civyshmp3002tco60lrtxieg4"}],"Tag":[{"name":"iOS","_id":"civyshmer0003co60glwzqqj7"},{"name":"语音识别","_id":"civyshmf90008co60dank2nhg"},{"name":"workspace","_id":"civyshmhi000kco60xsghrhmo"},{"name":"github","_id":"civyshmi0000qco60faqjzzxb"},{"name":"hexo","_id":"civyshmid000yco60o2xtnh2y"},{"name":"公共库","_id":"civyshmig0013co606q5x2o66"},{"name":"ssh key","_id":"civyshmii001eco608wi28o7h"},{"name":"视频录制","_id":"civyshmij001gco60zgunw4p9"},{"name":"缓存","_id":"civyshmik001jco60du4pl4kf"},{"name":"性能","_id":"civyshmil001mco60jb0k3eqs"},{"name":"Archive","_id":"civyshmiv001tco600g9agaub"},{"name":"targit","_id":"civyshmiw001wco60vpqx8ett"},{"name":"配置","_id":"civyshmiw001yco60m4krnfe8"},{"name":"UI","_id":"civyshmiy0021co608mbdjmm6"},{"name":"swift","_id":"civyshmiz0024co600vnscxtw"},{"name":"自动布局","_id":"civyshmj00027co60hfix8isa"},{"name":"AVplayer","_id":"civyshmj40029co608rua6r9m"},{"name":"runtime","_id":"civyshmot002ico6096mauz3c"},{"name":"Method Swizzling","_id":"civyshmoy002nco60katv91k2"},{"name":"UIRefreshControl","_id":"civyshmoz002oco606xe5qomd"}]}}